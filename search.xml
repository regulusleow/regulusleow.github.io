<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Python 学习笔记（一）【基础语法学习】</title>
    <url>/2018/01/10/20180110-Python%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%90%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E3%80%91/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br></pre></td></tr></table></figure>

<p>如果想让代码中可以输入中文，必须要加上这一句。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_function</span>(<span class="params">a, b</span>):</span><br><span class="line">    c = a + b</span><br><span class="line">    <span class="built_in">print</span> c</span><br></pre></td></tr></table></figure>

<p>Python 中定义一个函数用 <code>def</code> 关键字，函数没有大括号，用tab空格代表方法体。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">100</span></span><br><span class="line">tempC = <span class="string">&quot;Number: &quot;</span></span><br><span class="line"><span class="built_in">print</span> tempC + `num`</span><br><span class="line"><span class="built_in">print</span> tempC + <span class="built_in">str</span>(num)</span><br><span class="line"><span class="built_in">print</span> tempC + <span class="built_in">repr</span>(num)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>str和repr结果都一样，区别： str是 <code>对象类型</code> ；repr是 <code>函数</code> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;one is %s&quot;</span>%num</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;tempA: %s, tempB: %s&quot;</span>%(tempA, tempB)</span><br></pre></td></tr></table></figure>

<p>如果是两个占位符，要写在括号内，用逗号隔开。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">wordsA = <span class="string">&quot; this is a book &quot;</span></span><br><span class="line"><span class="built_in">print</span> wordsA[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span> wordsA[-<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 截取字符串</span></span><br><span class="line"><span class="built_in">print</span> wordsA[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span> wordsA[<span class="number">1</span>:] <span class="comment"># 表示从a[1]开始，一直到字符串的最后</span></span><br><span class="line"><span class="built_in">print</span> wordsA[:] <span class="comment"># 表示截取全部</span></span><br><span class="line"><span class="built_in">print</span> wordsA[:<span class="number">4</span>] <span class="comment"># 表示从字符串开头一直到a[4]前结束</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> wordsA.strip()</span><br><span class="line"><span class="built_in">print</span> wordsA.lstrip()</span><br><span class="line"><span class="built_in">print</span> wordsA.rstrip()</span><br></pre></td></tr></table></figure>

<p><code>strip()</code> 去掉字符串左右的空格，<code>lstrip()</code> 去掉左侧的空格，<code>rstrip()</code> 去掉右侧的空格。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="built_in">divmod</span>(<span class="number">5</span>, <span class="number">2</span>) <span class="comment"># 输出(2, 1)</span></span><br></pre></td></tr></table></figure>

<p>表示5除以2，返回了商和余数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="number">10</span> ** <span class="number">2</span> <span class="comment"># 100</span></span><br><span class="line"><span class="built_in">print</span> <span class="number">9</span> // <span class="number">2</span> <span class="comment"># 4</span></span><br></pre></td></tr></table></figure>

<p><code>**</code> 幂 - 返回 x 的 y 次幂<br><code>//</code> 取整除 - 返回商的整数部分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 布尔运算，与、或、非</span></span><br><span class="line"><span class="built_in">print</span> <span class="number">4</span> &gt; <span class="number">3</span> <span class="keyword">and</span> <span class="number">4</span> &lt; <span class="number">2</span> <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span> <span class="number">4</span> &gt; <span class="number">3</span> <span class="keyword">or</span> <span class="number">4</span> &lt; <span class="number">2</span> <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span> <span class="keyword">not</span>(<span class="number">4</span> &lt; <span class="number">2</span>) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p>与 <code>and</code> ，或 <code>or</code> ，非 <code>not</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">4</span> &gt; <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;4 &gt; 2&quot;</span></span><br><span class="line"><span class="keyword">elif</span> <span class="number">4</span> == <span class="number">2</span>: <span class="comment"># 注意这里的else if</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;4 == 2&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;4 &lt; 2&quot;</span></span><br></pre></td></tr></table></figure>

<p>python 中的 else if 写成 <code>elif</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">type</span>(ary) <span class="comment"># &lt;type &#x27;list&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>python 的数组叫做 <code>list</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ary.append(<span class="string">&quot;Test&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> ary</span><br><span class="line">ary2 = [<span class="string">&quot;Test1&quot;</span>, <span class="string">&quot;ddd&quot;</span>]</span><br><span class="line">ary.extend(ary2)</span><br><span class="line"><span class="built_in">print</span> ary</span><br></pre></td></tr></table></figure>

<p>python list 类型添加一个元素 <code>append()</code> ，合并两个 list <code>extend()</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> ary.count(<span class="string">&quot;ddd&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> ary[<span class="number">4</span>:]</span><br><span class="line"><span class="built_in">print</span> ary[<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span> ary.index(<span class="string">&quot;ddd&quot;</span>)</span><br><span class="line">ary.insert(<span class="number">2</span>, <span class="number">2.3</span>)</span><br><span class="line"><span class="built_in">print</span> ary</span><br></pre></td></tr></table></figure>

<p><code>count()</code> 用于计算某个元素出现的次数，这里计算 <code>ddd</code> 出现了几次。<br><code>index()</code> 查看 <code>ddd</code> 的下标。<br><code>insert()</code> 在指定地方插入元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">2.3</span> <span class="keyword">in</span> ary:</span><br><span class="line">    ary.remove(<span class="number">2.3</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;2.3在list中:&quot;</span></span><br><span class="line">    <span class="built_in">print</span> ary</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;2.3不在list中&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 </span></span><br><span class="line"><span class="comment"># 2.3在list中:</span></span><br><span class="line"><span class="comment"># [1, 2, 3, 4, &#x27;Test&#x27;, &#x27;Test1&#x27;, &#x27;ddd&#x27;]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ary.pop()</span><br><span class="line"><span class="built_in">print</span> ary</span><br><span class="line">ary.pop(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span> ary</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># [1, 2, 3, 4, &#x27;Test&#x27;, &#x27;Test1&#x27;]</span></span><br><span class="line"><span class="comment"># [1, 2, 3, &#x27;Test&#x27;, &#x27;Test1&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><code>pop()</code> 删除list中的最后一个元素。<br><code>pop(3)</code> 删除list中3这个元素，如果有多个，就删除最前面的一个。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="built_in">range</span>(<span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">10</span>, <span class="number">2</span>) <span class="comment"># step=2,每个元素等于start + i * step</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">range</span>(<span class="number">5</span>, <span class="number">100</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">range</span>(<span class="number">0</span>, -<span class="number">9</span>, -<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><code>range(start, stop[, step])</code><br>start：开始数值，默认为0,也就是如果不写这项，就是认为start&#x3D;0<br>stop：结束的数值，必须要写的。<br>step：变化的步长，默认是1,也就是不写，就是认为步长为1。坚决不能为0</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 排序</span></span><br><span class="line">number = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>]</span><br><span class="line">number.sort()</span><br><span class="line"><span class="built_in">print</span> number</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">sorted</span>(number)</span><br><span class="line">number.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span> number</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">sorted</span>(number, reverse=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p><code>reverse=True</code> 倒序排列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">power = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    power.append(x ** <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>在Python中，上面的代码可以改成如下形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br></pre></td></tr></table></figure>

<p>类似的，还有如下的形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> [n <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">100</span>) <span class="keyword">if</span> n % <span class="number">3</span> == <span class="number">0</span>] <span class="comment"># 被3整除的正整数 </span></span><br><span class="line"></span><br><span class="line">mybag = [<span class="string">&#x27; glass&#x27;</span>,<span class="string">&#x27; apple&#x27;</span>,<span class="string">&#x27;green leaf &#x27;</span>]              </span><br><span class="line"><span class="built_in">print</span> [one.strip() <span class="keyword">for</span> one <span class="keyword">in</span> mybag] <span class="comment"># 去掉每个元素前后的空格     </span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">weak = [<span class="string">&quot;周一&quot;</span>, <span class="string">&quot;周二&quot;</span>, <span class="string">&quot;周三&quot;</span>, <span class="string">&quot;周四&quot;</span>, <span class="string">&quot;周五&quot;</span>, <span class="string">&quot;周六&quot;</span>, <span class="string">&quot;周日&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> (idx, item) <span class="keyword">in</span> <span class="built_in">enumerate</span>(weak):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;idx: &quot;</span> + <span class="built_in">str</span>(idx) + <span class="string">&quot;; item: &quot;</span> + item</span><br></pre></td></tr></table></figure>

<p>list中的迭代器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dicNum = &#123;&#125;</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">type</span>(dicNum)</span><br><span class="line">dicNum[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;Tom&quot;</span></span><br><span class="line">dicNum[<span class="number">1</span>] = <span class="string">&quot;Tom&quot;</span></span><br><span class="line">dicNum[<span class="number">2</span>] = <span class="number">90</span></span><br><span class="line"><span class="built_in">print</span> dicNum</span><br></pre></td></tr></table></figure>

<p>字典类型，用大括号表示。<br>也可以这样创建字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = ([<span class="string">&quot;first&quot;</span>, <span class="string">&quot;Google&quot;</span>], [<span class="string">&quot;second&quot;</span>, <span class="string">&quot;Yahoo&quot;</span>])</span><br><span class="line">webSite = <span class="built_in">dict</span>(name)</span><br><span class="line"><span class="built_in">print</span> webSite		</span><br><span class="line"><span class="comment"># &#123;&#x27;second&#x27;: &#x27;Yahoo&#x27;, &#x27;first&#x27;: &#x27;Google&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">webSiteTest = &#123;&#125;.fromkeys((<span class="string">&quot;third&quot;</span>, <span class="string">&quot;forth&quot;</span>), <span class="string">&quot;facebook&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> webSiteTest</span><br><span class="line"><span class="comment"># &#123;&#x27;forth&#x27;: &#x27;facebook&#x27;, &#x27;third&#x27;: &#x27;facebook&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">a = <span class="built_in">dict</span>(one=<span class="number">1</span>, two=<span class="number">2</span>, three=<span class="number">3</span>)</span><br><span class="line">b = &#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;three&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">c = <span class="built_in">dict</span>(<span class="built_in">zip</span>([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line">d = <span class="built_in">dict</span>([(<span class="string">&#x27;two&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;one&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;three&#x27;</span>, <span class="number">3</span>)])</span><br><span class="line">e = <span class="built_in">dict</span>(&#123;<span class="string">&#x27;three&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="built_in">print</span> a		<span class="comment"># &#123;&#x27;three&#x27;: 3, &#x27;two&#x27;: 2, &#x27;one&#x27;: 1&#125;</span></span><br><span class="line"><span class="built_in">print</span> b		<span class="comment"># &#123;&#x27;three&#x27;: 3, &#x27;two&#x27;: 2, &#x27;one&#x27;: 1&#125;</span></span><br><span class="line"><span class="built_in">print</span> c		<span class="comment"># &#123;&#x27;three&#x27;: 3, &#x27;two&#x27;: 2, &#x27;one&#x27;: 1&#125;</span></span><br><span class="line"><span class="built_in">print</span> d		<span class="comment"># &#123;&#x27;three&#x27;: 3, &#x27;two&#x27;: 2, &#x27;one&#x27;: 1&#125;</span></span><br><span class="line"><span class="built_in">print</span> e		<span class="comment"># &#123;&#x27;one&#x27;: 1, &#x27;three&#x27;: 3, &#x27;two&#x27;: 2&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dicNum.update(webSiteTest)</span><br></pre></td></tr></table></figure>

<p>将 webSiteTest 合并到 dicNum。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">123</span>, <span class="string">&quot;test&quot;</span></span><br><span class="line"><span class="comment"># (1, 3, 4, 123, &#x27;test&#x27;)</span></span><br></pre></td></tr></table></figure>

<p>自动封装成元组类型，元组类型是不可变的。</p>
<p><strong>元组的使用：</strong></p>
<p>一般认为,tuple有这类特点,并且也是它使用的情景:</p>
<ul>
<li>Tuple 比 list 操作速度快。如果您定义了一个值的常量集，并且唯一要用它做的是不断地遍历它，请使用 tuple 代替 list。</li>
<li>如果对不需要修改的数据进行 “写保护”，可以使代码更安全。使用 tuple 而不是 list 如同拥有一个隐含的 assert 语句，说明这一数据是常量。如果必须要改变这些值，则需要执行 tuple 到 list 的转换 (需要使用一个特殊的函数)。</li>
<li>Tuples 可以在 dictionary 中被用做 key，但是 list 不行。实际上，事情要比这更复杂。Dictionary key 必须是不可变的。Tuple 本身是不可改变的，但是如果您有一个 list 的 tuple，那就认为是可变的了，用做 dictionary key 就是不安全的。只有字符串、整数或其它对 dictionary 安全的 tuple 才可以用作 dictionary key。</li>
<li>Tuples 可以用在字符串格式化中，后面会用到。</li>
</ul>
<p><strong>set可以用{}定义；</strong></p>
<ol>
<li>元素没有序列，不能重复（类似于dict）；</li>
<li>可以原处修改，但是不能通过下标的方式修改（类似于list，事实上是一种特别的set可以原处修改，另一种是不可以的）；</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = <span class="built_in">set</span>(<span class="string">&quot;qiwsir&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> s1</span><br></pre></td></tr></table></figure>

<p>输出内容：<code>set([&#39;q&#39;, &#39;i&#39;, &#39;s&#39;, &#39;r&#39;, &#39;w&#39;]) </code><br>将字符串拆开，并且没有重复的字母。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s3 = &#123;<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;21&quot;</span>, <span class="number">33</span>&#125;</span><br><span class="line"><span class="built_in">print</span> s3</span><br><span class="line"></span><br><span class="line">s4 = &#123;&#125; <span class="comment"># 这样建立的是dict，并不是set</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s6 = <span class="built_in">set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">s7 = <span class="built_in">set</span>([<span class="string">&#x27;github&#x27;</span>, <span class="string">&#x27;qiwsir&#x27;</span>])</span><br><span class="line">s6.update(s7)</span><br></pre></td></tr></table></figure>

<p>合并s7到s6, s7不变。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> s6.pop()</span><br></pre></td></tr></table></figure>

<p>从set中任意选择一个删除，并返回该值， <code>pop()</code> 不能有参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">&quot;github&quot;</span> <span class="keyword">in</span> s6:</span><br><span class="line">    s6.remove(<span class="string">&quot;github&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> s6</span><br></pre></td></tr></table></figure>

<p>想要删除特定的元素，需要使用 <code>remove(obj)</code> 函数。<br>并且obj必须在set中是存在的，否则报错。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s6.discard(<span class="string">&quot;github&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>discard(obj)</code> 跟remove类似，不同之处在于，如果删除的元素在set中不存在则 <code>discard(obj)</code> 函数什么也不做。</p>
<p>在Python中变量有如下特殊的赋值方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name, web = <span class="string">&quot;qiwsir&quot;</span>, <span class="string">&quot;qiwsir.github.io&quot;</span> <span class="comment"># 多个变量，按照顺序依次赋值，少了或者多了，都会报错</span></span><br><span class="line"></span><br><span class="line">one, two, three, four = <span class="string">&quot;good&quot;</span> <span class="comment"># 拆分</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 学习笔记（二）【文件的简单操作】</title>
    <url>/2018/01/15/20180115-Python%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%90%E6%96%87%E4%BB%B6%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%E3%80%91/</url>
    <content><![CDATA[<p>在 python 中简单的打开一个文件可以用 <code>open(name, model)</code> 的方式<br><code>name</code> 文件路径。<br><code>model</code> 打开的方式。</p>
<p><code>model</code> 参数如下：</p>
<p><img src="/my_pictures/20180115/1.png"></p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;散文.txt&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">    <span class="built_in">print</span> line,</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;\n\n第二次读取:&quot;</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">    <span class="built_in">print</span> line,</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;\n\n第二次读取结束。\n\n&quot;</span></span><br></pre></td></tr></table></figure>

<p>第二次读取没有内容，是因为第二次读取是从第一次读取的结束开始，那么自然就没有数据。<br>相当于文件的指针指向了文件的末尾，再从某未开始读取，自然就没有数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file.seek(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">    <span class="built_in">print</span> line,</span><br><span class="line">file.close() <span class="comment"># 关闭文件</span></span><br></pre></td></tr></table></figure>

<p>加上 <code>seek()</code> 这个方法，这时我们就能读取到数据了。<br>这个方法将指针移到了文件的开头。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file2 = <span class="built_in">open</span>(<span class="string">&quot;散文.txt&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">file2.write(<span class="string">&quot;这是新添加的内容。&quot;</span>)</span><br><span class="line">file2.close()</span><br></pre></td></tr></table></figure>

<p>写完必须关闭，这样才能保存到文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">file_state = os.stat(<span class="string">&quot;散文.txt&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> file_state</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">posix.stat_result(st_mode=<span class="number">33188</span>, st_ino=<span class="number">3496826</span>, st_dev=<span class="number">16777220</span>, st_nlink=<span class="number">1</span>, st_uid=<span class="number">501</span>, st_gid=<span class="number">20</span>, st_size=<span class="number">566</span>, st_atime=<span class="number">1510210604</span>, st_mtime=<span class="number">1510207603</span>, st_ctime=<span class="number">1510207603</span>)</span><br></pre></td></tr></table></figure>

<p>我们将信息格式化一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="built_in">print</span> time.localtime(file_state.st_ctime)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">time.struct_time(tm_year=<span class="number">2017</span>, tm_mon=<span class="number">11</span>, tm_mday=<span class="number">9</span>, tm_hour=<span class="number">14</span>, tm_min=<span class="number">6</span>, tm_sec=<span class="number">43</span>, tm_wday=<span class="number">3</span>, tm_yday=<span class="number">313</span>, tm_isdst=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>读取文件有很多方法，系统提供了 <code>read()</code> ，<code>readline()</code> ，<code>readlines</code> 。这些方法都是将内容读入至内存中。在读取大文件的时候最好用下面的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fpb = <span class="built_in">open</span>(<span class="string">&quot;散文.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> fpb:</span><br><span class="line">    <span class="built_in">print</span> item,</span><br><span class="line">fpb.close()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 使用 warning</title>
    <url>/2018/01/29/20180129-Swift%20%E4%BD%BF%E7%94%A8%20warning/</url>
    <content><![CDATA[<p>在 Swift 中无法使用 <code>#warning</code> ，Swift 中有如下的标记：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">FIXME:</span> - 待修复</span></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> - 接下来要做的事情</span></span><br><span class="line"><span class="comment">//MARK: - 标记</span></span><br><span class="line">注: 添加<span class="string">&quot;-&quot;</span> 可以显示分割线<span class="operator">-----</span><span class="type">Swift3下有效</span></span><br></pre></td></tr></table></figure>

<p>接下来给 <code>TODO:</code> 和 <code>FIXME:</code> 加上警告，实现类似的效果：</p>
<p>Build Phases —&gt;  add a new Build Phases —&gt; New run script phase</p>
<span id="more"></span>

<p>添加如下的代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">TAGS</span>=<span class="string">&quot;TODO:|FIXME:&quot;</span></span><br><span class="line">echo <span class="string">&quot;searching $&#123;SRCROOT&#125; for $&#123;TAGS&#125;&quot;</span></span><br><span class="line">find <span class="string">&quot;$&#123;SRCROOT&#125;&quot;</span> \( -name <span class="string">&quot;*.swift&quot;</span> \) -print0 | xargs -<span class="number">0</span> egrep --<span class="keyword">with</span>-filename --line-number --only-matching <span class="string">&quot;($TAGS).*\$&quot;</span> | perl -p -e <span class="string">&quot;s/($TAGS)/ warning: \$1/&quot;</span></span><br></pre></td></tr></table></figure>

<p>如图：</p>
<p><img src="/my_pictures/20180129/1.png"></p>
<p><img src="/my_pictures/20180129/2.png"></p>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>你应该定期更新 Homebrew</title>
    <url>/2018/01/29/20180129-%E4%BD%A0%E5%BA%94%E8%AF%A5%E5%AE%9A%E6%9C%9F%E6%9B%B4%E6%96%B0%20Homebrew/</url>
    <content><![CDATA[<h3 id="为什么要定期更新"><a href="#为什么要定期更新" class="headerlink" title="为什么要定期更新"></a>为什么要定期更新</h3><hr>
<p>我发现不少人都不会经常更新，或者只在必须用某个工具的新版本的时候才更新。他们的看法是，更新有可能产生一些意外的问题，反正当前环境足够稳定可以用，干嘛自找麻烦呢？<br>这个看法对也不对。对是因为，更新产生的潜在问题不可避免。不对是因为总有一天你需要升级的，也许是为了某个工具的新特性，也许是为了修复软件的漏洞，也许你安装的包非要依赖另一个包的新版本，等等。如果隔了很长一段时间才升级，那潜在的小问题可能就会变成大问题。<br>另一个有意思的现象是，当碰到比较破坏性的事情，比如 Mac OS 大版本更新后，很多人会选择重装 Homebrew 然后顺带安装最新版的包。很少人会去装一个指定的旧版本（除了特殊项目需要）。这说明他们不是不想用新版本，而是不想痛苦地更新。<br>既然总有一天需要更新，而更新带来问题不可避免，那为什么不更新得频繁点呢？这个道理跟 Git 的冲突解决有相似性。长时间不 pull&#x2F;push 的代码更容易产生冲突，一个解决方法就是频繁地 commit &amp; merge 。<br>我现在试着一个月更新一次，两次下来发现这些好处：</p>
<span id="more"></span>

<ul>
<li>每次更新的包很少，更新风险也小。</li>
<li>更容易发现不需要的包，便于清理，不为不需要的东西买单。</li>
<li>定期清理旧版本，释放空间。<br>更新流程其实都差不多，下面列一下我常用的命令。</li>
</ul>
<h3 id="更新-Homebrew"><a href="#更新-Homebrew" class="headerlink" title="更新 Homebrew"></a>更新 Homebrew</h3><hr>
<p>要获取最新的包的列表，首先得更新 Homebrew 自己。这可以用 <code>brew update</code> 办到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew update</span><br></pre></td></tr></table></figure>

<p>完后会显示可以更新的包列表，其中打钩的是已经安装的包。输出类似下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Updated Homebrew from fe93aa3 to 6ae64c3.</span><br><span class="line">Updated 1 tap (homebrew/versions).</span><br><span class="line">==&gt; Updated Formulae</span><br><span class="line">awscli      cmake ✔     homebrew/versions/libmongoclient-legacy</span><br></pre></td></tr></table></figure>

<h3 id="更新包-formula"><a href="#更新包-formula" class="headerlink" title="更新包 (formula)"></a>更新包 (formula)</h3><hr>
<p>更新之前，我会用 <code>brew outdated</code> 查看哪些包可以更新。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew outdated</span><br></pre></td></tr></table></figure>

<p>然后就可以用 <code>brew upgrade</code> 去更新了。Homebrew 会安装新版本的包，但旧版本仍然会保留。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew upgrade             # 更新所有的包</span><br><span class="line">brew upgrade $FORMULA    # 更新指定的包</span><br></pre></td></tr></table></figure>

<h3 id="清理旧版本"><a href="#清理旧版本" class="headerlink" title="清理旧版本"></a>清理旧版本</h3><hr>
<p>一般情况下，新版本安装了，旧版本就不需要了。我会用 <code>brew cleanup</code> 清理旧版本和缓存文件。Homebrew 只会清除比当前安装的包更老的版本，所以不用担心有些包没更新但被删了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew cleanup             # 清理所有包的旧版本</span><br><span class="line">brew cleanup $FORMULA    # 清理指定包的旧版本</span><br><span class="line">brew cleanup -n          # 查看可清理的旧版本包，不执行实际操作</span><br></pre></td></tr></table></figure>

<p>这样一套下来，该更新的都更新了，旧版本也被清理了。</p>
<h3 id="锁定不想更新的包"><a href="#锁定不想更新的包" class="headerlink" title="锁定不想更新的包"></a>锁定不想更新的包</h3><hr>
<p>如果经常更新的话， <code>brew update</code> 一次更新所有的包是非常方便的。但我们有时候会担心自动升级把一些不希望更新的包更新了。数据库就属于这一类，尤其是 PostgreSQL 跨 minor 版本升级都要迁移数据库的。我们更希望找个时间单独处理它。这时可用 <code>brew pin</code> 去锁定这个包，然后 <code>brew update</code> 就会略过它了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew pin $FORMULA      # 锁定某个包</span><br><span class="line">brew unpin $FORMULA    # 取消锁定</span><br></pre></td></tr></table></figure>

<h3 id="其他几个常用命令"><a href="#其他几个常用命令" class="headerlink" title="其他几个常用命令"></a>其他几个常用命令</h3><hr>
<p><code>brew info</code> 可以查看包的相关信息，最有用的应该是包依赖和相应的命令。比如 Nginx 会提醒你怎么加 <code>launchctl</code> ，PostgreSQL 会告诉你如何迁移数据库。这些信息会在包安装完成后自动显示，如果忘了的话可以用这个命令很方便地查看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew info $FORMULA    # 显示某个包的信息</span><br><span class="line">brew info             # 显示安装了包数量，文件数量，和总占用空间</span><br></pre></td></tr></table></figure>

<p><code>brew deps</code> 可以显示包的依赖关系，我常用它来查看已安装的包的依赖，然后判断哪些包是可以安全删除的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew deps --installed --tree # 查看已安装的包的依赖，树形显示</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elixir (required dependencies)</span><br><span class="line">└── :erlang</span><br><span class="line"></span><br><span class="line">wxmac (required dependencies)</span><br><span class="line">├── jpeg</span><br><span class="line">├── libpng</span><br><span class="line">│   └── xz</span><br><span class="line">└── libtiff</span><br><span class="line">    └── jpeg</span><br></pre></td></tr></table></figure>

<p>还有很多有用的命令和参数，没事 <code>man brew</code> 一下可以涨不少知识。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><hr>
<p>不想更新 Homebrew 往往有两个原因，害怕潜在的风险和对工具的不熟悉，我之前也是这样。写这篇文章最开始是为了帮我记录常用的命令方便以后查阅的。希望它也能帮到你。</p>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>homebrew</tag>
      </tags>
  </entry>
  <entry>
    <title>安装CocoaPods</title>
    <url>/2018/01/29/20180129-%E5%AE%89%E8%A3%85CocoaPods/</url>
    <content><![CDATA[<h4 id="更新系统的gem"><a href="#更新系统的gem" class="headerlink" title="更新系统的gem"></a>更新系统的gem</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gem update --system</span><br></pre></td></tr></table></figure>

<h4 id="安装CocoaPods"><a href="#安装CocoaPods" class="headerlink" title="安装CocoaPods"></a>安装CocoaPods</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gem install cocoapods</span><br></pre></td></tr></table></figure>

<h4 id="这时候可能会出现下面的错误"><a href="#这时候可能会出现下面的错误" class="headerlink" title="这时候可能会出现下面的错误"></a>这时候可能会出现下面的错误</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR:  While executing gem ... (Errno::EPERM)</span><br><span class="line">    Operation not permitted - /usr/bin/fuzzy_match</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为在<code>OS X El Capitan</code>版本之后，之前的命令就不适用了，我们可以用如下的命令来安装CocoaPods</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gem install -n /usr/local/bin cocoapods</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title>终端命令启动Sublime Text 3 和 VS Code</title>
    <url>/2018/01/29/20180129-%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E5%90%AF%E5%8A%A8Sublime%20Text%203%20%E5%92%8C%20VS%20Code/</url>
    <content><![CDATA[<p>加入软连接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 如果你是sublime 2</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s <span class="string">&quot;/Applications/Sublime Text 2.app/Contents/SharedSupport/bin/subl&quot;</span> /usr/local/bin/subl </span><br><span class="line"></span><br><span class="line">// 如果你是sublime 3</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl /usr/local/bin/subl</span><br><span class="line"></span><br><span class="line">// vs code</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /Applications/Visual\ Studio\ Code.app/Contents/Resources/app/bin/code /usr/local/bin/code</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>终端命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Introduction to RxTest - tasanobu tech blog</title>
    <url>/2018/01/30/20180130-Introduction%20to%20RxTest%20-%20tasanobu%20tech%20blog/</url>
    <content><![CDATA[<p>I had a <span class="exturl" data-url="aHR0cHM6Ly9zcGVha2VyZGVjay5jb20vdGFzYW5vYnUvcnh0ZXN0cnUtbWVu">presentation (in Japanese)<i class="fa fa-external-link-alt"></i></span> about RxTest at <span class="exturl" data-url="aHR0cHM6Ly9jb25ucGFzcy5jb20vZXZlbnQvNDE0Nzgv">RxSwift Meetup<i class="fa fa-external-link-alt"></i></span> held at Tokyo.<br>There does not seem to be lots of RxTest related materials on the web so I decided to translate the presentation into English and to write this post.</p>
<p> <strong>Notes</strong> </p>
<ul>
<li><p>This post is based on</p>
<ul>
<li>Xcode 8.1 &#x2F; Swift 3.0</li>
<li>RxSwift 3.0.0</li>
<li>RxTest 3.0.0</li>
</ul>
</li>
<li><p>The code shown in this post is published on my GitHub repository <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Rhc2Fub2J1L1J4VGVzdC1TYW1wbGVz">here<i class="fa fa-external-link-alt"></i></span> .</p>
</li>
</ul>
<span id="more"></span>

<h1 id="What-is-RxTest"><a href="#What-is-RxTest" class="headerlink" title="What is RxTest?"></a>What is RxTest?</h1><ul>
<li>RxTest is a test framework published at RxSwift repository.</li>
<li>Most(All?) of the unit testing in RxSwift is implemented with RxTest</li>
<li>RxTest is available for third-party like normal app developers and it’s easy to add it to your test target with Cocoapods by adding the code like below to your podfile.</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">target <span class="string">&#x27;RxTest-SampleTests&#x27;</span> <span class="keyword">do</span></span><br><span class="line">    pod <span class="string">&#x27;RxTest&#x27;</span>,     <span class="string">&#x27;~&gt; 3.0&#x27;</span></span><br><span class="line">    pod <span class="string">&#x27;RxSwift&#x27;</span>,    <span class="string">&#x27;~&gt; 3.0&#x27;</span></span><br><span class="line">    pod <span class="string">&#x27;RxCocoa&#x27;</span>,    <span class="string">&#x27;~&gt; 3.0&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h1 id="Main-classes-of-RxTest"><a href="#Main-classes-of-RxTest" class="headerlink" title="Main classes of RxTest"></a>Main classes of RxTest</h1><h5 id="TestScheduler"><a href="#TestScheduler" class="headerlink" title="TestScheduler"></a>TestScheduler</h5><ul>
<li>is a scheduler in which virtual time is implemented.</li>
<li>emits events and executes arbitrary closures based on virtual time.</li>
<li>has factory methods to instantiate <code>TestableObserver</code> and <code>TestObservable</code></li>
</ul>
<h5 id="TestableObservable"><a href="#TestableObservable" class="headerlink" title="TestableObservable"></a>TestableObservable</h5><ul>
<li>is an observable sequence which has events sent to observer at the designated virtual time and records subscriptions(subscribe&#x2F;unsubscribe) during its lifetime</li>
</ul>
<h5 id="TestableObserver"><a href="#TestableObserver" class="headerlink" title="TestableObserver"></a>TestableObserver</h5><ul>
<li>is an observer which records all emitted events together with virtual time when they were received.</li>
</ul>
<h1 id="Samples"><a href="#Samples" class="headerlink" title="Samples"></a>Samples</h1><p>Let’s see how to use the classes introduced above.</p>
<p><strong>map operator</strong></p>
<p>The following is the test code of map operetor in RxSwift (I simplified a little.)</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">test_map</span>() &#123;</span><br><span class="line">    <span class="comment">// 1. Instantiate TestScheduler by designating virtual time 0</span></span><br><span class="line">    <span class="keyword">let</span> scheduler <span class="operator">=</span> <span class="type">TestScheduler</span>(initialClock: <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 2. Instantiate TestableObservable&lt;Int&gt;</span></span><br><span class="line">    <span class="comment">// by designating value together with virtual time.</span></span><br><span class="line">    <span class="keyword">let</span> observable <span class="operator">=</span> scheduler.createHotObservable([</span><br><span class="line">        next(<span class="number">150</span>, <span class="number">1</span>),  <span class="comment">// (virtual time, value)</span></span><br><span class="line">        next(<span class="number">210</span>, <span class="number">0</span>),</span><br><span class="line">        next(<span class="number">240</span>, <span class="number">4</span>),</span><br><span class="line">        completed(<span class="number">300</span>)</span><br><span class="line">        ])</span><br><span class="line">    <span class="comment">// 3. Instantiate TestableObserver&lt;Int&gt;</span></span><br><span class="line">    <span class="keyword">let</span> observer <span class="operator">=</span> scheduler.createObserver(<span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line">    <span class="comment">// 4. Make `observer` subscribe `observable` at virtual time 200</span></span><br><span class="line">    scheduler.scheduleAt(<span class="number">200</span>) &#123;</span><br><span class="line">        observable.map &#123; <span class="variable">$0</span> <span class="operator">*</span> <span class="number">2</span> &#125;</span><br><span class="line">            .subscribe(observer)</span><br><span class="line">            .addDisposableTo(<span class="keyword">self</span>.disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. Start `scheduler`</span></span><br><span class="line">    scheduler.start()</span><br><span class="line">    <span class="keyword">let</span> expectedEvents <span class="operator">=</span> [</span><br><span class="line">        next(<span class="number">210</span>, <span class="number">0</span> <span class="operator">*</span> <span class="number">2</span>),</span><br><span class="line">        next(<span class="number">240</span>, <span class="number">4</span> <span class="operator">*</span> <span class="number">2</span>),</span><br><span class="line">        completed(<span class="number">300</span>)</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">// 6-1. Compare the events which `observer` received</span></span><br><span class="line">    <span class="type">XCTAssertEqual</span>(observer.events, expectedEvents)</span><br><span class="line">    <span class="keyword">let</span> expectedSubscriptions <span class="operator">=</span> [</span><br><span class="line">        <span class="type">Subscription</span>(<span class="number">200</span>, <span class="number">300</span>)</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">// 6-2. Compare the virtual times when `observable` was subscribed/unsubscribed</span></span><br><span class="line">    <span class="type">XCTAssertEqual</span>(observable.subscriptions, expectedSubscriptions)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ViewModel-of-Github-follower-search-view"><a href="#ViewModel-of-Github-follower-search-view" class="headerlink" title="ViewModel of Github follower search view"></a>ViewModel of Github follower search view</h2><p>As a more practical example, let’s see the view model for Github follower search view.</p>
<p> <strong>ViewModel</strong></p>
<p>The following class is the view model for the view and it is the test target.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SearchViewModel</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> disposeBag <span class="operator">=</span> <span class="type">DisposeBag</span>()</span><br><span class="line">    <span class="comment">// api call status: .loading, .loaded, .error</span></span><br><span class="line">    <span class="keyword">var</span> state: <span class="type">Variable</span>&lt;<span class="type">State</span>&gt;  <span class="operator">=</span> <span class="type">Variable</span>(.loaded([]))</span><br><span class="line">    <span class="comment">// followers list</span></span><br><span class="line">    <span class="keyword">var</span> users: <span class="type">Variable</span>&lt;[<span class="type">User</span>]&gt; <span class="operator">=</span> <span class="type">Variable</span>([])</span><br><span class="line">    <span class="comment">// Client which has a web API logic</span></span><br><span class="line">    <span class="keyword">let</span> client: <span class="type">Client</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">client</span>: <span class="type">Client</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.client <span class="operator">=</span> client</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Action method to search followers</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">searchFollowers</span>(<span class="params">ofUser</span> <span class="params">user</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        state.value <span class="operator">=</span> .loading</span><br><span class="line">        client.fetchFollowers(ofUser: user)</span><br><span class="line">            .subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">switch</span> event &#123;</span><br><span class="line">                <span class="keyword">case</span> .next(<span class="keyword">let</span> users) :</span><br><span class="line">                    <span class="keyword">self</span>.state.value <span class="operator">=</span> .loaded(users)</span><br><span class="line">                    <span class="keyword">self</span>.users.value <span class="operator">=</span> users</span><br><span class="line">                <span class="keyword">case</span> .error(<span class="keyword">let</span> e):</span><br><span class="line">                    <span class="keyword">self</span>.state.value <span class="operator">=</span> .error(e <span class="keyword">as?</span> <span class="type">Client</span>.<span class="type">Error</span> <span class="operator">??</span> .unknown)</span><br><span class="line">                    <span class="keyword">self</span>.users.value <span class="operator">=</span> []</span><br><span class="line">                <span class="keyword">default</span>: <span class="comment">// ignore `.completed`</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .addDisposableTo(disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There are 2 important points from unit testing perspective.</p>
<ol>
<li>Pass a <code>Client</code> object to <code>SearchModelView</code> ‘s initializer</li>
<li>Call <code>Client.fetchFollowers()</code> inside <code>SearchViewModel</code></li>
</ol>
<p><strong>Mock Client</strong></p>
<p>The following class is the mock object of <code>Client</code> which is used for unit testing.</p>
<p>The mock class inherits <code>Client</code> (in order to simplify the sample).<br>It has a property <code>response</code> which is a <code>TestableObservable</code> used as API response and overrides <code>fetchFollowers()</code> and returns <code>response</code> from it.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MockClient</span>: <span class="title class_ inherited__">Client</span> &#123;</span><br><span class="line">    <span class="comment">// Observable used as API response</span></span><br><span class="line">    <span class="keyword">let</span> response: <span class="type">TestableObservable</span>&lt;[<span class="type">User</span>]&gt;</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">response</span>: <span class="type">TestableObservable</span>&lt;[<span class="type">User</span>]&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>.response <span class="operator">=</span> response</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">fetchFollowers</span>(<span class="params">ofUser</span> <span class="params">user</span>: <span class="type">String</span>) -&gt; <span class="type">Observable</span>&lt;[<span class="type">User</span>]&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> response.asObservable()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Test-code-SearchViewModel-state"><a href="#Test-code-SearchViewModel-state" class="headerlink" title="Test code: SearchViewModel.state"></a>Test code: <code>SearchViewModel.state</code></h3><p>Below is the test sample of <code>SearchViewModel.state</code>.<br>The value of the property changes in response to <code>searchFollowers()</code> which causes network request.</p>
<p>The overall flow is almost the same as the previous example of <code>map</code> operator.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">test_state_when_searchFollowers_succeeded</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> users <span class="operator">=</span> [<span class="type">User</span>(id: <span class="number">12091114</span>, name: <span class="string">&quot;tunepolo&quot;</span>)]</span><br><span class="line">    <span class="comment">// 1. Instantiate TestableObserver</span></span><br><span class="line">    <span class="keyword">let</span> observer <span class="operator">=</span> scheduler.createObserver(<span class="type">State</span>.<span class="keyword">self</span>)</span><br><span class="line">    <span class="comment">// 2. Instantiate TestableObservable</span></span><br><span class="line">    <span class="keyword">let</span> observable <span class="operator">=</span> scheduler.createColdObservable([</span><br><span class="line">        next(<span class="number">100</span>, users)</span><br><span class="line">        ])</span><br><span class="line">    <span class="comment">// 3. Instantiate MockClient with the observable</span></span><br><span class="line">    <span class="keyword">let</span> client <span class="operator">=</span> <span class="type">MockClient</span>(response: observable)</span><br><span class="line">    <span class="comment">// 4. Instantiate SearchViewModel with MockClient</span></span><br><span class="line">    <span class="keyword">let</span> viewModel <span class="operator">=</span> <span class="type">SearchViewModel</span>(client: client)</span><br><span class="line">    <span class="comment">// 5. Make `observer` subscribe `observable` at virtual time 100</span></span><br><span class="line">    scheduler.scheduleAt(<span class="number">100</span>) &#123;</span><br><span class="line">      viewModel.state.asObservable()</span><br><span class="line">          .subscribe(observer)</span><br><span class="line">          .addDisposableTo(<span class="keyword">self</span>.disposeBag)</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="comment">// 6. Call `viewModel.searchFollowers()` at virtual time 200</span></span><br><span class="line">    scheduler.scheduleAt(<span class="number">200</span>) &#123;</span><br><span class="line">        viewModel.searchFollowers(ofUser: <span class="string">&quot;tasanobu&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 7. Start `scheduler`</span></span><br><span class="line">    scheduler.start()</span><br><span class="line">    <span class="comment">// 8. Inspect the events that the observer received</span></span><br><span class="line">    <span class="keyword">let</span> expectedEvents <span class="operator">=</span> [</span><br><span class="line">        next(<span class="number">100</span>, <span class="type">State</span>.loaded([])),</span><br><span class="line">        next(<span class="number">200</span>, <span class="type">State</span>.loading),</span><br><span class="line">        next(<span class="number">300</span>, <span class="type">State</span>.loaded(users))</span><br><span class="line">    ]</span><br><span class="line">    <span class="type">XCTAssertEqual</span>(observer.events, expectedEvents)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Wrap-up"><a href="#Wrap-up" class="headerlink" title="Wrap up"></a>Wrap up</h1><p>This post describes the overview of RxTest and the examples of unit testing with RxTest.<br>You might think it’s hard to get into unit testing of features implemented with RxSwift.<br>However, it’s doable to write such test code by following the steps below.</p>
<ol>
<li>Instantiate TestScheduler</li>
<li>As TestableObservable, instantiate an event sequence which you want to inspect</li>
<li>Instantiate TestableObserver which records events to be inspected</li>
<li>Make TestableObserver subscribe TestableObservable</li>
<li>Start TestScheduler</li>
<li>Inspect TestableObserver.events or TestableObservable.subscriptions depending on your test needs.</li>
</ol>
<p><strong>From:</strong> </p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly90YXNhbm9idS5naXRodWIuaW8vYmxvZy8yMDE2LzExLzE5L2ludHJvZHVjdGlvbi10by1yeHRlc3Qv">Introduction to RxTest - tasanobu tech blog<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>响应式框架</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>重装系统提示没有 Git 的解决方式</title>
    <url>/2018/01/29/20180129-%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E6%8F%90%E7%A4%BA%E6%B2%A1%E6%9C%89%20Git%20%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>执行 git 命令后，提示信息如下：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun</span><br></pre></td></tr></table></figure>

<p>运行如下命令：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>

<p>等安装好了之后，git 就又可以用了。</p>
<p>如果不行可以试试下面的命令：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">xcode-select --reset</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Pod Search 出现 JSON ParserError 错误</title>
    <url>/2018/02/07/20180207-Pod%20Search%20%E5%87%BA%E7%8E%B0%20JSON%20ParserError%20%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>今天执行 <code>pod search</code> 命令的时候出现了 <code>JSON ParserError</code> 的错误，类似于如下：</p>
<h3 id="Report"><a href="#Report" class="headerlink" title="Report"></a>Report</h3><ul>
<li>Run pod search PureLayout</li>
<li>List the search result</li>
<li>can not get the result list, and shows JSON::ParserError - A JSON text must at least contain two octets!</li>
</ul>
<span id="more"></span>

<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CocoaPods : 1.0.0.beta.8</span><br><span class="line">        Ruby : ruby 2.3.0p0 (2015-12-25 revision 53290) [x86_64-darwin15]</span><br><span class="line">    RubyGems : 2.5.1</span><br><span class="line">        Host : Mac OS X 10.11.4 (15E65)</span><br><span class="line">       Xcode : 7.3 (7D175)</span><br><span class="line">         Git : git version 2.6.4 (Apple Git-63)</span><br><span class="line">Ruby lib <span class="built_in">dir</span> : /Users/name/.rvm/rubies/ruby-2.3.0/lib</span><br><span class="line">Repositories : master - https://github.com/CocoaPods/Specs.git @ d8648f8172b778faf0b1fab50c1026c4d7dfa36a</span><br></pre></td></tr></table></figure>

<h3 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cocoapods-deintegrate : 1.0.0.beta.1</span><br><span class="line">cocoapods-plugins     : 1.0.0.beta.1</span><br><span class="line">cocoapods-search      : 1.0.0.beta.2</span><br><span class="line">cocoapods-stats       : 1.0.0.beta.4</span><br><span class="line">cocoapods-trunk       : 1.0.0.beta.4</span><br><span class="line">cocoapods-try         : 1.0.0.beta.4</span><br></pre></td></tr></table></figure>

<h3 id="Podfile"><a href="#Podfile" class="headerlink" title="Podfile"></a>Podfile</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Uncomment this line to define a global platform for your project</span></span><br><span class="line">platform :ios, <span class="string">&#x27;8.0&#x27;</span></span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;MapleStory&#x27;</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">pod <span class="string">&#x27;AFNetworking&#x27;</span>, <span class="string">&#x27;~&gt; 3.1.0&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;SDWebImage&#x27;</span>, <span class="string">&#x27;~&gt; 3.7.5&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;SVProgressHUD&#x27;</span>, <span class="string">&#x27;~&gt; 2.0.2&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;PureLayout&#x27;</span>, <span class="string">&#x27;~&gt; 3.0.1&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;MJRefresh&#x27;</span>, <span class="string">&#x27;~&gt; 3.1.0&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;UICKeyChainStore&#x27;</span>, <span class="string">&#x27;~&gt; 2.1.0&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;ReactiveCocoa&#x27;</span>, <span class="string">&#x27;~&gt; 2.5&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;JSONModel&#x27;</span>, <span class="string">&#x27;~&gt; 1.2.0&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;DZNEmptyDataSet&#x27;</span>, <span class="string">&#x27;~&gt; 1.7.3&#x27;</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;MapleStoryTests&#x27;</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;MapleStoryUITests&#x27;</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">JSON::ParserError - A JSON text must at least contain two octets!</span><br><span class="line">/Users/name/.rvm/rubies/ruby-2.3.0/lib/ruby/2.3.0/json/common.rb:156:<span class="keyword">in</span> `initialize<span class="string">&#x27;</span></span><br><span class="line"><span class="string">/Users/name/.rvm/rubies/ruby-2.3.0/lib/ruby/2.3.0/json/common.rb:156:in `new&#x27;</span></span><br><span class="line">/Users/name/.rvm/rubies/ruby-2.3.0/lib/ruby/2.3.0/json/common.rb:156:<span class="keyword">in</span> `parse<span class="string">&#x27;</span></span><br><span class="line"><span class="string">/Users/name/.rvm/gems/ruby-2.3.0/gems/cocoapods-core-1.0.0.beta.8/lib/cocoapods-core/source/manager.rb:251:in `stored_search_index&#x27;</span></span><br><span class="line">/Users/name/.rvm/gems/ruby-2.3.0/gems/cocoapods-core-1.0.0.beta.8/lib/cocoapods-core/source/manager.rb:187:<span class="keyword">in</span> `updated_search_index<span class="string">&#x27;</span></span><br><span class="line"><span class="string">/Users/name/.rvm/gems/ruby-2.3.0/gems/cocoapods-core-1.0.0.beta.8/lib/cocoapods-core/source/manager.rb:118:in `search_by_name&#x27;</span></span><br><span class="line">/Users/name/.rvm/gems/ruby-2.3.0/gems/cocoapods-search-1.0.0.beta.2/lib/cocoapods-search/command/search.rb:85:<span class="keyword">in</span> `local_search<span class="string">&#x27;</span></span><br><span class="line"><span class="string">/Users/name/.rvm/gems/ruby-2.3.0/gems/cocoapods-search-1.0.0.beta.2/lib/cocoapods-search/command/search.rb:61:in `run&#x27;</span></span><br><span class="line">/Users/name/.rvm/gems/ruby-2.3.0/gems/claide-1.0.0.beta.3/lib/claide/command.rb:334:<span class="keyword">in</span> `run<span class="string">&#x27;</span></span><br><span class="line"><span class="string">/Users/name/.rvm/gems/ruby-2.3.0/gems/cocoapods-1.0.0.beta.8/lib/cocoapods/command.rb:50:in `run&#x27;</span></span><br><span class="line">/Users/name/.rvm/gems/ruby-2.3.0/gems/cocoapods-1.0.0.beta.8/bin/pod:44:<span class="keyword">in</span> `&lt;top (required)&gt;<span class="string">&#x27;</span></span><br><span class="line"><span class="string">/Users/name/.rvm/gems/ruby-2.3.0/bin/pod:23:in `load&#x27;</span></span><br><span class="line">/Users/name/.rvm/gems/ruby-2.3.0/bin/pod:23:<span class="keyword">in</span> `&lt;main&gt;<span class="string">&#x27;</span></span><br><span class="line"><span class="string">/Users/name/.rvm/gems/ruby-2.3.0/bin/ruby_executable_hooks:15:in `eval&#x27;</span></span><br><span class="line">/Users/name/.rvm/gems/ruby-2.3.0/bin/ruby_executable_hooks:15:<span class="keyword">in</span> `&lt;main&gt;<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<p>解决方式也十分的简单：</p>
<h3 id="删除检索文件即可"><a href="#删除检索文件即可" class="headerlink" title="删除检索文件即可"></a>删除检索文件即可</h3><ul>
<li>查看 <code>~/Library/Caches/CocoaPods</code>  目录下是否有 <code>search_index.json</code> 文件，删除即可。</li>
<li>或者执行下面的命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> ~/Library/Caches/CocoaPods/search_index.json</span><br></pre></td></tr></table></figure>

<ul>
<li>之后再次执行 <code>pod search xxx</code> 命令即可。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NvY29hUG9kcy9Db2NvYVBvZHMvaXNzdWVzLzUxNzI=">pod search not work JSON ParserError · Issue #5172 · CocoaPods&#x2F;CocoaPods<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 学习笔记（三）【基础补全】</title>
    <url>/2018/02/05/20180205-Python%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%90%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%A8%E3%80%91/</url>
    <content><![CDATA[<h2 id="Python-基础语法"><a href="#Python-基础语法" class="headerlink" title="Python 基础语法"></a>Python 基础语法</h2><h3 id="Python-标识符"><a href="#Python-标识符" class="headerlink" title="Python 标识符"></a>Python 标识符</h3><hr>
<ul>
<li>在 Python 里，标识符由字母、数字、下划线组成。</li>
<li>在 Python 中，所有标识符可以包括英文、数字以及下划线(_)，但不能以数字开头。</li>
<li>Python 中的标识符是区分大小写的。</li>
<li>以下划线开头的标识符是有特殊意义的。以单下划线开头<code> _foo</code> 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用<code>from xxx import *</code> 而导入；</li>
<li>以双下划线开头的 <code>__foo</code> 代表类的私有成员；以双下划线开头和结尾的 <code>__foo__</code> 代表 Python 里特殊方法专用的标识，如 <code>__init__()</code> 代表类的构造函数。</li>
<li>Python 可以同一行显示多条语句，方法是用分号 <code>;</code> 分开，如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="string">&#x27;hello&#x27;</span>;<span class="built_in">print</span> <span class="string">&#x27;runoob&#x27;</span>;</span><br><span class="line">hello</span><br><span class="line">runoob</span><br></pre></td></tr></table></figure>

<span id="more"></span>


<h3 id="Python-引号"><a href="#Python-引号" class="headerlink" title="Python 引号"></a>Python 引号</h3><hr>
<ul>
<li>Python 可以使用引号( ‘ )、双引号( “ )、三引号( ‘’’ 或 “”” ) 来表示字符串，引号的开始与结束必须的相同类型的。</li>
<li>其中三引号可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被当做注释。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">word = <span class="string">&#x27;word&#x27;</span></span><br><span class="line">sentence = <span class="string">&quot;这是一个句子。&quot;</span></span><br><span class="line">paragraph = <span class="string">&quot;&quot;&quot;这是一个段落。</span></span><br><span class="line"><span class="string">包含了多个语句&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>


<h3 id="Python注释"><a href="#Python注释" class="headerlink" title="Python注释"></a>Python注释</h3><hr>
<ul>
<li>python 中多行注释使用三个单引号(‘’’)或三个双引号(“””)。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="comment"># 文件名：test.py</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这是多行注释，使用单引号。</span></span><br><span class="line"><span class="string">这是多行注释，使用单引号。</span></span><br><span class="line"><span class="string">这是多行注释，使用单引号。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这是多行注释，使用双引号。</span></span><br><span class="line"><span class="string">这是多行注释，使用双引号。</span></span><br><span class="line"><span class="string">这是多行注释，使用双引号。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>


<h2 id="Python-变量类型"><a href="#Python-变量类型" class="headerlink" title="Python 变量类型"></a>Python 变量类型</h2><h3 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h3><hr>
<ul>
<li>在内存中存储的数据可以有多种类型。</li>
<li>例如，一个人的年龄可以用数字来存储，他的名字可以用字符来存储。</li>
<li>Python 定义了一些标准类型，用于存储各种类型的数据。</li>
<li>Python有五个标准的数据类型：<ol>
<li>Numbers（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Dictionary（字典）</li>
</ol>
</li>
</ul>
<h3 id="Python数字"><a href="#Python数字" class="headerlink" title="Python数字"></a>Python数字</h3><hr>
<ul>
<li>数字数据类型用于存储数值。</li>
<li><strong>他们是不可改变的数据类型，这意味着改变数字数据类型会分配一个新的对象。</strong></li>
<li>当你指定一个值时，Number对象就会被创建：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var1 = <span class="number">1</span></span><br><span class="line">var2 = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<ul>
<li>您也可以使用del语句删除一些对象的引用。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">del语句的语法是：</span><br><span class="line">del var1[,var2[,var3[....,varN]]]]</span><br></pre></td></tr></table></figure>

<ul>
<li>您可以通过使用del语句删除单个或多个对象的引用。例如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> var</span><br><span class="line"><span class="keyword">del</span> var_a, var_b</span><br></pre></td></tr></table></figure>

<ul>
<li>Python支持四种不同的数字类型：<ol>
<li>int（有符号整型）</li>
<li>long（长整型[也可以代表八进制和十六进制]）</li>
<li>float（浮点型）</li>
<li>complex（复数）</li>
</ol>
</li>
<li>实例<br>一些数值类型的实例：<br><img src="/my_pictures/20180205/1.png"></li>
<li>长整型也可以使用小写 l，但是还是建议您使用大写 L，避免与数字 1 混淆。Python使用 L 来显示长整型。</li>
<li>Python 还支持复数，复数由实数部分和虚数部分构成，可以用 a + bj,或者 complex(a,b) 表示， 复数的实部 a 和虚部 b 都是浮点型。</li>
</ul>
<h3 id="Python字符串"><a href="#Python字符串" class="headerlink" title="Python字符串"></a>Python字符串</h3><hr>
<ul>
<li>加号（+）是字符串连接运算符，星号（*）是重复操作。如下实例：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>           <span class="comment"># 输出完整字符串</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>[<span class="number">0</span>]        <span class="comment"># 输出字符串中的第一个字符</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>[<span class="number">2</span>:<span class="number">5</span>]      <span class="comment"># 输出字符串中第三个至第五个之间的字符串</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>[<span class="number">2</span>:]       <span class="comment"># 输出从第三个字符开始的字符串</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span> * <span class="number">2</span>       <span class="comment"># 输出字符串两次</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span> + <span class="string">&quot;TEST&quot;</span>  <span class="comment"># 输出连接的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">Hello World!</span><br><span class="line">H</span><br><span class="line">llo</span><br><span class="line">llo World!</span><br><span class="line">Hello World!Hello World!</span><br><span class="line">Hello World!TEST</span><br></pre></td></tr></table></figure>


<h3 id="Python列表"><a href="#Python列表" class="headerlink" title="Python列表"></a>Python列表</h3><hr>
<ul>
<li>List（列表） 是 Python 中使用最频繁的数据类型。</li>
<li>列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。</li>
<li>列表用 [ ] 标识，是 python 最通用的复合数据类型。</li>
<li>列表中值的切割也可以用到变量 [头下标:尾下标] ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。</li>
<li>加号 + 是列表连接运算符，星号 * 是重复操作。如下实例：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">list</span> = [ <span class="string">&#x27;runoob&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;john&#x27;</span>, <span class="number">70.2</span> ]</span><br><span class="line">tinylist = [<span class="number">123</span>, <span class="string">&#x27;john&#x27;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span>               <span class="comment"># 输出完整列表</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span>[<span class="number">0</span>]            <span class="comment"># 输出列表的第一个元素</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span>[<span class="number">1</span>:<span class="number">3</span>]          <span class="comment"># 输出第二个至第三个元素 </span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span>[<span class="number">2</span>:]           <span class="comment"># 输出从第三个开始至列表末尾的所有元素</span></span><br><span class="line"><span class="built_in">print</span> tinylist * <span class="number">2</span>       <span class="comment"># 输出列表两次</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span> + tinylist    <span class="comment"># 打印组合的列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># [&#x27;runoob&#x27;, 786, 2.23, &#x27;john&#x27;, 70.2]</span></span><br><span class="line"><span class="comment"># runoob</span></span><br><span class="line"><span class="comment"># [786, 2.23]</span></span><br><span class="line"><span class="comment"># [2.23, &#x27;john&#x27;, 70.2]</span></span><br><span class="line"><span class="comment"># [123, &#x27;john&#x27;, 123, &#x27;john&#x27;]</span></span><br><span class="line"><span class="comment"># [&#x27;runoob&#x27;, 786, 2.23, &#x27;john&#x27;, 70.2, 123, &#x27;john&#x27;]</span></span><br></pre></td></tr></table></figure>


<h3 id="Python元组"><a href="#Python元组" class="headerlink" title="Python元组"></a>Python元组</h3><hr>
<p>元组是另一个数据类型，类似于List（列表）。<br>元组用”()”标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">tuple</span> = ( <span class="string">&#x27;runoob&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;john&#x27;</span>, <span class="number">70.2</span> )</span><br><span class="line">tinytuple = (<span class="number">123</span>, <span class="string">&#x27;john&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="built_in">tuple</span>               <span class="comment"># 输出完整元组</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">tuple</span>[<span class="number">0</span>]            <span class="comment"># 输出元组的第一个元素</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">tuple</span>[<span class="number">1</span>:<span class="number">3</span>]          <span class="comment"># 输出第二个至第三个的元素 </span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">tuple</span>[<span class="number">2</span>:]           <span class="comment"># 输出从第三个开始至列表末尾的所有元素</span></span><br><span class="line"><span class="built_in">print</span> tinytuple * <span class="number">2</span>       <span class="comment"># 输出元组两次</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">tuple</span> + tinytuple   <span class="comment"># 打印组合的元组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># (&#x27;runoob&#x27;, 786, 2.23, &#x27;john&#x27;, 70.2)</span></span><br><span class="line"><span class="comment"># runoob</span></span><br><span class="line"><span class="comment"># (786, 2.23)</span></span><br><span class="line"><span class="comment"># (2.23, &#x27;john&#x27;, 70.2)</span></span><br><span class="line"><span class="comment"># (123, &#x27;john&#x27;, 123, &#x27;john&#x27;)</span></span><br><span class="line"><span class="comment"># (&#x27;runoob&#x27;, 786, 2.23, &#x27;john&#x27;, 70.2, 123, &#x27;john&#x27;)</span></span><br></pre></td></tr></table></figure>

<p>以下是元组无效的，因为元组是不允许更新的。而列表是允许更新的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">tuple</span> = ( <span class="string">&#x27;runoob&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;john&#x27;</span>, <span class="number">70.2</span> )</span><br><span class="line"><span class="built_in">list</span> = [ <span class="string">&#x27;runoob&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;john&#x27;</span>, <span class="number">70.2</span> ]</span><br><span class="line"><span class="built_in">tuple</span>[<span class="number">2</span>] = <span class="number">1000</span>    <span class="comment"># 元组中是非法应用</span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">2</span>] = <span class="number">1000</span>     <span class="comment"># 列表中是合法应用</span></span><br></pre></td></tr></table></figure>


<h3 id="Python数据类型转换"><a href="#Python数据类型转换" class="headerlink" title="Python数据类型转换"></a>Python数据类型转换</h3><hr>
<p><img src="/my_pictures/20180205/2.png"></p>
<h2 id="Python-运算符"><a href="#Python-运算符" class="headerlink" title="Python 运算符"></a>Python 运算符</h2><h3 id="Python算术运算符"><a href="#Python算术运算符" class="headerlink" title="Python算术运算符"></a>Python算术运算符</h3><hr>
<p><img src="/my_pictures/20180205/3.png"></p>
<p><strong>注意：Python2.x 里，整数除整数，只能得出整数。如果要得到小数部分，把其中一个数改成浮点数即可。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>/<span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1.0</span>/<span class="number">2</span></span><br><span class="line"><span class="number">0.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>/<span class="built_in">float</span>(<span class="number">2</span>)</span><br><span class="line"><span class="number">0.5</span></span><br></pre></td></tr></table></figure>


<h3 id="Python位运算符"><a href="#Python位运算符" class="headerlink" title="Python位运算符"></a>Python位运算符</h3><hr>
<p>按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下：<br>下表中变量 a 为 60，b 为 13，二进制格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = 0011 <span class="number">1100</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">0000</span> <span class="number">1101</span></span><br><span class="line"></span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">a&amp;b = <span class="number">0000</span> <span class="number">1100</span></span><br><span class="line"></span><br><span class="line">a|b = 0011 <span class="number">1101</span></span><br><span class="line"></span><br><span class="line">a^b = 0011 0001</span><br><span class="line"></span><br><span class="line">~a  = <span class="number">1100</span> 0011</span><br></pre></td></tr></table></figure>

<p><img src="/my_pictures/20180205/4.png"></p>
<h3 id="Python逻辑运算符"><a href="#Python逻辑运算符" class="headerlink" title="Python逻辑运算符"></a>Python逻辑运算符</h3><hr>
<p>Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:</p>
<p><img src="/my_pictures/20180205/5.png"></p>
<h3 id="Python成员运算符"><a href="#Python成员运算符" class="headerlink" title="Python成员运算符"></a>Python成员运算符</h3><hr>
<p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p>
<p><img src="/my_pictures/20180205/6.png"></p>
<h2 id="Python身份运算符"><a href="#Python身份运算符" class="headerlink" title="Python身份运算符"></a>Python身份运算符</h2><hr>
<p>身份运算符用于比较两个对象的存储单元</p>
<p><img src="/my_pictures/20180205/7.png"></p>
<p><strong>is 与 &#x3D;&#x3D; 区别：</strong><br>is 用于判断两个变量引用对象是否为同一个， &#x3D;&#x3D; 用于判断引用变量的值是否相等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> a </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b == a</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b == a</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>ShareSDK 回调一直是 SSDKResponseStateCancel</title>
    <url>/2018/02/07/20180207-ShareSDK%20%E5%9B%9E%E8%B0%83%E4%B8%80%E7%9B%B4%E6%98%AF%20SSDKResponseStateCancel/</url>
    <content><![CDATA[<p>之前解决了，点击登录无反应的 <code>ShareSDK</code> 问题，今天又碰到了点击登陆后回调的 <code>SSDKResponseState</code> 参数一直都是 <code>cancel</code> 的问题。</p>
<p>刚开始以为是我的配置文件出现了问题，一直修改 <code>info.plist</code> 文件，但是问题依旧。问了技术支持，说让我升级到最新的版本，我又 <code>pod update</code>  一下，确实是最新的版本。之后觉得可能我的 <code>repo</code>  不是最新的，又更新了我的 <code>repo</code> ，发现还是不行。我看了一下 <code>sharesdk </code> 的版本，确实是<strong>4.0.4</strong>最新的没错啊，之后在 GitHub 上看 sharesdk 最新版本的时候，无意间看到了 sharesdk 名字改成了 <code>mob_sharesdk</code> 最新版本是<strong>4.0.9</strong>，终于知道原因了。</p>
<span id="more"></span>

<h4 id="我之前的写法："><a href="#我之前的写法：" class="headerlink" title="我之前的写法："></a>我之前的写法：</h4><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod <span class="string">&#x27;ShareSDK3&#x27;</span>, <span class="string">&#x27;~&gt; 4.0.4&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="更改后"><a href="#更改后" class="headerlink" title="更改后"></a>更改后</h4><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod <span class="string">&#x27;mob_sharesdk&#x27;</span>, <span class="string">&#x27;~&gt; 4.0.9&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pod update</span><br></pre></td></tr></table></figure>

<p>重新进行第三方登陆，终于可以了😭</p>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>ShareSDK</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 学习笔记（四）【日期和时间】</title>
    <url>/2018/02/06/20180206-Python%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E3%80%90%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E3%80%91/</url>
    <content><![CDATA[<h3 id="获取格式化的时间"><a href="#获取格式化的时间" class="headerlink" title="获取格式化的时间"></a>获取格式化的时间</h3><hr>
<p>你可以根据需求选取各种格式，但是最简单的获取可读的时间模式的函数是asctime():</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">localtime = time.asctime( time.localtime(time.time()) )</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;本地时间为 :&quot;</span>, localtime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># 本地时间为 : Thu Apr  7 10:05:21 2016</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>


<h3 id="格式化日期"><a href="#格式化日期" class="headerlink" title="格式化日期"></a>格式化日期</h3><hr>
<p>我们可以使用 time 模块的 strftime 方法来格式化日期：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化成2016-03-20 11:45:39形式</span></span><br><span class="line"><span class="built_in">print</span> time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime()) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化成Sat Mar 28 22:24:24 2016形式</span></span><br><span class="line"><span class="built_in">print</span> time.strftime(<span class="string">&quot;%a %b %d %H:%M:%S %Y&quot;</span>, time.localtime()) </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 将格式字符串转换为时间戳</span></span><br><span class="line">a = <span class="string">&quot;Sat Mar 28 22:24:24 2016&quot;</span></span><br><span class="line"><span class="built_in">print</span> time.mktime(time.strptime(a,<span class="string">&quot;%a %b %d %H:%M:%S %Y&quot;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># 2016-04-07 10:25:09</span></span><br><span class="line"><span class="comment"># Thu Apr 07 10:25:09 2016</span></span><br><span class="line"><span class="comment"># 1459175064.0</span></span><br></pre></td></tr></table></figure>


<h3 id="Python中时间日期格式化符号"><a href="#Python中时间日期格式化符号" class="headerlink" title="Python中时间日期格式化符号"></a>Python中时间日期格式化符号</h3><hr>
<ul>
<li>%y 两位数的年份表示（00-99）</li>
<li>%Y 四位数的年份表示（000-9999）</li>
<li>%m 月份（01-12）</li>
<li>%d 月内中的一天（0-31）</li>
<li>%H 24小时制小时数（0-23）</li>
<li>%I 12小时制小时数（01-12）</li>
<li>%M 分钟数（00&#x3D;59）</li>
<li>%S 秒（00-59）</li>
<li>%a 本地简化星期名称</li>
<li>%A 本地完整星期名称</li>
<li>%b 本地简化的月份名称</li>
<li>%B 本地完整的月份名称</li>
<li>%c 本地相应的日期表示和时间表示</li>
<li>%j 年内的一天（001-366）</li>
<li>%p 本地A.M.或P.M.的等价符</li>
<li>%U 一年中的星期数（00-53）星期天为星期的开始</li>
<li>%w 星期（0-6），星期天为星期的开始</li>
<li>%W 一年中的星期数（00-53）星期一为星期的开始</li>
<li>%x 本地相应的日期表示</li>
<li>%X 本地相应的时间表示</li>
<li>%Z 当前时区的名称</li>
<li>%% %号本身</li>
</ul>
<h3 id="获取某月日历"><a href="#获取某月日历" class="headerlink" title="获取某月日历"></a>获取某月日历</h3><hr>
<p>Calendar模块有很广泛的方法用来处理年历和月历，例如打印某月的月历：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> calendar</span><br><span class="line"></span><br><span class="line">cal = calendar.month(<span class="number">2016</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;以下输出2016年1月份的日历:&quot;</span></span><br><span class="line"><span class="built_in">print</span> cal;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># 以下输出2016年1月份的日历:</span></span><br><span class="line"><span class="comment">#     January 2016</span></span><br><span class="line"><span class="comment"># Mo Tu We Th Fr Sa Su</span></span><br><span class="line"><span class="comment">#              1  2  3</span></span><br><span class="line"><span class="comment">#  4  5  6  7  8  9 10</span></span><br><span class="line"><span class="comment"># 11 12 13 14 15 16 17</span></span><br><span class="line"><span class="comment"># 18 19 20 21 22 23 24</span></span><br><span class="line"><span class="comment"># 25 26 27 28 29 30 31</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C 中的强引用（__strong）和 弱引用（__weak）</title>
    <url>/2018/02/08/20180208-Objective-C%20%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%88__strong%EF%BC%89%E5%92%8C%20%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%88__weak%EF%BC%89/</url>
    <content><![CDATA[<p>在Objective-C的ARC模式中，</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">id</span> obj1 = [[<span class="built_in">NSObject</span> alloc] init];</span><br></pre></td></tr></table></figure>

<p>这里虽然没有显示的声明为 <code>__strong</code> ，但是 <code>Objective-C</code> 默认声明的一个对象就为 <code>__strong</code> ，即：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">id</span> obj1 = [[<span class="built_in">NSObject</span> alloc] init];</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">id</span> __<span class="keyword">strong</span> obj1 = [[<span class="built_in">NSObject</span> alloc] init];</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>是等价的。</p>
<p>在强引用中，有时会出现循环引用的情况，这时就需要弱引用来帮忙（ <code>__weak</code> ）。</p>
<p>强引用持有对象，弱引用不持有对象。</p>
<p>强引用可以释放对象，但弱引用不可以，因为弱引用不持有对象，当弱引用指向一个强引用所持有的对象时，当强引用将对象释放掉后，弱引用会自动的被赋值为nil，即弱引用会自动的指向nil。</p>
<p>下面用代码来说明：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.m</span></span><br><span class="line"><span class="comment">//  ARC中的强引用和弱引用</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by on 15/3/31.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2015年 apple. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="type">id</span> __<span class="keyword">weak</span> obj0 = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line">            <span class="type">id</span> obj1 = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">            obj0 = obj1;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;obj0: %@&quot;</span>, obj0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;obj0: %@&quot;</span>, obj0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  输出结果</span></span><br><span class="line"><span class="comment"> *  obj0: &lt;NSObject: 0x1003066c0&gt;</span></span><br><span class="line"><span class="comment"> *  obj0: (null)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  因为obj1生成的默认的为强引用(__strong)，在超出if的作用域之后，obj1所持有的对象被释放，</span></span><br><span class="line"><span class="comment"> *  obj0为弱引用，所以obj0不持有对象，在obj1对象释放后，obj0自动的被赋值为nil</span></span><br><span class="line"><span class="comment"> *  弱引用的特性是，不持有对象，即便是写成id __weak obj1 = [[NSObject alloc] init];</span></span><br><span class="line"><span class="comment"> *  此代码系统会给与警告，因为这里obj1被声明成弱引用，那么在赋值之后，alloc出来的对象会被立即释放。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 原生实现扫描二维码和条形码功能，限制扫描区域</title>
    <url>/2018/02/08/20180208-iOS%20%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%E6%89%AB%E6%8F%8F%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%92%8C%E6%9D%A1%E5%BD%A2%E7%A0%81%E5%8A%9F%E8%83%BD%EF%BC%8C%E9%99%90%E5%88%B6%E6%89%AB%E6%8F%8F%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<blockquote>
<p>现在苹果iOS系统已经原生支持了二维码扫描的功能，使用原生来扫描需要导入 <strong>AVFoundation</strong> 。  </p>
</blockquote>
<h3 id="扫描准备"><a href="#扫描准备" class="headerlink" title="扫描准备"></a>扫描准备</h3><hr>
<p><strong>一、获取摄像设备：</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">device <span class="operator">=</span> <span class="type">AVCaptureDevice</span>.defaultDevice(withMediaType: <span class="type">AVMediaTypeVideo</span>)</span><br></pre></td></tr></table></figure>

<p><strong>二、创建输入流</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> input <span class="operator">=</span> <span class="type">AVCaptureDeviceInput</span>(device: device)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="keyword">let</span> e <span class="keyword">as</span> <span class="type">NSError</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(e.localizedDescription)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><strong>三、创建输出流</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">output <span class="operator">=</span> <span class="type">AVCaptureMetadataOutput</span>()</span><br><span class="line"><span class="comment">// 设置代理在主线程中刷新</span></span><br><span class="line">output<span class="operator">?</span>.setMetadataObjectsDelegate(<span class="keyword">self</span>, queue: <span class="type">DispatchQueue</span>.main)</span><br></pre></td></tr></table></figure>

<p><strong>四、初始化连接对象</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">session <span class="operator">=</span> <span class="type">AVCaptureSession</span>()</span><br><span class="line"><span class="comment">// 高质量采集率</span></span><br><span class="line">session<span class="operator">?</span>.canSetSessionPreset(<span class="type">AVCaptureSessionPresetHigh</span>)</span><br><span class="line">session<span class="operator">?</span>.addOutput(output)</span><br><span class="line">session<span class="operator">?</span>.addInput(input)</span><br></pre></td></tr></table></figure>

<p><strong>五、设置扫描区域</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 特别注意的地方：有效的扫描区域，定位是以设置的右顶点为原点。屏幕宽所在的那条线为y轴，屏幕高所在的线为x轴</span></span><br><span class="line"><span class="keyword">let</span> x <span class="operator">=</span> ((<span class="type">SCREENHeight</span> <span class="operator">-</span> <span class="type">QRCodeWidth</span> <span class="operator">-</span> topViewHeight) <span class="operator">/</span> <span class="number">2.0</span>) <span class="operator">/</span> <span class="type">SCREENHeight</span></span><br><span class="line"><span class="keyword">let</span> y <span class="operator">=</span> ((<span class="type">SCREENWidth</span> <span class="operator">-</span> <span class="type">QRCodeWidth</span>) <span class="operator">/</span> <span class="number">2.0</span>) <span class="operator">/</span> <span class="type">SCREENWidth</span></span><br><span class="line"><span class="keyword">let</span> width <span class="operator">=</span> <span class="type">QRCodeWidth</span> <span class="operator">/</span> <span class="type">SCREENHeight</span></span><br><span class="line"><span class="keyword">let</span> height <span class="operator">=</span> <span class="type">QRCodeWidth</span> <span class="operator">/</span> <span class="type">SCREENWidth</span></span><br><span class="line">output<span class="operator">?</span>.rectOfInterest <span class="operator">=</span> <span class="type">CGRect</span>(x: x, y: y, width: width, height: height)</span><br></pre></td></tr></table></figure>

<p><strong>六、设置扫码支持的编码格式(如下设置条形码和二维码兼容)</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">output<span class="operator">?</span>.metadataObjectTypes <span class="operator">=</span> [<span class="type">AVMetadataObjectTypeQRCode</span>, <span class="type">AVMetadataObjectTypeEAN13Code</span>, <span class="type">AVMetadataObjectTypeEAN8Code</span>, <span class="type">AVMetadataObjectTypeCode128Code</span>]</span><br></pre></td></tr></table></figure>

<p><strong>七、开始捕获</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">preview <span class="operator">=</span> <span class="type">AVCaptureVideoPreviewLayer</span>(session: session)</span><br><span class="line">preview<span class="operator">?</span>.videoGravity <span class="operator">=</span> <span class="type">AVLayerVideoGravityResizeAspectFill</span></span><br><span class="line">preview<span class="operator">?</span>.frame <span class="operator">=</span> <span class="keyword">self</span>.view.layer.bounds</span><br><span class="line"><span class="keyword">self</span>.view.layer.insertSublayer(preview<span class="operator">!</span>, at: <span class="number">0</span>)</span><br><span class="line">session<span class="operator">?</span>.startRunning()</span><br></pre></td></tr></table></figure>

<h3 id="扫描动画"><a href="#扫描动画" class="headerlink" title="扫描动画"></a>扫描动画</h3><hr>
<blockquote>
<p>这里的动画是仿支付宝的扫描框动画  </p>
</blockquote>
<p>我们新建一个方法，专门处理我们的动画。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">func</span> <span class="title function_">scanAnimation</span>() -&gt; <span class="type">CABasicAnimation</span> &#123;</span><br><span class="line">     <span class="keyword">let</span> scanNetAnimation <span class="operator">=</span> <span class="type">CABasicAnimation</span>()</span><br><span class="line">        <span class="comment">// 沿Y轴运动</span></span><br><span class="line">     scanNetAnimation.keyPath <span class="operator">=</span> <span class="string">&quot;transform.translation.y&quot;</span></span><br><span class="line">     <span class="comment">// 扫描框的高度，注意：这里是实际高度的相反数</span></span><br><span class="line">     scanNetAnimation.byValue <span class="operator">=</span> <span class="type">QRCodeWidth</span></span><br><span class="line">       <span class="comment">// 动画的持续时间</span></span><br><span class="line">     scanNetAnimation.duration <span class="operator">=</span> <span class="number">1.5</span></span><br><span class="line">     <span class="comment">// 动画的重复次数</span></span><br><span class="line">     scanNetAnimation.repeatCount <span class="operator">=</span> <span class="type">MAXFLOAT</span></span><br><span class="line">        </span><br><span class="line">     <span class="keyword">return</span> scanNetAnimation</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用动画：</p>
<p>我们在创建界面的时候，扫描框有一个UIImageView，我们需要将我们的动画添加到这个ImageView上面。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">scanImageView<span class="operator">?</span>.layer.add(scanAnimation(), forKey: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<h3 id="扫描之后的处理"><a href="#扫描之后的处理" class="headerlink" title="扫描之后的处理"></a>扫描之后的处理</h3><hr>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">captureOutput</span>(<span class="keyword">_</span> <span class="params">captureOutput</span>: <span class="type">AVCaptureOutput</span>!, <span class="params">didOutputMetadataObjects</span> <span class="params">metadataObjects</span>: [<span class="keyword">Any</span>]<span class="operator">!</span>, <span class="params">from</span> <span class="params">connection</span>: <span class="type">AVCaptureConnection</span>!) &#123;</span><br><span class="line">    <span class="keyword">if</span> metadataObjects.count <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">        session<span class="operator">?</span>.stopRunning()</span><br><span class="line">        <span class="keyword">let</span> metadataObject <span class="operator">=</span> metadataObjects[<span class="number">0</span>] <span class="keyword">as</span> <span class="type">AnyObject</span></span><br><span class="line">        <span class="keyword">let</span> stringValue: <span class="type">String</span> <span class="operator">=</span> metadataObject.stringValue</span><br><span class="line">        <span class="keyword">let</span> vc <span class="operator">=</span> <span class="type">QRCodeResultViewController</span>.instantiate()</span><br><span class="line">        vc.resultStr <span class="operator">=</span> stringValue</span><br><span class="line">        <span class="keyword">self</span>.navigationController<span class="operator">?</span>.pushViewController(vc, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="点击扫描结果的处理"><a href="#点击扫描结果的处理" class="headerlink" title="点击扫描结果的处理"></a>点击扫描结果的处理</h3><hr>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">webView</span>(<span class="keyword">_</span> <span class="params">webView</span>: <span class="type">UIWebView</span>, <span class="params">shouldStartLoadWith</span> <span class="params">request</span>: <span class="type">URLRequest</span>, <span class="params">navigationType</span>: <span class="type">UIWebViewNavigationType</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> requestURL <span class="operator">=</span> request.url</span><br><span class="line">    <span class="keyword">if</span> requestURL<span class="operator">?</span>.scheme <span class="operator">==</span> <span class="string">&quot;http&quot;</span> <span class="operator">||</span> requestURL<span class="operator">?</span>.scheme <span class="operator">==</span> <span class="string">&quot;https&quot;</span> <span class="operator">||</span> requestURL<span class="operator">?</span>.scheme <span class="operator">==</span> <span class="string">&quot;mailto&quot;</span> <span class="operator">&amp;&amp;</span> navigationType <span class="operator">==</span> .linkClicked &#123;</span><br><span class="line"><span class="comment">//        UIApplication.shared.open(requestURL!, options: [:], completionHandler: nil)</span></span><br><span class="line">        <span class="keyword">let</span> svc <span class="operator">=</span> <span class="type">SFSafariViewController</span>(url: requestURL<span class="operator">!</span>)</span><br><span class="line">        <span class="keyword">self</span>.present(svc, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以用</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">open</span>(<span class="keyword">_</span> <span class="params">url</span>: <span class="type">URL</span>, <span class="params">options</span>: [<span class="params">String</span> : <span class="keyword">Any</span>] <span class="operator">=</span> [:], <span class="params">completionHandler</span> <span class="params">completion</span>: ((<span class="type">Bool</span>) -&gt; <span class="type">Swift</span>.<span class="type">Void</span>)<span class="operator">?</span> <span class="operator">=</span> <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<p>在Safari中打开连接。不过最好是把事件控制在自己的程序中，在iOS 9 之后，苹果引入了 SFSafariViewController 这个类，可以用这个类来显示需要浏览的网页。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> svc <span class="operator">=</span> <span class="type">SFSafariViewController</span>(url: requestURL<span class="operator">!</span>)</span><br><span class="line"><span class="keyword">self</span>.present(svc, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>功能开发</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 学习笔记（五）【函数】</title>
    <url>/2018/02/07/20180207-Python%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E3%80%90%E5%87%BD%E6%95%B0%E3%80%91/</url>
    <content><![CDATA[<h3 id="定义一个函数"><a href="#定义一个函数" class="headerlink" title="定义一个函数"></a>定义一个函数</h3><hr>
<p>你可以定义一个由自己想要功能的函数，以下是简单的规则：</p>
<ul>
<li>函数代码块以 def 关键词开头，后接函数标识符名称和圆括号()。</li>
<li>任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。</li>
<li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</li>
<li>函数内容以冒号起始，并且缩进。</li>
<li>return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</li>
</ul>
<span id="more"></span>

<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><hr>
<p>在 python 中，类型属于对象，变量是没有类型的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a = <span class="string">&quot;Runoob&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>以上代码中，[1,2,3] 是 List 类型，”Runoob” 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是 List 类型对象，也可以指向 String 类型对象。</strong></p>
<h3 id="可更改-mutable-与不可更改-immutable-对象"><a href="#可更改-mutable-与不可更改-immutable-对象" class="headerlink" title="可更改(mutable)与不可更改(immutable)对象"></a>可更改(mutable)与不可更改(immutable)对象</h3><hr>
<p>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p>
<ul>
<li><em>不可变类型</em>：变量赋值 a&#x3D;5 后再赋值 a&#x3D;10，<strong>这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。</strong></li>
<li><em>可变类型</em>：变量赋值 la&#x3D;[1,2,3,4] 后再赋值 la[2]&#x3D;5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</li>
</ul>
<p>python 函数的参数传递：</p>
<ul>
<li><strong>不可变类型</strong>：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。</li>
<li><strong>可变类型</strong>：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响</li>
</ul>
<p><strong>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</strong></p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><hr>
<h5 id="必备参数"><a href="#必备参数" class="headerlink" title="必备参数"></a>必备参数</h5><p>必备参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。<br>调用printme()函数，你必须传入一个参数，不然会出现语法错误：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printme</span>(<span class="params"> <span class="built_in">str</span> </span>):</span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> <span class="built_in">str</span>;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printme函数</span></span><br><span class="line">printme();</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;test.py&quot;</span>, line <span class="number">11</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    printme();</span><br><span class="line">TypeError: printme() takes exactly <span class="number">1</span> argument (<span class="number">0</span> given)</span><br></pre></td></tr></table></figure>

<h5 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h5><p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。<br><strong>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</strong><br>以下实例在函数 printme() 调用时使用参数名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printme</span>(<span class="params"> <span class="built_in">str</span> </span>):</span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> <span class="built_in">str</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printme函数</span></span><br><span class="line">printme( <span class="built_in">str</span> = <span class="string">&quot;My string&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">My string</span><br></pre></td></tr></table></figure>

<p>下例能将关键字参数顺序不重要展示得更清楚：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> name, age </span>):</span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;Name: &quot;</span>, name</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;Age &quot;</span>, age</span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printinfo函数</span></span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">&quot;miki&quot;</span> )</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Name:  miki</span><br><span class="line">Age  <span class="number">50</span></span><br></pre></td></tr></table></figure>

<h5 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h5><p>你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">functionname</span>(<span class="params">[formal_args,] *var_args_tuple </span>):</span><br><span class="line">   <span class="string">&quot;函数_文档字符串&quot;</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure>

<p>加了星号（*）的变量名会存放所有未命名的变量参数。不定长参数实例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_var_info</span>(<span class="params">arg1, *vartuple</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;不定长参数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;输出:&quot;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;arg1: &quot;</span>, arg1</span><br><span class="line">    <span class="keyword">for</span> var <span class="keyword">in</span> vartuple:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;var: &quot;</span>, var</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">print_var_info(<span class="number">10</span>)</span><br><span class="line">print_var_info(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># arg1:  10</span></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># arg1:  10</span></span><br><span class="line"><span class="comment"># var:  20</span></span><br><span class="line"><span class="comment"># var:  30</span></span><br></pre></td></tr></table></figure>

<h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5><p>python 使用 lambda 来创建匿名函数。</p>
<ul>
<li>lambda只是一个表达式，函数体比def简单很多。</li>
<li>lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。</li>
<li>lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。</li>
<li>虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</li>
</ul>
<p><strong>语法</strong><br>lambda函数的语法只包含一个语句，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> [arg1 [,arg2,.....argn]]:expression</span><br></pre></td></tr></table></figure>

<p>如下实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="built_in">sum</span> = <span class="keyword">lambda</span> arg1, arg2: arg1 + arg2;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用sum函数</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;相加后的值为 : &quot;</span>, <span class="built_in">sum</span>( <span class="number">10</span>, <span class="number">20</span> )</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;相加后的值为 : &quot;</span>, <span class="built_in">sum</span>( <span class="number">20</span>, <span class="number">20</span> )</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">相加后的值为 :  <span class="number">30</span></span><br><span class="line">相加后的值为 :  <span class="number">40</span></span><br></pre></td></tr></table></figure>

<p>补充：<br>    在Python中，有 filter，map，reduce方法，lambda用于此方法中如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = [<span class="number">2</span>, <span class="number">18</span>, <span class="number">9</span>, <span class="number">22</span>, <span class="number">17</span>, <span class="number">24</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">27</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">3</span> == <span class="number">0</span>, foo)</span><br><span class="line">[<span class="number">18</span>, <span class="number">9</span>, <span class="number">24</span>, <span class="number">12</span>, <span class="number">27</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * <span class="number">2</span> + <span class="number">10</span>, foo)</span><br><span class="line">[<span class="number">14</span>, <span class="number">46</span>, <span class="number">28</span>, <span class="number">54</span>, <span class="number">44</span>, <span class="number">58</span>, <span class="number">26</span>, <span class="number">34</span>, <span class="number">64</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> reduce(<span class="keyword">lambda</span> x, y: x + y, foo)</span><br><span class="line"><span class="number">139</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义OS X的window button</title>
    <url>/2018/02/08/20180208-%E8%87%AA%E5%AE%9A%E4%B9%89OS%20X%E7%9A%84window%20button/</url>
    <content><![CDATA[<blockquote>
<p>由于项目原来的设计，导致在OS X 10.10之后的系统上会出现一些奇怪的Bug，调用<code>- addSubview:positioned:relativeTo:</code>方法却并没有实现将视图放在最上层。经过不断的查找，才知道，子视图的父视图并没有被显示出来，导致了<code>- addSubview:positioned:relativeTo:</code>方法不起作用。那么如果将父视图显示出来的话，window button（关闭按钮，最小化按钮，全屏按钮，最大化窗口按钮）又会被遮盖掉，无奈，需要自定义window button。</p>
</blockquote>
<h3 id="在自定义之前一定要将系统自动创建的按钮关闭"><a href="#在自定义之前一定要将系统自动创建的按钮关闭" class="headerlink" title="在自定义之前一定要将系统自动创建的按钮关闭"></a>在自定义之前一定要将系统自动创建的按钮关闭</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[<span class="keyword">self</span>.window standardWindowButton:<span class="built_in">NSWindowCloseButton</span>] setEnabled:<span class="literal">NO</span>];</span><br><span class="line">[[<span class="keyword">self</span>.window standardWindowButton:<span class="built_in">NSWindowMiniaturizeButton</span>] setEnabled:<span class="literal">NO</span>];</span><br><span class="line">[[<span class="keyword">self</span>.window standardWindowButton:<span class="built_in">NSWindowFullScreenButton</span>] setEnabled:<span class="literal">NO</span>];</span><br><span class="line">[[<span class="keyword">self</span>.window standardWindowButton:<span class="built_in">NSWindowZoomButton</span>] setEnabled:<span class="literal">NO</span>];</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="自定义左上角的三个控制按钮"><a href="#自定义左上角的三个控制按钮" class="headerlink" title="自定义左上角的三个控制按钮"></a>自定义左上角的三个控制按钮</h3><p>这里我是将三个按钮写到了一个自定义View中，方便布局用。</p>
<p>首先是头文件中声明：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Cocoa/Cocoa.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CustomWindowButtonView</span> : <span class="title">NSView</span> </span>&#123;</span><br><span class="line"><span class="keyword">@private</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">BOOL</span> mouseInside_;</span><br><span class="line">    <span class="built_in">NSButton</span> *closeButton_;</span><br><span class="line">    <span class="built_in">NSButton</span> *minitButton_;</span><br><span class="line">    <span class="built_in">NSButton</span> *zoomButton_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">BOOL</span> mouseInside;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="built_in">NSButton</span> *closeButton;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="built_in">NSButton</span> *minitButton;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="built_in">NSButton</span> *zoomButton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>mouseInside参数是用于判断鼠标是否在视图之中。</p>
<p>创建一个window button所用到的方法是<code>+ standardWindowButton:forStyleMask:</code><br>文档中相关说明：</p>
<blockquote>
<p>Returns a new instance of a given standard window button, sized appropriately for a given window style.</p>
</blockquote>
<p>这里说明了，此方法是返回一个标准的window button实例，并且会设置合适的window style。<br><code>NSWindowButton</code>取值如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">   <span class="built_in">NSWindowCloseButton</span>,</span><br><span class="line">   <span class="built_in">NSWindowMiniaturizeButton</span>,</span><br><span class="line">   <span class="built_in">NSWindowZoomButton</span>,</span><br><span class="line">   <span class="built_in">NSWindowToolbarButton</span>,</span><br><span class="line">   <span class="built_in">NSWindowDocumentIconButton</span>,</span><br><span class="line">   <span class="built_in">NSWindowDocumentVersionsButton</span> = <span class="number">6</span>,</span><br><span class="line">   <span class="built_in">NSWindowFullScreenButton</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSUInteger</span> <span class="built_in">NSWindowButton</span>;</span><br></pre></td></tr></table></figure>

<p>名字很清楚的显示了window button的作用，这里我们需要自定义的是左边的三个按钮，所以需要用到的是<code>NSWindowCloseButton</code>（关闭窗口按钮），<code>NSWindowMiniaturizeButton</code>（最小化窗口按钮）和<code>NSWindowZoomButton</code>（最大化窗口按钮，<strong>不是全屏按钮</strong>）。</p>
<p><strong>注意</strong><br>在OS X 10.10之后的版本中，<code>NSWindowZoomButton</code>会变成全屏按钮，而不是10.10之前的最大化窗口按钮。</p>
<p>第二个参数设置成<code>self.window.styleMask</code>就OK了。</p>
<p>这里windows button需要实现系统的悬停，响应窗口和非响应窗口的不同效果，那么就要实现鼠标移入和移出的方法<code>- mouseEntered:</code>和<code>- mouseExited:</code>，但是实现这个方法，需要重写<code>- updateTrackingAreas</code>方法，因为当大小或坐标改变后就会造成所指定的检测区域错误,所以我们需要重写<code>updateTrackingAreas</code>方法,将创建<code>NSTrackingArea</code>的工作放在其中。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)updateTrackingAreas &#123;</span><br><span class="line"></span><br><span class="line">    [<span class="variable language_">super</span> updateTrackingAreas];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSTrackingArea</span> *<span class="keyword">const</span> trackingArea = [[<span class="built_in">NSTrackingArea</span> alloc] initWithRect:<span class="built_in">NSZeroRect</span> options:(<span class="built_in">NSTrackingMouseEnteredAndExited</span> | <span class="built_in">NSTrackingActiveAlways</span> | <span class="built_in">NSTrackingInVisibleRect</span>) owner:<span class="keyword">self</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">    [<span class="keyword">self</span> addTrackingArea:trackingArea];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后继续实现鼠标移入移出的方法：</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)mouseEntered:(<span class="built_in">NSEvent</span> *)event &#123;</span><br><span class="line">    [<span class="variable language_">super</span> mouseEntered:event];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.mouseInside = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span> setNeedsDisplayForStandardWindowButtons];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)mouseExited:(<span class="built_in">NSEvent</span> *)event &#123;</span><br><span class="line">    [<span class="variable language_">super</span> mouseExited:event];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.mouseInside = <span class="literal">NO</span>;</span><br><span class="line">    [<span class="keyword">self</span> setNeedsDisplayForStandardWindowButtons];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里我们需要实现一个在<strong>苹果的官方文档中并不存在</strong>的方法<code>- _mouseInGroup:</code>，这个方法用来返回判断鼠标是否在视图中的参数。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)_mouseInGroup:(<span class="built_in">NSButton</span> *)button &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.mouseInside;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最后一个就是需要重绘一下按钮的状态：</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setNeedsDisplayForStandardWindowButtons &#123;</span><br><span class="line">    [<span class="keyword">self</span>.closeButton setNeedsDisplay];</span><br><span class="line">    [<span class="keyword">self</span>.minitButton setNeedsDisplay];</span><br><span class="line">    [<span class="keyword">self</span>.zoomButton setNeedsDisplay];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就实现了自定义的window button，但是窗口在成为第一响应者和不适第一响应者的时候，还有当点击最小化的时候等等情况下，window button都会处于错误的状态中，例如，当失去第一响应的时候，这三个按钮应该变为淡灰色，但却是彩色，当点击最小化，然后再点击显示窗口的时候，三个按钮还是停留在鼠标移入的状态中，所以这些情况都要进行处理。这里我用通知实现了相关的处理：</p>
<p><strong>首先，注册通知：</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSNotificationCenter</span> *defaultCenter = [<span class="built_in">NSNotificationCenter</span> defaultCenter];</span><br><span class="line">[defaultCenter addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(applicationWillBecomeActive:)</span><br><span class="line">                      name:<span class="built_in">NSApplicationWillBecomeActiveNotification</span> object:<span class="built_in">NSApp</span>];</span><br><span class="line">[defaultCenter addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(applicationDidResignActive:)</span><br><span class="line">                      name:<span class="built_in">NSApplicationDidResignActiveNotification</span> object:<span class="built_in">NSApp</span>];</span><br><span class="line">[defaultCenter addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(windowActiveChanged:)</span><br><span class="line">                       name:<span class="built_in">NSWindowDidBecomeMainNotification</span> object:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>

<p><strong>然后实现处理方法（如果有更好的处理方式，大家可以自行写逻辑，这里仅供参考）：</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)applicationWillBecomeActive:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.mouseInside = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span> setNeedsDisplayForStandardWindowButtons];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.mouseInside = <span class="literal">NO</span>;</span><br><span class="line">    [<span class="keyword">self</span> setNeedsDisplayForStandardWindowButtons];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)applicationDidResignActive:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.mouseInside = <span class="literal">NO</span>;</span><br><span class="line">    [<span class="keyword">self</span> setNeedsDisplayForStandardWindowButtons];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)windowActiveChanged:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.mouseInside = <span class="literal">NO</span>;</span><br><span class="line">    [<span class="keyword">self</span> setNeedsDisplayForStandardWindowButtons];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样左边的三个自定义window button就已经完成。</p>
<h3 id="兼容10-10之前的按钮需要实现自定义全屏按钮（NSWindowFullScreenButton）"><a href="#兼容10-10之前的按钮需要实现自定义全屏按钮（NSWindowFullScreenButton）" class="headerlink" title="兼容10.10之前的按钮需要实现自定义全屏按钮（NSWindowFullScreenButton）"></a>兼容10.10之前的按钮需要实现自定义全屏按钮（NSWindowFullScreenButton）</h3><p>创建全屏按钮的方式与之前相同，不多说直接看代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.versionNum != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.fullScreenButton = [<span class="built_in">NSWindow</span> standardWindowButton:<span class="built_in">NSWindowFullScreenButton</span> forStyleMask:<span class="keyword">self</span>.window.styleMask];</span><br><span class="line">        [<span class="keyword">self</span>.fullScreenButton setFrame:<span class="built_in">NSMakeRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.fullScreenButton.frame.size.width, <span class="keyword">self</span>.fullScreenButton.frame.size.height)];</span><br><span class="line">        [<span class="keyword">self</span>.topView.fullScreenBackView addSubview:<span class="keyword">self</span>.fullScreenButton];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里我判断了一下系统的版本。</p>
<p><strong>注意</strong></p>
<blockquote>
<p>设置按钮一定要在主视图控制器中进行，不能在自定义的子视图中进行，否则在10.10之前的系统中会出现coreUI的错误提示。而且这个错误出现的几率不是100%</p>
</blockquote>
<p>在全屏之后，我们最好将所有的window button给隐藏掉，调用<code>setHidden:</code>即可。</p>
<p>这下，自定义的window button就完成了。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy50YW5oYW8ubWUvcGllY2VzLzE4MDguaHRtbC8=">OSX的MouseEntered和MouseExited事件检测<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83NjM0Nzg4L2NvY29hLW9zeC1uc3dpbmRvdy1zdGFuZGFyZHdpbmRvd2J1dHRvbi1iZWhhdmluZy1zdHJhbmdlbHktb25jZS1jb3BpZWQtYW5kLWFkZA==">Cocoa&#x2F;OSX - NSWindow standardWindowButton behaving strangely once copied and added again<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>配置 git 代理</title>
    <url>/2018/02/08/20180208-%E9%85%8D%E7%BD%AE%20git%20%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>当我们再做开发，从github上面下载库的时候，总是很慢。pod setup 那是更加的慢。这里我们配置一下代理，速度立马就上去了。  </p>
</blockquote>
<p>Git 目前支持的三种协议 <code>git://</code>、<code>ssh://</code> 和 <code>http://</code> ，其代理配置各不相同： <code>core.gitproxy</code> 用于 <code>git://</code> 协议， <code>http.proxy</code> 用于 <code>http://</code> 协议， <code>ssh://</code> 协议的代理需要配置 <code>ssh</code> 的 <code>ProxyCommand</code> 参数。</p>
<span id="more"></span>

<p>1、配置http和https代理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ git config --<span class="keyword">global</span> http.proxy http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">1087</span></span><br><span class="line">$ git config --<span class="keyword">global</span> https.proxy https://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">1087</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 删除代理</span></span><br><span class="line">$ git config --<span class="keyword">global</span> --unset http.proxy</span><br><span class="line">$ git config --<span class="keyword">global</span> --unset https.proxy</span><br><span class="line"></span><br><span class="line">$ npm config delete proxy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置socks5代理</span></span><br><span class="line">$ git config --<span class="keyword">global</span> http.proxy <span class="string">&#x27;socks5://127.0.0.1:1086&#x27;</span></span><br><span class="line">$ git config --<span class="keyword">global</span> https.proxy <span class="string">&#x27;socks5://127.0.0.1:1086&#x27;</span></span><br></pre></td></tr></table></figure>

<p>2、 配置git代理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --global core.gitproxy github.com</span><br></pre></td></tr></table></figure>

<p>后面的 <code>github.com</code> 是根据情况而定，这里配置的是github的 <code>git.proxy</code></p>
<p><strong>ssh代理没有试过，略</strong></p>
<p>终端中执行 <code>clone</code> 命令，速度应该很快了。</p>
<blockquote>
<p><strong>sourcetree</strong> 速度也会变快，因为它的 <code>clone</code> 操作，其实也是调用 <code>git clone</code> 命令。  </p>
</blockquote>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH 免密登陆 VPS</title>
    <url>/2018/02/09/20180209-SSH%20%E5%85%8D%E5%AF%86%E7%99%BB%E9%99%86%20VPS/</url>
    <content><![CDATA[<p>我们在进行 SSH 登陆的时候，每次都需要输入密码，就感到十分的不方便，这里可以利用 SSH Key（ssh公钥） 来验证登录，从而实现免密登陆。</p>
<h3 id="通过命令生成-SSH-Key"><a href="#通过命令生成-SSH-Key" class="headerlink" title="通过命令生成 SSH Key"></a>通过命令生成 SSH Key</h3><p>生成 SSH Key 我们需要 <code>ssh-keygen</code> 命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;xxxxx@xxxxx.com&quot;</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># Generating public/private rsa key pair...</span></span><br><span class="line"><span class="comment"># 三次回车即可生成 ssh key</span></span><br></pre></td></tr></table></figure>

<p>查看生成的 SSH Key</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br><span class="line"><span class="comment"># ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc....</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>在 <code>.ssh</code> 文件夹中，可能有三个文件</p>
<ul>
<li>id_rsa : 生成的私钥文件</li>
<li>id_rsa.pub ： 生成的公钥文件</li>
<li>know_hosts :  已知的主机公钥清单</li>
</ul>
<p>我们需要用的就在 <code>id_rsa.pub</code> 文件中。</p>
<p>如果希望ssh公钥生效需满足至少下面两个条件：<br>    * <code>.ssh</code> 目录的权限必须是700<br>    * <code>.ssh/authorized_keys</code> 文件权限必须是600</p>
<h3 id="将-SSH-Key-上传到服务器"><a href="#将-SSH-Key-上传到服务器" class="headerlink" title="将 SSH Key 上传到服务器"></a>将 SSH Key 上传到服务器</h3><h4 id="方法一：手动复制"><a href="#方法一：手动复制" class="headerlink" title="方法一：手动复制"></a>方法一：手动复制</h4><p>先登录服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh root@服务器IP地址 -p 端口</span><br></pre></td></tr></table></figure>

<p>在 VPS 的默认目录（&#x2F;root）下面新建文件夹 <code>.ssh</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/.ssh</span><br></pre></td></tr></table></figure>

<p>进入 <code>.ssh</code> 目录，执行 <code>vi</code> 命令新建 <code>authorized_keys</code> 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line">vi authorized_keys</span><br></pre></td></tr></table></figure>

<p>将 <code>id_rsa.pub</code> 文件中的内容粘贴到 <code>authorized_keys</code> 文件中，保存退出，之后就可以实现免密登陆。</p>
<h4 id="方法二：执行-scp-命令快速建立-authorized-keys-文件"><a href="#方法二：执行-scp-命令快速建立-authorized-keys-文件" class="headerlink" title="方法二：执行 scp 命令快速建立 authorized_keys 文件"></a>方法二：执行 <code>scp</code> 命令快速建立 <code>authorized_keys</code> 文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -P 端口 ~/.ssh/id_rsa.pub root@服务器IP地址:/root/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<p>注意：这里 <code>-P</code> 的 P 是大写。</p>
<p>输入密码后，<code>authorized_keys</code> 文件就新建成功，之后就可以免密登陆了。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 学习笔记（七）【Python中的包】</title>
    <url>/2018/02/12/20180212-Python%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E3%80%90Python%E4%B8%AD%E7%9A%84%E5%8C%85%E3%80%91/</url>
    <content><![CDATA[<p>包是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的子包等组成的 Python 的应用环境。<br><strong>简单来说，包就是文件夹，但该文件夹下必须存在 <code>__init__.py</code> 文件, 该文件的内容可以为空。<code>__int__.py</code> 用于标识当前文件夹是一个包。</strong><br>考虑一个在 <code>package_runoob</code> 目录下的 <code>runoob1.py</code>、<code>runoob2.py</code>、<code>__init__.py</code> 文件，<code>test.py</code> 为测试调用包的代码，目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test.py</span><br><span class="line">package_runoob</span><br><span class="line">|-- __init__.py</span><br><span class="line">|-- runoob1.py</span><br><span class="line">|-- runoob2.py</span><br></pre></td></tr></table></figure>

<p><strong>package_runoob&#x2F;runoob1.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">runoob1</span>():</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;I&#x27;m in runoob1&quot;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><strong>package_runoob&#x2F;runoob2.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">runoob2</span>():</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;I&#x27;m in runoob2&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>现在，在 package_runoob 目录下创建 init.py：</strong><br><strong>package_runoob&#x2F;init.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;作为主程序运行&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;package_runoob 初始化&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>然后我们在 package_runoob 同级目录下创建 test.py 来调用 package_runoob 包</strong></p>
<p><strong>test.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 导入 Phone 包</span></span><br><span class="line"><span class="keyword">from</span> package_runoob.runoob1 <span class="keyword">import</span> runoob1</span><br><span class="line"><span class="keyword">from</span> package_runoob.runoob2 <span class="keyword">import</span> runoob2</span><br><span class="line"> </span><br><span class="line">runoob1()</span><br><span class="line">runoob2()</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package_runoob 初始化</span><br><span class="line">I&#x27;m in runoob1</span><br><span class="line">I&#x27;m in runoob2</span><br></pre></td></tr></table></figure>

<p>如上，为了举例，我们只在每个文件里放置了一个函数，但其实你可以放置许多函数。你也可以在这些文件里定义Python的类，然后为这些类建一个包。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 学习笔记（八）【File(文件) 方法】</title>
    <url>/2018/02/15/20180215-Python%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%E3%80%90File(%E6%96%87%E4%BB%B6)%20%E6%96%B9%E6%B3%95%E3%80%91/</url>
    <content><![CDATA[<p>file 对象使用 open 函数来创建，下表列出了 file 对象常用的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">file.close()</span><br><span class="line"><span class="comment"># 关闭文件。关闭后文件不能再进行读写操作。</span></span><br><span class="line"></span><br><span class="line">file.flush()</span><br><span class="line"><span class="comment"># 刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。</span></span><br><span class="line"></span><br><span class="line">file.fileno()</span><br><span class="line"><span class="comment"># 返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。</span></span><br><span class="line"></span><br><span class="line">file.isatty()</span><br><span class="line"><span class="comment"># 如果文件连接到一个终端设备返回 True，否则返回 False。</span></span><br><span class="line"></span><br><span class="line">file.<span class="built_in">next</span>()</span><br><span class="line"><span class="comment"># 返回文件下一行。</span></span><br><span class="line"></span><br><span class="line">file.read([size])</span><br><span class="line"><span class="comment"># 从文件读取指定的字节数，如果未给定或为负则读取所有。</span></span><br><span class="line"></span><br><span class="line">file.readline([size])</span><br><span class="line"><span class="comment"># 读取整行，包括 &quot;\n&quot; 字符。</span></span><br><span class="line"></span><br><span class="line">file.readlines([sizehint])</span><br><span class="line"><span class="comment"># 读取所有行并返回列表，若给定sizeint&gt;0，则是设置一次读多少字节，这是为了减轻读取压力。</span></span><br><span class="line"></span><br><span class="line">file.seek(offset[, whence])</span><br><span class="line"><span class="comment"># 设置文件当前位置</span></span><br><span class="line"></span><br><span class="line">file.tell()</span><br><span class="line"><span class="comment"># 返回文件当前位置。</span></span><br><span class="line"></span><br><span class="line">file.truncate([size])</span><br><span class="line"><span class="comment"># 截取文件，截取的字节通过size指定，默认为当前文件位置。</span></span><br><span class="line"></span><br><span class="line">file.write(<span class="built_in">str</span>)</span><br><span class="line"><span class="comment"># 将字符串写入文件，没有返回值。</span></span><br><span class="line"></span><br><span class="line">file.writelines(sequence)</span><br><span class="line"><span class="comment"># 向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift是一门动态类型的强类型语言</title>
    <url>/2018/02/26/20180226-Swift%E6%98%AF%E4%B8%80%E9%97%A8%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BC%BA%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>之前我一直以为，Swift是一门弱类型的语言。</p>
<p>判断依据：</p>
<blockquote>
<p>Swift 变量不强制的指定类型，而是用 <code>var</code> 和 <code>let</code> 表示可变与不可变。所以，Swift是一门弱类型的语言。  </p>
</blockquote>
<p>但是，看了一下强弱类型的时候，才恍然大悟。其实 <code>var</code> 和 <code>let</code> 的特性，只是说明Swift是一门动态类型的语言。并不能指出是否是强或弱类型。</p>
<p>一些定义：</p>
<ul>
<li>静态类型语言：是一种编译器无法自动检测类型的语言。</li>
<li>动态类型语言：是一种编译器能够自动检测类型的语言。</li>
<li>强类型语言：强类型语言也称为强类型定义语言。是一种总是强制类型定义的语言，要求变量的使用要严格符合定义，所有变量都必须先定义后使用。</li>
<li>弱类型语言：弱类型语言也称为弱类型定义语言。与强类型定义相反。像vb，php，js等就属于弱类型语言。</li>
</ul>
<span id="more"></span>

<p>光看定义不够生动，还是来举个例子：</p>
<p>Java是一种静态类型语言，也是一种强类型语言。因为编译器不能自动检测类型，所以它是静态的，而且类型受到严格限制，所以它也是一种强类型语言。</p>
<p>javascript是一种动态类型语言和非强类型语言。<br>因为编译器能够在运行时检测类型，并且类型也不受严格限制。</p>
<p>所以，基于上面的例子，你可以说swift允许我们不声明类型并且让编译器自己检测类型，所以swift被Apple官方公布为动态类型语言。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这里没有强制声明类型，看似一个弱类型的语言，其实不然。Swift 编译器能够推断出 <code>num</code> 是 <code>Int</code> 类型。那么 <code>num</code> 就不能再被赋值为 <code>String</code> 类型。更不能写成如下的形式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> str <span class="operator">=</span> <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> num <span class="operator">+</span> str</span><br></pre></td></tr></table></figure>

<p>编译器将会报如下的错误：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">error: binary <span class="keyword">operator</span> &#x27;<span class="operator">+</span>&#x27; cannot be applied to operands of type &#x27;<span class="type">Int</span>&#x27; and &#x27;<span class="type">String</span>&#x27;</span><br><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> num <span class="operator">+</span> str</span><br><span class="line">             <span class="operator">~~~</span> <span class="operator">^</span> <span class="operator">~~~</span></span><br><span class="line">note: overloads <span class="keyword">for</span> &#x27;<span class="operator">+</span>&#x27; exist with these partially matching parameter lists: (<span class="type">Int</span>, <span class="type">Int</span>), (<span class="type">String</span>, <span class="type">String</span>), (<span class="type">Int</span>, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Pointee</span>&gt;), (<span class="type">Int</span>, <span class="type">UnsafePointer</span>&lt;<span class="type">Pointee</span>&gt;)</span><br><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> num <span class="operator">+</span> str</span><br><span class="line">                 <span class="operator">^</span></span><br></pre></td></tr></table></figure>

<p>这说明了，Swift 是一门强类型的语言。Swift 的类型声明，你可以看成是在定义变量的时候，隐式声明的（由编译器推断出），当然也可以显式的声明。如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num: <span class="type">Int</span> <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9zYW5kZXNoc2FyZGFyLmNvbS8yMDE3LzA2LzI5L3N3aWZ0LWlzLWR5bmFtaWMtYW5kLXN0cm9uZy10eXBlLWxhbmd1YWdlLw==">Swift is Dynamic and strong type language<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9hYzk5MzY2MTEyZjU=">关于 Swift 的 5 个误区<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 学习笔记（六）【模块】</title>
    <url>/2018/02/10/20180210-Python%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E3%80%90%E6%A8%A1%E5%9D%97%E3%80%91/</url>
    <content><![CDATA[<blockquote>
<p>Python 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和Python语句。<br>模块让你能够有逻辑地组织你的 Python 代码段。<br>把相关的代码分配到一个模块里能让你的代码更好用，更易懂。<br>模块能定义函数，类和变量，模块里也能包含可执行的代码。  </p>
</blockquote>
<h5 id="import-语句"><a href="#import-语句" class="headerlink" title="import 语句"></a>import 语句</h5><hr>
<p><strong>模块的引入</strong></p>
<p>模块定义好后，我们可以使用 import 语句来引入模块，语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> module1[, module2[,... moduleN]</span><br></pre></td></tr></table></figure>

<p>比如要引用模块 math，就可以在文件最开始的地方用 import math 来引入。在调用 math 模块中的函数时，必须这样引用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">模块名.函数名</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。</p>
<p><strong>一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。</strong></p>
<h5 id="From…import-语句"><a href="#From…import-语句" class="headerlink" title="From…import 语句"></a>From…import 语句</h5><hr>
<p>Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中。语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> modname <span class="keyword">import</span> name1[, name2[, ... nameN]]</span><br></pre></td></tr></table></figure>

<p>例如，要导入模块 fib 的 fibonacci 函数，使用如下语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fib <span class="keyword">import</span> fibonacci</span><br></pre></td></tr></table></figure>

<p>这个声明不会把整个 fib 模块导入到当前的命名空间中，它只会将 fib 里的 fibonacci 单个引入到执行这个声明的模块的全局符号表。</p>
<h5 id="From…import-语句-1"><a href="#From…import-语句-1" class="headerlink" title="From…import* 语句"></a>From…import* 语句</h5><hr>
<p>把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> modname <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<p>这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。<br>例如我们想一次性引入 math 模块中所有的东西，语句如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<h5 id="搜索路径"><a href="#搜索路径" class="headerlink" title="搜索路径"></a>搜索路径</h5><hr>
<p>当你导入一个模块，Python 解析器对模块位置的搜索顺序是：<br>    * 1、当前目录<br>    * 2、如果不在当前目录，Python 则搜索在 shell 变量 PYTHONPATH 下的每个目录。<br>    * 3、如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python&#x2F;。<br>模块搜索路径存储在 system 模块的 sys.path 变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。</p>
<h5 id="PYTHONPATH-变量"><a href="#PYTHONPATH-变量" class="headerlink" title="PYTHONPATH 变量"></a>PYTHONPATH 变量</h5><p>作为环境变量，PYTHONPATH 由装在一个列表里的许多目录组成。PYTHONPATH 的语法和 shell 变量 PATH 的一样。<br>在 Windows 系统，典型的 PYTHONPATH 如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> PYTHONPATH=c:\python27\lib;</span><br></pre></td></tr></table></figure>

<p>在 UNIX 系统，典型的 PYTHONPATH 如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> PYTHONPATH=/usr/local/lib/python</span><br></pre></td></tr></table></figure>

<h5 id="命名空间和作用域"><a href="#命名空间和作用域" class="headerlink" title="命名空间和作用域"></a>命名空间和作用域</h5><hr>
<p>变量是拥有匹配对象的名字（标识符）。命名空间是一个包含了变量名称们（键）和它们各自相应的对象们（值）的字典。</p>
<p>一个 Python 表达式可以访问局部命名空间和全局命名空间里的变量。如果一个局部变量和一个全局变量重名，则局部变量会覆盖全局变量。</p>
<p>每个函数都有自己的命名空间。类的方法的作用域规则和通常函数的一样。</p>
<p><strong>Python 会智能地猜测一个变量是局部的还是全局的，它假设任何在函数内赋值的变量都是局部的。</strong></p>
<p><strong>因此，如果要给函数内的全局变量赋值，必须使用 global 语句。</strong></p>
<p><strong>global VarName 的表达式会告诉 Python， VarName 是一个全局变量，这样 Python 就不会在局部命名空间里寻找这个变量了。</strong></p>
<p>例如，我们在全局命名空间里定义一个变量 Money。我们再在函数内给变量 Money 赋值，然后 Python 会假定 Money 是一个局部变量。然而，我们并没有在访问前声明一个局部变量 Money，结果就是会出现一个 UnboundLocalError 的错误。取消 global 语句的注释就能解决这个问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line">Money = <span class="number">2000</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">AddMoney</span>():</span><br><span class="line">   <span class="comment"># 想改正代码就取消以下注释:</span></span><br><span class="line">   <span class="comment"># global Money</span></span><br><span class="line">   Money = Money + <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> Money</span><br><span class="line">AddMoney()</span><br><span class="line"><span class="built_in">print</span> Money</span><br></pre></td></tr></table></figure>

<h5 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir()函数"></a>dir()函数</h5><hr>
<p>dir() 函数一个排好序的字符串列表，内容是一个模块里定义过的名字。</p>
<p>返回的列表容纳了在一个模块里定义的所有模块，变量和函数。如下一个简单的实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 导入内置math模块</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"> </span><br><span class="line">content = <span class="built_in">dir</span>(math)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> content;</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;__doc__&#x27;, &#x27;__file__&#x27;, &#x27;__name__&#x27;, &#x27;acos&#x27;, &#x27;asin&#x27;, &#x27;atan&#x27;, </span><br><span class="line">&#x27;atan2&#x27;, &#x27;ceil&#x27;, &#x27;cos&#x27;, &#x27;cosh&#x27;, &#x27;degrees&#x27;, &#x27;e&#x27;, &#x27;exp&#x27;, </span><br><span class="line">&#x27;fabs&#x27;, &#x27;floor&#x27;, &#x27;fmod&#x27;, &#x27;frexp&#x27;, &#x27;hypot&#x27;, &#x27;ldexp&#x27;, &#x27;log&#x27;,</span><br><span class="line">&#x27;log10&#x27;, &#x27;modf&#x27;, &#x27;pi&#x27;, &#x27;pow&#x27;, &#x27;radians&#x27;, &#x27;sin&#x27;, &#x27;sinh&#x27;, </span><br><span class="line">&#x27;sqrt&#x27;, &#x27;tan&#x27;, &#x27;tanh&#x27;]</span><br></pre></td></tr></table></figure>

<p><strong>在这里，特殊字符串变量__name__指向模块的名字，__file__指向该模块的导入文件名。</strong></p>
<h5 id="globals-和-locals-函数"><a href="#globals-和-locals-函数" class="headerlink" title="globals() 和 locals() 函数"></a>globals() 和 locals() 函数</h5><hr>
<p><strong>根据调用地方的不同，globals() 和 locals() 函数可被用来返回全局和局部命名空间里的名字。</strong></p>
<p>如果在函数内部调用 locals()，返回的是所有能在该函数里访问的命名。</p>
<p>如果在函数内部调用 globals()，返回的是所有在该函数里能访问的全局名字。</p>
<p>两个函数的返回类型都是字典。所以名字们能用 keys() 函数摘取。</p>
<h5 id="reload-函数"><a href="#reload-函数" class="headerlink" title="reload() 函数"></a>reload() 函数</h5><hr>
<p><strong>当一个模块被导入到一个脚本，模块顶层部分的代码只会被执行一次。</strong></p>
<p><strong>因此，如果你想重新执行模块里顶层部分的代码，可以用 reload() 函数。该函数会重新导入之前导入过的模块。语法如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reload(module_name)</span><br></pre></td></tr></table></figure>

<p><strong>在这里，module_name要直接放模块的名字，而不是一个字符串形式。</strong>比如想重载 hello 模块，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reload(hello)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>修改 VPS 的 SSH 端口</title>
    <url>/2018/02/25/20180225-%E4%BF%AE%E6%94%B9%20VPS%20%E7%9A%84%20SSH%20%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<p>如果你发现连不上你的 VPS了，那么有一种可能就是端口被封，我们需要改一下 VPS 端口了。</p>
<h3 id="登陆服务器"><a href="#登陆服务器" class="headerlink" title="登陆服务器"></a>登陆服务器</h3><p>如何登陆 VPS 可以参考这篇文章： <span class="exturl" data-url="aHR0cHM6Ly90b21hdG9zeC5naXRodWIuaW8vJUU3JUJEJTkxJUU3JUJCJTlDLzIwMTgvMDIvMDkvU1NILSVFNSU4NSU4RCVFNSVBRiU4NiVFNyU5OSVCQiVFOSU5OSU4Ni1WUFMv">SSH 免密登陆 VPS<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="修改-VPS-的-SSH-端口"><a href="#修改-VPS-的-SSH-端口" class="headerlink" title="修改 VPS 的 SSH 端口"></a>修改 VPS 的 SSH 端口</h3><p>VPS 的端口配置在文件 <code>sshd_config </code> 中，我们直接用如下的命令打开文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>

<p>在文章的末尾你能看到 <code>Port</code> 字段，一般默认是 22，随意修改一个数字，建议 1000 以下。然后保存退出。重启 VPS 即可。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>获取电信光猫超级密码</title>
    <url>/2018/02/25/20180225-%E8%8E%B7%E5%8F%96%E7%94%B5%E4%BF%A1%E5%85%89%E7%8C%AB%E8%B6%85%E7%BA%A7%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h3 id="登陆电信光猫"><a href="#登陆电信光猫" class="headerlink" title="登陆电信光猫"></a>登陆电信光猫</h3><p>打开浏览器，输入 <code>http://192.168.1.1</code> ，进入光猫管理页面，用 <code>useradmin</code> 账户登陆。将地址栏中的连接 <code>http://192.168.1.1/cgi-bin/content.asp</code>  改为 <code>http://192.168.1.1/cgi-bin/telnet.asp</code> 。出来如下的界面：</p>
<p><img src="/my_pictures/20180225/1.jpg"></p>
<p>启用 <code>Telnet</code> ，点击确定。</p>
<h3 id="终端获取超级密码"><a href="#终端获取超级密码" class="headerlink" title="终端获取超级密码"></a>终端获取超级密码</h3><p>打开 Mac 终端，输入命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">telnet 192.168.1.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户名 admin</span></span><br><span class="line"><span class="comment"># 密码 1234</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> /tmp/ctromfile.cfg</span><br></pre></td></tr></table></figure>

<p>按住 <code>control + s</code> 键，保存终端内容到文件。</p>
<p>文件中搜索 <code>telecomadmin</code> ，就能看到超级密码了。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>电信</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 进阶【一】内建集合类型</title>
    <url>/2018/02/27/20180227-Swift%20%E8%BF%9B%E9%98%B6%E3%80%90%E4%B8%80%E3%80%91%E5%86%85%E5%BB%BA%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="数组和可变性"><a href="#数组和可变性" class="headerlink" title="数组和可变性"></a>数组和可变性</h3><hr>
<p>在Swift中，数组是值类型。并且Swift中，Swift标准库中的所有集合类型都使用了“写时复制”这一技术，避免了大量副本导致性能下降。值类型的好处，不仅是性能有提高，其次就是能保证数组的不可变。</p>
<p>在Objective-C中，声明一个不可变的数组 <code>NSArray</code> 并不能保证数组的不可变。例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mutableAry <span class="operator">=</span> <span class="type">NSMutableArray</span>(array: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">/// 我们不想让 ary 被改变，声明为不可变数组</span></span><br><span class="line"><span class="keyword">let</span> ary: <span class="type">NSArray</span> <span class="operator">=</span> mutableAry</span><br><span class="line"><span class="comment">/// 但是事实上它依然能够被 a 影响并改变</span></span><br><span class="line">mutableAry.add(<span class="number">5</span>)</span><br><span class="line">ary <span class="comment">// [1, 2, 3, 5]</span></span><br></pre></td></tr></table></figure>

<p>正确的做法是，在赋值的时候，先进行拷贝：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nsAry <span class="operator">=</span> mutableAry.copy() <span class="keyword">as!</span> <span class="type">NSArray</span></span><br><span class="line">mutableAry.add(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">mutableAry <span class="comment">// [1, 2, 3, 5, 10]</span></span><br><span class="line">nsAry <span class="comment">// [1, 2, 3, 5]</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><strong>值类型的优点</strong></p>
<pre><code>* 不变性
值类型的变量是严格的被一个所有者控制的
* 独立性
引用类型是一种隐式的共享实例
* 安全性
在多线程时可以放心值传递
</code></pre>
<p><strong>不可变性在安全中的作用</strong></p>
<blockquote>
<p>选择值类型而不是引用类型的一个主要原因是能让你的代码变得更加简单。你在任何情况下用一个值类型，都能够假设你的其他代码不会使它改变，这通常在多线程环境中很有用，如果一个线程中使用的数据被另一个线程给意外的修改了，这通常会产生非常严重的Bug，且相当难以调试。<br>由于只有当你需要修改数据时两者的区别才会得到体现，所以当你的实例不会对数据进行修改的时候，值类型和引用类型看起来是完全相同的。<br>你也许会想，写一个完全不可变的类，这或许是有价值的，使用Cocoa的NSObject能简化这个过程，并且能很好地保持原有的语义。现在，你能通过使用不可变的存储属性，以及避免暴露修改数据的接口，从而在Swift里实现一个不可变的类。事实上，大多数的Cocoa类，比如NSURL等，都被设计为不可变的类，然而，Swift当前并没有提供任何语言机制去强制申明一个类不可改变（比如子类化就能修改一个类的实现），只有结构体和枚举才是强制不可变的。  </p>
</blockquote>
<h3 id="使用函数将行为参数化"><a href="#使用函数将行为参数化" class="headerlink" title="使用函数将行为参数化"></a>使用函数将行为参数化</h3><hr>
<p>类似于如下的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> names <span class="operator">=</span> [<span class="string">&quot;Paula&quot;</span>, <span class="string">&quot;Elena&quot;</span>, <span class="string">&quot;Zoe&quot;</span>]</span><br><span class="line"><span class="keyword">var</span> lastNameEndingInA: <span class="type">String</span>?</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names.reversed() <span class="keyword">where</span> name.hasSuffix(<span class="string">&quot;a&quot;</span>) &#123;</span><br><span class="line">	  lastNameEndingInA <span class="operator">=</span> name</span><br><span class="line">	  <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">lastNameEndingInA <span class="comment">// Optional(&quot;Elena&quot;)</span></span><br></pre></td></tr></table></figure>

<p>可以将其改写成 <code>Sequence</code> 的一个扩展，详解，参考<strong>函数式编程</strong>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Sequence</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">last</span>(<span class="params">where</span> <span class="params">predicate</span>: (<span class="type">Iterator</span>.<span class="type">Element</span>) -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Iterator</span>.<span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> reversed() <span class="keyword">where</span> predicate(element) &#123;</span><br><span class="line">            <span class="keyword">return</span> element</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Filter函数"><a href="#Filter函数" class="headerlink" title="Filter函数"></a>Filter函数</h3><hr>
<p>一个关于性能的小提示：如果你正在写下面这样的代码，请不要这么做！</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">bigArray.filter &#123; someCondition &#125;.count <span class="operator">&gt;</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>filter 会创建一个全新的数组，并且会对数组中的每个元素都进行操作。然而在上面这段代码中，这显然是不必要的。上面的代码仅仅检查了是否有至少一个元素满足条件，在这个情景下，使用 contains(where:) 更为合适：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">bigArray.contains &#123; someCondition &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Reduce函数"><a href="#Reduce函数" class="headerlink" title="Reduce函数"></a>Reduce函数</h3><hr>
<p>使用reduce函数可以向下面一样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum <span class="operator">=</span> fibs.reduce(<span class="number">0</span>) &#123; total, num <span class="keyword">in</span> total <span class="operator">+</span> num &#125; <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<p>运算符也是函数，所以我们也可以把上面的例子写成这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fibs.reduce(<span class="number">0</span>, <span class="operator">+</span>) <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<h3 id="集合代数"><a href="#集合代数" class="headerlink" title="集合代数"></a>集合代数</h3><hr>
<p>Set中，可以对Set执行数学中的基本集合操作<strong>补集</strong>，<strong>交集</strong>，<strong>并集</strong><br>因为在标准库中，Set是唯一实现了 <code>SetAlgebra</code> 协议的类型。</p>
<blockquote>
<p>但是这个协议在 Foundation 中还被另外两个很有意思的类型实现了：那就是 IndexSet 和 CharacterSet。  </p>
</blockquote>
<p>具体可以参考 <code>SetAlgebra</code> 协议。</p>
<p><strong>补集</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> iPods: <span class="type">Set</span> <span class="operator">=</span> [<span class="string">&quot;iPod touch&quot;</span>, <span class="string">&quot;iPod nano&quot;</span>, <span class="string">&quot;iPod mini&quot;</span>, <span class="string">&quot;iPod shuffle&quot;</span>, <span class="string">&quot;iPod Classic&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> discontinuedIPods: <span class="type">Set</span> <span class="operator">=</span> [<span class="string">&quot;iPod mini&quot;</span>, <span class="string">&quot;iPod Classic&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> currentIPods <span class="operator">=</span> iPods.subtracting(discontinuedIPods)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;iPod shuffle&quot;, &quot;iPod nano&quot;, &quot;iPod touch&quot;]</span></span><br></pre></td></tr></table></figure>

<p><strong>交集</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> touchscreen: <span class="type">Set</span> <span class="operator">=</span> [<span class="string">&quot;iPhone&quot;</span>, <span class="string">&quot;iPad&quot;</span>, <span class="string">&quot;iPod touch&quot;</span>, <span class="string">&quot;iPod nano&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> iPodsWithTouch <span class="operator">=</span> iPods.intersection(touchscreen)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;iPod touch&quot;, &quot;iPod nano&quot;]</span></span><br></pre></td></tr></table></figure>

<p><strong>并集</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> discontinued: <span class="type">Set</span> <span class="operator">=</span> [<span class="string">&quot;iBook&quot;</span>, <span class="string">&quot;Powerbook&quot;</span>, <span class="string">&quot;Power Mac&quot;</span>]</span><br><span class="line">discontinued.formUnion(discontinuedIPods)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;iBook&quot;, &quot;iPod mini&quot;, &quot;Powerbook&quot;, &quot;Power Mac&quot;, &quot;iPod Classic&quot;]</span></span><br></pre></td></tr></table></figure>

<h3 id="索引集合和字符集合"><a href="#索引集合和字符集合" class="headerlink" title="索引集合和字符集合"></a>索引集合和字符集合</h3><hr>
<p><strong>IndexSet 表示了一个由正整数组成的集合。当然，你可以用Set<Int>来做这件事，但是IndexSet更加高效，因为它内部使用了一组范围列表进行实现。</strong></p>
<p>如果选择 <code>Set&lt;Int&gt;</code> 来存储1000以内所选择的数字的话，最坏的情况是存储1000个元素。如果用 <code>IndexSet</code> ，即使选择前500个数字的话，<code>IndexSet</code> 里其实只存储了选择的首位和末位两个整数值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> indices <span class="operator">=</span> <span class="type">IndexSet</span>()</span><br><span class="line">indices.insert(integersIn: <span class="number">1</span><span class="operator">..&lt;</span><span class="number">5</span>)</span><br><span class="line">indices.insert(integersIn: <span class="number">11</span><span class="operator">..&lt;</span><span class="number">15</span>)</span><br><span class="line"><span class="keyword">let</span> evenIndices <span class="operator">=</span> indices.filter &#123; <span class="variable">$0</span> <span class="operator">%</span> <span class="number">2</span> <span class="operator">==</span> <span class="number">0</span> &#125; <span class="comment">// [2, 4, 12, 14]</span></span><br></pre></td></tr></table></figure>

<p><code>CharacterSet</code> 将在字符串一章讨论。</p>
<p><strong>思考：</strong></p>
<p>过滤数组中重复的元素，并且保持数组中元素的顺序。</p>
<p>我们可以用 <code>Set</code> 去除重复，但是 <code>Set</code> 是无序，我们可以结合闭包来实现。这里我们写一个 <code>Sequence</code> 的扩展。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Sequence</span> <span class="keyword">where</span> <span class="type">Iterator</span>.<span class="type">Element</span>: <span class="type">Hashable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">unique</span>() -&gt; [<span class="type">Iterator</span>.<span class="type">Element</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> seen: <span class="type">Set</span>&lt;<span class="type">Iterator</span>.<span class="type">Element</span>&gt; <span class="operator">=</span> []</span><br><span class="line">        <span class="keyword">return</span> filter &#123;</span><br><span class="line">            <span class="keyword">if</span> seen.contains(<span class="variable">$0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                seen.insert(<span class="variable">$0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">6</span>].unique() <span class="comment">// [1, 2, 3, 12, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<h4 id="2018年3月11日-上午3-35-更新"><a href="#2018年3月11日-上午3-35-更新" class="headerlink" title="2018年3月11日 上午3:35 更新"></a>2018年3月11日 上午3:35 更新</h4><hr>
<p>关于去除数组中重复项的更函数式的写法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// SwifterSwift: Remove all duplicate elements from Array.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///        [1, 2, 2, 3, 4, 5].removeDuplicates() -&gt; [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">///        [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]. removeDuplicates() -&gt; [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;o&quot;]</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">removeDuplicates</span>() &#123;</span><br><span class="line">    <span class="comment">// Thanks to https://github.com/sairamkotha for improving the method</span></span><br><span class="line">    <span class="keyword">self</span> <span class="operator">=</span> reduce([])&#123; <span class="variable">$0</span>.contains(<span class="variable">$1</span>) <span class="operator">?</span> <span class="variable">$0</span> : <span class="variable">$0</span> <span class="operator">+</span> [<span class="variable">$1</span>] &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// SwifterSwift: Return array with all duplicate elements removed.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///        [1, 2, 2, 3, 4, 5, 5].duplicatesRemoved() -&gt; [ 2, 5]</span></span><br><span class="line"><span class="comment">///        [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]. duplicatesRemoved() -&gt; [&quot;l&quot;]</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Returns: an array of unique elements.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">duplicatesRemoved</span>() -&gt; [<span class="type">Element</span>] &#123;</span><br><span class="line">    <span class="comment">// Thanks to https://github.com/sairamkotha for improving the property</span></span><br><span class="line">    <span class="keyword">return</span> reduce([])&#123; (<span class="variable">$0</span> <span class="keyword">as</span> [<span class="type">Element</span>]).contains(<span class="variable">$1</span>) <span class="operator">?</span> <span class="variable">$0</span> : <span class="variable">$0</span> <span class="operator">+</span> [<span class="variable">$1</span>] &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 进阶【二】集合类型协议</title>
    <url>/2018/02/28/20180228-Swift%20%E8%BF%9B%E9%98%B6%E3%80%90%E4%BA%8C%E3%80%91%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h3 id="序列（Sequence）"><a href="#序列（Sequence）" class="headerlink" title="序列（Sequence）"></a>序列（Sequence）</h3><hr>
<p>Sequence定义：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Sequence</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Iterator</span>: <span class="type">IteratorProtocol</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeIterator</span>() -&gt; <span class="type">Iterator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要实现一个Sequence，首先需要提供一个返回<strong>迭代器（iterator）</strong>的<code>makeIterator()</code> 方法。<br>对于迭代器，它是一个满足 <code>IteratorProtocol</code> 协议的类型。</p>
<p>IteratorProtocol协议的定义：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">IteratorProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Element</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">next</span>() -&gt; <span class="type">Element</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><strong>IteratorProtocol 协议中唯一的一个方法是 next()，这个方法需要在每次被调用时返回序列中的下一个值。当序列被耗尽时，next() 应该返回 nil</strong></p>
<p>关联类型 <code>Element</code> 指定了迭代器产生的值的类型。</p>
<p>举几个例子进行体会：</p>
<p>1、斐波那契数列</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 菲波那切数列</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FibsIterator</span>: <span class="title class_ inherited__">IteratorProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> state <span class="operator">=</span> (<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">next</span>() -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">        <span class="keyword">let</span> upcomingNumber <span class="operator">=</span> state.<span class="number">0</span></span><br><span class="line">        state <span class="operator">=</span> (state.<span class="number">1</span>, state.<span class="number">0</span> <span class="operator">+</span> state.<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> upcomingNumber <span class="operator">&gt;</span> <span class="number">1000</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> upcomingNumber</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator <span class="operator">=</span> <span class="type">FibsIterator</span>()</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> number <span class="operator">=</span> iterator.next() &#123;</span><br><span class="line">    <span class="built_in">print</span>(number)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987</span></span><br></pre></td></tr></table></figure>

<p>2、返回字符串切片</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 依次返回字符串的切片</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PrefixIterator</span>: <span class="title class_ inherited__">IteratorProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> string: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> offset: <span class="type">String</span>.<span class="type">Index</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">str</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.string <span class="operator">=</span> str</span><br><span class="line">        <span class="keyword">self</span>.offset <span class="operator">=</span> str.startIndex</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">next</span>() -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">        <span class="keyword">guard</span> offset <span class="operator">&lt;</span> string.endIndex <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        offset <span class="operator">=</span> string.index(after: offset)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(string[string.startIndex<span class="operator">..&lt;</span>offset])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> strIterator <span class="operator">=</span> <span class="type">PrefixIterator</span>(str: <span class="string">&quot;ABCDEFG&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> str <span class="operator">=</span> strIterator.next() &#123;</span><br><span class="line">    <span class="built_in">print</span>(str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="comment">// AB</span></span><br><span class="line"><span class="comment">// ABC</span></span><br><span class="line"><span class="comment">// ABCD</span></span><br><span class="line"><span class="comment">// ABCDE</span></span><br><span class="line"><span class="comment">// ABCDEF</span></span><br><span class="line"><span class="comment">// ABCDEFG</span></span><br></pre></td></tr></table></figure>

<p>再定义一个PrefixSequence类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 实现PrefixIterator的sequence协议，之后可以用for来进行循环</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PrefixSequence</span>: <span class="title class_ inherited__">Sequence</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> str: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeIterator</span>() -&gt; <span class="type">PrefixIterator</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">PrefixIterator</span>(str: str)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> str <span class="keyword">in</span> <span class="type">PrefixSequence</span>(str: <span class="string">&quot;ABCDEFGHIJKLMN&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现了sequence协议，就可以使用sequence协议中提供的所有方法</span></span><br><span class="line"><span class="keyword">let</span> lower <span class="operator">=</span> <span class="type">PrefixSequence</span>(str: <span class="string">&quot;ABCDEFGHIJKLMN&quot;</span>).map &#123; <span class="keyword">return</span> <span class="variable">$0</span>.lowercased() &#125;</span><br><span class="line"><span class="built_in">print</span>(lower.prefix(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>


<h3 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h3><hr>
<p>集合类型 (Collection) 指的是那些稳定的序列，它们能够被多次遍历且保持一致。和序列不同，集合类型不能是无限的。</p>
<p>Collection 协议是建立在 Sequence 协议上的。除了从 Sequence 继承了全部方法以外，得益于可以获取指定位置的元素以及稳定迭代的保证，集合还获取了一些新的能力。比如 count 属性，如果序列是不稳定的，那么对序列计数将会消耗序列中的元素，这显然不是我们的目的。但是对于稳定的集合类型，我们就可以对其进行计数。</p>
<p>集合类型在标准库中运用广泛。除了 Array，Dictionary 和 Set 以外，String 的四种表示方式都是集合类型。另外还有 CountableRange 和 UnsafeBufferPointer 也是如此。更进一步，我们可以看到标准库外的一些类型也遵守了 Collection 协议。有两个我们熟知的类型通过这种方法获得了很多新的能力，它们是 Data 和 IndexSet，它们都来自 Foundation 框架。</p>
<p>自定义一个队列的集合类型：</p>
<p>1、为队列设计协议：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 一个能够将元素入队和出队的类型</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="comment">/// 在 `self` 中所持有的元素的类型</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Element</span></span><br><span class="line">    <span class="comment">/// 将 `newElement` 入队到 `self`</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">enqueue</span>(<span class="keyword">_</span> <span class="params">newElement</span>: <span class="type">Element</span>)</span><br><span class="line">    <span class="comment">/// 从 `self` 出队一个元素</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">dequeue</span>() -&gt; <span class="type">Element</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、队列的实现</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 一个高效的 FIFO 队列，其中元素类型为 `Element`</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FIFOQueue</span>&lt;<span class="type">Element</span>&gt;: <span class="title class_ inherited__">Queue</span> &#123;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> left: [<span class="type">Element</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> right: [<span class="type">Element</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="comment">/// 将元素添加到队列最后</span></span><br><span class="line">    <span class="comment">/// - 复杂度: O(1)</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">enqueue</span>(<span class="keyword">_</span> <span class="params">newElement</span>: <span class="type">Element</span>) &#123;</span><br><span class="line">        right.append(newElement)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 从队列前端移除一个元素</span></span><br><span class="line">    <span class="comment">/// 当队列为空时，返回 nil</span></span><br><span class="line">    <span class="comment">/// - 复杂度: 平摊 O(1)</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">dequeue</span>() -&gt; <span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> left.isEmpty &#123;</span><br><span class="line">            left <span class="operator">=</span> right.reversed()</span><br><span class="line">            right.removeAll()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left.popLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能会对 dequeue 操作被声明为 O(1) 感到有一点奇怪。确实，它包含了一个复杂度为 O(n) 的 reverse 操作。对于单个的操作来说可能耗时会长一些，不过对于非常多的 push 和 pop 操作来说，取出一个元素的平摊耗时是一个常数。</p>
<p>理解这个复杂度的关键在于理解反向操作发生的频率以及发生在多少个元素上。我们可以使用“银行家理论”来分析平摊复杂度。想象一下，你每次将一个元素放入队列，就相当于你在银行存了一块钱。接下来，你把右侧的栈的内容转移到左侧去，因为对应每个已经入队的元素，你在银行里都相当于有一块钱。你可以用这些钱来支付反转。你的账户永远不会负债，你也从来不会花费比你付出的更多的东西。</p>
<p>这个理论可以用来解释一个操作的消耗在时间上进行平摊的情况，即便其中的某次调用可能不是常数，但平摊下来以后这个耗时依然是常数。Swift 中向数组后面添加一个元素的操作是常数时间复杂度，这也可以用同样的理论进行解释。当数组存储空间耗尽时，它需要申请更大的空间，并且把所有已经存在于数组中的元素复制过去。但是因为每次申请空间都会使存储空间翻倍，“添加元素，支付一块钱，数组尺寸翻倍，最多耗费所有钱来进行复制”这个理论已然是有效的。</p>
<h5 id="遵守-ExpressibleByArrayLiteral-协议"><a href="#遵守-ExpressibleByArrayLiteral-协议" class="headerlink" title="遵守 ExpressibleByArrayLiteral 协议"></a>遵守 ExpressibleByArrayLiteral 协议</h5><hr>
<p>遵守 ExpressibleByArrayLiteral 协议的好处是，可以像用字面量去创建一个Array的方式去创建队列（[value1, value2, etc]）。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">FIFOQueue</span>: <span class="title class_ inherited__">ExpressibleByArrayLiteral</span> &#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">ArrayLiteralElement</span> <span class="operator">=</span> <span class="type">Element</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">arrayLiteral</span> <span class="params">elements</span>: <span class="type">Element</span>...) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(left: elements.reversed(), right: [])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> queue: <span class="type">FIFOQueue</span>&lt;<span class="type">Int</span>&gt; <span class="operator">=</span> [<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>字面量和类型的区别</strong></p>
<p>在这里需要特别注意 Swift 中字面量和类型的区别。<strong>这里的 [1, 2, 3] 并不是一个数组，它只是一个“数组字面量”，是一种写法，我们可以用它来创建任意的遵守 ExpressibleByArrayLiteral 的类型。</strong>在这个字面量里面还包括了其他的字面量类型，比如能够创建任意遵守 ExpressibleByIntegerLiteral 的整数型字面量。<br>这些字面量有“默认”的类型，<strong>如果你不指明类型，那些 Swift 将假设你想要的就是默认的类型。</strong>正如你所料，数组字面量的默认类型是 Array，整数字面量的默认类型是 Int，浮点数字面量默认为 Double，而字符串字面量则对应 String。<strong>但是这只发生在你没有指定类型的情况下。</strong></p>
<h5 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h5><hr>
<p>building…</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 进阶【四】结构体和类</title>
    <url>/2018/03/02/20180302-Swift%20%E8%BF%9B%E9%98%B6%E3%80%90%E5%9B%9B%E3%80%91%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB/</url>
    <content><![CDATA[<h3 id="结构体和类的主要不同点："><a href="#结构体和类的主要不同点：" class="headerlink" title="结构体和类的主要不同点："></a>结构体和类的主要不同点：</h3><ul>
<li><p>结构体 (和枚举) 是值类型，而类是引用类型。在设计结构体时，我们可以要求编译器保证不可变性。而对于类来说，我们就得自己来确保这件事情。</p>
</li>
<li><p>内存的管理方式有所不同。结构体可以被直接持有及访问，但是类的实例只能通过引用来间接地访问。结构体不会被引用，但是会被复制。也就是说，结构体的持有者是唯一的，但是类却能有很多个持有者。</p>
</li>
<li><p>使用类，我们可以通过继承来共享代码。而结构体 (以及枚举) 是不能被继承的。想要在不同的结构体或者枚举之间共享代码，我们需要使用不同的技术，比如像是组合、泛型以及协议扩展等。</p>
</li>
</ul>
<h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><hr>
<p><strong>值语义 (value semantics)</strong><br>    * 结构体只有一个持有者。比如，当我们将结构体变量传递给一个函数时，函数将接收到结构体的复制，它也只能改变它自己的这份复制。这叫做值语义 (value semantics)，有时候也被叫做复制语义。</p>
<p><strong>引用语义 (reference semantics)</strong><br>    * 对于对象来说，它们是通过传递引用来工作的，因此类对象会拥有很多持有者，这被叫做引用语义 (reference semantics)。</p>
<p>因为结构体只有一个持有者，所以它不可能造成引用循环。而对于类和函数这样的引用类型，我们需要特别小心，避免造成引用循环的问题。</p>
<p>编译器所做的对于值类型的复制优化和值语义类型的写时复制行为并不是一回事儿。写时复制必须由开发者来实现，想要实现写时复制，你需要检测所包含的类是否有共享的引用。和自动移除不必要的值类型复制不同，写时复制是需要自己实现的。不过编译器会移除那些不必要的“无效”浅复制，以及像是数组这样的类型中的代码会执行“智能的”写时复制，两者互为补充，都是对值类型的优化。</p>
<span id="more"></span>

<p>如果你的结构体只由其他结构体组成，那编译器可以确保不可变性。同样地，当使用结构体时，编译器也可以生成非常快的代码。举个例子，对一个只含有结构体的数组进行操作的效率，通常要比对一个含有对象的数组进行操作的效率高得多。这是因为结构体通常要更直接：值是直接存储在数组的内存中的。而对象的数组中包含的只是对象的引用。最后，在很多情况下，编译器可以将结构体放到栈上，而不用放在堆里。</p>
<h3 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h3><hr>
<p>Swift 可以让我们在写出安全代码的同时，保留直观的可变代码的风格。</p>
<p>可变性带来的问题，在Foundation中有两个类，<code>NSArray</code> 和<code>NSMutableArray</code>。我们可以用 NSMutableArray 写出下面这样 (会崩溃) 的程序：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mutableArray: <span class="type">NSMutableArray</span> <span class="operator">=</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> mutableArray &#123;</span><br><span class="line">    mutableArray.removeLastObject()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当迭代一个 NSMutableArray，你不能去改变它，因为迭代器是基于原始的数组工作的，改变数组将会破坏迭代器的内部状态。</p>
<p>在Swift数组中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ary <span class="operator">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> ary &#123;</span><br><span class="line">    ary.removeLast()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子不会崩溃，这是因为迭代器持有了数组的一个本地的，独立的复制。这样，无论如何移除 <code>ary</code> 中的数据，数组的迭代器的复制依然持有最开始的三个元素。</p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><hr>
<p>对于结构体，Swift 会自动按照成员变量为它添加初始化方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">Float</span></span><br><span class="line">    <span class="keyword">var</span> y: <span class="type">Float</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面的方法，可以这样初始化：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newPoint <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">0.1</span>, y: <span class="number">0.2</span>)</span><br></pre></td></tr></table></figure>

<p>为 <code>Point</code> 重载加号：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">+</span>(<span class="params">lhs</span>: <span class="type">Point</span>, <span class="params">rhs</span>: <span class="type">Point</span>) -&gt; <span class="type">Point</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Point</span>(x: lhs.x <span class="operator">+</span> rhs.x, y: lhs.y <span class="operator">+</span> rhs.y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就可以进行 <code>Point</code> 之间相加了。这里是生成新的一个值，如果是 <code>+=</code> 该如何实现呢，这就要用到 <code>inout</code> 关键字。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">+=</span>(<span class="params">lhs</span>: <span class="keyword">inout</span> <span class="type">Point</span>, <span class="params">rhs</span>: <span class="type">Point</span>) &#123;</span><br><span class="line">    lhs <span class="operator">=</span> lhs <span class="operator">+</span> rhs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里接受一个 <code>Point</code> 值，并且在本地改变它的值，然后将新的值复制回去（覆盖原来的 <code>lhs</code> 的值）。这个行为和 mutating 方法如出一辙。实际上，mutating 标记的方法也就是结构体上的普通方法，只不过隐式的 self 被标记为了 inout 而已。</p>
<p>结构体并不意味着你的代码就可以像魔法一般做到线程安全。在闭包内的 while 循环和闭包外的 while 循环都引用了同一个结构体变量，两者会在同时发生改变。</p>
<h3 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h3><hr>
<p>在 Swift 标准库中，像是 Array，Dictionary 和 Set 这样的集合类型是通过一种叫做写时复制 (copy-on-write) 的技术实现的。我们这里有一个整数数组：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="operator">=</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> y <span class="operator">=</span> x</span><br></pre></td></tr></table></figure>

<p>如果我们创建了一个新的变量 y，并且把 x 赋值给它时，会发生复制，现在 x 和 y 含有的事独立的结构体。在内部，这些 Array 结构体含有指向某个内存的引用。这个内存就是数组中元素所存储的位置，它们位于堆 (heap) 上。在这个时候，两个数组的引用指向的是内存中同一个位置，这两个数组共享了它们的存储部分。不过，当我们改变 x 的时候，这个共享会被检测到，内存将会被复制。这样一来，我们得以独立地改变两个变量。昂贵的元素复制操作只在必要的时候发生，也就是我们改变这两个变量的时候发生复制：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">x.append(<span class="number">5</span>)</span><br><span class="line">y.removeLast()</span><br><span class="line">x <span class="comment">// [1, 2, 3, 5]</span></span><br><span class="line">y <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>

<p>如果 Array 结构体中的引用在数组被改变的一瞬间时是唯一的话 (比如，没有声明 y)，那么也不会有复制发生，内存的改变将在原地进行。这种行为就是写时复制，作为一个结构体的作者，你并不能免费获得这种特性，你需要自己进行实现。当你自己的类型内部含有一个或多个可变引用，同时你想要保持值语义，并且避免不必要的复制时，为你的类型实现写时复制是有意义的。</p>
<h3 id="闭包和可变性"><a href="#闭包和可变性" class="headerlink" title="闭包和可变性"></a>闭包和可变性</h3><hr>
<p>例如，有一个函数在每次被调用时生成一个唯一的整数，直到 Int.max。这可以通过将状态移动到函数外部来实现。换句话说，这个函数对变量 i 进行了闭合 (close)。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">uniqueInteger</span>() -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    i <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>封装成闭包</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">uniqueIntegerProvider</span>() -&gt; () -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        i <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数也是引用类型，如果我们将函数A赋值给另一个变量，编译器不会复制这个函数或者 i。相反，它将会创建一个指向相同函数的引用。<br>这对所有的闭包和函数来说都是正确的：如果我们传递这些闭包和函数，它们会以引用的方式存在，并共享同样的状态。</p>
<p>Swift 的结构体一般被存储在栈上，而非堆上。不过这其实是一种优化：默认情况下结构体是存储在堆上的，但是在绝大多数时候，这个优化会生效，并将结构体存储到栈上。当结构体变量被一个函数闭合的时候，优化将不再生效，此时这个结构体将存储在堆上。因为变量 i 被函数闭合了，所以结构体将存在于堆上。这样一来，就算uniqueIntegerProvider 退出了作用域，i 也将继续存在。与此相似，如果结构体太大，它也会被存储在堆上。</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><hr>
<p>当把 Swift 和使用垃圾回收机制的语言进行对比时，第一印象是它们在内存管理上似乎很相似。大多数时候，你都不太需要考虑它。不过，看看下面的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> window: <span class="type">Window</span>? <span class="operator">=</span> <span class="type">Window</span>()</span><br><span class="line"><span class="keyword">var</span> view: <span class="type">View</span>? <span class="operator">=</span> <span class="type">View</span>(window: window<span class="operator">!</span>)</span><br><span class="line">window<span class="operator">?</span>.rootView <span class="operator">=</span> view</span><br><span class="line">view <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">window <span class="operator">=</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>首先，我们创建了 window 对象，window 的引用计数将为 1。之后创建 view 对象时，它持有了 window 对象的强引用，所以这时候 window 的引用计数为 2，view 的计数为 1。接下来，将 view 设置为 window 的 rootView 将会使 view 的引用计数加一。此时 view 和 window 的引用计数都是 2。当把两个变量都设置为 nil 后，它们的引用计数都会是 1。即使它们已经不能通过变量进行访问了，但是它们却互相有着对彼此的强引用。这就被叫做引用循环，当处理类似于这样的数据结构时，我们需要特别小心这一点。因为存在引用循环，这样的两个对象在程序的生命周期中将永远无法被释放。</p>
<h4 id="weak-引用"><a href="#weak-引用" class="headerlink" title="weak 引用"></a>weak 引用</h4><p>要打破引用循环，我们需要确保其中一个引用要么是 weak，要么是 unowned。weak 引用表示不增加引用计数，并且当被引用的对象被释放时，将该 weak 引用自身设置为 nil。</p>
<p>构造函数<br>    * 构造函数 ，是一种特殊的方法。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。特别的一个类可以有多个构造函数 ，可根据其参数个数的不同或参数类型的不同来区分它们 即构造函数的重载。</p>
<p>析构函数<br>    * 析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做“清理善后” 的工作（例如在建立对象时用new开辟了一片内存空间，delete会自动调用析构函数后释放内存）。</p>
<h4 id="unowned-引用"><a href="#unowned-引用" class="headerlink" title="unowned 引用"></a>unowned 引用</h4><p>因为 weak 引用的变量可以变为 nil，所以它们必须是可选值类型，但是有些时候这并不是你想要的。例如，也许我们知道我们的 view 将一定有一个 window，这样这个属性就不应该是可选值，而同时我们又不想一个 view 强引用 window。这种情况下，我们可以使用 unowned 关键字，这将不持有引用的对象，但是却假定该引用会一直有效。</p>
<p>对每个 unowned 的引用，Swift 运行时将为这个对象维护另外一个引用计数。当所有的 strong 引用消失时，对象将把它的资源 (比如对其他对象的引用) 释放掉。不过，这个对象本身的内存将继续存在，直到所有的 unowned 引用也都消失。这部分内存将被标记为无效 (有时候我们也把它叫做僵尸 (zombie) 内存)，当我们试图访问这样的 unowned 引用时，就会发生运行时错误。</p>
<p>当你不需要 weak 的时候，还是建议使用 unowned。一个 weak 变量总是需要被定义为 var，而 unowned 变量可以使用 let 来定义。不过，只有在你确定你的引用将一直有效时，才应该使用 unowned。</p>
<p>个人来说，我经常发现自己即使是在那些可以用 unowned 的场合，也还一直在用 weak。我们可能会时不时地对一些代码进行重构，而这可能会导致我们之前对于对象有效的假设失效，这种情况下使用 unowned 就很危险。当使用 weak 时，一个好处是编译器强制我们需要处理引用为 nil 时的可能性。</p>
<h3 id="结构体和类使用实践"><a href="#结构体和类使用实践" class="headerlink" title="结构体和类使用实践"></a>结构体和类使用实践</h3><hr>
<p>例子：银行账户转账功能：</p>
<p><strong>基于类的实现：</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 银行账户</span></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">USDCents</span> <span class="operator">=</span> <span class="type">Int</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> funds: <span class="type">USDCents</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">funds</span>: <span class="type">USDCents</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.funds <span class="operator">=</span> funds</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个账户</span></span><br><span class="line"><span class="keyword">let</span> alice <span class="operator">=</span> <span class="type">Account</span>(funds: <span class="number">100</span>)</span><br><span class="line"><span class="keyword">let</span> bob <span class="operator">=</span> <span class="type">Account</span>(funds: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转账函数</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">transfer</span>(<span class="params">amount</span>: <span class="type">USDCents</span>, <span class="params">source</span>: <span class="type">Account</span>, <span class="params">destination</span>: <span class="type">Account</span>)</span><br><span class="line">    -&gt; <span class="type">Bool</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">guard</span> source.funds <span class="operator">&gt;=</span> amount <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">    source.funds <span class="operator">-=</span> amount</span><br><span class="line">    destination.funds <span class="operator">+=</span> amount</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行转账</span></span><br><span class="line">transfer(<span class="number">50</span>, source: alice, destination: bob)</span><br></pre></td></tr></table></figure>

<p>缺点：<br>    * 不是线程安全的</p>
<hr>
<p><strong>基于纯结构体的实现：</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> funds: <span class="type">USDCents</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有使用 inout 关键词，这里的逻辑就要复杂一些</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">transfer</span>(<span class="params">amount</span>: <span class="type">USDCents</span>, <span class="params">source</span>: <span class="type">Account</span>, <span class="params">destination</span>: <span class="type">Account</span>)</span><br><span class="line">    -&gt; (source: <span class="type">Account</span>, destination: <span class="type">Account</span>)<span class="operator">?</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">guard</span> source.funds <span class="operator">&gt;=</span> amount <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> newSource <span class="operator">=</span> source</span><br><span class="line">    <span class="keyword">var</span> newDestination <span class="operator">=</span> destination</span><br><span class="line">    newSource.funds <span class="operator">-=</span> amount</span><br><span class="line">    newDestination.funds <span class="operator">+=</span> amount</span><br><span class="line">    <span class="keyword">return</span> (newSource, newDestination)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> (newAlice, newBob) <span class="operator">=</span> transfer(<span class="number">50</span>, source: alice, destination: bob) &#123;</span><br><span class="line">    <span class="comment">// 更新数据源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：<br>    * 线程安全</p>
<p>缺点：<br>    * 程序变得啰嗦</p>
<hr>
<p><strong>基于 inout 结构体实现</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">transfer</span></span><br><span class="line">    (<span class="params">amount</span>: <span class="type">USDCents</span>, <span class="params">inout</span> <span class="params">source</span>: <span class="type">Account</span>, <span class="params">inout</span> <span class="params">destination</span>: <span class="type">Account</span>)</span><br><span class="line">    -&gt; <span class="type">Bool</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">guard</span> source.funds <span class="operator">&gt;=</span> amount <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">    source.funds <span class="operator">-=</span> amount</span><br><span class="line">    destination.funds <span class="operator">+=</span> amount</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们调用含有 inout 修饰的参数的函数时，我们需要为变量加上 &amp; 符号。不过注意，和传递 C 指针的语法不同，这里不代表引用传递。当函数返回的时候，被改变的值会被复制回调用者中去：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> alice <span class="operator">=</span> <span class="type">Account</span>(funds: <span class="number">100</span>)</span><br><span class="line"><span class="keyword">var</span> bob <span class="operator">=</span> <span class="type">Account</span>(funds: <span class="number">0</span>)</span><br><span class="line">transfer(<span class="number">50</span>, source: <span class="operator">&amp;</span>alice, destination: <span class="operator">&amp;</span>bob)</span><br></pre></td></tr></table></figure>

<p>优点：<br>    * 线程安全，保证了函数体内的稳定性<br>    * 写起来和基于类的策略一样容易</p>
<h3 id="闭包和内存"><a href="#闭包和内存" class="headerlink" title="闭包和内存"></a>闭包和内存</h3><hr>
<p>在 Swift 中，除了类以外，函数 (包括闭包) 也是引用类型。我们在闭包和可变性的部分已经看到过，闭包可以捕获变量。如果这些变量是引用类型的话，闭包将持有对它们的强引用。</p>
<p><strong>引用循环：</strong></p>
<p>对象 A 引用了对象 B，但是对象 B 引用了一个包含对象 A 的回调。让我们考虑之前的例子，当一个视图引用了它的窗口时，窗口通过一个弱引用指向这个根视图。在此基础上，窗口现在多了一个 onRotate 回调，它是一个可选值，初始值为 nil：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> window: <span class="type">Window</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">window</span>: <span class="type">Window</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.window <span class="operator">=</span> window</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Deinit View&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> rootView: <span class="type">View</span>?</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Deinit Window&quot;</span>)&#125;</span><br><span class="line">    <span class="keyword">var</span> onRotate: (() -&gt; ())<span class="operator">?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们像之前那样创建视图，设置窗口，一切照旧，我们不会引入引用循环：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> window: <span class="type">Window</span>? <span class="operator">=</span> <span class="type">Window</span>()</span><br><span class="line"><span class="keyword">var</span> view: <span class="type">View</span>? <span class="operator">=</span> <span class="type">View</span>(window: window<span class="operator">!</span>)</span><br><span class="line">window<span class="operator">?</span>.rootView <span class="operator">=</span> view<span class="operator">!</span></span><br></pre></td></tr></table></figure>

<p>视图强引用了窗口，但是窗口只是弱引用视图，一切安好。但是，如果我们对 onRotate 回调进行配置，并在其中使用 view 的话，我们就会引入一个引用循环：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">window<span class="operator">?</span>.onRotate <span class="operator">=</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;We now also need to update the view: <span class="subst">\(view)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>视图引用了窗口，窗口引用回调，回调引用视图：循环形成。</p>
<p><img src="/my_pictures/20180302/1.jpg"></p>
<p>我们需要找到一种办法来打破这个引用循环。有三种方式可以打破循环，每种方式都在图表中用箭头表示出来了：</p>
<ul>
<li>我们可以让指向 Window 的引用变为 weak。不过不幸的是，这会导致 Window 消失，因为没有其他指向它的强引用了。</li>
<li>我们可以将 Window 的 onRotate 闭包声明为 weak。不过这也不可行，因为闭包其实是没有办法被标记为 weak 的，而且就算 weak 闭包是可能的，所有的 Window 的用户需要知道这件事情，因为有时候会需要手动引用这个闭包。</li>
<li>我们可以通过使用捕获列表 (capture list) 来让闭包不去引用视图。这在上面这些例子中是唯一正确的选项。</li>
</ul>
<p><strong>捕获列表：</strong></p>
<p>为了打破上面的循环，我们需要保证闭包不去引用 视图。我们可以通过使用捕获列表并将捕获变量 view 标记为 weak 或者 unowned 来达到这个目的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">window<span class="operator">?</span>.onRotate <span class="operator">=</span> &#123; [<span class="keyword">weak</span> view] <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;We now also need to update the view: <span class="subst">\(view)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>捕获列表也可以用来初始化新的变量。比如，如果我们想要用一个 weak 变量来引用窗口，我们可以将它在捕获列表中进行初始化，我们甚至可以定义完全不相关的变量，就像这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">window<span class="operator">?</span>.onRotate <span class="operator">=</span> &#123; [<span class="keyword">weak</span> view, <span class="keyword">weak</span> myWindow<span class="operator">=</span>window, x<span class="operator">=</span><span class="number">5</span><span class="operator">*</span><span class="number">5</span>] <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;We now also need to update the view: <span class="subst">\(view)</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Because the window <span class="subst">\(myWindow)</span> changed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这和上面闭包的定义几乎是一样的，只有在捕获列表的地方有所不同。这些变量的作用域只在闭包内部，在闭包外面它们是不能使用的。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 进阶【三】可选值</title>
    <url>/2018/03/01/20180301-Swift%20%E8%BF%9B%E9%98%B6%E3%80%90%E4%B8%89%E3%80%91%E5%8F%AF%E9%80%89%E5%80%BC/</url>
    <content><![CDATA[<p>Swift 中可选值的定义如下</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Optional</span>&lt;<span class="type">Wrapped</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">case</span> none</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">some</span>(wrapped)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>Optional</code> 是枚举类型，所以有的时候可以用模式匹配来进行一些巧妙的操作：</p>
<ul>
<li>使用 if case 来进行模式匹配，对非 nil 的值做 for 循环</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ary <span class="operator">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">nil</span>, <span class="number">4</span>, <span class="literal">nil</span>, <span class="number">44</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">let</span> i<span class="operator">?</span> <span class="keyword">in</span> ary &#123;</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1, 2, 4, 44</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<ul>
<li>或者只对 nil 值进行循环</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">case</span> <span class="literal">nil</span> <span class="keyword">in</span> ary &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No Value&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了 x? 这个模式，它只会匹配那些非 nil 的值。这个语法是 .Some(x) 的简写形式，所以该循环还可以被写为：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">let</span> .some(i) <span class="keyword">in</span> ary &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>内存：栈和堆（C / Swift）</title>
    <url>/2018/03/14/20180314-%E5%86%85%E5%AD%98%EF%BC%9A%E6%A0%88%E5%92%8C%E5%A0%86%EF%BC%88C%20:%20Swift%EF%BC%89/</url>
    <content><![CDATA[<h3 id="栈（C-语言描述）"><a href="#栈（C-语言描述）" class="headerlink" title="栈（C 语言描述）"></a>栈（C 语言描述）</h3><hr>
<p>什么是栈（Stack）？这是计算机内存中的一个特殊区域，它存储由每个函数创建的临时变量（包括 <code>main()</code> 函数）。栈是一个“LIFO”（后进先出）的数据结构。它是被 CPU 管理和优化的。每次函数声明一个新变量时，它都被“压入”栈中。然后每次函数退出时，所有由该函数压入栈的变量都被释放（也就是说，它们被删除）。一旦释放栈变量，该区域的内存就可用于其他栈变量。</p>
<p>使用栈来存储变量的优点是内存是自动为你管理的。你无需手动分配内存，或者在你不再需要时释放内存。更重要的是，由于 CPU 如此高效地组织栈内存，读取和写入栈变量的速度非常快。</p>
<p>理解栈的关键是这样一个概念：当一个函数退出时，它的所有变量都从栈中弹出（因此永远丢失）。因此栈变量本质上是本地的。这与我们之前看到的一个概念（称为变量范围）或局部变量或全局变量有关。 C 编程中的一个常见错误是尝试访问某个函数内栈上创建的变量，该函数在该函数之外的某个地方（即该函数退出后）从该程序中创建。</p>
<p>要记住栈的另一个特性是，可以存储在栈上的变量的大小有一个限制（随OS变化）。对于在堆中分配的变量，情况并非如此。</p>
<p><strong>栈的总结：</strong> </p>
<ul>
<li>随着函数压入和弹出局部变量，栈增长和缩小 </li>
<li>没有必要自己管理内存，变量内存被自动的分配和释放 </li>
<li>栈具有大小限制 </li>
<li>栈变量仅在创建它们的函数正在运行时才存在</li>
</ul>
<h3 id="堆（C-语言描述）"><a href="#堆（C-语言描述）" class="headerlink" title="堆（C 语言描述）"></a>堆（C 语言描述）</h3><hr>
<p>堆是计算机内存中的一个区域，不会自动为你进行内存管理，并且不受 CPU 的严格管理。它是一个更自由的内存区域（并且更大）。要在堆上分配内存，必须使用 <code>malloc()</code> 或 <code>calloc()</code> ，它们是内置的 C 函数。一旦你在堆上分配了内存，当你不再需要它的时候，你就有责任使用 <code>free()</code> 来释放内存。如果你没有做到这一点，你的程序将会有所谓的内存泄漏。也就是说，堆上的内存仍然会被留出（并且不会被其他进程使用）。</p>
<span id="more"></span>

<p>与栈不同，堆没有栈那样大小的限制（除了计算机明显的物理限制外）。<br>由于必须使用指针访问堆上的内存，因此堆内存的读取和写入速度稍慢。<br>与栈不同，在堆中创建的变量可以通过程序中任何位置的任何函数访问。<br>堆变量实质上是全局的。</p>
<h3 id="栈与堆的优点和缺点"><a href="#栈与堆的优点和缺点" class="headerlink" title="栈与堆的优点和缺点"></a>栈与堆的优点和缺点</h3><hr>
<p>栈 </p>
<ul>
<li>访问速度非常快 </li>
<li>不必显式的释放分配的内存 </li>
<li>空间由 CPU 高效管理，内存不会变得碎片化 </li>
<li>只有局部变量 </li>
<li>栈的大小有限制（取决于操作系统） </li>
<li>变量不能调整内存大小</li>
</ul>
<p>堆 </p>
<ul>
<li>变量可以全局访问 </li>
<li>内存大小没有限制 </li>
<li>（相对）较慢的访问 </li>
<li>没有保证有效利用空间，随着内存块被分配，内存随着时间的推移可能变得碎片化，然后释放 </li>
<li>你必须手动管理内存（分配和释放） </li>
<li>可以使用 <code>realloc()</code> 来调整变量的内存大小</li>
</ul>
<h3 id="例子🌰"><a href="#例子🌰" class="headerlink" title="例子🌰"></a>例子🌰</h3><hr>
<p>下面是一个简短的程序，它在<strong>栈</strong>上创建它的变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">multiplyByTwo</span> <span class="params">(<span class="type">double</span> input)</span> &#123;</span><br><span class="line">    <span class="type">double</span> twice = input * <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">return</span> twice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> age = <span class="number">30</span>;</span><br><span class="line">    <span class="type">double</span> salary = <span class="number">12345.67</span>;</span><br><span class="line">    <span class="type">double</span> myList[<span class="number">3</span>] = &#123;<span class="number">1.2</span>, <span class="number">2.3</span>, <span class="number">3.4</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;double your salary is %.3f\n&quot;</span>, multiplyByTwo(salary));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// double your salary is 24691.340</span></span><br></pre></td></tr></table></figure>

<p>在第 10, 11 和 12 行，我们声明了变量：一个 <code>int </code> ，一个 <code>double</code> 和一个由三个双精度组成的数组。只要 <code>main()</code> 函数执行，这三个变量就会被压入栈。当 <code>main()</code> 函数退出（并且程序停止）时，这些变量将从栈中弹出。类似地，在函数 <code>multiplyByTwo()</code> 中，一旦 <code>multiplyByTwo()</code> 函数执行， <code>double</code> 变量，即 <code>double</code> 将被压入栈。一旦 <code>multiplyByTwo()</code> 函数退出，两个变量就从栈中弹出，并且永远消失。</p>
<p>另一点说明，有一种方法可以告诉 C 保存栈变量，即使在其创建者函数退出，就是在声明变量时使用 <code>static</code> 关键字。用 <code>static</code> 关键字声明的变量因此变成类似于全局变量的变量，但是仅在创建它的函数内部可见。这是一种奇怪的结构，除非在特定的情况下，否则你可能不需要这种结构。</p>
<p>下面是该程序的另一个版本，它将它的所有变量分配给<strong>堆</strong>而不是<strong>栈</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> *<span class="title function_">multiplyByTwo</span> <span class="params">(<span class="type">double</span> *input)</span> &#123;</span><br><span class="line">    <span class="type">double</span> *twice = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">    *twice = *input * <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">return</span> twice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *age = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *age = <span class="number">30</span>;</span><br><span class="line">    <span class="type">double</span> *salary = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">    *salary = <span class="number">12345.67</span>;</span><br><span class="line">    <span class="type">double</span> *myList = <span class="built_in">malloc</span>(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">    myList[<span class="number">0</span>] = <span class="number">1.2</span>;</span><br><span class="line">    myList[<span class="number">1</span>] = <span class="number">2.3</span>;</span><br><span class="line">    myList[<span class="number">2</span>] = <span class="number">3.4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> *twiceSalary = multiplyByTwo(salary);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;double your salary is %.3f\n&quot;</span>, *twiceSalary);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(age);</span><br><span class="line">    <span class="built_in">free</span>(salary);</span><br><span class="line">    <span class="built_in">free</span>(myList);</span><br><span class="line">    <span class="built_in">free</span>(twiceSalary);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如你所看到的，使用 <code>malloc()</code> 在堆上分配内存，然后使用 <code>free()</code> 来释放它，没有什么大不了的，但有点麻烦。另外要注意的是，现在到处都有一堆星号（*）。那些是什么？答案是，他们是指针。 <code>malloc()</code>（<code>calloc()</code> 和 <code>free()</code> ）函数处理的是指针而不是实际值。指针是 C 中的一种特殊数据类型，它将地址存储在内存中，而不是存储实际值。因此，在上面的第 5 行中，两次变量不是 <code>double</code>，而是一个指向 <code>double</code> 的指针。在内存地址中，这是一个 <code>double</code> 类型的数据。</p>
<h3 id="何时使用堆？何时使用栈？"><a href="#何时使用堆？何时使用栈？" class="headerlink" title="何时使用堆？何时使用栈？"></a>何时使用堆？何时使用栈？</h3><hr>
<p>什么时候应该使用堆，什么时候应该使用栈？</p>
<ul>
<li>如果你需要分配一大块内存（例如一个大的数组，或者一个大的结构体），并且你需要在很长的时间内保存这个变量（比如全局变量），那么你应该把它分配到堆上。</li>
<li>如果你正在处理的是只有在使用它们的函数仍然存在时才需要保持的小变量，那么你应该使用栈，因为它使用起来更容易也更快。</li>
<li>如果你需要动态改变大小的数组和结构体等变量（例如可根据需要增长或缩小的数组），那么你可能需要在堆上分配它们，并使用动态内存分配函数，如<code>malloc()</code> ，<code>calloc()</code> ，<code>realloc()</code> 和 <code>free()</code> 来“手动”管理该内存。</li>
</ul>
<h3 id="数据在内存中的存储（C-语言描述-）"><a href="#数据在内存中的存储（C-语言描述-）" class="headerlink" title="数据在内存中的存储（C 语言描述 ）"></a>数据在内存中的存储（C 语言描述 ）</h3><hr>
<p>这里有一条黄金法则：</p>
<ul>
<li>引用类型总是被分配到“堆”上。</li>
<li>值类型总是分配到它声明的地方：<ul>
<li>作为引用类型的成员变量分配到“堆”上</li>
<li>作为方法的局部变量时分配到“栈”上</li>
</ul>
</li>
</ul>
<h3 id="结构体在内存中的存储（Swift-语言描述）"><a href="#结构体在内存中的存储（Swift-语言描述）" class="headerlink" title="结构体在内存中的存储（Swift 语言描述）"></a>结构体在内存中的存储（Swift 语言描述）</h3><hr>
<p>与 C 语言不同，苹果对 Swift 中的结构体有着优化，使其能够存储在栈上，进而加快访问速度与增加操作的安全性。</p>
<p>如果你的结构体只由其他结构体组成，那编译器可以确保不可变性。同样地，当使用结构体时，编译器也可以生成非常快的代码。举个例子，对一个只含有结构体的数组进行操作的效率，通常要比对一个含有对象的数组进行操作的效率高得多。这是因为结构体通常要更直接：值是直接存储在数组的内存中的。而对象的数组中包含的只是对象的引用。最后，在很多情况下，编译器可以将结构体放到栈上，而不用放在堆里。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">uniqueIntegerProvider</span>() -&gt; <span class="type">AnyIterator</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">AnyIterator</span> &#123;</span><br><span class="line">        i <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Swift 的结构体一般被存储在栈上，而非堆上。不过这其实是一种优化：默认情况下结构体是存储在堆上的，但是在绝大多数时候，这个优化会生效，并将结构体存储到栈上。<strong>当结构体变量被一个函数闭合的时候，优化将不再生效，此时这个结构体将存储在堆上</strong>。因为变量 i 被函数闭合了，所以结构体将存在于堆上。这样一来，就算 uniqueIntegerProvider 退出了作用域，i 也将继续存在。与此相似，<strong>如果结构体太大，它也会被存储在堆上</strong>。</p>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 进阶【五】函数</title>
    <url>/2018/03/16/20180316-Swift%20%E8%BF%9B%E9%98%B6%E3%80%90%E4%BA%94%E3%80%91%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="在-Swift-中函数是一等公民。"><a href="#在-Swift-中函数是一等公民。" class="headerlink" title="在 Swift 中函数是一等公民。"></a>在 Swift 中函数是一等公民。</h3><hr>
<p>要理解 Swift 中的函数和闭包，需要先明白三件事情，按重要程度进行大致排序如下：</p>
<ol>
<li>函数可以像 Int 或者 String 那样被赋值给变量，也可以作为另一个函数的输入参数，或者另一个函数的返回值来使用。</li>
<li>函数能够捕获存在于其局部作用域之外的变量。</li>
<li>有两种方法可以创建函数，一种是使用 <code>func</code> 关键字，另一种是 <code>&#123; &#125;</code>。在 Swift 中，后一种被称为<strong>闭包表达式</strong>。</li>
</ol>
<h5 id="函数可以被赋值给变量，也能够作为函数的输入和输出"><a href="#函数可以被赋值给变量，也能够作为函数的输入和输出" class="headerlink" title="函数可以被赋值给变量，也能够作为函数的输入和输出"></a>函数可以被赋值给变量，也能够作为函数的输入和输出</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个函数接受 Int 值并将其打印</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">printInt</span>(<span class="params">i</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;you passed <span class="subst">\(i)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要将函数赋值给一个变量，比如 funVar，我们只需要将函数名字作为值就可以了。注意在函数名后没有括号：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> funVar <span class="operator">=</span> printInt</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>现在，我们可以使用 funVar 变量来调用 printInt 函数。注意在函数名后面需要使用括号：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">funVar(<span class="number">2</span>) <span class="comment">// 将打印 &quot;you passed 2&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们也能够写出一个接受函数作为参数的函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">useFunction</span>(<span class="params">function</span>: (<span class="type">Int</span>) -&gt; () ) &#123;</span><br><span class="line">    function(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">useFunction(function: printInt) <span class="comment">// you passed 3</span></span><br><span class="line">useFunction(function: funVar) <span class="comment">// you passed 3</span></span><br></pre></td></tr></table></figure>

<p>为什么将函数作为变量来处理这件事情如此关键？因为它让你很容易写出 “高阶” 函数，高阶函数将函数作为参数的能力使得它们在很多方面都非常有用。</p>
<p>你也可以在其他函数中返回一个函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">returnFunc</span>() -&gt; (<span class="type">Int</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">innerFunc</span>(<span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;you passed <span class="subst">\(i)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> innerFunc</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myFunc <span class="operator">=</span> returnFunc()</span><br><span class="line">myFunc(<span class="number">3</span>) <span class="comment">// you passed 3</span></span><br></pre></td></tr></table></figure>

<h5 id="函数可以捕获存在于它们作用范围之外的变量"><a href="#函数可以捕获存在于它们作用范围之外的变量" class="headerlink" title="函数可以捕获存在于它们作用范围之外的变量"></a>函数可以捕获存在于它们作用范围之外的变量</h5><p>当函数引用了在函数作用域外部的变量时，这个变量就被 “捕获” 了，它们将会继续存在，而不是在超过作用域后被摧毁。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">counterFunc</span>() -&gt; (<span class="type">Int</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> counter <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">innerFunc</span>(<span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        counter <span class="operator">+=</span> i <span class="comment">// counter is captured</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;running total: <span class="subst">\(counter)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> innerFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，因为 counter 是一个 counterFunc 的局部变量，它在 return 语句执行之后应该离开作用域并被摧毁。但是这个因为 innerFunc 捕获了它，它将继续存在。我们在结构体和类讨论过，counter 将存在于堆上而非栈上。我们可以多次调用 innerFunc，并且看到 running total 的输出在增加：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> f <span class="operator">=</span> counterFunc()</span><br><span class="line">f(<span class="number">3</span>) <span class="comment">// running total: 3</span></span><br><span class="line">f(<span class="number">4</span>) <span class="comment">// running total: 7</span></span><br></pre></td></tr></table></figure>

<p>如果我们再次调用 counterFunc() 函数，将会生成并“捕获”新的 counter 变量：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> g <span class="operator">=</span> counterFunc()</span><br><span class="line">g(<span class="number">2</span>) <span class="comment">// running total: 2</span></span><br><span class="line">g(<span class="number">2</span>) <span class="comment">// running total: 4</span></span><br></pre></td></tr></table></figure>

<p>这不影响我们的第一个函数，它拥有它自己的 counter：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">f(<span class="number">2</span>) <span class="comment">// running total: 9</span></span><br></pre></td></tr></table></figure>

<p><strong>你可以将这些函数以及它们所捕获的变量想象为一个类的实例，这个类拥有一个单一的方法 (也就是这里的函数) 以及一些成员变量 (这里的被捕获的变量)。</strong></p>
<p><strong>在编程术语里，一个函数和它所捕获的变量环境组合起来被称为闭包。上面 f 和 g 都是闭包的例子，因为它们捕获并使用了一个在它们外部声明的非局部变量 counter。</strong></p>
<h5 id="函数可以使用-来声明为闭包表达式"><a href="#函数可以使用-来声明为闭包表达式" class="headerlink" title="函数可以使用 { } 来声明为闭包表达式"></a>函数可以使用 { } 来声明为闭包表达式</h5><p>在 Swift 中，定义函数的方法有两种。一种是像上面所示那样使用 func 关键字。另一种方法是使用<strong>闭包表达式</strong>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">doubler</span>(<span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i <span class="operator">*</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].map(doubler) <span class="comment">// [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure>

<p>使用闭包表达式的语法来写相同的函数，像之前那样将它传给 map：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> doublerAlt <span class="operator">=</span> &#123; (i: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span> <span class="keyword">return</span> i<span class="operator">*</span><span class="number">2</span> &#125;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].map(doublerAlt) <span class="comment">// [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure>

<p><strong>使用闭包表达式来定义的函数可以被想成函数的字面量</strong>，就和 1 是整数字面量，”hello” 是字符串字面量那样。与 func 相比较，它的区别在于闭包表达式是匿名的，它们没有被赋予一个名字。使用它们的唯一方法是在它们被创建时将其赋值给一个变量，就像我们这里对 doubler 进行的赋值一样。</p>
<p><strong>使用闭包表达式声明的 doubler，和之前我们使用 func 关键字声明的函数，其实是完全等价的。它们甚至存在于同一个“命名空间”中，这一点和一些其他语言有所不同。</strong></p>
<p>这里，我们将 doubler map 的例子用短得多的形式进行了重写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map &#123; <span class="variable">$0</span> <span class="operator">*</span> <span class="number">2</span> &#125; <span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure>

<p>之所以看起来和原来很不同，是因为我们使用了 Swift 中的一些特性，来让代码更加简洁。我们来一个个看看这些用到的特性：</p>
<ol>
<li>如果你将闭包作为参数传递，并且你不再用这个闭包做其他事情的话，就没有必要现将它存储到一个局部变量中。可以想象一下比如 5*i 这样的数值表达式，你可以把它直接传递给一个接受 Int 的函数，而不必先将它计算并存储到变量里。</li>
<li>如果编译器可以从上下文中推断出类型的话，你就不需要指明它了。在我们的例子中，从数组元素的类型可以推断出传递给 map 的函数接受 Int 作为参数，从闭包的乘法结果的类型可以推断出闭包返回的也是 Int。</li>
<li>如果闭包表达式的主体部分只包括一个单一的表达式的话，它将自动返回这个表达式的结果，你可以不写 return。</li>
<li>Swift 会自动为函数的参数提供简写形式，$0 代表第一个参数，$1 代表第二个参数，以此类推。</li>
<li>如果函数的最后一个参数是闭包表达式的话，你可以将这个闭包表达式移到函数调用的圆括号的外部。这样的尾随闭包语法在多行的闭包表达式中表现非常好，因为它看起来更接近于装配了一个普通的函数定义，或者是像 if (expr) { } 这样的执行块的表达形式。</li>
<li>最后，如果一个函数除了闭包表达式外没有别的参数，那么方法名后面的调用时的圆括号也可以一并省略。</li>
</ol>
<p><strong>最后要说明的是关于命名的问题。要清楚，那些使用 func 声明的函数也可以是闭包，就和用 { } 声明的是一样的。记住，闭包指的是一个函数以及被它所捕获的所有变量的组合。而使用 { } 来创建的函数被称为闭包表达式，人们常常会把这种语法简单地叫做闭包。但是不要因此就认为使用闭包表达式语法声明的函数和其他方法声明的函数有什么不同。它们都是一样的，它们都是函数，也都可以是闭包。</strong> </p>
<h3 id="inout-参数和可变方法"><a href="#inout-参数和可变方法" class="headerlink" title="inout 参数和可变方法"></a>inout 参数和可变方法</h3><hr>
<p>如果你有一些 <code>C</code> 或者 <code>C++</code> 背景的话，在 Swift 中 <code>inout</code> 参数前面使用的 <code>&amp;</code> 符号可能会给你一种它是传递引用的印象。但事实并非如此，<code>inout</code> 做的事情是通过值传递，然后复制回来，而并不是传递引用。 引用官方《Swift 编程语言》中的话：</p>
<blockquote>
<p>inout 参数将一个值传递给函数，函数可以改变这个值，然后将原来的值替换掉，并从函数中传出。  </p>
</blockquote>
<h3 id="嵌套函数和inout"><a href="#嵌套函数和inout" class="headerlink" title="嵌套函数和inout"></a>嵌套函数和inout</h3><hr>
<p>在一个嵌套函数中也可以使用 <code>inout</code> 关键词，Swift 依然会保证你的使用是安全的。比如说，你可以定义一个嵌套函数（使用 func 或者使用闭包表达式），然后安全地改变一个 <code>inout</code> 的参数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">incrementTenTimes</span>(<span class="params">value</span>: <span class="keyword">inout</span> <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">inc</span>() &#123;</span><br><span class="line">        value <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="number">10</span> &#123;</span><br><span class="line">        inc()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">incrementTenTimes(value: <span class="operator">&amp;</span>x)</span><br><span class="line">x <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>不过，你不能够让这个 <code>inout</code> 参数逃逸（我们会在本章最后详细提到逃逸函数的内容）：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">escapeIncrement</span>(<span class="params">value</span>: <span class="keyword">inout</span> <span class="type">Int</span>) -&gt; () -&gt; () &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">inc</span>() &#123;</span><br><span class="line">        value <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以这么理解，因为 <code>inout</code> 的值会在函数返回之前复制回去，那么要是我们可以在函数返回之后再去改变它，应该要怎么做呢？是说值应该在改变以后再复制吗？要是调用源已经不存在了怎么办？编译器必须对此进行验证，因为这对保证安全十分关键。</p>
<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><hr>
<p>计算属性看起来和常规的属性很像，但是它并不使用任何内存来存储自己的值。相反，这个属性每次被访问时，返回值都将被实时计算出来。 </p>
<p>举个简单的例子，GPS 追踪信息结构体：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">GPSTrack</span> &#123;</span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> record: [(<span class="type">CLLocation</span>, <span class="type">Date</span>)] <span class="operator">=</span> []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">GPSTrack</span> &#123;</span><br><span class="line">    <span class="comment">/// 返回 GPS 追踪的所有日期</span></span><br><span class="line">    <span class="comment">/// - 复杂度：O(n)，n 是记录点的数量。</span></span><br><span class="line">    <span class="keyword">var</span> dates: [<span class="type">Date</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> record.map &#123; <span class="variable">$0</span>.<span class="number">1</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们没有指定 <code>setter</code>，所以 <code>dates</code> 属性是只读的。它的结果不会被缓存，每次在你调用 <code>dates</code> 属性时，结果都要被计算一遍。<strong>Swift API 指南推荐你对所有复杂度不是 O(1) 的计算属性都应该在文档中写明，因为调用者可能会假设一个计算属性的耗时是常数时间。</strong></p>
<h3 id="延迟存储属性（懒加载）"><a href="#延迟存储属性（懒加载）" class="headerlink" title="延迟存储属性（懒加载）"></a>延迟存储属性（懒加载）</h3><hr>
<p>延迟初始化一个值在 Swift 中是一种常见的模式，Swift 为此准备了一个特殊的 <code>lazy</code> 关键字来定义一个延迟属性（lazy property）。需要注意，延迟属性会被自动声明为 <code>mutating</code>，因此，这个属性也必须被声明为 <code>var</code>。延迟修饰符是编程记忆化的一种特殊形式。</p>
<p>比如，如果我们有一个 <code>view controller</code> 来显示 GPSTrack，我们可能会想展示一张追踪的预览图像。通过将属性改为延迟加载，我们可以将昂贵的图像生成工作推迟到属性被首次访问：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GPSTrackViewController</span>: <span class="title class_ inherited__">UIViewController</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> track: <span class="type">GPSTrack</span> <span class="operator">=</span> <span class="type">GPSTrack</span>()</span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> preview: <span class="type">UIImage</span> <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> point <span class="keyword">in</span> <span class="keyword">self</span>.track.record &#123;</span><br><span class="line">            <span class="comment">// 进行昂贵的计算</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIImage</span>()</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们第一次访问这个属性 <code>preview</code> 的时候，闭包将被执行（注意闭包后面的括号），它的返回值被存储在变量中。</p>
<p><strong>如果 <code>track</code> 属性发生了改变，<code>preview</code> 并不会自动更新。</strong>让我们来用一个更简单的例子来看看发生了什么。我们有一个 <code>Point</code> 结构体，并且用延迟的方式存储了 <code>distanceFromOrigin</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> y: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> distanceFromOrigin: <span class="type">Double</span> <span class="operator">=</span> <span class="keyword">self</span>.x <span class="operator">*</span> <span class="keyword">self</span>.x <span class="operator">+</span> <span class="keyword">self</span>.y <span class="operator">*</span> <span class="keyword">self</span>.y</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">x</span>: <span class="type">Double</span>, <span class="params">y</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x <span class="operator">=</span> x</span><br><span class="line">        <span class="keyword">self</span>.y <span class="operator">=</span> y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> point <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">3</span>, y: <span class="number">4</span>)</span><br><span class="line">point.distanceFromOrigin <span class="comment">// 25.0</span></span><br><span class="line">point.x <span class="operator">+=</span> <span class="number">10</span></span><br><span class="line">point.distanceFromOrigin <span class="comment">// 25.0</span></span><br></pre></td></tr></table></figure>

<p>当我们创建一个点后，可以访问 <code>distanceFromOrigin</code> 属性，这将会计算出值，并存储起来<strong>等待重用</strong>。不过，如果我们之后改变了 x 的值，这个变化将不会反应在 <code>distanceFromOrigin</code> 中。</p>
<p>解决办法：将其改为普通的（非延迟）计算属性。</p>
<h3 id="escaping-标注"><a href="#escaping-标注" class="headerlink" title="@escaping 标注"></a>@escaping 标注</h3><hr>
<p>正如我们在之前一章中看到的那样，在处理闭包时我们需要对内存格外小心。回想一下捕获列表的例子，在那个例子中为了避免引用循环，我们将 <code>view</code> 标记为了 <code>weak</code> ：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">window<span class="operator">?</span>.onRotate <span class="operator">=</span> &#123; [<span class="keyword">weak</span> view] <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;We now also need to update the view: <span class="subst">\(view)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，在我们使用 <code>map</code> 这样的函数的时候，我们从来不会去把什么东西标记为 <code>weak</code>。因为 <code>map</code> 将同步执行，这个闭包不会被任何地方持有，也不会有引用循环被创建出来，所以并不需要这么做。和我们传递给 <code>map</code> 的闭包相比，这里存储在 <code>onRotate</code> 中的闭包是逃逸的 (escape)，两者有所区别。</p>
<p>一个被保存在某个地方等待稍后（比如函数返回以后）再调用的闭包就叫做<strong>逃逸闭包</strong>。而传递给 <code>map</code> 的闭包会在 <code>map</code> 中被直接使用。这意味着编译去不需要改变在闭包中被捕获的变量的引用计数。</p>
<blockquote>
<p>在 Swift 3 之前，事情完全相反：那时候逃逸闭包是默认的，对非逃逸闭包，你需要标记出<code>@noescape</code>。Swift 3 的行为更好，因为它默认是安全的：如果一个函数参数可能导致引用循环，那么它需要被显式地标记出来。<code>@escaping</code> 标记可以作为一个警告，来提醒使用这个函数的开发者注意引用关系。非逃逸闭包可以被编译器高度优化，快速的执行路径将被作为基准而使用，除非你在有需要的时候显式地使用其他方法。  </p>
</blockquote>
<p><strong>注意默认非逃逸的规则只对那些直接参数位置（immediate parameter position）的函数类型有效。也就是说，类型是函数的存储属性将会是逃逸的（这很正常）。出乎意料的是，对于那些使用闭包作为参数的函数，如果闭包被封装到像是多元组或者可选值等类型的话，这个闭包参数也是逃逸的。因为在这种情况下闭包不是直接参数，它将自动变为逃逸闭包。这样的结果是，你不能写出一个函数，使它接受的函数参数同时满足可选值和非逃逸。很多情况下，你可以通过为闭包提供一个默认值来避免可选值。如果这样做行不通的话，可以通过重载函数，提供一个包含可选值 (逃逸) 的函数，以及一个不可选，不逃逸的函数来绕过这个限制：</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">transform</span>(<span class="keyword">_</span> <span class="params">input</span>: <span class="type">Int</span>, <span class="params">with</span> <span class="params">f</span>: ((<span class="type">Int</span>) -&gt; <span class="type">Int</span>)<span class="operator">?</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Using optional overload&quot;</span>)</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> f <span class="operator">=</span> f <span class="keyword">else</span> &#123; <span class="keyword">return</span> input &#125;</span><br><span class="line">    <span class="keyword">return</span> f(input)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">transform</span>(<span class="keyword">_</span> <span class="params">input</span>: <span class="type">Int</span>, <span class="params">with</span> <span class="params">f</span>: (<span class="type">Int</span>) -&gt; <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Using non-optional overload&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> f(input)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">transform(<span class="number">10</span>, with: <span class="literal">nil</span>) <span class="comment">// 使用可选值重载</span></span><br><span class="line">transform(<span class="number">10</span>) &#123; <span class="variable">$0</span> <span class="operator">*</span> <span class="variable">$0</span> &#125; <span class="comment">// 使用非可选值重载</span></span><br></pre></td></tr></table></figure>

<p>这样一来，如果用 <code>nil</code> 参数（或者一个可选值类型的变量）来调用函数，将使用可选值变种，而如果使用闭包字面量的调用将使用非逃逸和非可选值的重载方法。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>layoutIfNeeded() 函数对 UIScrollView 的影响</title>
    <url>/2018/03/17/20180317-layoutIfNeeded()%20%E5%87%BD%E6%95%B0%E5%AF%B9%20UIScrollView%20%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
    <content><![CDATA[<p>在做 iOS 相关的约束动画时，我们一定会用到 <code>layoutIfNeeded()</code> 函数，但是在大多数情况下使用并没有什么问题。当与 <code>UIScrollView</code> 相关的控件结合使用的时候要注意了。</p>
<p>在开发一个 App 时（类似于浏览器的 App），需求是，滑动的时候，需要隐藏掉顶部的 <code>navigation bar</code> （这里我是用 <code>UIView</code> 自定义的一个 <code>navigation bar</code>）。向上滑动，让 <code>navigation bar</code> 移动到可视区域外消失，当然，移动的时候是有动画的，这里我用的是 <code>constraint</code> 相关的动画，所以我需要在最后调用一次 <code>layoutIfNeeded()</code> 函数。代码类似如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.35</span>) &#123;</span><br><span class="line">    <span class="comment">// 进行更改约束的操作</span></span><br><span class="line">    <span class="keyword">self</span>.view.layoutIfNeeded()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>这时就出现问题了，滑动的时候，你想让滑动停止，当然是手指放在屏幕上，滑动就会立刻停止，不过在进行布局动画的时候，滑动将会继续，只有当动画完了的时候，视图才会响应你的点击事件。</p>
<p>为了避免上述的问题，建议使用 <code>Core Graphics</code> 来完成上述的动画效果，即：<code>CGAffineTransform</code></p>
<p>使用 <code>Core Graphics</code> 完成动画，也能避免 <code>layoutIfNeeded()</code> 必须在父视图中调用这一要求的一些恶心的问题。</p>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 11权限更新</title>
    <url>/2018/03/17/20180317-iOS%2011%E6%9D%83%E9%99%90%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<p>最近项目中遇到了一个崩溃，当点击图片选择保存的时候，并没有出现请求相册权限的对话框，而是直接就崩溃，并且没有任何错误信息。开始以为是权限没有添加，但是 <code>NSPhotoLibraryUsageDescription</code> 是添加了的，搞不懂了。去翻了翻官方的文档，果然找到了解决方式。</p>
<p>从 iOS 11 开始，相册的权限参数发生了变化，适配 iOS 11 还需要添加一个 <code>NSPhotoLibraryAddUsageDescription</code> 的参数。官方的描述如下：</p>
<blockquote>
<p><strong>NSPhotoLibraryAddUsageDescription</strong></p>
<p><code>NSPhotoLibraryAddUsageDescription</code> ( <code>String</code> - iOS) This key lets you describe the reason your app seeks write-only access to the user’s photo library. When the system prompts the user to allow access, this string is displayed as part of the alert.</p>
<p>Important: To protect user privacy, an iOS app linked on or after iOS 10.0, and that accesses the user’s photo library, must statically declare the intent to do so. Include the NSPhotoLibraryAddUsageDescription key (in apps that link on or after iOS 11) or NSPhotoLibraryUsageDescription key in your app’s <code>Info.plist</code> file and provide a purpose string for the key. If your app attempts to access the user’s photo library without a corresponding purpose string, your app exits.  </p>
<p>This key is supported in iOS 11.0 and later.</p>
</blockquote>
<p>从 important 的最后一句话可以看出，当应用试图访问用户相册但是 <code>Info.plist</code>  中并没有对应权限的参数的话，应用就会退出。</p>
<span id="more"></span>

<p>原因找到，添加上新的参数。搞定！！！</p>
<p>关于 <code>Info.plist</code> 中的 <code>key</code> ，可以参考官方的文档：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvY29udGVudC9kb2N1bWVudGF0aW9uL0dlbmVyYWwvUmVmZXJlbmNlL0luZm9QbGlzdEtleVJlZmVyZW5jZS9BcnRpY2xlcy9Db2NvYUtleXMuaHRtbA==">Cocoa Keys<i class="fa fa-external-link-alt"></i></span></p>
<p>相关权限申请：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PermissionsManager</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 相册权限</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Parameters:</span></span><br><span class="line">    <span class="comment">///   - authorizedClosure: 已授权回调</span></span><br><span class="line">    <span class="comment">///   - deniedClosure: 未授权回调</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">albumPermissions</span>(<span class="params">authorizedClosure</span>: (() -&gt; ())<span class="operator">?</span>, <span class="params">deniedClosure</span>: (() -&gt; ())<span class="operator">?</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> status <span class="operator">=</span> <span class="type">PHPhotoLibrary</span>.authorizationStatus()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> status &#123;</span><br><span class="line">        <span class="keyword">case</span> .notDetermined:</span><br><span class="line">            <span class="type">PHPhotoLibrary</span>.requestAuthorization &#123; <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.albumPermissions(authorizedClosure: authorizedClosure, deniedClosure: deniedClosure)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> .authorized:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> authorized <span class="operator">=</span> authorizedClosure &#123;</span><br><span class="line">                authorized()</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> denied <span class="operator">=</span> deniedClosure &#123;</span><br><span class="line">                denied()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 相机权限</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Parameters:</span></span><br><span class="line">    <span class="comment">///   - authorizedClosure: 已授权回调</span></span><br><span class="line">    <span class="comment">///   - deniedClosure: 未授权回调</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">cameraPermissions</span>(<span class="params">authorizedClosure</span>: (() -&gt; ())<span class="operator">?</span>, <span class="params">deniedClosure</span>: (() -&gt; ())<span class="operator">?</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> status <span class="operator">=</span> <span class="type">AVCaptureDevice</span>.authorizationStatus(for: .video)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> status &#123;</span><br><span class="line">        <span class="keyword">case</span> .notDetermined:</span><br><span class="line">            <span class="type">AVCaptureDevice</span>.requestAccess(for: .video) &#123; <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.cameraPermissions(authorizedClosure: authorizedClosure, deniedClosure: deniedClosure)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> .authorized:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> authorized <span class="operator">=</span> authorizedClosure &#123;</span><br><span class="line">                authorized()</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> denied <span class="operator">=</span> deniedClosure &#123;</span><br><span class="line">                denied()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Escaping Closures - Swift</title>
    <url>/2018/03/19/20180319-Escaping%20Closures%20-%20Swift/</url>
    <content><![CDATA[<h3 id="逃逸闭包和非逃逸闭包"><a href="#逃逸闭包和非逃逸闭包" class="headerlink" title="逃逸闭包和非逃逸闭包"></a>逃逸闭包和非逃逸闭包</h3><hr>
<p><strong>逃逸闭包（escaping closure）</strong>，什么是逃逸闭包？苹果官方给的定义是：当一个闭包作为一个参数传递给函数，但是它是在函数返回之后调用的，这时候，这个闭包就称为<strong>逃逸闭包</strong>。当你声明一个将闭包作为参数的函数时，你可以在参数的类型之前用 <code>@escaping</code> 来表明这个闭包是允许逃逸的。</p>
<p>闭包可以逃逸的一种方式是存储在函数之外定义的变量中。作为例子，许多启动异步操作的函数都将闭包参数放在异步执行完毕之后的操作中执行（completion handler）。该函数在开始操作后返回，但在操作完成之前不会调用闭包 — 闭包需要逃逸，稍后调用，举个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> completionHandlers: [() -&gt; <span class="type">Void</span>] <span class="operator">=</span> []</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">someFunctionWithEscapingClosure</span>(<span class="params">completionHandler</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    completionHandlers.append(completionHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><code>someFunctionWithEscapingClosure(_ :)</code> 函数将闭包作为其参数，并将其添加到在函数外声明的数组中。如果你没有用 <code>@escaping</code>  来标记这个函数的参数，你会得到一个编译时的错误。</p>
<p>将一个闭包用 <code>@escaping</code> 来标记的话，意味着你需要在闭包中明确的引用自身 <code>self</code> ，例如，在下面的代码中，传递给 <code>someFunctionWithEscapingClosure(_:)</code> 的闭包是逃逸闭包，这就意味着它必须要明确的引用自身 <code>self</code> ， 相比之下，传递给 <code>someFunctionWithNonescapingClosure(_:)</code> 的闭包是非逃逸闭包，这意味着它可以隐式的引用自身。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunctionWithNonescapingClosure</span>(<span class="params">closure</span>: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    closure()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">doSomething</span>() &#123;</span><br><span class="line">        someFunctionWithEscapingClosure &#123; <span class="keyword">self</span>.x <span class="operator">=</span> <span class="number">100</span> &#125;</span><br><span class="line">        someFunctionWithNonescapingClosure &#123; x <span class="operator">=</span> <span class="number">200</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance <span class="operator">=</span> <span class="type">SomeClass</span>()</span><br><span class="line">instance.doSomething()</span><br><span class="line"><span class="built_in">print</span>(instance.x)</span><br><span class="line"><span class="comment">// Prints &quot;200&quot;</span></span><br><span class="line"></span><br><span class="line">completionHandlers.first<span class="operator">?</span>()</span><br><span class="line"><span class="built_in">print</span>(instance.x)</span><br><span class="line"><span class="comment">// Prints &quot;100&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="非逃逸闭包示意图"><a href="#非逃逸闭包示意图" class="headerlink" title="非逃逸闭包示意图"></a>非逃逸闭包示意图</h3><hr>
<p><img src="/my_pictures/20180319001/1.png" alt="非逃逸闭包示意图"></p>
<h3 id="逃逸闭包示意图"><a href="#逃逸闭包示意图" class="headerlink" title="逃逸闭包示意图"></a>逃逸闭包示意图</h3><hr>
<p><img src="/my_pictures/20180319001/2.png" alt="逃逸闭包示意图"></p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>优化 Swift 中 Notification.Name 的使用方式</title>
    <url>/2018/03/19/20180319-%E4%BC%98%E5%8C%96%20Swift%20%E4%B8%AD%20Notification.Name%20%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>在 <code>Swift</code> 中使用通知，在写通知名称的时候，并不能像 <code>Objective-C</code> 那样简单方便，一个字符串搞定。刚开始使用 <code>Swift</code> 通知时，感觉各种不爽，需要这样写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Notification</span>.<span class="type">Name</span>(<span class="string">&quot;myNotification&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>光取个名字就需要这么长一串代码，真的有悖于 <code>Swift</code> 给我的那种简洁的印象。下面我们就来优化一下。</p>
<h3 id="方法一：简单粗暴的-Notification-Name-扩展"><a href="#方法一：简单粗暴的-Notification-Name-扩展" class="headerlink" title="方法一：简单粗暴的 Notification.Name 扩展"></a>方法一：简单粗暴的 Notification.Name 扩展</h3><hr>
<p>最简单的方式就是对 <code>Notification.Name</code> 进行扩展，代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Notification</span>.<span class="type">Name</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> myNotification <span class="operator">=</span> <span class="type">Notification</span>.<span class="type">Name</span>(<span class="string">&quot;myNotification&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>使用的时候就能用点进行调用了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NotificationCenter</span>.default.post(name: .myNotification, object: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<p>一瞬间简单了不少。不过还不够，我希望自定义的通知名称与系统的分开，并且如果一个编程不规范的人可能还会犯 <code>namespace</code> 错误。<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OTgwYTkxNmYyNjVkYTNlMmU1NmU4Y2U=">Swift中Notification.Name这么难用怎么办<i class="fa fa-external-link-alt"></i></span> 这篇文章给了我灵感。</p>
<h3 id="方法二：使用-Enum-定义自己的通知名称"><a href="#方法二：使用-Enum-定义自己的通知名称" class="headerlink" title="方法二：使用 Enum 定义自己的通知名称"></a>方法二：使用 Enum 定义自己的通知名称</h3><hr>
<p>首先我们要新建一个枚举类型 <code>NotificationNames</code> ，为了避免 <code>namespace</code> 的问题，声明一个计算属性，添加一个前缀，就好像以前 <code>Objective-C</code> 的前缀 <code>NS</code> 一样。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">NotificationNames</span>: <span class="title class_ inherited__">String</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> myNotification</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> nameValue: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;NN&quot;</span> <span class="operator">+</span> rawValue</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> notiName: <span class="type">Notification</span>.<span class="type">Name</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Notification</span>.<span class="type">Name</span>(nameValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再添加一个自定义的 <code>post</code> 函数，方便调用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">post</span>(<span class="keyword">_</span> <span class="params">name</span>: <span class="type">NotificationNames</span>, <span class="params">object</span> <span class="params">myObject</span>: <span class="type">AnyObject</span>? <span class="operator">=</span> <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="type">NotificationCenter</span>.default.post(name: name.notiName, object: myObject)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用起来就简单了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NotificationCenter</span>.default.post(.myNotification, object: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<p>当在 <code>NotificationNames</code>  类型参数输入点的时候，就会很快的列出我们自定义的名称了。</p>
<p>类似的，<code>RxSwift</code> 版本的扩展如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Reactive</span> <span class="keyword">where</span> <span class="type">Base</span>: <span class="type">NotificationCenter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">notification</span>(<span class="keyword">_</span> <span class="params">myName</span>: <span class="type">NotificationNames</span>, <span class="params">object</span>: <span class="type">AnyObject</span>? <span class="operator">=</span> <span class="literal">nil</span>) -&gt; <span class="type">Observable</span>&lt;<span class="type">Notification</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> notification(myName.notiName, object: object)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NotificationCenter</span>.default</span><br><span class="line">        .rx.notification(.myNotification, object: <span class="literal">nil</span>)</span><br><span class="line">        .subscribe(onNext: &#123; <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// code</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br></pre></td></tr></table></figure>

<p>参考： <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OTgwYTkxNmYyNjVkYTNlMmU1NmU4Y2U=">Swift中Notification.Name这么难用怎么办<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>8 Mistakes to Avoid while Using RxSwift</title>
    <url>/2018/03/19/20180319-8%20Mistakes%20to%20Avoid%20while%20Using%20RxSwift/</url>
    <content><![CDATA[<p>Judging by the number of talks, articles and discussions related to reactive programming in Swift, it looks like the community has been taken by the storm. It’s not that the concept of <em>reactiveness</em> itself is a new shiny thing. The idea of using it for the development within the Apple ecosystem had been played with for a long time. Frameworks like <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlQ29jb2EvUmVhY3RpdmVDb2NvYQ==">ReactiveCocoa<i class="fa fa-external-link-alt"></i></span> have existed for years and did an awesome job at bringing the reactive programming to the Objective-C. However, the new and exciting features of Swift make it even more convenient to go full in on the “signals as your apps’ building blocks” model.</p>
<p>Here at Polidea, we’ve also embraced the reactive paradigm, mostly in the form of <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0">RxSwift<i class="fa fa-external-link-alt"></i></span>, the port of C#-originated <span class="exturl" data-url="aHR0cDovL3JlYWN0aXZleC5pby8=">Reactive Extensions<i class="fa fa-external-link-alt"></i></span>. And we couldn’t be happier! It helps us build more expressive and better-architectured apps faster and easier. Unifying various patterns (target-action, completion block, notification) under a universal API that is easy to use, easy to compose and easy to test has so many benefits. Also, introducing new team members is way easier now, when so much logic is written with methods familiar either from sequences (map, filter, zip, flatMap) or from other languages that Reactive Extensions had been ported to.</p>
<span id="more"></span>

<p>The process of learning RxSwift, however, hasn’t been painless. We’ve made many mistakes, fallen into many traps and eventually arrived at the other end to share what we’ve learned along the way. This is what this series is about: showing you the most common pitfalls to avoid when going reactive. They all come from the everyday practical use of RxSwift in non-trivial applications. It took us many hours to learn our lessons and we hope that with our help it’s going to take you only few minutes to enjoy the benefits of reactive programming without ever encountering its dark side.</p>
<p>So, let’s start!</p>
<h3 id="Not-disposing-a-subscription"><a href="#Not-disposing-a-subscription" class="headerlink" title="Not disposing a subscription"></a>Not disposing a subscription</h3><p>When you started using RxSwift for the first time, you’ve probably tried to observe some events by writing:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">observable</span><br><span class="line">    .subscribe(onNext: &#123; <span class="operator">...</span> &#125;)</span><br></pre></td></tr></table></figure>

<p>Such an expression was, however, openly criticized by Xcode with the default <code>Result to call to &#39;subscribe&#39; is unused</code> warning. Luckily, there’s an easy fix available just around the corner. Telling the compiler that we ignore the call result with <code>_ =</code> would be enough, right? So now it’s:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">_</span> <span class="operator">=</span> observable</span><br><span class="line">        .subscribe(onNext: &#123; <span class="operator">...</span> &#125;)</span><br></pre></td></tr></table></figure>

<p>and everything is fixed, isn’t it? If you think so, prepare yourself for a treat. There’re probably a whole lot of low-hanging fruits of undisposed subscriptions just waiting to be picked from your memory-management tree. Ignoring the subscription’s result is a clear path to memory leaks. While there are situations in which you’ll be spared any problems, in the worst-case scenario both your <code>observable</code> and the observer closure will never be released. The bad news is that by ignoring the value returned from <code>subscribe</code> method you’re giving away the control over which scenario is going to happen.</p>
<p>To understand the problem, I’ll show you the mental model of the subscription process in terms of memory-management first. Then, I’ll derive the best practices. Finally, I’m going to peek into RxSwift source code to understand what is actually happening in the current (v3.X&#x2F;4.0) implementation and how it relates to the mental model presented earlier.</p>
<h3 id="The-mental-model-for-subscription-memory-management"><a href="#The-mental-model-for-subscription-memory-management" class="headerlink" title="The mental model for subscription memory-management"></a>The mental model for subscription memory-management</h3><p><em>Calling <code>subscribe</code> creates a reference cycle that retains both the <code>observable</code> and the <code>observer</code></em>. Neither of them is going to be released unless the cycle is broken, and it’s broken only in two situations:</p>
<ul>
<li>when the observable sequence completes, either with <code>.completed</code> or <code>.error</code> event,</li>
<li>when someone explicitly calls <code>.dispose()</code> on the <em>reference cycle manager</em> returned by <code>subscribe</code> method.</li>
</ul>
<p><img src="/my_pictures/20180319/1.jpeg"></p>
<p>The details may vary, but the basic idea of what it means to <em>subscribe</em> holds regardless of your particular observable, observer or subscription. The crucial thing to spot is that ignoring the <em>reference cycle manager</em>, aka <code>disposable</code>, strips you of the possibility to break reference cycle yourself. It is your gateway drug into the memory arrangement, and once it’s not available, there is no going back. If you use the <code>_ =</code> syntax, you basically state that the only way for the <code>observable</code> and <code>observer</code> to be released is by completing the observable sequence.</p>
<p>This might sometimes be exactly what you want! For example, if you’re calling <code>Observable.just</code>, it doesn’t really matter that you won’t ensure breaking the cycle. The single element is being emitted instantaneously, followed by <code>.completed</code> event. There are, however, many situations in which you might not be entirely sure of the completion possibilities for observable in question:</p>
<ul>
<li>you’re given the <code>Observable</code> from another object and the documentation doesn’t state whether it completes,</li>
<li>you’re given the <code>Observable</code> from another object and the documentation does state it completes, but there have been some changes in the internal implementation of that object along the way and no one remembered to update documentation,</li>
<li>the <code>Observable</code> is explicitly not completing (examples include <code>Variable</code>, <code>Observable.interval</code>, subjects),</li>
<li>there is an error in observable implementation, such as forgetting to send <code>.completed</code> event in <code>Observable.create</code> closure.<br>Since you’re rarely in control of all the observables in your app, and even then there’s a possibility for a mistake, the rule of thumb is to ensure yourself that the reference cycle will be broken. Either keep the reference to <code>disposable</code> and call the <code>.dispose()</code> method when the time comes, or use a handy helper like <code>DisposeBag</code> that’s gonna do it for you. You might also provide a separate cycle-breaking observable with <code>.takeUntil</code> operator. What way to choose depends on your particular situation, but always remember that:</li>
</ul>
<blockquote>
<p>Subscription creates a reference cycle between the observable and the observer. It might be broken implicitly, when observable completes, or explicitly, via <code>.dispose()</code>call. If you’re not 100% sure when or whether observable will complete, break the subscription reference cycle yourself!   </p>
</blockquote>
<p>Now that we’ve cleared things up, I feel like I owe you a little bit of explanation. The mental model I’ve drawn above is, well, a mental model, and therefore not strictly correct. What’s happening in the current RxSwift implementation (version 3.x&#x2F;4.x at the time of writing) is a little bit more complicated. To understand the actual behavior, let us have a deeper dive into the RxSwift internals.</p>
<h3 id="The-implementation-of-the-subscribe-method"><a href="#The-implementation-of-the-subscribe-method" class="headerlink" title="The implementation of the subscribe method"></a>The implementation of the <code>subscribe</code> method</h3><p>Where is the <code>subscribe</code> method implemented? First place to search would be, unsurprisingly, the <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZVR5cGUuc3dpZnQ=">ObservableType.swift<i class="fa fa-external-link-alt"></i></span> file. It contains declaration of <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZVR5cGUuc3dpZnQjTDM5">subscribe<i class="fa fa-external-link-alt"></i></span> method as a part of the <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZVR5cGUuc3dpZnQjTDEw">ObservableType<i class="fa fa-external-link-alt"></i></span> protocol:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ObservableType.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">subscribe</span>&lt;<span class="type">O</span>: <span class="type">ObserverType</span>&gt;(</span><br><span class="line">    <span class="keyword">_</span> <span class="params">observer</span>: <span class="type">O</span></span><br><span class="line">) -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">O</span>.<span class="type">E</span> <span class="operator">==</span> <span class="type">E</span></span><br></pre></td></tr></table></figure>

<p>What implements this protocol? Basically, all the various types of observables. Let’s concentrate on the major implementation called <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZS5zd2lmdA==">Observable<i class="fa fa-external-link-alt"></i></span>, since it’s a base class for all but one of the observables defined in RxSwift. Its version of <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZS5zd2lmdCNMMjI=">subscribe<i class="fa fa-external-link-alt"></i></span> method is short and simple:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Observable.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">subscribe</span>&lt;<span class="type">O</span>: <span class="type">ObserverType</span>&gt;(</span><br><span class="line">    <span class="keyword">_</span> <span class="params">observer</span>: <span class="type">O</span></span><br><span class="line">) -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">O</span>.<span class="type">E</span> <span class="operator">==</span> <span class="type">E</span> &#123;</span><br><span class="line">    rxAbstractMethod()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Oh, the abstract method. We need to look into the <code>Observable</code> subclasses then. A quick search reveals that there are 14 different overridden <code>subscribe</code> methods within the RxSwift source code at the time of writing. We can put each of them in one of three buckets:</p>
<ul>
<li>implementations in subjects, which provide their own subscription logic due to the extraordinary place they occupy in the RxSwift lore,</li>
<li>implementations in connectable observables, which must deal with subscriptions in a special way due to their ability of multicasting,</li>
<li>implementation in <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvUHJvZHVjZXIuc3dpZnQ=">Producer<i class="fa fa-external-link-alt"></i></span>, a subclass of <code>Observable</code> which provides the subscription logic for most of the operators you’ve grown to love and use.</li>
</ul>
<p><img src="/my_pictures/20180319/2.jpeg"></p>
<p>Let’s concentrate on <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvUHJvZHVjZXIuc3dpZnQ=">Producer<i class="fa fa-external-link-alt"></i></span> type, since it represents the variant of observable that is simplest to reason about: the emitter of the sequence of events, from the single source to single recipient. It’s definitely the most common use case. Almost all the operators are derived from <code>Producer</code> base class. While a few of them provide a dedicated subscription logic that’s optimized further to their particular needs (see <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvSnVzdC5zd2lmdA==">Just<i class="fa fa-external-link-alt"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvRW1wdHkuc3dpZnQ=">Empty<i class="fa fa-external-link-alt"></i></span> or <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvRXJyb3Iuc3dpZnQ=">Error<i class="fa fa-external-link-alt"></i></span> for basic examples), the vast majority use the following implementation of <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvUHJvZHVjZXIuc3dpZnQjTDE0">subscribe<i class="fa fa-external-link-alt"></i></span> from <code>Producer</code> (some scheduler-related logic was stripped for better readability):</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Producer.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">subscribe</span>&lt;<span class="type">O</span> : <span class="type">ObserverType</span>&gt;(</span><br><span class="line">    <span class="keyword">_</span> <span class="params">observer</span>: <span class="type">O</span></span><br><span class="line">) -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">O</span>.<span class="type">E</span> <span class="operator">==</span> <span class="type">Element</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> disposer <span class="operator">=</span> <span class="type">SinkDisposer</span>()</span><br><span class="line">    <span class="keyword">let</span> sinkAndSubscription <span class="operator">=</span> run(observer, cancel: disposer)</span><br><span class="line">    disposer.setSinkAndSubscription(</span><br><span class="line">        sink: sinkAndSubscription.sink,</span><br><span class="line">        subscription: sinkAndSubscription.subscription</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> disposer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So, what’s happening here? First, the observable creates a <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvUHJvZHVjZXIuc3dpZnQjTDM5">SinkDisposer<i class="fa fa-external-link-alt"></i></span> object. Then it uses the <code>SinkDisposer</code> instance to create two additional objects: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvUHJvZHVjZXIuc3dpZnQjTDE4">sink and subscription<i class="fa fa-external-link-alt"></i></span>. They both have the same type: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvRGlzcG9zYWJsZS5zd2lmdA==">Disposable<i class="fa fa-external-link-alt"></i></span>, which is a protocol exposing a single <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvRGlzcG9zYWJsZS5zd2lmdCNMMTI=">dispose<i class="fa fa-external-link-alt"></i></span> method. These two objects are being passed back to <code>SinkDisposer</code> via a setter method, which suggests, correctly, that their references will be kept. After all that setup is done, the <code>SinkDisposer</code> is being returned. So, when we’re calling <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvUHJvZHVjZXIuc3dpZnQjTDc2">.dispose()<i class="fa fa-external-link-alt"></i></span> on the object returned from the <code>subscribe</code> method to break the subscription, we’re actually calling it on <code>SinkDisposer</code> instance.</p>
<p>So far, so good. One mystery down, still a few to go. Let’s dive into two crucial steps performed here: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvUHJvZHVjZXIuc3dpZnQjTDE3">let sinkAndSubscription &#x3D; run(observer, cancel: disposer)<i class="fa fa-external-link-alt"></i></span> and <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvUHJvZHVjZXIuc3dpZnQjTDE4">disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink, subscription: sinkAndSubscription.subscription)<i class="fa fa-external-link-alt"></i></span> methods. They are, as you’ll see, the essential parts of creating the reference cycle that keeps the subscription alive.</p>
<h3 id="Sinking-in-the-sea-of-Observables"><a href="#Sinking-in-the-sea-of-Observables" class="headerlink" title="Sinking in the sea of Observables"></a>Sinking in the sea of Observables</h3><p>The <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvUHJvZHVjZXIuc3dpZnQjTDM0">run<i class="fa fa-external-link-alt"></i></span> method is provided by the <code>Producer</code>, but only in an abstract variant:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Producer.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">run</span>&lt;<span class="type">O</span> : <span class="type">ObserverType</span>&gt;(</span><br><span class="line">    <span class="keyword">_</span> <span class="params">observer</span>: <span class="type">O</span>, <span class="params">cancel</span>: <span class="type">Cancelable</span></span><br><span class="line">) -&gt; (sink: <span class="type">Disposable</span>, subscription: <span class="type">Disposable</span>)</span><br><span class="line"><span class="keyword">where</span> <span class="type">O</span>.<span class="type">E</span> <span class="operator">==</span> <span class="type">Element</span> &#123;</span><br><span class="line">    rxAbstractMethod()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The actual logic is specific to the particular <code>Producer</code> subclass. Before we check them, it’s crucial to understand the pattern that is very common across the RxSwift operators implementation: <em>sink</em>. This is the way that RxSwift deals with the complexity of observable streams and how it separates the creation of the observable from the logic that is being run the moment you <code>subscribe</code> to it.</p>
<p>The idea is simple: when you use the particular operator (say you <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvTWFwLnN3aWZ0I0wyMA==">map<i class="fa fa-external-link-alt"></i></span> the existing observable), it returns an instance of a particular observable type dedicated to the task at hand. So calling <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvSnVzdC5zd2lmdCNMMTg=">Observable.just(1)<i class="fa fa-external-link-alt"></i></span> gives you back the instance of <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvSnVzdC5zd2lmdCNMNzU=">Just<i class="fa fa-external-link-alt"></i></span> class, which is a subclass of the <code>Producer</code> optimized for returning just one element and then completing. When you call <code>Observable&lt;Int&gt;.just(1).map &#123; $0 == 42 &#125;</code>, you’re being given back the instance of <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvTWFwLnN3aWZ0I0wxNDI=">Map<i class="fa fa-external-link-alt"></i></span> class, which is a subclass of the <code>Producer</code> optimized for applying the closure to each element in the <code>.next</code> event. However, at the very moment you create an observable, there’s nothing being actually sent to anyone yet, because no one has subscribed. The actual work of passing the events starts during the <code>subscribe</code> method, more precisely: in the <code>run</code> method that we’re so interested in.</p>
<p>That’s where the sink pattern shines. Each observable type has its own dedicated <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvU2luay5zd2lmdA==">Sink<i class="fa fa-external-link-alt"></i></span> subclass. For the <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvVGltZXIuc3dpZnQjTDE5">interval<i class="fa fa-external-link-alt"></i></span> operator, represented by the <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvVGltZXIuc3dpZnQjTDg4">Timer<i class="fa fa-external-link-alt"></i></span> observable, there is the <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvVGltZXIuc3dpZnQjTDQ5">TimerSink<i class="fa fa-external-link-alt"></i></span>. For the <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvTWVyZ2Uuc3dpZnQjTDE5">flatMap<i class="fa fa-external-link-alt"></i></span> operator, represented by the <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvTWVyZ2Uuc3dpZnQjTDU0Ng==">FlatMap<i class="fa fa-external-link-alt"></i></span> observable, there is the <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvTWVyZ2Uuc3dpZnQjTDM1NQ==">FlatMapSink<i class="fa fa-external-link-alt"></i></span>. For the <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvQ2F0Y2guc3dpZnQjTDMy">catchErrorJustReturn<i class="fa fa-external-link-alt"></i></span> operator, represented by the <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvQ2F0Y2guc3dpZnQjTDE1MQ==">Catch<i class="fa fa-external-link-alt"></i></span> observable, there is the <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvQ2F0Y2guc3dpZnQjTDEwOA==">CatchSink<i class="fa fa-external-link-alt"></i></span>. I think you get the idea!</p>
<p>But what is this <code>Sink</code> object, exactly? It is the place that stores the actual operator logic. So, for the <code>interval</code>, the <code>TimerSink</code> is the place that schedules sending events after each period and keeps track of the internal state (i.e. how many events were already sent). For the <code>flatMap</code>, the <code>FlatMapSink</code> (and its superclass, <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvTWVyZ2Uuc3dpZnQjTDQzOA==">MergeSink<i class="fa fa-external-link-alt"></i></span> ) is the place that subscribes to the observables returned from flatmapping closure, keeps track of them and passes their events further. You may basically think of a <code>Sink</code> as a wrapper for the observer. It listens for the events from observable, applies the operator-related logic and then passes those transformed events further down the stream.</p>
<p>This is how RxSwift isolates the creation of observables from the execution of subscription logic for <code>Producer</code> -based observables. The former is encapsulated in the <code>Observable</code> subclass, the latter is provided by the <code>Sink</code> subclass. The separation of responsibilities greatly simplifies the actual objects’ implementations and makes it possible to write multiple variants of <code>Sink</code> optimized for different scenarios.</p>
<h3 id="Sink-full-of-knowledge"><a href="#Sink-full-of-knowledge" class="headerlink" title="Sink full of knowledge"></a><code>Sink</code> full of knowledge</h3><p>Now that we know what the <em>sink</em> pattern is, let’s go back to the <code>run</code> method. Each of these <code>Producer</code> subclasses provides its own <code>run</code> implementation. While details may vary, it usually can be abstracted into three steps:</p>
<ul>
<li>create a <code>sink</code> object as an instance of a class that derives from <code>Sink</code> type,</li>
<li>create a subscription instance, usually by running <code>sink.run</code> method,</li>
<li>return both instances wrapped in a tuple.<br>To clarify things further, please look at the <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvTWVyZ2Uuc3dpZnQjTDU1OA==">FlatMap.run<i class="fa fa-external-link-alt"></i></span> example:</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Merge.swift, FlatMap observable class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">run</span>&lt;<span class="type">O</span>: <span class="type">ObserverType</span>&gt;(</span><br><span class="line">  <span class="keyword">_</span> <span class="params">observer</span>: <span class="type">O</span>, <span class="params">cancel</span>: <span class="type">Cancelable</span></span><br><span class="line">) -&gt; (sink: <span class="type">Disposable</span>, subscription: <span class="type">Disposable</span>)</span><br><span class="line"><span class="keyword">where</span> <span class="type">O</span>.<span class="type">E</span> <span class="operator">==</span> <span class="type">SourceSequence</span>.<span class="type">E</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> sink <span class="operator">=</span> <span class="type">FlatMapSink</span>(</span><br><span class="line">      selector: _selector,</span><br><span class="line">      observer: observer,</span><br><span class="line">      cancel: cancel</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">let</span> subscription <span class="operator">=</span> sink.run(_source)</span><br><span class="line">  <span class="keyword">return</span> (sink: sink, subscription: subscription)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The most important thing from the memory-management perspective is that in the moment of subscription the <code>sink</code> is given everything that’s needed to do the job:</p>
<ul>
<li>the events source (aka <em>Observable</em> ),</li>
<li>the event recipient (called <code>observer</code> ),</li>
<li>the operator-related data (for example, the flatmapping closure),</li>
<li>and the <code>SinkDisposer</code> instance (under the name <code>cancel</code> ).<br><code>sink</code> is free to store as many of these references as it sees fit for providing the required behavior of the operator. At the minimum, it’s gonna store the <code>observer</code> and, what’s gonna be crucial later, the <code>SinkDisposer</code>. Possibly more! Looking at the memory graph, <code>sink</code> quickly becomes the Northern Star in the constellation of objects related to the subscription.</li>
</ul>
<p>There is, however, one more object returned from observable’s <code>run</code> method. It’s <code>subscription</code>. This is the object that takes care of the logic that should be run when the subscription is being disposed of. Remember <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvQ3JlYXRlLnN3aWZ0I0wyMA==">create<i class="fa fa-external-link-alt"></i></span> operator? It takes a closure that returns <code>Disposable</code>, an object responsible for performing the cleanup. This is the same <code>Disposable</code> that’s returned from <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvQ3JlYXRlLnN3aWZ0I0wyNQ==">AnonymousObservableSink<i class="fa fa-external-link-alt"></i></span>‘s <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvQ3JlYXRlLnN3aWZ0I0w1OQ==">run<i class="fa fa-external-link-alt"></i></span> method as <code>subscription</code>. For each operator there might be some tasks to cancel, some resources to free, some internal subscription to dispose of. They’re all enclosed in the <code>subscription</code> object, and the ability to perform the cleanup is exposed via <code>subscription.dispose</code> method.</p>
<h3 id="The-Producer‘s-reference-cycle-Sink-and-SinkDisposer"><a href="#The-Producer‘s-reference-cycle-Sink-and-SinkDisposer" class="headerlink" title="The Producer‘s reference cycle: Sink and SinkDisposer"></a>The <code>Producer</code>‘s reference cycle: Sink and SinkDisposer</h3><p>Knowing that, let’s get back to the last component of the <code>subscribe</code> method implementation. Before the <code>SinkDisposer</code> is returned, the <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvUHJvZHVjZXIuc3dpZnQjTDU5">setSinkAndSubscription<i class="fa fa-external-link-alt"></i></span> method is called. It does exactly what you might expect: the <code>sink</code> and <code>subscription</code> objects are passed via setter and kept in the <code>SinkDisposer</code> properties. They are referenced strongly, but wrapped into Optionals, which makes it possible set the references to <code>nil</code> later.</p>
<p>Have you already spotted the reference cycle from our mental model? It’s hidden in the plain sight! <code>sink</code> <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvU2luay5zd2lmdCNMMTE=">stores the reference<i class="fa fa-external-link-alt"></i></span> to <code>SinkDisposer</code>, and <code>SinkDisposer</code> <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvUHJvZHVjZXIuc3dpZnQjTDUy">stores the reference<i class="fa fa-external-link-alt"></i></span> to <code>sink</code>. That’s why the subscription doesn’t release itself on the scope exit. Two objects keep each other alive, in an eternal hug of memory-lockup, until the end of the app. And since <code>sink</code> keeps <code>SinkDisposer</code> as non-Optional property, the one and only way of breaking the cycle is by asking the <code>SinkDisposer</code> to set the <code>sink</code> Optional reference to <code>nil</code>. And guess what? This is exactly what’s happening in the <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvUHJvZHVjZXIuc3dpZnQjTDc2">SinkDisposer.dispose<i class="fa fa-external-link-alt"></i></span> method. It calls <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvUHJvZHVjZXIuc3dpZnQjTDkx">dispose<i class="fa fa-external-link-alt"></i></span> on <code>sink</code>, then it calls <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvUHJvZHVjZXIuc3dpZnQjTDky">dispose<i class="fa fa-external-link-alt"></i></span> on subscription and then it <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvUHJvZHVjZXIuc3dpZnQjTDk0">nils out references<i class="fa fa-external-link-alt"></i></span> to break the retain cycle. So for the <code>Producer</code> -based observables, the <code>SinkDisposer</code> is the <em>reference cycle manager</em> from the mental model that we’ve introduced earlier.</p>
<p>After all those details, you might wonder how come the reference cycle breaks itself when observable completes? Well, we’ve just stated that it requires <code>SinkDisposer.dispose()</code> method, so the answer is simple. The central point of subscription process, <code>sink</code> object, keeps the reference to <code>SinkDisposer</code> and also receives all the events from the observable. So once it gets either <code>.completed</code> or <code>.error</code> event and once its own logic determines that this is the sequence completion, it simply calls <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL1J4U3dpZnQvT2JzZXJ2YWJsZXMvU2luay5zd2lmdCNMNDg=">dispose<i class="fa fa-external-link-alt"></i></span> method on its <code>SinkDisposer</code> reference. This way the cycle is being broken from the inside.</p>
<p>To summarize the process, here comes the diagram of the actual reference cycle in the usual <code>Producer</code> -based observable subscription:</p>
<p><img src="/my_pictures/20180319/3.jpeg"></p>
<h3 id="The-road-goes-ever-on-and-on"><a href="#The-road-goes-ever-on-and-on" class="headerlink" title="The road goes ever on and on"></a>The road goes ever on and on</h3><p>Aren’t you curious what happens in non- <code>Producer</code> -based cases, such as subjects or connectable observables? The concept is very similar. There is always a reference cycle that’s controlled by some kind of <em>reference cycle manager</em> and there is always a way of breaking this cycle by <code>dispose</code> method invocation. I encourage you to dive into RxSwift source code and see for yourself!</p>
<p>Now it is clear where the mental model comes from. The details of particular subscription vary, and each observable type has specific optimizations applied for better performance and cleaner architecture. However, the basic idea prevails: there’s a reference cycle and the only way of breaking this cycle is either by completing the observable or through <em>reference cycle manager</em>.</p>
<p>Relying on the completion of the observable, while useful in many real-life situations, should always be a road taken with much care and deliberation. If you’re not sure of how to handle the subscription’s memory management, or you simply want your code to be more resilient to the future changes, it’s always best to default to supplying a mechanism of breaking the reference cycle explicitly.</p>
<p>That’s all for this time. More ways to shoot yourself in the foot with RxSwift are coming. Next time we’re going to look at memory management from a different perspective, focusing not on the subscription process, but on what’s being passed to operators. Until then, don’t forget to <span class="exturl" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9wb2xpZGVh">follow Polidea on Twitter<i class="fa fa-external-link-alt"></i></span> for more mobile development related posts!</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cucG9saWRlYS5jb20vYmxvZy84LU1pc3Rha2VzLXRvLUF2b2lkLXdoaWxlLVVzaW5nLVJ4U3dpZnRQYXJ0LTEv">8 Mistakes to Avoid while Using RxSwift. Part 1 - Polidea<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>响应式框架</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift ABI Stability Manifesto</title>
    <url>/2018/03/29/20180329-Swift%20ABI%20Stability%20Manifesto/</url>
    <content><![CDATA[<ul>
<li>Authors: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pbHNlbWFu">Michael Ilseman<i class="fa fa-external-link-alt"></i></span> (compiled through conversations with many others)</li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><hr>
<h3 id="The-Big-Picture"><a href="#The-Big-Picture" class="headerlink" title="The Big Picture"></a>The Big Picture</h3><p>One of the top priorities for Swift right now is compatibility across future Swift versions. Compatibility aims at accomplishing two goals:</p>
<ol>
<li><strong>Source compatibility</strong> means that newer compilers can compile code written in an older version of Swift. This aims to reduce the migration pain that Swift developers face when migrating to a newer Swift version. Without source compatibility, projects face version-lock where all source code in a project and its packages must be written in the same version of Swift. With source compatibility, package authors will be able to maintain a single code base across multiple Swift versions while allowing their users to use a newer version of Swift.</li>
</ol>
<span id="more"></span>

<ol start="2">
<li><p><strong>Binary framework &amp; runtime compatibility</strong> enables the distribution of frameworks in a binary form that works across multiple Swift versions. Binary frameworks include both a <em>Swift module file</em>, which communicates source-level information of the framework’s API, and a <em>shared library</em>, which provides the compiled implementation that is loaded at runtime. Thus, there are two necessary goals for binary framework compatibility:</p>
<ul>
<li><p><strong>Module format stability</strong> stabilizes the module file, which is the compiler’s representation of the public interfaces of a framework. This includes API declarations and inlineable code. The module file is used by the compiler for necessary tasks such as type checking and code generation when compiling client code using a framework.</p>
</li>
<li><p><strong>ABI stability</strong> enables binary compatibility between applications and libraries compiled with different Swift versions. It is the focus of the rest of this document.</p>
</li>
</ul>
</li>
</ol>
<p>This document is an exploration and explanation of Swift’s ABI alongside the goals and investigations needed before declaring Swift’s ABI stable. It is meant to be a resource to the community as well as a declaration of the direction of Swift’s ABI.</p>
<p>Throughout this document there will be references to issues in Swift’s <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy8=">issue tracking system<i class="fa fa-external-link-alt"></i></span> denoted by “SR-xxxx”. These references track open engineering and design tasks for Swift’s ABI.</p>
<h3 id="What-Is-ABI"><a href="#What-Is-ABI" class="headerlink" title="What Is ABI?"></a>What Is ABI?</h3><p>At runtime, Swift program binaries interact with other libraries and components through an ABI. ABI is Application Binary Interface, or the specification to which independently compiled binary entities must conform to be linked together and executed. These binary entities must agree on many low level details: how to call functions, how their data is represented in memory, and even where their metadata is and how to access it.</p>
<p>ABI is per-platform, as it is a low level concern influenced by both the architecture and the OS. Most platform vendors define a “standard ABI” which is used for C code and built on by C-family languages. Swift, however, is a very different language from C and has its own per-platform ABI. While most of this document is platform-agnostic, platform-specific concerns have influenced details of the design and implementation of Swift’s ABI. For details on each platform’s standard ABI, refer to the <a href="#platform-abis">Appendix</a>.</p>
<h3 id="What-Is-ABI-Stability"><a href="#What-Is-ABI-Stability" class="headerlink" title="What Is ABI Stability?"></a>What Is ABI Stability?</h3><p>ABI stability means locking down the ABI to the point that future compiler versions can produce binaries conforming to the stable ABI. Once an ABI is stable, it tends to persist for the rest of the platform’s lifetime due to ever-increasing mutual dependencies.</p>
<p>ABI stability only affects invariants of externally visible public interfaces and symbols. Internal symbols, conventions, and layout can continue to change without breaking the ABI. For example, future compilers are free to change the calling conventions for internal function calls so long as the public interfaces are preserved.</p>
<p>Decisions about the ABI will have long-term ramifications and may limit the ways in which the language can grow and evolve in the future. Future Swift versions can add new, orthogonal aspects to the ABI, but any inefficiencies or inflexibilities present when stability is declared will (effectively) persist forever for that platform.</p>
<p>ABI changes that are new and orthogonal are called <em>ABI-additive</em> changes. ABI-additive changes may be taken advantage of when the minimum targeted Swift version supports them. This allows us to extend or progressively lock down more of the ABI. These may be ABI additions to support new features or that allow for more efficient data access. Examples appear throughout this document.</p>
<h3 id="What-Does-ABI-Stability-Enable"><a href="#What-Does-ABI-Stability-Enable" class="headerlink" title="What Does ABI Stability Enable?"></a>What Does ABI Stability Enable?</h3><p>ABI stability enables OS vendors to embed a Swift standard library and runtime that is compatible with applications built with older or newer versions of Swift. This would remove the need for apps to distribute their own copy of these libraries on those platforms. It also allows for better decoupling of tools and better integration into the OS.</p>
<p>As noted earlier, ABI stability is necessary, though not sufficient, for binary frameworks. Module format stability is also required and is beyond the scope of this document.</p>
<h3 id="Library-Evolution"><a href="#Library-Evolution" class="headerlink" title="Library Evolution"></a>Library Evolution</h3><p>Expressive and performance-focused languages which have binary interfaces tend to exhibit the <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRnJhZ2lsZV9iaW5hcnlfaW50ZXJmYWNlX3Byb2JsZW0=">fragile binary interface problem<i class="fa fa-external-link-alt"></i></span>, which makes it difficult for any library or component to change over time without requiring every user to recompile with new versions of that library. A major push in Swift currently is the plan for <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0L2Jsb2IvbWFzdGVyL2RvY3MvTGlicmFyeUV2b2x1dGlvbi5yc3Q=">Library Evolution<i class="fa fa-external-link-alt"></i></span>, which aims to grant flexibility for library authors to maintain backwards and forwards binary compatibility. Many implementation concerns therein could have an impact on ABI.</p>
<p>One of the goals of rolling out ABI stability is to remain flexible enough to accommodate library evolution changes without limiting the design space. Library evolution concerns will be addressed in each individual section, though a common refrain will be that the details are still undecided.</p>
<h2 id="Components-of-the-Swift-ABI"><a href="#Components-of-the-Swift-ABI" class="headerlink" title="Components of the Swift ABI"></a>Components of the Swift ABI</h2><hr>
<p>In practice, ABI concerns can be tightly coupled. But, as a conceptual model, I’d like to break them out into 6 separate classifications:</p>
<ol>
<li><p>Types, such as structs and classes, must have a defined in-memory layout for instances of that type. For binary entities to interoperate, they must share the same layout conventions. This layout is discussed in the <a href="#data-layout">Data Layout</a> section.</p>
</li>
<li><p>Type metadata is used extensively by Swift programs, the Swift runtime, reflection, and tools such as debuggers and visualizers. This metadata must either have a defined memory layout, or have a set of defined APIs for querying the metadata of a type. Type metadata is discussed in the <a href="#metadata">Type Metadata</a> section.</p>
</li>
<li><p>Every exported or external symbol in a library needs a unique name upon which binary entities can agree. Swift provides function overloading and contextual name spaces (such as modules and types), which means that any name in source code might not be globally unique. A unique name is produced through a technique called <em>name mangling</em>. Swift’s name mangling scheme is discussed in the <a href="#mangling">Mangling</a> section.</p>
</li>
<li><p>Functions must know how to call each other, which entails such things as the layout of the call stack, what registers are preserved, and ownership conventions. Calling conventions are discussed in the <a href="#calling-convention">Calling Convention</a> section.</p>
</li>
<li><p>Swift ships with a runtime library which handles such things as dynamic casting, reference counting, reflection, etc. Compiled Swift programs make external calls out to this runtime. Thus, Swift runtime API is Swift ABI. Runtime API stability is discussed in the <a href="#runtime">Runtime</a> section.</p>
</li>
<li><p>Swift ships with a standard library that defines many common types, structures, and operations on these. For a shipped standard library to work with applications written in different versions of Swift, it must expose a stable API. Thus, Swift Standard Library API is Swift ABI, as well as the layout of many of the types it defines. Swift standard library ABI stability concerns are discussed in the <a href="#standard-library">Standard Library</a> section.</p>
</li>
</ol>
<h2 id="Data-Layout"><a href="#Data-Layout" class="headerlink" title="Data Layout"></a>Data Layout</h2><hr>
<h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>First, let’s define some common terminology.</p>
<ul>
<li>An <em>object</em> is a stored entity of some type, meaning it has a location in memory or in registers. Objects can be values of struct&#x2F;enum type, class instances, references to class instances, values of protocol type, or even closures. This is <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT2JqZWN0XyUyOGNvbXB1dGVyX3NjaWVuY2UlMjk=">in contrast to<i class="fa fa-external-link-alt"></i></span> the class-based-OO definition of object as being an instance of a class.</li>
<li>A <em>data member</em> of an object is any value that requires layout within the object itself. Data members include an object’s stored properties and associated values.</li>
<li>A <em>spare bit</em> is a bit that is unused by objects of a given type. These often arise due to things such as alignment, padding, and address spaces, further described below.</li>
<li>An <em>extra inhabitant</em> is a bit pattern that does not represent a valid value for objects of a given type. For example, a simple C-like enum with 3 cases can fit in 2 bits, where it will have one extra inhabitant: the fourth unused bit pattern.<br><em>Data layout</em>, also known as type layout, specifies the in-memory layout of an object’s data. This includes the size of an object in memory, the alignment of an object (defined later), and how to find each data member within an object.</li>
</ul>
<p>An object has a statically known layout if the compiler is able to determine its layout at compilation time. Objects whose layout is not determinable until runtime have <em>opaque layout</em>. Such objects are further discussed in the <a href="#opaque-layout">opaque layout section</a></p>
<h4 id="Layout-and-Properties-of-Types"><a href="#Layout-and-Properties-of-Types" class="headerlink" title="Layout and Properties of Types"></a>Layout and Properties of Types</h4><p>For every type <code>T</code> in Swift with statically known layout, the ABI specifies a means to determine:</p>
<ul>
<li>The <em>alignment</em> for that type: for <code>x : T</code>, the address of <code>x</code> modulo alignment is always zero.</li>
<li>The <em>size</em> for that type: the byte size (possibly 0) without padding at the end.</li>
<li>The <em>offset</em> for each data member (if applicable): the address at which every member resides, relative to the object’s base address.</li>
</ul>
<p>Derived from alignment and size is the <em>stride</em> of the type, which is the size of objects of that type rounded up to alignment (minimum 1). The stride is mostly useful for objects laid out contiguously in memory, such as in arrays.</p>
<p> Some types have interesting properties:</p>
<ul>
<li>A type is <em>trivial</em>, also known as POD (“plain ol’ data”), if it merely stores data and has no extra copy, move, or destruction semantics. Trivial objects can be copied by replicating their bits, and are destroyed through deallocation. A type is trivial only if all data members are also trivial.</li>
<li>A type is <em>bitwise movable</em> if there are no side table references dependent on its address. A <span class="exturl" data-url="aHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9ib29rL293bmVyc2hpcC5odG1sI21vdmUtc2VtYW50aWNz">move<i class="fa fa-external-link-alt"></i></span> operation can occur when an object is copied from one location into another and the original location is no longer used. Bitwise movable objects are moved by performing a bitwise copy and then invalidating the original location. A type is bitwise movable only if all its data members are also bitwise movable. All trivial types are bitwise movable.</li>
</ul>
<p>An example of a trivial type is a Point struct that contains two Double fields: an x coordinate and a y coordinate. This struct is trivial, as it can be copied merely by copying its bits and its destruction performs no extra operations.</p>
<p>An example of a bitwise movable, but non-trivial, type is a struct that contains a reference to a class instance. Objects of that type cannot be copied merely by copying their bits, because a retain operation must be performed on the reference. Upon destruction, such objects must perform a release. However, the object can be moved from one address to another by copying its bits provided the original location is invalidated, keeping the overall retain count unchanged.</p>
<p>An example of a type that is neither trivial nor bitwise movable is a struct containing a weak reference. Weak references are tracked in a side table so that they can be nil-ed out when the referenced object is destroyed. When moving an object of such type from one address to another, the side table must be updated to refer to the weak reference’s new address.</p>
<h4 id="Opaque-Layout"><a href="#Opaque-Layout" class="headerlink" title="Opaque Layout"></a>Opaque Layout</h4><p>Opaque layout occurs whenever the layout is not known until runtime. This can come up for unspecialized generics, which do not have a known layout at compilation time. It can also come up for resilient types, which are described in the <a href="#layout-library-evolution">next section</a>.</p>
<p>The size and alignment of an object of opaque layout, as well as whether it is trivial or bitwise movable, is determined by querying its value witness table, which is described further in the <a href="#value-witness-table">value witness table section</a>. The offsets for data members are determined by querying the type’s metadata, which is described further in the <a href="#value-metadata">value metadata section</a>. Objects of opaque layout must typically be passed indirectly, described further in the <a href="#function-signature-lowering">function signature lowering section</a>. The Swift runtime interacts with objects of opaque layout through pointers, and thus they must be addressable, described further in the <a href="#abstraction-levels">abstraction levels section</a>.</p>
<p>In practice, layout might be partially-known at compilation time. An example is a generic struct over type <code>T</code> that stores an integer as well as an object of type <code>T</code>. In this case, the layout of the integer itself is known and its location within the generic struct might be as well, depending on the specifics of the layout algorithm. However, the generic stored property has opaque layout, and thus the struct overall has an unknown size and alignment. We are investigating how to most efficiently lay out partially-opaque aggregates [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItMzcyMg==">SR-3722<i class="fa fa-external-link-alt"></i></span> ]. This will likely entail placing the opaque members at the end in order to guarantee known offsets of non-opaque data members.</p>
<h4 id="Library-Evolution-1"><a href="#Library-Evolution-1" class="headerlink" title="Library Evolution"></a>Library Evolution</h4><p>Library evolution introduces <em>resilient</em> layouts of public types by default and provides new annotations that freeze the layout for performance. A resilient layout avoids many of the pitfalls of the fragile binary problem by making the layout opaque. Resilient types have far more freedom to change and evolve without breaking binary compatibility: public data members can be rearranged, added, and even removed (by providing a computed getter&#x2F;setter instead). The new annotations provide the ability to relinquish these freedoms by making stricter guarantees about their layout in order to be more efficiently compiled and accessed.</p>
<p>In order to allow for cross-module optimizations for modules that are distributed together, there is the concept of a <em>resilience domain</em>. A resilience domain is a grouping of modules which are version-locked with each other and thus do not have binary compatibility across multiple version requirements with each other. See <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0L2Jsb2IvbWFzdGVyL2RvY3MvTGlicmFyeUV2b2x1dGlvbi5yc3QjcmVzaWxpZW5jZS1kb21haW5z">Resilience Domains<i class="fa fa-external-link-alt"></i></span> for more details.</p>
<p>Resilient types are required to have opaque layout when exposed outside their resilience domain. Inside a resilience domain, this requirement is lifted and their layout may be statically known or opaque as determined by their type (see <a href="#opaque-layout">previous section</a> ).</p>
<p>Annotations may be applied to a library’s types in future versions of that library, in which case the annotations are versioned, yet the library remains binary compatible. How this will impact the ABI is still under investigation [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItMzkxMQ==">SR-3911<i class="fa fa-external-link-alt"></i></span> ].</p>
<h4 id="Abstraction-Levels"><a href="#Abstraction-Levels" class="headerlink" title="Abstraction Levels"></a>Abstraction Levels</h4><p>All types in Swift conceptually exist at multiple levels of abstraction. For example, an <code>Int</code> value is of a concrete type and can be passed to functions in registers. But, that same value might be passed to a function expecting a generic type <code>T</code>, which has opaque layout. Since the function is expecting its argument to be passed indirectly, the integer value must be promoted to the stack. When that value has type <code>T</code>, it is said to be at a higher abstraction level than when it was an integer. Moving between abstraction levels is done through a process called <em>reabstraction</em>.</p>
<p>For many types in Swift, reabstraction involves directly copying the value to memory so that it is addressable. Reabstraction may be more complicated for tuples and higher-order functions, explained later in the <a href="#tuples">tuples layout section</a> and the <a href="#lowering-higher-order-functions">function signature lowering section</a>.</p>
<h3 id="A-Tour-of-Types"><a href="#A-Tour-of-Types" class="headerlink" title="A Tour of Types"></a>A Tour of Types</h3><p>What follows is a breakdown of the different kinds of types in Swift and what needs to be specified.</p>
<h4 id="Structs"><a href="#Structs" class="headerlink" title="Structs"></a>Structs</h4><p>The layout algorithm for structs should result in an efficient use of space, possibly by laying out fields in a different order than declared [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItMzcyMw==">SR-3723<i class="fa fa-external-link-alt"></i></span> ]. We may want a fully declaration-order-agnostic algorithm to allow data members to be reordered in source without breaking binary compatibility [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItMzcyNA==">SR-3724<i class="fa fa-external-link-alt"></i></span> ]. We also need to consider whether, by default, we want to ensure struct data members are addressable (i.e. byte-aligned) or if we’d rather do bit-packing to save space [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItMzcyNQ==">SR-3725<i class="fa fa-external-link-alt"></i></span> ].</p>
<p>Zero sized structs do not take up any space as data members and struct members may be laid out in the padding of sub-structs. We may want to explore whether there are implementation benefits to capping alignment at some number, e.g. 16 on many platforms [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItMzkxMg==">SR-3912<i class="fa fa-external-link-alt"></i></span> ].</p>
<h4 id="Tuples"><a href="#Tuples" class="headerlink" title="Tuples"></a>Tuples</h4><p>Tuples are similar to anonymous structs, but they differ in that they exhibit structural subtyping: a tuple of type e.g. <code>(Bool, Bool)</code> can be passed anywhere expecting generic types <code>(T, U)</code>. But, the type <code>(T, U)</code> exists at a higher abstraction level than <code>(Bool, Bool)</code>. Due to this, tuples may face more expensive reabstraction costs if their layout is aggressively packed. Reabstracting such a tuple would involve splitting and promoting each element into their own addresses.</p>
<p>This may be an argument for a simple, declaration-order, non bit-packed layout algorithm for tuples. Tuples are often used for small local values and rarely persisted across ABI boundaries in a way that aggressive packing is performance-critical. This would also be more consistent with how fixed-size C arrays are presented in Swift, which are imported as tuples.</p>
<p>We should investigate whether to aggressively bit-pack tuple elements similarly to structs, paying the reabstraction costs, or if the benefits are not worth the costs [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItMzcyNg==">SR-3726<i class="fa fa-external-link-alt"></i></span> ].</p>
<p>Tuples should be binary compatible between labeled and unlabeled tuples of the same type and structure.</p>
<h4 id="Enums"><a href="#Enums" class="headerlink" title="Enums"></a>Enums</h4><p>A value of enum type exists as one of many variants or cases. Determining which is the job of the <em>discriminator</em>, also known as a tag, which is an integer value denoting which case is presently stored. To save space, discriminators can be put in spare bits or be represented by extra inhabitants.</p>
<p><code>@closed</code> enums, that is enums that can’t have cases added to them later, can be classified into the following:</p>
<ul>
<li>Degenerate - zero cased, or single cased without an associated value</li>
<li>Trivial - no associated values</li>
<li>Single payload - an enum where only one case has associated values</li>
<li>Multi-payload - an enum that has multiple cases with associated values</li>
</ul>
<p>Degenerate enums take zero space. Trivial enums are just their discriminator.</p>
<p>Single payload enums try to fit their discriminator in the payload’s extra inhabitants for the non-payload cases, otherwise they will store the discriminator after the payload. When the discriminator is stored after the payload, the bits are not set for the payload case. The payload is guaranteed to be layout compatible with the enum as the payload case does not use any extra inhabitants. Storing the discriminator after the payload may also result in more efficient layout of aggregates containing the enum, due to alignment.</p>
<p>The layout algorithm for multi-payload enums is more complicated and still needs to be developed [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItMzcyNw==">SR-3727<i class="fa fa-external-link-alt"></i></span> ]. The algorithm should try to rearrange payloads so as to coalesce cases and save space. This rearrangement can also improve performance and code size. For example, if ARC-ed payload components reside in the same location, operations like copy can be done directly on the values without extensive switching.</p>
<p>Enum raw values are not ABI, as they are implemented as code present in the computed property getter and setter. <code>@objc</code> enums are C-compatible, which means they must be trivial.</p>
<p>Library evolution adds the notion of <code>@open</code> enums (which will also be resilient), which allow library owners to add new cases and reorder existing cases without breaking binary compatibility. How this is accomplished is still to be determined.</p>
<h4 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h4><p>There are two constructs present when discussing about class layout: <em>class instances</em>, which reside on the heap, and <em>references</em> to class instances, which are reference-counted pointers.</p>
<h4 id="Class-Instances"><a href="#Class-Instances" class="headerlink" title="Class Instances"></a>Class Instances</h4><p>The layout of class instances is mostly opaque. This is to avoid the vexing problem of <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRnJhZ2lsZV9iaW5hcnlfaW50ZXJmYWNlX3Byb2JsZW0=">fragile binary interfaces<i class="fa fa-external-link-alt"></i></span>, also known as the “fragile base class problem”, in which seemingly minor changes to a base class break binary compatibility with subclasses.</p>
<p>The run-time type of a non-final class instance or a class existential is not known statically. To facilitate dynamic casts, the object must store a pointer to its type, called the <em>isa</em> pointer. The <em>isa</em> pointer is always stored at offset 0 within the object. How that type is represented and what information it provides is part of the class’s metadata and is covered in the <a href="#class-metadata">class metadata section</a>. Similarly, the function for a non-final method call is also not known statically and is dispatched based on the run-time type. Method dispatch is covered in the <a href="#method-dispatch">method dispatch section</a>.</p>
<p>Class instances will, as part of ABI-stability, guarantee a word-sized field of opaque data following the isa field that may be used for reference counting by the runtime [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItNDM1Mw==">SR-4353<i class="fa fa-external-link-alt"></i></span> ]. But, the format and conventions of this opaque data will not be ABI at first in order to have more flexibility for language or implementation changes. Instead, runtime functions provide the means to interact with reference counts. This opaque data and its conventions may be locked down for more efficient access in the future, which will be an ABI-additive change.</p>
<h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><p>Classes are reference types. This means that Swift code dealing with class instances does so through references, which are pointers at the binary level. These references participate in <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQXV0b21hdGljX1JlZmVyZW5jZV9Db3VudGluZw==">automatic reference counting<i class="fa fa-external-link-alt"></i></span> (ARC).</p>
<p>References to Objective-C-compatible class instances (i.e. those that inherit from an Objective-C class or are imported from Objective-C) must provide the same bit-level guarantees to the Objective-C runtime as Objective-C references. Thus, such references are opaque: they have no guarantees other than that nil is 0 and provide no extra inhabitants.</p>
<p>References to native, non-Objective-C-compatible Swift class instances do not have this constraint. The alignment of native Swift class instances is part of ABI, providing spare bits in the lower bits of references. Platforms may also provide spare bits (typically upper bits) and extra inhabitants (typically lower addresses) for references due to limited address spaces.</p>
<p>We may want to explore using spare bits in references to store local reference counts in order to perform some ARC operations more efficiently [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItMzcyOA==">SR-3728<i class="fa fa-external-link-alt"></i></span> ]. These would need to be flushed to the object whenever a reference may escape or the local reference count reaches zero. If these local reference counts can cross ABI boundaries, then such a change will have to be implemented in an ABI-additive way with deployment target checking.</p>
<h4 id="Existential-Containers"><a href="#Existential-Containers" class="headerlink" title="Existential Containers"></a>Existential Containers</h4><p>Any discussion of existentials quickly becomes bogged down in obscure terminology, so let’s first establish some background surrounding the terms <em>existential values</em>, <em>existential containers</em>, and <em>witness tables</em>.</p>
<p>In type theory, an <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHlwZV9zeXN0ZW0jRXhpc3RlbnRpYWxfdHlwZXM=">existential type<i class="fa fa-external-link-alt"></i></span> describes an interface of an abstract type. Values of an existential type are <em>existential values</em>. These arise in Swift when an object’s type is a protocol: storing or passing an object of protocol type means that the actual run-time type is opaque (not known at compile time, and thus neither is its layout). But, that opaque type has known interfaces because that type conforms to the protocol.</p>
<p>A type’s conformance to a protocol consists of functions (whether methods or getters and setters), but the specific addresses of those functions are not known at compilation time for existential values as their actual type is not known until run time. This is a similar situation as with references to non-final class instances, and is solved using a <a href="#method-dispatch">similar technique</a>. <em>Witness tables</em> are tables of function pointers implementing a protocol conformance and are further discussed in the <a href="#witness-tables">witness table section</a>.</p>
<p><em>Existential containers</em> store values of protocol or protocol composition type alongside corresponding witness tables for each protocol conformance. For existentials that are not class-constrained (may be value types or classes), the container needs to store:</p>
<ul>
<li>the value itself: either in an inline buffer or as a pointer to out-of-line storage</li>
<li>a pointer to the type metadata</li>
<li>a witness table pointer for every conformance.</li>
</ul>
<p>Class-constrained existentials omit the metadata pointer (as the object itself contains a pointer to its type), as well as any excess inline buffer space. <code>Any</code>, which is an existential value without any conformances, has no witness table pointer.</p>
<p>We are re-evaluating the inline buffer size for existential containers prior to ABI stability [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItMzM0MA==">SR-3340<i class="fa fa-external-link-alt"></i></span> ]. We are also considering making the out-of-line allocation be copy-on-write (COW) [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItNDMzMA==">SR-4330<i class="fa fa-external-link-alt"></i></span> ]. We should also explore “exploding” existential parameters, i.e. converting an existential parameter into a protocol-constrained generic parameter [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItNDMzMQ==">SR-4331<i class="fa fa-external-link-alt"></i></span> ].</p>
<h3 id="Declaring-Stability"><a href="#Declaring-Stability" class="headerlink" title="Declaring Stability"></a>Declaring Stability</h3><p>ABI stability means nailing down type layout and making decisions about how to handle the concerns of Library Evolution. The end result will be a technical specification of the layout algorithms that future compilers must adhere to in order to ensure binary compatibility [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItMzczMA==">SR-3730<i class="fa fa-external-link-alt"></i></span> ].</p>
<p>For all of the areas discussed above, more aggressive layout improvements may be invented in the post-ABI stability future. For example, we may want to explore rearranging and packing nested type data members with outer type data members. Such improvements would have to be done in an ABI-additive fashion through deployment target and&#x2F;or min-version checking. This may mean that the module file will need to track per-type ABI versioning information.</p>
<p>A potentially out of date description of Swift’s current type layout can be found in the <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0L2Jsb2IvbWFzdGVyL2RvY3MvQUJJLnJzdCN0eXBlLWxheW91dA==">Type Layout docs<i class="fa fa-external-link-alt"></i></span>.</p>
<h2 id="Type-Metadata"><a href="#Type-Metadata" class="headerlink" title="Type Metadata"></a>Type Metadata</h2><hr>
<p>While data layout specifies the layout of objects of a given type, <em>type metadata</em> holds information about the types themselves. The information available and how to access this information is part of Swift ABI.</p>
<p>Swift keeps metadata records for every <em>concrete type</em>. Concrete types include all non-generic types as well as generic types with concrete type parameters. These records are created by the compiler as well as lazily created at run time (e.g. for generic type instantiations). This metadata stores information about its type, discussed in each section below.</p>
<p>A potential approach to stability mechanism is to provide metadata read&#x2F;write functions alongside the runtime to interact with metadata, giving some freedom to the underlying structures to grow and change. This effectively makes large portions of metadata opaque. But, certain fields require access to be as efficient as possible (e.g. dynamic casts, calling into witness tables) and the performance hit from going through an intermediary function would be unacceptable. Thus, we will probably freeze the performance-critical parts and use accessor functions for the rest [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItMzkyMw==">SR-3923<i class="fa fa-external-link-alt"></i></span> ].</p>
<p>Metadata has many historical artifacts in its representation that we want to clean up [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItMzkyNA==">SR-3924<i class="fa fa-external-link-alt"></i></span> ]. We also want to make small tweaks to present more semantic information in the metadata, to enable better future tooling and features such as reflection [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItMzkyNQ==">SR-3925<i class="fa fa-external-link-alt"></i></span> ]. Some of these need to be done before declaring ABI stability and some may be additive.</p>
<h3 id="Declaring-Stability-1"><a href="#Declaring-Stability-1" class="headerlink" title="Declaring Stability"></a>Declaring Stability</h3><p>Stabilizing the ABI means producing a precise technical specification for the fixed part of the metadata layout of all language constructs so that future compilers and tools can continue to read and write them. A prose description is not necessarily needed, though explanations are useful. We will also want to carve out extra space for areas where it is likely to be needed for future functionality [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItMzczMQ==">SR-3731<i class="fa fa-external-link-alt"></i></span> ].</p>
<p>For more, but potentially out of date, details see the <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0L2Jsb2IvbWFzdGVyL2RvY3MvQUJJLnJzdCN0eXBlLW1ldGFkYXRh">Type Metadata docs<i class="fa fa-external-link-alt"></i></span>.</p>
<h3 id="Generic-Parameters"><a href="#Generic-Parameters" class="headerlink" title="Generic Parameters"></a>Generic Parameters</h3><p>Swift has a powerful generics system, which shows up both at compilation time (through specialization optimizations) and at run time when the type is unknown. Swift types may be parameterized over generic types, and thus every type’s metadata describes whether generic type parameters are present and if so provides information about them.</p>
<p>At run time, objects only have concrete types. If the type in source code is generic, the concrete type is an instantiation of that generic type. Generic instantiation metadata provide type metadata for each generic type parameter. If the generic type is constrained, corresponding <a href="#witness-tables">witness tables</a> for each protocol conformance are also provided in the metadata.</p>
<h3 id="Value-Metadata"><a href="#Value-Metadata" class="headerlink" title="Value Metadata"></a>Value Metadata</h3><p>Named value types store the type name (currently mangled but we are investigating un-mangled [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItMzkyNg==">SR-3926<i class="fa fa-external-link-alt"></i></span> ]) and a pointer to the type’s parent for nested types.</p>
<p>Value type metadata also has kind-specific entries. Struct metadata stores information about its fields, field offsets, field names, and field metadata. Enum metadata stores information about its cases, payload sizes, and payload metadata. Tuple metadata stores information about its elements and labels.</p>
<h4 id="Value-Witness-Tables"><a href="#Value-Witness-Tables" class="headerlink" title="Value Witness Tables"></a>Value Witness Tables</h4><p>Every concrete type has a <em>value witness table</em> that provides information about how to lay out and manipulate values of that type. When a value type has <a href="#opaque-layout">opaque layout</a>, the actual layout and properties of that value type are not known at compilation time, so the value witness table is consulted.</p>
<p>The value witness table stores whether a type is trivial and&#x2F;or bitwise movable, whether there are extra inhabitants and if so how to store and retrieve them, etc. For enums, the value witness table will also provide functionality for interacting with the discriminator. There may be more efficient ways of representing enums that simplify this functionality (or provide a fast path), and that’s under investigation [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItNDMzMg==">SR-4332<i class="fa fa-external-link-alt"></i></span> ].</p>
<p>These value witness tables may be constructed statically for known values or dynamically for some generic values. While every unique type in Swift has a unique metadata pointer, value witness tables can be shared by types so long as the information provided is identical (i.e. same layout). Value witness tables always represent a type at its highest <a href="#abstraction-levels">abstraction level</a>. The value witness table entries and structure need to be locked down for ABI stability [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItMzkyNw==">SR-3927<i class="fa fa-external-link-alt"></i></span> ].</p>
<h3 id="Class-Metadata"><a href="#Class-Metadata" class="headerlink" title="Class Metadata"></a>Class Metadata</h3><p>Swift class metadata is layout-compatible with Objective-C class objects on Apple’s platforms, which places requirements on the contents of the first section of class metadata. In this first section, entries such as super class pointers, instance size, instance alignment, flags, and opaque data for the Objective-C runtime are stored.</p>
<p>Following that are superclass members, parent type metadata, generic parameter metadata, class members, and <em>vtables</em>, described below. Library evolution may present many changes to what exactly is present and will likely make many of the contents opaque to accommodate changes [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItNDM0Mw==">SR-4343<i class="fa fa-external-link-alt"></i></span> ].</p>
<h4 id="Method-Dispatch"><a href="#Method-Dispatch" class="headerlink" title="Method Dispatch"></a>Method Dispatch</h4><p>Invoking a non-final instance method involves calling a function that is not known at compile time: it must be resolved at run time. This is solved through the use of a <em>vtable</em>, or virtual method table (so called because overridable methods are also known as “virtual” methods). A <em>vtable</em> is a table of function pointers to a class or subclass’s implementation of overridable methods. If the vtable is determined to be part of ABI, it needs a layout algorithm that also provides flexibility for library evolution.</p>
<p>Alternatively, we may decide to perform inter-module calls through opaque <em>thunks</em>, or compiler-created intermediary functions, which then perform either direct or vtable dispatch as needed [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItMzkyOA==">SR-3928<i class="fa fa-external-link-alt"></i></span> ]. This enables greater library evolution without breaking binary compatibility by allowing internal class hierarchies to change. This would also unify non-final method dispatch between open and non-open classes while still allowing for aggressive compiler optimizations like de-virtualization for non-open classes. This approach would make vtables not be ABI, as that part of the type metadata would effectively be opaque to another module.</p>
<h3 id="Protocol-and-Existential-Metadata"><a href="#Protocol-and-Existential-Metadata" class="headerlink" title="Protocol and Existential Metadata"></a>Protocol and Existential Metadata</h3><h4 id="Protocol-Witness-Tables"><a href="#Protocol-Witness-Tables" class="headerlink" title="Protocol Witness Tables"></a>Protocol Witness Tables</h4><p>The protocol witness table is a function table of a type’s conformance to the protocol’s interfaces. If the protocol also has an associated type requirement, then the witness table will store the metadata for the associated type. Protocol witness tables are used with <a href="#existential-containers">existential containers</a> where the run time type is not known.</p>
<p>Protocol witness tables may be created dynamically by the runtime or statically by the compiler. The layout of a protocol witness table is ABI and we need to determine a layout algorithm that also accommodates library evolution concerns, where additional protocol requirements may be added with default fall-backs [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItMzczMg==">SR-3732<i class="fa fa-external-link-alt"></i></span> ].</p>
<h4 id="Existential-Metadata"><a href="#Existential-Metadata" class="headerlink" title="Existential Metadata"></a>Existential Metadata</h4><p>Existential type metadata contains the number of witness tables present, whether the type is class-constrained, and a <em>protocol descriptor</em> for each protocol constraint. A protocol descriptor describes an individual protocol constraint, such as whether it is class-constrained, the size of conforming witness tables, and protocol descriptors for any protocols it refines. Protocol descriptors are layout compatible with the Objective-C runtime’s protocol records on Apple platforms. The format of the existential type metadata needs to be reviewed as part of the ABI definition [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItNDM0MQ==">SR-4341<i class="fa fa-external-link-alt"></i></span> ].</p>
<h3 id="Function-Metadata"><a href="#Function-Metadata" class="headerlink" title="Function Metadata"></a>Function Metadata</h3><p>In addition to common metadata entries, function type metadata stores information about the function signature: parameter and result type metadata, calling convention, per-parameter ownership conventions, and whether the function throws. Function type metadata always represents the function at its highest abstraction level, which is explained later in the <a href="#lowering-higher-order-functions">function signature lowering section</a>. Function parameters are currently modeled with a tuple-based design, but this should be updated to match modern Swift [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItNDMzMw==">SR-4333<i class="fa fa-external-link-alt"></i></span> ]. As more ownership semantics are modeled, more information may be stored about each parameter.</p>
<h2 id="Mangling"><a href="#Mangling" class="headerlink" title="Mangling"></a>Mangling</h2><hr>
<p>Mangling is used to produce unique symbols. It applies to both external (public) symbols as well as internal or hidden symbols. Only the mangling scheme for external symbols is part of ABI.</p>
<p>ABI stability means a stable mangling scheme, fully specified so that future compilers and tools can honor it. For a potentially out-of-date specification of what the mangling currently looks like, see the <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0L2Jsb2IvbWFzdGVyL2RvY3MvQUJJLnJzdCNtYW5nbGluZw==">Name Mangling docs<i class="fa fa-external-link-alt"></i></span>.</p>
<p>There are some corner cases currently in the mangling scheme that should be fixed before declaring ABI stability. We need to come up with a canonicalization of generic and protocol requirements to allow for order-agnostic mangling [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItMzczMw==">SR-3733<i class="fa fa-external-link-alt"></i></span> ]. We also may decide to more carefully mangle variadicity of function parameters, etc [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItMzczNA==">SR-3734<i class="fa fa-external-link-alt"></i></span> ]. Most often, though, mangling improvements focus on reducing symbol size.</p>
<p>Mangling design centers around coming up with short and efficient manglings that still retain important properties such as uniqueness and integration with existing tools and formats. Given the prevalence of public symbols in libraries and frameworks, and debugging symbols in applications, the symbol names themselves can make up a significant portion of binary size. Reducing this impact is a major focus of stabilizing the mangling. Post-ABI-stability, any new manglings or techniques must be additive and must support the existing manglings.</p>
<p>There are many ways to improve the existing mangling without major impact on existing tools. Throughout these endeavors, we will be empirically measuring and tracking symbol size and its impact on binary size. ABI work on mangling focuses on producing <em>compact manglings</em> and using <em>suffix differentiation</em>.</p>
<h3 id="Compact-Manglings"><a href="#Compact-Manglings" class="headerlink" title="Compact Manglings"></a>Compact Manglings</h3><p>Minor tweaks to shorten the mangling can have a beneficial impact on all Swift program binary sizes. These tweaks should compact existing manglings while preserving a simple unique mapping. One example is not distinguishing between struct&#x2F;enum in mangling structures, which would also provide more library evolution freedom [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItMzkzMA==">SR-3930<i class="fa fa-external-link-alt"></i></span> ]. We are considering dropping some internal witness table symbols when they don’t provide any meaningful information conducive to debugging [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItMzkzMQ==">SR-3931<i class="fa fa-external-link-alt"></i></span> ]. We recently overhauled word substitutions in mangling, with the goal of reducing as much redundancy in names as possible [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItNDM0NA==">SR-4344<i class="fa fa-external-link-alt"></i></span> ].</p>
<p>There are other aggressive directions to investigate as well, such as mangling based on a known overload set for non-resilient functions. This does have the downside of making manglings unstable when new overloads are added, so its benefits would have to be carefully weighed [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItMzkzMw==">SR-3933<i class="fa fa-external-link-alt"></i></span> ].</p>
<p>Any more ambitious reimagining of how to store symbols such as aggressive whole-library symbol name compression would have to be done in tight coupling with existing low level tools. Unfortunately, this might make some of the more ambitious options infeasible in time for ABI stability. They could be rolled out as ABI-additive using deployment target checking in the future.</p>
<h3 id="Suffix-Differentiation"><a href="#Suffix-Differentiation" class="headerlink" title="Suffix Differentiation"></a>Suffix Differentiation</h3><p>There are many existing low level tools and formats that store and consume the symbol information, and some of them use efficient storage techniques such as tries. Suffix differentiation is about adjusting the mangling in ways that take advantage of them: by distinguishing manglings through suffixes, i.e. having common shared prefixes. This is currently underway and is resulting in binary size reductions for platforms that use these techniques [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItMzkzMg==">SR-3932<i class="fa fa-external-link-alt"></i></span> ].</p>
<h2 id="Calling-Convention"><a href="#Calling-Convention" class="headerlink" title="Calling Convention"></a>Calling Convention</h2><hr>
<p>For the purposes of this document, “standard calling convention” refers to the C calling convention for a given platform (see <a href="#platform-abis">appendix</a> ), and “Swift calling convention” refers to the calling convention used by Swift code when calling other Swift code. One of the first steps toward ABI stability is for Swift to adopt the Swift calling convention [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItNDM0Ng==">SR-4346<i class="fa fa-external-link-alt"></i></span> ]. The Swift runtime uses the standard calling convention, though it may make alterations (see section <a href="#runtime-calling-convention">Runtime calling convention</a> ).</p>
<p>Calling convention stability pertains to public interfaces. The Swift compiler is free to choose any convention for internal (intra-module) functions and calls.</p>
<p>For rationale and potentially-out-of-date details, see the <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0L2Jsb2IvbWFzdGVyL2RvY3MvQ2FsbGluZ0NvbnZlbnRpb24ucnN0">Swift Calling Convention Whitepaper<i class="fa fa-external-link-alt"></i></span>. As part of nailing down the calling conventions, that document will either be updated with the final specifications of the calling conventions or else moved to a rationale document and a more succinct and rigorous specification put in its place.</p>
<h3 id="Register-convention"><a href="#Register-convention" class="headerlink" title="Register convention"></a>Register convention</h3><p>This section will be using the terms <em>callee-saved</em> and <em>scratch</em> to classify registers as part of a register convention.</p>
<ul>
<li>A <em>callee-saved register</em> must be preserved over the duration of a function call. If a called function (the <em>callee</em> ) wishes to change the value stored in the register, it must restore it before returning.</li>
<li>A <em>scratch</em> register, also known as caller-saved or callee-clobbered, is not preserved over the duration of a function call. If the register’s value must be preserved, code surrounding a function call must save and restore the value.</li>
</ul>
<p>Swift uses roughly the same categorization of registers as the standard calling convention. But, for some platforms, the Swift calling convention adds additional situational uses of some callee-saved registers: the <em>call context</em> register and the <em>error</em> register.</p>
<h4 id="Call-Context-Register"><a href="#Call-Context-Register" class="headerlink" title="Call Context Register"></a>Call Context Register</h4><p>The value held in the <em>call context</em> register depends on the kind of function called:</p>
<ul>
<li>Instance methods on class types: pointer to self</li>
<li>Class methods: pointer to type metadata (which may be subclass metadata)</li>
<li>Mutating method on value types: pointer to the value (i.e. value is passed indirectly)</li>
<li>Non-mutating methods on value types: self may fit in one or more registers, else passed indirectly</li>
<li><em>Thick closures</em>, i.e. closures requiring a context: the closure context</li>
</ul>
<p>Having the call context register be callee-saved is advantageous. It keeps the register stable across calls, where the context is very likely to be used and reused in subsequent or nested calls. Additionally, this makes partial application free as well as converting thin closures to thick.</p>
<h4 id="Error-Register"><a href="#Error-Register" class="headerlink" title="Error Register"></a>Error Register</h4><p>Throwing functions communicate error values to their callers through the <em>error</em> register on some platforms. The error register holds a pointer to the error value if an error occurred, otherwise 0. The caller of a throwing function is expected to quickly check for 0 before continuing on with non-error code, otherwise branching to code to handle or propagate the error. Using a callee-saved register for the error register enables free conversion from non-throwing to throwing functions, which is required to honor the subtyping relationship.</p>
<h3 id="Function-Signature-Lowering"><a href="#Function-Signature-Lowering" class="headerlink" title="Function Signature Lowering"></a>Function Signature Lowering</h3><p>Function signature lowering is the mapping of a function’s source-language type, which includes formal parameters and results, all the way down to a physical convention, which dictates what values are stored in what registers and what values to pass on the stack.</p>
<p>ABI stability requires nailing down and fully specifying this algorithm so that future Swift versions can lower Swift types to the same physical call signature as prior Swift versions [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItNDM0OQ==">SR-4349<i class="fa fa-external-link-alt"></i></span> ]. More in-depth descriptions and rationale of function signature lowering can be found in the <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0L2Jsb2IvbWFzdGVyL2RvY3MvQ2FsbGluZ0NvbnZlbnRpb24ucnN0I2Z1bmN0aW9uLXNpZ25hdHVyZS1sb3dlcmluZw==">function signature lowering docs<i class="fa fa-external-link-alt"></i></span>.</p>
<p>Lowering the result value is usually done first, with a certain number of registers designated to hold the result value if it fits, otherwise the result value is passed on the stack. A good heuristic is needed for the limit and is architecture specific (e.g. 4 registers on modern 64-bit architectures) [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItMzk0Ng==">SR-3946<i class="fa fa-external-link-alt"></i></span> ].</p>
<p>Next comes lowering parameters, which proceeds greedily by trying to fit values into registers from left-to-right, though some parameters may be re-ordered. For example, closures are best placed at the end to take advantage of ABI compatibility between thick closures and thin ones without a context.</p>
<p>Some values must be passed and returned indirectly as they are <em>address only</em>. Address only values include <a href="#type-properties">non-bitwise-copyable</a> values, values with <a href="#opaque-layout">opaque layout</a>, and non-class-constrained <a href="#existential-containers">existential values</a>. Even if the runtime type would normally be passed in a register, or even if the type is statically known at the call-site, if the callee receives or returns values with opaque layout, they must be passed or returned indirectly.</p>
<p>We should investigate whether it makes sense to split values with partially opaque layout by passing the non-opaque parts in registers [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItMzk0Nw==">SR-3947<i class="fa fa-external-link-alt"></i></span> ].</p>
<p>Parameter ownership is not reflected in the physical calling convention, though it will be noted in the mangling of the function name. Default argument expressions will not be ABI, as they will be emitted into the caller. This means that a library can add, modify, or remove default argument expressions without breaking binary compatibility (though modifying&#x2F;removing may break source compatibility).</p>
<h4 id="Lowering-Higher-Order-Functions"><a href="#Lowering-Higher-Order-Functions" class="headerlink" title="Lowering Higher-Order Functions"></a>Lowering Higher-Order Functions</h4><p>Passing or returning higher-order functions may involve undergoing <a href="#abstraction-levels">reabstraction</a>, which requires that the compiler creates a thunk mapping between the actual calling convention and the expected calling convention.</p>
<p>For example, let’s say there are two functions:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">add1</span>(<span class="keyword">_</span> <span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> i<span class="operator">+</span><span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">apply</span>&lt;<span class="type">T</span>,<span class="type">U</span>&gt;(<span class="keyword">_</span> <span class="params">f</span>: (<span class="type">T</span>) -&gt; <span class="type">U</span>, <span class="keyword">_</span> <span class="params">x</span>: <span class="type">T</span>) -&gt; <span class="type">U</span> &#123; <span class="keyword">return</span> f(x) &#125;</span><br></pre></td></tr></table></figure>

<p><code>apply</code>‘s function parameter <code>f</code> must take and return its values indirectly, as <code>T</code> and <code>U</code> have opaque layout. If <code>add1</code> is passed to <code>apply</code>, the compiler will create a thunk for <code>apply</code> to call that takes a parameter indirectly and calls <code>add1</code> by passing it in register. The thunk will then receive the result in register and return it indirectly back to <code>apply</code>.</p>
<h3 id="Stack-Invariants"><a href="#Stack-Invariants" class="headerlink" title="Stack Invariants"></a>Stack Invariants</h3><p>Calling conventions include invariants about the call stack, such as stack alignment. Unless there is a very compelling reason to deviate, Swift should just honor the stack invariants of the standard calling convention. This is because Swift functions may share their call stack with non-Swift code. For example a Swift function that calls an Objective-C function, which in turn calls another Swift function, would want to maintain the proper stack alignment (and any other stack invariants) for all calls. This is far simpler if they both honor the same invariants.</p>
<h3 id="Runtime-Calling-Convention"><a href="#Runtime-Calling-Convention" class="headerlink" title="Runtime Calling Convention"></a>Runtime Calling Convention</h3><p>The Swift runtime uses the standard calling convention, though it may evolve to preserve more invariants. It’s likely beneficial to introduce one or a number of tweaks to the scratch register sets of some runtime functions. Swift code that makes a call into the runtime assumes some registers are scratch, i.e. clobbered by the runtime function. But, some runtime functions may not need as many scratch registers and can guarantee more registers as callee-saved. Every formerly-scratch register that is denoted callee-saved (i.e. runtime function saved) relieves the register pressure of the surrounding Swift code making the runtime call.</p>
<p>Such changes to runtime functions can be rolled out incrementally in the future, and they are backwards compatible so long as no version of that function ever clobbers the now-saved registers. But, such a change is ratcheting, that is every register that is changed to be runtime-saved can no longer go back to being scratch without breaking binary compatibility. If the reduced scratch register set causes the runtime function to spill, then the whole exercise was pointless and actively harmful. Great care should be taken and testing applied for any change to ensure that the runtime function never spills in the future.</p>
<h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><p>Swift exposes a runtime that provides APIs for compiled code. Calls into the Swift runtime are produced by the compiler for concerns such as memory management and run-time type information. Additionally, the runtime exposes low-level reflection APIs that are useful to the standard library and some users.</p>
<p>Every existing runtime function will need to be audited for its desirability and behavior [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItMzczNQ==">SR-3735<i class="fa fa-external-link-alt"></i></span> ]. For every function, we need to evaluate whether we want the API as is:</p>
<ul>
<li>If yes, then we need to precisely specify the semantics and guarantees of the API.</li>
<li>If not, we need to either change, remove, or replace the API, and precisely specify the new semantics.</li>
</ul>
<p>The runtime is also responsible for lazily creating new type metadata entries at run time, either for generic type instantiations or for resilient constructs. Library evolution in general introduces a whole new category of needs from the runtime by making data and metadata more opaque, requiring interaction to be done through runtime APIs. Additionally, ownership semantics may require new runtime APIs or modifications to existing APIs. These new runtime needs are still under investigation [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItNDM1Mg==">SR-4352<i class="fa fa-external-link-alt"></i></span> ].</p>
<p>There are many potential future directions to open up the ABI and operate on less-opaque data directly, as well a techniques such as call-site caching. These are ABI-additive, and will be interesting to explore in the future.</p>
<p>For a potentially-out-of-date listing of runtime symbols and some details, see the <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0L2Jsb2IvbWFzdGVyL2RvY3MvUnVudGltZS5tZA==">Runtime docs<i class="fa fa-external-link-alt"></i></span>.</p>
<h2 id="Standard-Library"><a href="#Standard-Library" class="headerlink" title="Standard Library"></a>Standard Library</h2><hr>
<p>Any standard library API shipped post-ABI-stability must be supported into the future to ensure binary compatibility. The standard library will also be utilizing resilience annotations and <em>inlineable</em> code. Inlineable code is code that is bundled with the client’s code, and is available for inlining to the optimizer if it decides to do so. The standard library faces the following (non-exhaustive) list of challenges for ensuring binary compatibility:</p>
<ul>
<li>Published public functions and types cannot be removed or changed in ways that break binary compatibility.</li>
<li>Choosing what code to make inlineable will affect performance and flexibility.</li>
<li>Internal functions called by inlineable code become ABI, and are subject to the same binary compatibility concerns as public functions.</li>
<li>Non-resilient types cannot change their layout.</li>
<li>Protocols cannot add new requirements.</li>
</ul>
<h3 id="Inlineability"><a href="#Inlineability" class="headerlink" title="Inlineability"></a>Inlineability</h3><p>Inlineable code that calls internal functions makes those internal functions ABI, as the client code will be making external calls to them. Thus, many internal interfaces in the standard library will need to be locked down if called from inlineable code. Whether to mark code inlineable will have to carefully weigh performance requirements against keeping flexibility for future changes.</p>
<p>This tradeoff between performance and flexibility also affects the ability to deploy bug fixes and performance improvements to users. Users that have inlined code from the standard library will not be able to get bug fixes and performance improvements in an OS update without performing a recompilation with the new library. For more information on this topic, see <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0L2Jsb2IvbWFzdGVyL2RvY3MvTGlicmFyeUV2b2x1dGlvbi5yc3QjaW5saW5lYWJsZS1mdW5jdGlvbnM=">Inlineable Functions<i class="fa fa-external-link-alt"></i></span>.</p>
<h3 id="Upcoming-Changes"><a href="#Upcoming-Changes" class="headerlink" title="Upcoming Changes"></a>Upcoming Changes</h3><p>While the standard library is already ensuring source stability, it will be changing many of its fundamental underlying representations this year. When ABI stability lands, the standard library will be severely limited in the kinds of changes it can make to existing APIs and non-resilient types. Getting the standard library in the right place is of critical importance.</p>
<p>The programming model for String is still being redesigned [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItNDM1NA==">SR-4354<i class="fa fa-external-link-alt"></i></span> ], and many types such as Int are undergoing implementation changes [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItMzE5Ng==">SR-3196<i class="fa fa-external-link-alt"></i></span> ]. At the same time, the standard library is simultaneously switching to new compiler features such as conditional conformances to clean up and deliver the best APIs [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItMzQ1OA==">SR-3458<i class="fa fa-external-link-alt"></i></span> ].</p>
<p>Another goal of Swift is to improve the applicability of Swift to systems programming. Ownership semantics may make a large impact, including things such as improved <code>inout</code> semantics that allow for efficient and safe array slicing. Providing the right abstractions for efficient use of contiguous memory is still under investigation [ <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy9icm93c2UvU1ItNDM1NQ==">SR-4355<i class="fa fa-external-link-alt"></i></span> ].</p>
<h2 id="Next-Steps"><a href="#Next-Steps" class="headerlink" title="Next Steps"></a>Next Steps</h2><p>All progress and issue tracking will be done through JIRA on <span class="exturl" data-url="aHR0cHM6Ly9idWdzLnN3aWZ0Lm9yZy8=">bugs.swift.org<i class="fa fa-external-link-alt"></i></span>, using the “AffectsABI” label. We will make an ABI stability dashboard to more easily monitor specifics and progress. The next step is to start making issues for everything that needs fixing and issues for the directions we want to explore.</p>
<p>This document will be a living document until ABI stability is reached, updated with new findings and JIRA issues as they come up. After ABI stability is achieved, this document should be succeeded by technical specifications of Swift’s ABI.</p>
<p>Issue tracking alone doesn’t effectively communicate the overall progress and when ABI stability can be expected to land. Some issues take longer than others and there isn’t a good indication of how long the known tasks will take, nor of how many unknown issues are yet to be filed. For that, a higher level view of the overall status will be provided, possibly on <span class="exturl" data-url="aHR0cHM6Ly9zd2lmdC5vcmcv">swift.org<i class="fa fa-external-link-alt"></i></span>.</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0L2Jsb2IvbWFzdGVyL2RvY3MvQUJJU3RhYmlsaXR5TWFuaWZlc3RvLm1k">Swift ABI Stability Manifesto<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 进阶【六】编码和解码</title>
    <url>/2018/03/28/20180328-Swift%20%E8%BF%9B%E9%98%B6%E3%80%90%E5%85%AD%E3%80%91%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81/</url>
    <content><![CDATA[<p>将程序内部的数据结构序列化为一些可交换的数据格式，以及反过来将通用的数据格式反序列化为内部使用的数据结构，这在编程中是一项非常常见的任务。Swift 将这些操作称为编码（encoding）和解码（decoing）。Swift 4 的一个主要特性就是定义了一套标准的编码和解码数据的方法，所有的自定义类型都能选择使用这套方法。</p>
<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><hr>
<p>Codable 系统（以其基本“协议”命名，而这个协议其实是一个类型别名）的设计主要围绕三个核心目标；</p>
<ul>
<li><strong>普遍性</strong> — 它对结构体，枚举和类都适用。</li>
<li><strong>类型安全</strong> — 像是 JSON 这样的可交换格式通常都是弱类型，而你的代码应该要使用强类型数据。</li>
<li><strong>减少模板代码</strong> — 在让自定义类型加入这套系统时，应该让开发者尽可能少地写重复的“适配代码”。编译器应该为你自动生成这些代码。</li>
</ul>
<span id="more"></span>

<p>某个类型通过声明自己遵守 Encodable 和&#x2F;或 Decodable 协议来表明自己具备被序列化和&#x2F;或反序列化的能力。这两个协议各自只有一个必须实现的方法 - Encodable 定义了 <code>encode(to:)</code> 用来对值自身进行编码，Decodable 指定了一个初始化方法，来从序列化的数据中创建实例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 某个类型可以将自身编码为一种外部表示。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">Encodable</span> &#123;</span><br><span class="line">    <span class="comment">/// 将值编码到给定的 encoder 中。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">encode</span>(<span class="params">to</span> <span class="params">encoder</span>: <span class="type">Encoder</span>) <span class="keyword">throws</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 某个类型可以从外部表示中解码得到自身。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">Decodable</span> &#123;</span><br><span class="line">    <span class="comment">/// 通过从给定的 decoder 中解码来创建新的实例。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">from</span> <span class="params">decoder</span>: <span class="type">Decoder</span>) <span class="keyword">throws</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为大多数实现了其中一个协议的类型，也会实现另一个，所以标准库中还提供了 Codable 类型别名，来作为这两个协议组合后的简写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Codable</span> <span class="operator">=</span> <span class="type">Decodable</span> &amp; <span class="type">Encodable</span> </span><br></pre></td></tr></table></figure>

<p>标准库中包括 <code>Bool</code>，数值类型和 <code>String</code> 等所有基本类型，都直接是 Codable 类型。那些含有 Codable 元素的可选值，数组，字典和集合，也都满足 Codable。最后，包括 <code>Data</code>，<code>Date</code>，<code>URL</code>，<code>CGPoint</code> 和 <code>CGRect</code> 在内的许多 Apple 框架中的常用数据类型，也已经适配了 Codable。</p>
<h3 id="Encoding"><a href="#Encoding" class="headerlink" title="Encoding"></a>Encoding</h3><hr>
<p>因为 JSON 是最常见的格式，所以我们来集中研究一下 <code>JSONEncoder</code> 和 <code>JSONDecoder</code> 。</p>
<p>我们先来建两个结构体，一个是封装了坐标的结构体，一个是封装了地点的结构体。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 坐标</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Coordinate</span>: <span class="title class_ inherited__">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> latitude: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> longitude: <span class="type">Double</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 地点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Placemark</span>: <span class="title class_ inherited__">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> coordinate: <span class="type">Coordinate</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们可以将一个 <code>Placemark</code> 数组编码为 JSON 格式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> places <span class="operator">=</span> [</span><br><span class="line">    <span class="type">Placemark</span>(name: <span class="string">&quot;Berlin&quot;</span>, coordinate:</span><br><span class="line">        <span class="type">Coordinate</span>(latitude: <span class="number">52</span>, longitude: <span class="number">13</span>)),</span><br><span class="line">    <span class="type">Placemark</span>(name: <span class="string">&quot;Cape Town&quot;</span>, coordinate:</span><br><span class="line">        <span class="type">Coordinate</span>(latitude: <span class="operator">-</span><span class="number">34</span>, longitude: <span class="number">18</span>))</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> encoder <span class="operator">=</span> <span class="type">JSONEncoder</span>()</span><br><span class="line">    <span class="keyword">let</span> jsonData <span class="operator">=</span> <span class="keyword">try</span> encoder.encode(places) <span class="comment">// 129 bytes</span></span><br><span class="line">    <span class="keyword">let</span> jsonString <span class="operator">=</span> <span class="type">String</span>(decoding: jsonData, as: <span class="type">UTF8</span>.<span class="keyword">self</span>)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     [&#123;&quot;name&quot;:&quot;Berlin&quot;,&quot;coordinate&quot;:&#123;&quot;longitude&quot;:13,&quot;latitude&quot;:52&#125;&#125;,</span></span><br><span class="line"><span class="comment">     &#123;&quot;name&quot;:&quot;Cape Town&quot;,&quot;coordinate&quot;:&#123;&quot;longitude&quot;:18,&quot;latitude&quot;:-34&#125;&#125;]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Decoding"><a href="#Decoding" class="headerlink" title="Decoding"></a>Decoding</h3><hr>
<p>这一次我们来看一个复杂一点的，但是在实际应用中，能够经常见到的 JSON 格式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">let jsonStr = </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        &quot;success&quot;: true,</span></span><br><span class="line"><span class="string">        &quot;message&quot;: &quot;got the locations!&quot;,</span></span><br><span class="line"><span class="string">        &quot;data&quot;: &#123;</span></span><br><span class="line"><span class="string">            &quot;LocationList&quot;: [</span></span><br><span class="line"><span class="string">                &#123;</span></span><br><span class="line"><span class="string">                    &quot;LocID&quot;: 1,</span></span><br><span class="line"><span class="string">                    &quot;LocName&quot;: &quot;Downtown&quot;</span></span><br><span class="line"><span class="string">                &#125;,</span></span><br><span class="line"><span class="string">                &#123;</span></span><br><span class="line"><span class="string">                    &quot;LocID&quot;: 2,</span></span><br><span class="line"><span class="string">                    &quot;LocName&quot;: &quot;Uptown&quot;</span></span><br><span class="line"><span class="string">                &#125;,</span></span><br><span class="line"><span class="string">                &#123;</span></span><br><span class="line"><span class="string">                    &quot;LocID&quot;: 3,</span></span><br><span class="line"><span class="string">                    &quot;LocName&quot;: &quot;Midtown&quot;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            ]</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里有三层结构，第一层是最外面的一层，第二层是 <code>data</code> 的这一层，第三层是 <code>LocationList</code> 对应的这一层，这一层是一个数组。</p>
<p>下面我们来建立三个结构体，分别对应着三层结构：</p>
<h4 id="第一层-Location"><a href="#第一层-Location" class="headerlink" title="第一层 Location"></a>第一层 Location</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Location</span>: <span class="title class_ inherited__">Codable</span> &#123;</span><br><span class="line">	  <span class="keyword">var</span> success: <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">var</span> message: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> data: <span class="type">LocationData</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第二层-LocationData"><a href="#第二层-LocationData" class="headerlink" title="第二层 LocationData"></a>第二层 LocationData</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LocationData</span>: <span class="title class_ inherited__">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="type">LocationList</span>: [<span class="type">LocationItem</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第三层-LocationItem"><a href="#第三层-LocationItem" class="headerlink" title="第三层 LocationItem"></a>第三层 LocationItem</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LocationItem</span>: <span class="title class_ inherited__">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="type">LocID</span>: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> <span class="type">LocName</span>: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JSON-解码"><a href="#JSON-解码" class="headerlink" title="JSON 解码"></a>JSON 解码</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonDecode <span class="operator">=</span> <span class="type">JSONDecoder</span>()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> jsonData <span class="operator">=</span> jsonStr.data(using: .utf8) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> decoded <span class="operator">=</span> <span class="keyword">try</span> jsonDecode.decode(<span class="type">Location</span>.<span class="keyword">self</span>, from: jsonData)</span><br><span class="line">        <span class="built_in">print</span>(decoded.data.<span class="type">LocationList</span>.first<span class="operator">?</span>.<span class="type">LocName</span> <span class="operator">??</span> <span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> <span class="keyword">let</span> error &#123;</span><br><span class="line">        <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="一种更容易看出-JSON-包含情况的结构体声明"><a href="#一种更容易看出-JSON-包含情况的结构体声明" class="headerlink" title="一种更容易看出 JSON 包含情况的结构体声明"></a>一种更容易看出 JSON 包含情况的结构体声明</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Location</span>: <span class="title class_ inherited__">Codable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LocationData</span>: <span class="title class_ inherited__">Codable</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">LocationItem</span>: <span class="title class_ inherited__">Codable</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> <span class="type">LocID</span>: <span class="type">Int</span></span><br><span class="line">            <span class="keyword">var</span> <span class="type">LocName</span>: <span class="type">String</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> <span class="type">LocationList</span>: [<span class="type">LocationItem</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> success: <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">var</span> message: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> data: <span class="type">LocationData</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









































]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 进阶【七】字符串</title>
    <url>/2018/04/01/20180401-Swift%20%E8%BF%9B%E9%98%B6%E3%80%90%E4%B8%83%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h3><hr>
<p>大部分编程语言使用整数值对字符串进行下标操作，比如 <code>str[5]</code> 将会返回 <code>str</code> 中的第六个“字符” (这里的“字符”的概念由所操作的编程语言进行定义)。Swift 不允许这么做。为什么？答案可能现在你已经很耳熟了：因为整数的下标访问无法在常数时间内完成 (对于 <code>Collection</code> 协议来说这也是个直观要求)，而且查找第 n 个 <code>Character</code> 的操作也必须要对它之前的所有字节进行检查。</p>
<p><code>String.Index</code> 是 <code>String</code> 和它的视图所使用的索引类型，它本质上是一个存储了从字符串开头的字节偏移量的不透明值。如果你想计算第 n 个字符所对应的索引，你依然从字符串的开头或结尾开始，并花费 O(n) 的时间。但是一旦你拥有了有效的索引，就可以通过索引下标以 O(1) 的时间对字符串进行访问了。至关重要的是，通过一个已有索引来寻找下一个索引也是很快的，因为你可以从这个已有索引的字节偏移量开始进行查找，而不需要从头开始。正是由于这个原因，按顺序 (前向或者后向) 对字符串中的字符进行迭代是一个高效操作。</p>
<span id="more"></span>

<p>对字符串索引的操作的 API 与你在遇到其他任何集合时使用的索引操作是一样的。我们之所以经常容易忽略索引操作的等效性，是因为到现在为止我们最经常使用的数组的索引是整数类型，于是我们往往通过简单的算数，而非正式的索引操作 API，来对数组索引进行操作。<code>index(after:)</code> 方法将返回下一个字符的索引：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s <span class="operator">=</span> <span class="string">&quot;abcdef&quot;</span></span><br><span class="line"><span class="keyword">let</span> second <span class="operator">=</span> s.index(after: s.startIndex)</span><br><span class="line">s[second] <span class="comment">// b</span></span><br></pre></td></tr></table></figure>

<p>如果需要一次性地自动对多个字符进行迭代：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步进 4 个字符</span></span><br><span class="line"><span class="keyword">let</span> sixth <span class="operator">=</span> s.index(second, offsetBy: <span class="number">4</span>)</span><br><span class="line">s[sixth] <span class="comment">// f</span></span><br></pre></td></tr></table></figure>

<p>如果存在超过字符串末尾的风险，你可以加上 <code>limitedBy:</code> 参数。如果这个方法在达到目标索引之前就先触发了限制条件的话，它将返回 <code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> safeIdx <span class="operator">=</span> s.index(s.startIndex, offsetBy: <span class="number">400</span>, limitedBy: s.endIndex)</span><br><span class="line">safeIdx <span class="comment">// nil</span></span><br></pre></td></tr></table></figure>

<p>毫无疑问，这比简单的整数索引需要更多的代码，但是再一次，Swift 就是这样设计的。如果 Swift 允许使用整数下标索引来访问字符串，会大大增加意外地写出性能相当糟糕的代码的可能性（比如，在一个循环中使用了整数下标）。</p>
<h3 id="子字符串"><a href="#子字符串" class="headerlink" title="子字符串"></a>子字符串</h3><hr>
<p>和所有集合类型一样，<code>String</code> 有一个特定的 <code>SubSequence</code> 类型，它就是 <code>Substring</code> 。<code>Substring</code> 和 <code>ArraySlice</code> 很相似：它是一个以不同起始和结束索引的对原字符串的切片。子字符串和原字符串共享文本存储，这带来的巨大的好处，它让对字符串切片成为了非常高效的操作。在下面的例子中，创建 <code>firstWord</code> 并不会导致昂贵的复制操作或者内存申请：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sentence <span class="operator">=</span> <span class="string">&quot;The quick brown fox jumped over the lazy dog.&quot;</span></span><br><span class="line"><span class="keyword">let</span> firstSpace <span class="operator">=</span> sentence.index(of: <span class="string">&quot; &quot;</span>) <span class="operator">??</span> sentence.endIndex</span><br><span class="line"><span class="keyword">let</span> firstWord <span class="operator">=</span> sentence[<span class="operator">..&lt;</span>firstSpace] <span class="comment">// The</span></span><br><span class="line"><span class="built_in">type</span>(of: firstWord) <span class="comment">// Substring</span></span><br></pre></td></tr></table></figure>

<p>在你对一个（可能会很长的）字符串进行迭代并提取它的各个部分的循环中，切片的高效特性就非常重要了。这类任务可能包括在文本中寻找某个单词出现的所有位置，或者解析一个 CSV 文件等。在这里，字符串分割是一个很有用的操作。<code>Colleciton</code> 定义了一个 <code>split</code> 方法，它会返回一个子序列的数组（也就是 <code>[Substring]</code> ）。最常用的一种形式是：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Collection</span> <span class="keyword">where</span> <span class="type">Element</span>: <span class="type">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">split</span>(<span class="params">separator</span>: <span class="type">Element</span>, <span class="params">maxSplits</span>: <span class="type">Int</span> <span class="operator">=</span> <span class="type">Int</span>.max,</span><br><span class="line">                      <span class="params">omittingEmptySubsequences</span>: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">true</span>) -&gt; [<span class="type">SubSequence</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以这样来使用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> poem <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Over the wintry</span></span><br><span class="line"><span class="string">forest, winds howl in rage</span></span><br><span class="line"><span class="string">with no leaves to blow.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">let</span> lines <span class="operator">=</span> poem.split(separator: <span class="string">&quot;<span class="subst">\n</span>&quot;</span>)</span><br><span class="line"><span class="comment">// [&quot;Over the wintry&quot;, &quot;forest, winds howl in rage&quot;, &quot;with no leaves to blow.&quot;]</span></span><br><span class="line"><span class="built_in">type</span>(of: lines) <span class="comment">// Array&lt;Substring&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="StringProtocol"><a href="#StringProtocol" class="headerlink" title="StringProtocol"></a>StringProtocol</h3><hr>
<p><code>Substring</code> 和 <code>String</code> 的接口几乎完全一样。这是通过一个叫做 <code>StringProtocol</code> 的通用协议来达到的，<code>String</code> 和 <code>Substring</code> 都遵守这个协议。因为几乎所有的字符串 API 都被定义在 <code>StringProtocol</code> 上，对于 <code>Substring</code>，你完全可以假装将它看作就是一个 <code>String</code>，并完成各项操作。不过，在某些时候，你还是需要将子字符串转回 <code>String</code> 实例；和所有的切片一样，子字符串也只能用于短期的存储，这可以避免在操作过程中发生昂贵的复制。当这个操作结束，你想将结果保存起来，或是传递给下一个子系统，这时你应该通过初始化方法从 <code>Substring</code> 创建一个新的 <code>String</code>，如下例所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">lastWord</span>(<span class="params">in</span> <span class="params">input</span>: <span class="type">String</span>) -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">    <span class="comment">// 处理输入，操作子字符串</span></span><br><span class="line">    <span class="keyword">let</span> words <span class="operator">=</span> input.split(separators: [<span class="string">&quot;,&quot;</span>, <span class="string">&quot; &quot;</span>])</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> lastWord <span class="operator">=</span> words.last <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="comment">// 转换为字符串并返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">String</span>(lastWord)</span><br><span class="line">&#125;</span><br><span class="line">lastWord(in: <span class="string">&quot;one, two, three, four, five&quot;</span>) <span class="comment">// Optional(&quot;five&quot;)</span></span><br></pre></td></tr></table></figure>

<p><strong>不鼓励长期存储子字符串的根本原因在于，子字符串会一直持有整个原始字符串。如果有一个巨大的字符串，它的一个只表示单个字符的子字符串将会在内存中持有整个字符串。即使当原字符串的生命周期本应该结束时，只要子字符串还存在，这部分内存就无法释放。长期存储子字符串实际上会造成内存泄漏，由于原字符串还必须被持有在内存中，但是它们却不能再被访问。</strong></p>
<p>如果你想要扩展 <code>String</code> 为其添加新的功能，将这个扩展放在 <code>StringProtocol</code> 会是一个好主意，这可以保持 <code>String</code> 和 <code>Substring API</code> 的统一性。<code>StringProtocol</code> 设计之初就是为了在你想要对 String 扩展时来使用的。如果你想要将已有的扩展从 <code>String</code> 移动到 <code>StringProtocol</code> 的话，唯一需要做的改动是将传入其他 API 的 <code>self</code> 通过 <code>String(self)</code> 换为具体的 <code>String</code> 类型实例。</p>
<p>不过需要记住，在 Swift 4 中，<code>StringProtocol</code> 还并不是一个你想要构建自己的字符串类型时所应该实现的目标协议。文档中明确警告了这一点：</p>
<blockquote>
<p>不要声明任意新的遵守 <code>StringProtocol</code> 协议的类型。只有标准库中的 <code>String</code> 和 <code>Substring</code> 类型是有效的适配类型。  </p>
</blockquote>
<p>最终的目标是允许开发者创建他们自己的字符串类型 (比如带有特定的存储或者性能优化)，但是协议的设计还没有结束，所以现在就遵守这个协议的话，可能会让你的代码在 Swift 5 中无法通过编译。</p>
<h3 id="CustomStringConvertible"><a href="#CustomStringConvertible" class="headerlink" title="CustomStringConvertible"></a>CustomStringConvertible</h3><hr>
<p>符合 <code>CustomStringConvertible</code> 协议的类型可以在将实例转换为字符串时提供自己的表示形式。<code>String(describing:)</code> 初始值设定项是将任何类型的实例转换为字符串的首选方法。如果传递的实例符合<code>CustomStringConvertible</code> ，则 <code>String(describing:</code> 初始值设定项和 <code>print(_:)</code> 函数将使用实例的自定义描述属性。</p>
<p>不鼓励直接访问类型的 <code>description</code> 属性或使用 <code>CustomStringConvertible </code> 作为通用约束。</p>
<h4 id="遵守-CustomStringConvertible-协议"><a href="#遵守-CustomStringConvertible-协议" class="headerlink" title="遵守 CustomStringConvertible 协议"></a>遵守 <code>CustomStringConvertible</code> 协议</h4><p>通过定义 <code>description</code> 属性将 <code>CustomStringConvertible</code> 协议添加到自定义类型中。</p>
<p>例如，这个自定义的 <code>Point</code> 结构体使用标准库提供的默认表示形式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span>, y: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">21</span>, y: <span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"><span class="comment">// Prints &quot;Point(x: 21, y: 30)&quot;</span></span><br></pre></td></tr></table></figure>

<p>在实现 <code>description</code> 属性并遵守 <code>CustomStringConvertible</code> 协议之后，<code>Point</code> 类型提供了它自己的自定义表示。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Point</span>: <span class="title class_ inherited__">CustomStringConvertible</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"><span class="comment">// Prints &quot;(21, 30)&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="CustomDebugStringConvertible"><a href="#CustomDebugStringConvertible" class="headerlink" title="CustomDebugStringConvertible"></a>CustomDebugStringConvertible</h3><hr>
<p>Swift 为任意类型（any type）提供了默认的调试文本表示。 <code>String(reflecting:)</code> 的初始化和 <code>debugPrint(_:)</code> 函数使用该默认表示形式。要自定义该表示，请使您的类型符合 <code>CustomDebugStringConvertible </code> 协议。</p>
<p>由于 <code>String(reflecting:)</code> 的初始化适用于任何类型的实例，如果传递的值符合 <code>CustomDebugStringConvertible</code> ，则返回实例的 <code>debugDescription</code> ，不鼓励直接访问类型的 <code>debugDescription</code> 属性，或者使用 <code>CustomDebugStringConvertible</code> 作为通用约束。</p>
<blockquote>
<p>Note  </p>
<p>调用 <code>dump(_:_:_:_:)</code> 函数并在调试器中打印时使用 <code>String(reflecting:)</code> 和 <code>Mirror(reflecting:)</code> 来收集有关实例的信息，如果你为你自定义的类型实现了 <code>CustomDebugStringConvertible</code> 协议，则可能需要考虑通过实现 <code>CustomReflectable</code> 协议来提供自定义镜像。  </p>
</blockquote>
<h4 id="遵守-CustomDebugStringConvertible-协议"><a href="#遵守-CustomDebugStringConvertible-协议" class="headerlink" title="遵守 CustomDebugStringConvertible  协议"></a>遵守 <code>CustomDebugStringConvertible </code> 协议</h4><p>通过定义 <code>debugDescription </code> 属性将 <code>CustomDebugStringConvertible </code> 协议添加到自定义类型中。</p>
<p>例如，这个自定义的 <code>Point</code> 结构体使用标准库提供的默认表示形式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span>, y: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">21</span>, y: <span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="type">String</span>(reflecting: p))</span><br><span class="line"><span class="comment">// Prints &quot;p: Point = &#123;</span></span><br><span class="line"><span class="comment">//           x = 21</span></span><br><span class="line"><span class="comment">//           y = 30</span></span><br><span class="line"><span class="comment">//         &#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>在实现 <code>debugDescription </code> 属性并遵守 <code>CustomDebugStringConvertible </code> 协议之后，<code>Point</code> 类型提供了它自己的自定义表示。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Point</span>: <span class="title class_ inherited__">CustomDebugStringConvertible</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> debugDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Point(x: <span class="subst">\(x)</span>, y: <span class="subst">\(y)</span>)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="type">String</span>(reflecting: p))</span><br><span class="line"><span class="comment">// Prints &quot;Point(x: 21, y: 30)&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 操作符</title>
    <url>/2018/04/02/20180402-Swift%20%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<blockquote>
<p>Swift 支持重载操作符的特性，让我们可以自定义一些简单的计算。<br>最经典的例子就是两个二维向量之间的计算了。  </p>
</blockquote>
<p>首先我们定义一个二维向量，并创建两个向量</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2D</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> v1 <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">let</span> v2 <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">1.0</span>, y: <span class="number">4.0</span>)</span><br></pre></td></tr></table></figure>

<p>相加两个向量：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> v3 <span class="operator">=</span> <span class="type">Vector2D</span>(x: v1.x <span class="operator">+</span> v2.x, y: v1.y <span class="operator">+</span> v2.y)</span><br></pre></td></tr></table></figure>

<p>这样一次的话，感觉还好。但是遇到复杂的运算的话，这样写感觉就太啰嗦了，这时候重载操作符是最好的选择。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">+</span>(<span class="params">left</span>: <span class="type">Vector2D</span>, <span class="params">right</span>: <span class="type">Vector2D</span>) -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Vector2D</span>(x: left.x <span class="operator">+</span> right.x, y: left.y <span class="operator">+</span> right.y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>这样，我们相加两个向量就简单的多了</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> v3 <span class="operator">=</span> v1 <span class="operator">+</span> v2</span><br><span class="line"><span class="built_in">print</span>(v3) <span class="comment">// 输出 Vector2D(x: 3.0, y: 7.0)</span></span><br></pre></td></tr></table></figure>

<p>向量的内积运算符API中是没有定义的，所以我们自定义一个内积运算符。<br>这里是Swift 3的实现方式（感觉看起来比之前的版本可读性好多了）。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义操作符 别名类型</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">+*</span>: <span class="type">InnerProductPrecedence</span></span><br><span class="line"><span class="comment">// 自定义操作符的运算优先级</span></span><br><span class="line"><span class="keyword">precedencegroup</span> <span class="title">InnerProductPrecedence</span> &#123;</span><br><span class="line">//    结合律：内积的结果是一个 <span class="type">Double，不再会和其他内积结合使用，所以这里写成</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">associativity</span>: <span class="keyword">none</span></span><br><span class="line">//    优先级设置：高于普通运算。</span><br><span class="line">//    <span class="type">MultiplicationPrecedence（代表乘法和除法）</span></span><br><span class="line">//    <span class="type">AdditionPrecedence（代表加法和减法）</span></span><br><span class="line">    <span class="keyword">higherThan</span>: <span class="type">MultiplicationPrecedence</span>, <span class="type">AdditionPrecedence</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们就可以写具体的运算实现了</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">+*</span>(<span class="params">left</span>: <span class="type">Vector2D</span>, <span class="params">right</span>: <span class="type">Vector2D</span>) -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> left.x <span class="operator">*</span> right.x <span class="operator">+</span> left.y <span class="operator">*</span> right.y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> v1 <span class="operator">+*</span> v2 <span class="comment">// 14</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="precedencegroup"><a href="#precedencegroup" class="headerlink" title="precedencegroup"></a>precedencegroup</h3><blockquote>
<p>定义了一个操作符优先级别。操作符优先级的定义和类型声明有些相似，一个操作符比需要属于某个特定的优先级。Swift 标准库中已经定义了一些常用的运算优先级组，比如加法优先级 (AdditionPrecedence) 和乘法优先级 (MultiplicationPrecedence) 等，你可以在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0LWV2b2x1dGlvbi9ibG9iL21hc3Rlci9wcm9wb3NhbHMvMDA3Ny1vcGVyYXRvci1wcmVjZWRlbmNlLm1k">这里<i class="fa fa-external-link-alt"></i></span>找到完整的列表。如果没有适合你的运算符的优先级组，你就需要像我们在例子中做得这样，自己指定结合律方式和优先级顺序了。  </p>
</blockquote>
<h3 id="infix"><a href="#infix" class="headerlink" title="infix"></a>infix</h3><blockquote>
<p>表示要定义的是一个中位操作符，即前后都是输入；其他的修饰还包括 prefix 和 postfix，不再赘述  </p>
</blockquote>
<h3 id="associativity"><a href="#associativity" class="headerlink" title="associativity"></a>associativity</h3><blockquote>
<p>定义了结合律，即如果多个同类的操作符顺序出现的计算顺序。比如常见的加法和减法都是 left，就是说多个加法同时出现时按照从左往右的顺序计算 (因为加法满足交换律，所以这个顺序无所谓，但是减法的话计算顺序就很重要了)。点乘的结果是一个 Double，不再会和其他点乘结合使用，所以这里写成 none  </p>
</blockquote>
<h3 id="higherThan"><a href="#higherThan" class="headerlink" title="higherThan"></a>higherThan</h3><blockquote>
<p>运算的优先级，点积运算是优先于乘法运算的。除了 higherThan，也支持使用 lowerThan 来指定优先级低于某个其他组。  </p>
</blockquote>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 进阶【八】泛型</title>
    <url>/2018/04/03/20180403-Swift%20%E8%BF%9B%E9%98%B6%E3%80%90%E5%85%AB%E3%80%91%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<p>和大多数先进语言一样，Swift 拥有不少能被归类于泛型编程下的特性。使用泛型代码，你可以写出可重用的函数和数据结构，只要它们满足你所定义的约束，它们就能够适用于各种类型。比如，像是 <code>Array</code> 和 <code>Set</code> 等多个类型，实际上是它们中的元素类型就是泛型抽象。我们也可以创建泛型方法，它们可以对输入或者输出的类型进行泛型处理。<code>func identity&lt;A&gt;(input: A) -&gt; A</code> 就定义了一个可以作用于任意类型 A 的函数。某种意义上，我们甚至可以认为带有关联类型的协议是“泛型协议”。关联类型允许我们对特定的实现进行抽象。<code>IteratorProtocol</code> 协议就是一个这样的例子：它所生成的 <code>Element</code> 就是一个泛型。</p>
<p>泛型编程的目的是表达算法或者数据结构所要求的核心接口。比如，考虑内建集合一章中的 <code>last(where:)</code> 函数。将它写为 <code>Array</code> 的一个扩展原本是最明显的选择，但是 <code>Array</code> 其实包含了很多 <code>last(where:)</code> 并不需要的特性。通过确认核心接口到底是什么，也就是说，找到想要实现的功能的最小需求，我们可以将这个函数定义在宽阔得多的类型范围内。在这个例子中，<code>last(where:)</code> 只有一个需求：它需要能够逆序遍历一系列元素。所以，将这个算法定义为 <code>Sequence</code> 的扩展是更好的选择 (我们也可以为 <code>BidirectionalCollection</code> 添加一个更高效的实现)。</p>
<span id="more"></span>

<p>在本章中，我们会研究如何书写泛型代码。我们会先看一看什么是重载 (overloading) ，因为这个概念和泛型紧密相关。然后我们会使用泛型的方式，基于不同的假设，来为一个算法提供多种实现。之后我们将讨论一些你在为集合书写泛型算法时会遇到的常见问题，了解这些问题后你就将能使用泛型数据类型来重构代码，并使它们易于测试，更加灵活。最后，我们会谈一谈编译器是如何处理泛型代码的，以及要如何优化我们的泛型代码以获取更高性能的问题。</p>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><hr>
<p>拥有同样名字，但是参数或返回类型不同的多个方法互相称为重载方法，方法的重载并不意味着泛型。不过和泛型类似，我们可以将多种类型使用在同一个接口上。</p>
<h4 id="自由函数的重载"><a href="#自由函数的重载" class="headerlink" title="自由函数的重载"></a>自由函数的重载</h4><p>Swift 有一系列的复杂规则来确定到底使用哪个重载函数，这套规则基于函数是否是泛型，以及传入的参数是怎样的类型来确定使用优先级。整套规则十分复杂，不过它们可以被总结为一句话，那就是“选择最具体的一个”。也就是说，<strong>非通用的函数会优先于通用函数被使用</strong>。</p>
<p>来看下面这个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">log</span>&lt;<span class="type">View</span>: <span class="type">UIView</span>&gt;(<span class="keyword">_</span> <span class="params">view</span>: <span class="type">View</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It&#x27;s a <span class="subst">\(<span class="built_in">type</span>(of: view))</span>, frame: <span class="subst">\(view.frame)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">log</span>(<span class="keyword">_</span> <span class="params">view</span>: <span class="type">UILabel</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> text <span class="operator">=</span> view.text <span class="operator">??</span> <span class="string">&quot;(empty)&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It&#x27;s a label, text: <span class="subst">\(text)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入 <code>UILabel</code> 将会调用专门针对 <code>label</code> 的重载，而传入其他的视图将会调用到泛型函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> label <span class="operator">=</span> <span class="type">UILabel</span>(frame: <span class="type">CGRect</span>(x: <span class="number">20</span>, y: <span class="number">20</span>, width: <span class="number">200</span>, height: <span class="number">32</span>))</span><br><span class="line">label.text <span class="operator">=</span> <span class="string">&quot;Password&quot;</span></span><br><span class="line">log(label) <span class="comment">// It&#x27;s a label, text: Password</span></span><br><span class="line"><span class="keyword">let</span> button <span class="operator">=</span> <span class="type">UIButton</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">100</span>, height: <span class="number">50</span>))</span><br><span class="line">log(button) <span class="comment">// It&#x27;s a UIButton, frame: (0.0, 0.0, 100.0, 50.0)</span></span><br></pre></td></tr></table></figure>

<p><strong>要特别注意，重载的使用是在编译期间静态决定的。也就是说，编译器会依据变量的静态类型来决定要调用哪一个重载，而不是在运行时根据值的动态类型来决定。</strong>我们如果将上面的 <code>label</code> 和 <code>button</code> 都放到一个 <code>UIView</code> 数组中，并对它们迭代并调用 <code>log</code> 的话，使用的都是泛型重载的版本：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> views <span class="operator">=</span> [label, button] <span class="comment">// Type of views is [UIView]</span></span><br><span class="line"><span class="keyword">for</span> view <span class="keyword">in</span> views &#123;</span><br><span class="line">    log(view)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> It&#x27;s a UILabel, frame: (20.0, 20.0, 200.0, 32.0)</span></span><br><span class="line"><span class="comment"> It&#x27;s a UIButton, frame: (0.0, 0.0, 100.0, 50.0)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><code>view</code> 的静态类型是 <code>UIView</code>，<code>UILabel</code> 本来应该使用更专门的另一个重载，但是因为重载并不会考虑运行时的动态类型，所以两者都使用了 <code>UIView</code> 的泛型重载。</p>
<h4 id="运算符的重载"><a href="#运算符的重载" class="headerlink" title="运算符的重载"></a>运算符的重载</h4><p>当使用操作符重载时，编译器会表现出一些奇怪的行为。Matt Gallagher 指出，即使泛型版本应该是更好的选择（而且应该在一个普通函数调用时被选择）的时候，类型检查器也还是会去选择那些非泛型的重载，而不去选择泛型重载。</p>
<p>我们来看一个幂运算的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 幂运算比乘法运算优先级更高</span></span><br><span class="line"><span class="keyword">precedencegroup</span> <span class="title">ExponentiationPrecedence</span> &#123;</span><br><span class="line">    <span class="keyword">associativity</span>: <span class="keyword">left</span></span><br><span class="line">    <span class="keyword">higherThan</span>: <span class="type">MultiplicationPrecedence</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">**</span>: <span class="type">ExponentiationPrecedence</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">**</span>(<span class="params">lhs</span>: <span class="type">Double</span>, <span class="params">rhs</span>: <span class="type">Double</span>) -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pow(lhs, rhs)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">**</span>(<span class="params">lhs</span>: <span class="type">Float</span>, <span class="params">rhs</span>: <span class="type">Float</span>) -&gt; <span class="type">Float</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> powf(lhs, rhs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们添加一个整数的重载，让它对所有的整数类型有效，这里我们对所有满足 <code>BinaryInteger</code> 的类型定义了一个重载。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">**&lt;</span><span class="type">I</span>: <span class="type">BinaryInteger</span><span class="operator">&gt;</span>(lhs: <span class="type">I</span>, rhs: <span class="type">I</span>) -&gt; <span class="type">I</span> &#123;</span><br><span class="line">    <span class="comment">// 转换为 Int64，使用 Double 的重载计算结果</span></span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> <span class="type">Double</span>(<span class="type">Int64</span>(lhs)) <span class="operator">**</span> <span class="type">Double</span>(<span class="type">Int64</span>(rhs))</span><br><span class="line">    <span class="keyword">return</span> <span class="type">I</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的泛型看起来没什么问题，但是在我们使用整型调用 <code>**</code> 的时候，<strong>编译器会报错说 <code>**</code> 存在歧义</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="operator">**</span> <span class="number">3</span> <span class="comment">// 错误：操作符 &#x27;**&#x27; 的使用存在歧义。</span></span><br></pre></td></tr></table></figure>

<p><strong>要解释原因，我们需要回到我们在本节一开头说道的：对于重载的运算符，类型检查器会去使用非泛型版本的重载，而不考虑泛型版本。显然，编译器忽略了整数的泛型重载，因此它无法确定是去调用 <code>Double</code> 的重载还是 <code>Float</code> 的重载，因为两者对于整数字面量输入来说，是相同优先级的可选项（Swift 编译器会将整数字面量在需要时自动向上转换为 <code>Double</code> 或者 <code>Float</code> ），所以编译器报错说存在歧义。要让编译器选择正确的重载，我们需要至少将一个参数显式地声明为整数类型，或者明确提供返回值的类型：</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> intResult: <span class="type">Int</span> <span class="operator">=</span> <span class="number">2</span> <span class="operator">**</span> <span class="number">3</span> <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<h4 id="使用泛型约束进行重载"><a href="#使用泛型约束进行重载" class="headerlink" title="使用泛型约束进行重载"></a>使用泛型约束进行重载</h4><p><strong>当你在写一些可以被用多种算法表达的同样的操作，并且算法对它们的泛型参数又有不同的要求的代码的时候，你可能经常会遇到带有泛型代码的重载。假设我们要写一个算法，来确定一个数组中的所有元素是不是都被包含在另一个数组中。换句话说，我们想要知道第一个数组是不是第二个数组的子集 (这里元素的顺序不重要)。标准库中提供了一个叫做 <code>isSubset(of:)</code> 的方法，不过这个方法只适用于像 <code>Set</code> 这样满足 <code>SetAlgebra</code> 协议的类型。</strong></p>
<p>我们可以写一个适用于更宽广范围的 <code>isSubset(of:)</code>，它看起来可能是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Sequence</span> <span class="keyword">where</span> <span class="type">Element</span>: <span class="type">Equatable</span> &#123;</span><br><span class="line">    <span class="comment">/// 当且仅当 `self` 中的所有元素都包含在 `other` 中，返回 true</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">isSubset</span>(<span class="params">of</span> <span class="params">other</span>: [<span class="type">Element</span>]) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> other.contains(element) <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> oneToThree <span class="operator">=</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> fiveToOne <span class="operator">=</span> [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">oneToThree.isSubset(of: fiveToOne) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这个 <code>isSubset</code> 的版本有一个重大缺陷，那就是性能。这里的算法的时间复杂度是 O(nm)，其中 n 和 m 分别代表两个数组的元素个数。也就是说，随着输入的增多，这个函数的最坏情况的耗时将成平方增加。这是因为 <code>contains</code> 在数组中的复杂度是线性的 O(m)，这个函数会迭代源序列中的元素，逐个检查它是够匹配给定的元素。而 <code>contains</code> 是在另一个迭代最初数组的元素的循环中被调用了，这个循环也很类似，是一个线性时间复杂度的循环。所以我们是在一个 O(n) 循环里执行了一个 O(m) 的循环，结果这个函数的复杂度就是 O(nm)。</p>
<p>我们可以通过要求元素满足 <code>Hashable</code> 来收紧序列元素类型的限制来写出性能更好的版本。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Sequence</span> <span class="keyword">where</span> <span class="type">Element</span>: <span class="type">Hashable</span> &#123;</span><br><span class="line">    <span class="comment">/// 如果 `self` 中的所有元素都包含在 `other` 中，则返回 true</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">isSubset</span>(<span class="params">of</span> <span class="params">other</span>: [<span class="type">Element</span>]) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> otherSet <span class="operator">=</span> <span class="type">Set</span>(other)</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> otherSet.contains(element) <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样查找操作就可以在常数时间内进行了。</p>
<p>类型检查器会使用它所能找到的最精确的重载。这里 <code>isSubset</code> 的两个版本都是泛型函数，所以非泛型函数先于泛型函数的规则并不适用。不过因为 <code>Hashable</code> 是对 <code>Equatable</code> 的扩展，所以要求 <code>Hashable</code> 的版本更加精确。有了这些约束，我们可能可以像例子中的 <code>isSubset</code> 这样写出更加高效的算法，所以编译器假设更加具体的函数会是更好的选择。</p>
<p><code>isSubset</code> 还可以更加通用，到现在位置，它只接受一个数组并对其检查。但是 <code>Array</code> 是一个具体的类型。实际上 <code>isSubset</code> 并不需要这么具体，在两个版本中只有两个函数调用，那就是两者中都有的 <code>contains</code> 以及 <code>Hashable</code> 版本中的 <code>Set.init</code>。这两种情况下，这些函数只要求输入类型满足 <code>Sequence</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Sequence</span> <span class="keyword">where</span> <span class="type">Element</span>: <span class="type">Equatable</span> &#123;</span><br><span class="line">    <span class="comment">/// 根据序列是否包含给定元素返回一个布尔值。</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">contains</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">Element</span>) -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Set</span>&lt;<span class="type">Element</span>: <span class="type">Hashable</span>&gt;:</span><br><span class="line">    <span class="title class_ inherited__">SetAlgebra</span>, <span class="title class_ inherited__">Hashable</span>, <span class="title class_ inherited__">Collection</span>, <span class="title class_ inherited__">ExpressibleByArrayLiteral</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// 通过一个有限序列创建新的集合。</span></span><br><span class="line">    <span class="keyword">init</span>&lt;<span class="type">Source</span>: <span class="type">Sequence</span>&gt;(<span class="keyword">_</span> <span class="params">sequence</span>: <span class="type">Source</span>)</span><br><span class="line">    <span class="keyword">where</span> <span class="type">Source</span>.<span class="type">Element</span> <span class="operator">==</span> <span class="type">Element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，<code>isSubset</code> 中 <code>other</code> 只需要是遵守 <code>Sequence</code> 的任意类型就可以了。另外，<code>self</code> 和 <code>other</code> 这两个序列类型并不需要是同样的类型。我们只需要其中的元素类型相同就能进行操作。下面是针对任意两种序列重写的 <code>Hashable</code> 版本的函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Sequence</span> <span class="keyword">where</span> <span class="type">Element</span>: <span class="type">Hashable</span> &#123;</span><br><span class="line">    <span class="comment">/// 如果 `self` 中的所有元素都包含在 `other` 中，则返回 true</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">isSubset</span>&lt;<span class="type">S</span>: <span class="type">Sequence</span>&gt;(<span class="params">of</span> <span class="params">other</span>: <span class="type">S</span>) -&gt; <span class="type">Bool</span></span><br><span class="line">        <span class="keyword">where</span> <span class="type">S</span>.<span class="type">Element</span> <span class="operator">==</span> <span class="type">Element</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> otherSet <span class="operator">=</span> <span class="type">Set</span>(other)</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> otherSet.contains(element) <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在两个序列不需要有相同的类型了，这为我们开启了更多的可能性。比如，你可以传入一个数字的 <code>CountableRange</code> 来进行检查：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>].isSubset(of: <span class="number">1</span><span class="operator">...</span><span class="number">10</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>我们可以对可判等的元素的函数作出同样的更改。</p>
<h4 id="使用闭包对行为进行参数化"><a href="#使用闭包对行为进行参数化" class="headerlink" title="使用闭包对行为进行参数化"></a>使用闭包对行为进行参数化</h4><p>使用闭包对行为参数化，指的就是闭包表达式，类似于 <code>Array</code> 的 <code>map</code> ，<code>filter</code> ，<code>reduce</code> 这些函数。 我们的 <code>isSubset</code> 函数还有更加通用化的可能，对于那些不遵循 <code>Equatable</code> 的序列要怎么办？比如 <code>Array</code> 的元素也是 <code>Array</code> 的时候，本身 <code>Array</code> 无法遵循 <code>Equatable</code> ，因为 <code>Array</code> 元素本身就可能不能判等。</p>
<p>遇到这种情况的时候，我们可以将判等的工作交给调用者去实现，使用闭包。标准库中的 <code>contains</code> 函数就是一个很好的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Sequence</span> &#123;</span><br><span class="line">    <span class="comment">/// 根据序列是否包含满足给定断言的元素，返回一个布尔值。</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">contains</span>(<span class="params">where</span> <span class="params">predicate</span>: (<span class="type">Element</span>) <span class="keyword">throws</span> -&gt; <span class="type">Bool</span>)</span><br><span class="line">        <span class="keyword">rethrows</span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 <code>contains</code> 函数很强大，你可以用它来对一个序列进行各种条件的检查。用于我们的 <code>isSubset</code> 函数上后，就像下面这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Sequence</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">isSubset</span>&lt;<span class="type">S</span>: <span class="type">Sequence</span>&gt;(<span class="params">of</span> <span class="params">other</span>: <span class="type">S</span>,</span><br><span class="line">                               <span class="params">by</span> <span class="params">areEquivalent</span>: (<span class="type">Element</span>, <span class="type">S</span>.<span class="type">Element</span>) -&gt; <span class="type">Bool</span>)</span><br><span class="line">        -&gt; <span class="type">Bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> other.contains(where: &#123; areEquivalent(element, <span class="variable">$0</span>) &#125;) <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们可以将 <code>isSubset</code> 用在数组的数组上了，只需要为它提供一个闭包表达式，并使用 <code>==</code> 来对数组进行比较。<strong>不幸的是，如果我们导入了 <code>Foundation</code>，另一个对类型检查器的性能优化将会导致编译器不再确定到底应该使用哪个 <code>==</code>，从而使编译发生错误。我们需要在代码的某个地方加上类型标注：</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[[<span class="number">1</span>,<span class="number">2</span>]].isSubset(of: [[<span class="number">1</span>,<span class="number">2</span>] <span class="keyword">as</span> [<span class="type">Int</span>], [<span class="number">3</span>,<span class="number">4</span>]]) &#123; <span class="variable">$0</span> <span class="operator">==</span> <span class="variable">$1</span> &#125; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="对集合采用泛型操作"><a href="#对集合采用泛型操作" class="headerlink" title="对集合采用泛型操作"></a>对集合采用泛型操作</h3><hr>
<p>集合上的泛型算法通常会带出一些特殊的问题，特别在与索引和切片一起使用时更是如此。在这节中，我们通过两个依赖于正确处理索引和切片的例子，来看看如何解决这些问题。</p>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>说到二分查找，相信大家都会马上想起自己写的最简单的二分查找法。例如下面这个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span> &#123;</span><br><span class="line">    <span class="comment">/// 返回 `value` 第一次出现在 `self` 中的索引值，</span></span><br><span class="line">    <span class="comment">/// 如果 `value` 不存在，返回 `nil`</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - 要求: `isOrderedBefore` 是在 `self` 中元素上</span></span><br><span class="line">    <span class="comment">/// 的严格弱序，且数组中的元素已经按它进行过排序</span></span><br><span class="line">    <span class="comment">/// - 复杂度: O(log `count`)</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">binarySearch</span>(<span class="params">for</span> <span class="params">value</span>: <span class="type">Element</span>,</span><br><span class="line">                      <span class="params">areInIncreasingOrder</span>: (<span class="type">Element</span>, <span class="type">Element</span>) -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Int</span>?</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> left <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> right <span class="operator">=</span> count <span class="operator">-</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left <span class="operator">&lt;=</span> right &#123;</span><br><span class="line">            <span class="keyword">let</span> mid <span class="operator">=</span> (left <span class="operator">+</span> right) <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">            <span class="keyword">let</span> candidate <span class="operator">=</span> <span class="keyword">self</span>[mid]</span><br><span class="line">            <span class="keyword">if</span> areInIncreasingOrder(candidate,value) &#123;</span><br><span class="line">                left <span class="operator">=</span> mid <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> areInIncreasingOrder(value,candidate) &#123;</span><br><span class="line">                right <span class="operator">=</span> mid <span class="operator">-</span> <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 由于 isOrderedBefore 的要求，如果两个元素互无顺序关系，那么它们一定相等</span></span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span> <span class="keyword">where</span> <span class="type">Element</span>: <span class="type">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">binarySearch</span>(<span class="params">for</span> <span class="params">value</span>: <span class="type">Element</span>) -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.binarySearch(for: value, areInIncreasingOrder: <span class="operator">&lt;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个简单的二分查找算法，其实有一个 Bug。</p>
<blockquote>
<p>在数组非常大的情况下，将两个索引值相加有可能会造成溢出 (比如 <code>count</code> 很接近 <code>Int.max</code>，并且要搜索的元素是数组最后一个元素时的情况)。不过，将距离的一半加到左侧索引时，这个问题就不会发生。当然了，想要触发这个 bug 的机会其实很小。  </p>
</blockquote>
<p>现在我们来改善一下既有的算法设计，以前二分查找算法都是基于普通数组的，但是在 Swift 中，有一些特殊的数组，像是 <code>ArraySlice</code> ，上面的算法是无法直接在 <code>ArraySlice</code> 数组中运行的，当我们在计算中间下标的时候，会出现一个 Bug，因为 <code>ArraySlice</code> 的下标并不一定是从 0 开始。所以我们定义二分查找算法的时候，不能定义在普通的数组 <code>Array</code> 上，我们应该定义在 <code>RandomAccessCollection</code>。</p>
<h4 id="泛型二分查找"><a href="#泛型二分查找" class="headerlink" title="泛型二分查找"></a>泛型二分查找</h4><p>如果你把 Int 索引的要求去掉，将会发生一些编译错误。原来的代码需要进行一些重写才能完全满足泛型的要求。下面是完全泛型化之后的版本：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">RandomAccessCollection</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">binarySearch</span>(<span class="params">for</span> <span class="params">value</span>: <span class="type">Element</span>, <span class="params">areInIncreasingOrder</span>: (<span class="type">Element</span>, <span class="type">Element</span>) -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Index</span>? &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="operator">!</span>isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> left <span class="operator">=</span> startIndex</span><br><span class="line">        <span class="keyword">var</span> right <span class="operator">=</span> index(before: endIndex)</span><br><span class="line">        <span class="keyword">while</span> left <span class="operator">&lt;=</span> right &#123;</span><br><span class="line">            <span class="keyword">let</span> dist <span class="operator">=</span> distance(from: left, to: right)</span><br><span class="line">            <span class="keyword">let</span> mid <span class="operator">=</span> index(left, offsetBy: dist <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">let</span> candidate <span class="operator">=</span> <span class="keyword">self</span>[mid]</span><br><span class="line">            <span class="keyword">if</span> areInIncreasingOrder(candidate, value) &#123;</span><br><span class="line">                left <span class="operator">=</span> index(after: mid)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> areInIncreasingOrder(value, candidate) &#123;</span><br><span class="line">                right <span class="operator">=</span> index(before: mid)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">RandomAccessCollection</span> <span class="keyword">where</span> <span class="type">Element</span>: <span class="type">Comparable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">binarySearch</span>(<span class="params">for</span> <span class="params">value</span>: <span class="type">Element</span>) -&gt; <span class="type">Index</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(for: value, areInIncreasingOrder: <span class="operator">&lt;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strAry <span class="operator">=</span> [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>, <span class="string">&quot;g&quot;</span>]</span><br><span class="line">strAry.binarySearch(for: <span class="string">&quot;d&quot;</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ArraySlice 并不一定是从下标为 0 开始</span></span><br><span class="line"><span class="keyword">let</span> subStrAry <span class="operator">=</span> strAry[<span class="number">3</span><span class="operator">..&lt;</span><span class="number">5</span>] <span class="comment">// [&quot;d&quot;, &quot;e&quot;]</span></span><br><span class="line">subStrAry.binarySearch(for: <span class="string">&quot;d&quot;</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>改动虽小，意义重大。首先，<code>left</code> 和 <code>right</code> 变量现在不再是整数类型了。我们使用了起始索引和结束索引值。这些值可能是整数，但它们也可能是像是 <code>String</code> 的索引，<code>Dictionary</code> 的索引，或者是 <code>Set</code> 的索引这样的非透明索引，它们是无法随机访问的。</p>
<h3 id="使用泛型进行代码设计"><a href="#使用泛型进行代码设计" class="headerlink" title="使用泛型进行代码设计"></a>使用泛型进行代码设计</h3><hr>
<p>让我们来写一些与网络服务交互的函数。比如，获取用户列表的数据，并将它解析为 <code>User</code> 数据类型。我们创建一个 <code>loadUsers</code> 函数，它可以从网上异步加载用户，并且在完成后通过一个回调来传递获取到的用户列表。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">loadUsers</span>(<span class="params">callback</span>: ([<span class="type">User</span>]<span class="operator">?</span>) -&gt; ()) &#123;</span><br><span class="line">    <span class="keyword">let</span> usersURL <span class="operator">=</span> webserviceURL.appendingPathComponent(<span class="string">&quot;/users&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> data <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">Data</span>(contentsOf: usersURL)</span><br><span class="line">    <span class="keyword">let</span> json <span class="operator">=</span> data.flatMap &#123;</span><br><span class="line">        <span class="keyword">try?</span> <span class="type">JSONSerialization</span>.jsonObject(with: <span class="variable">$0</span>, options: [])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> users <span class="operator">=</span> (json <span class="keyword">as?</span> [<span class="keyword">Any</span>]).flatMap &#123; jsonObject <span class="keyword">in</span></span><br><span class="line">        jsonObject.flatMap(<span class="type">User</span>.<span class="keyword">init</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    callback(users)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数有个严重的问题，代码的重用性非常差，如果我们想要写一个相同的函数来加载其他资源，我们可能需要复制这里的大部分代码。打个比方，我们需要一个加载博客文章的函数，它看起来是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">loadBlogPosts</span>(<span class="params">callback</span>: ([<span class="type">BlogPost</span>])<span class="operator">?</span> -&gt; ())</span><br></pre></td></tr></table></figure>

<h4 id="提取共通功能"><a href="#提取共通功能" class="headerlink" title="提取共通功能"></a>提取共通功能</h4><p>相比于复制粘贴，将函数中 User 相关的部分提取出来，将其他部分进行重用，会是更好的方式。我们可以将 URL 路径和解析转换的函数作为参数传入。因为我们希望可以传入不同的转换函数，所以我们将 loadResource 声明为 A 的泛型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">loadResource</span>&lt;<span class="type">A</span>&gt;(<span class="params">at</span> <span class="params">path</span>: <span class="type">String</span>,</span><br><span class="line">                     <span class="params">parse</span>: (<span class="keyword">Any</span>) -&gt; <span class="type">A</span>?, <span class="params">callback</span>: (<span class="type">A</span>?) -&gt; ())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> resourceURL <span class="operator">=</span> webserviceURL.appendingPathComponent(path)</span><br><span class="line">    <span class="keyword">let</span> data <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">Data</span>(contentsOf: resourceURL)</span><br><span class="line">    <span class="keyword">let</span> json <span class="operator">=</span> data.flatMap &#123;</span><br><span class="line">        <span class="keyword">try?</span> <span class="type">JSONSerialization</span>.jsonObject(with: <span class="variable">$0</span>, options: [])</span><br><span class="line">    &#125;</span><br><span class="line">    callback(json.flatMap(parse))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们可以将 <code>loadUsers</code> 函数基于 <code>loadResource</code> 重写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">loadUsers</span>(<span class="params">callback</span>: ([<span class="type">User</span>]<span class="operator">?</span>) -&gt; ()) &#123;</span><br><span class="line">    loadResource(at: <span class="string">&quot;/users&quot;</span>, parse: jsonArray(<span class="type">User</span>.<span class="keyword">init</span>), callback: callback)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用了一个辅助函数，<code>jsonArray</code>，它首先尝试将一个 <code>Any</code> 转换为一个 <code>Any</code> 的数组，接着对每个元素用提供的解析函数进行解析，如果期间任何一步发生了错误，则返回 <code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">jsonArray</span>&lt;<span class="type">A</span>&gt;(<span class="keyword">_</span> <span class="params">transform</span>: <span class="keyword">@escaping</span> (<span class="keyword">Any</span>) -&gt; <span class="type">A</span>?) -&gt; (<span class="keyword">Any</span>) -&gt; [<span class="type">A</span>]<span class="operator">?</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; array <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> array <span class="operator">=</span> array <span class="keyword">as?</span> [<span class="keyword">Any</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array.flatMap(transform)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于加载博客文章的函数，我们只需要替换请求路径和解析函数就行了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">loadBlogPosts</span>(<span class="params">callback</span>: ([<span class="type">BlogPost</span>]<span class="operator">?</span>) -&gt; ()) &#123;</span><br><span class="line">    loadResource(at: <span class="string">&quot;/posts&quot;</span>, parse: jsonArray(<span class="type">BlogPost</span>.<span class="keyword">init</span>), callback: callback)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建泛型数据类型"><a href="#创建泛型数据类型" class="headerlink" title="创建泛型数据类型"></a>创建泛型数据类型</h4><p><code>loadResource</code> 函数中的 <code>path</code> 和 <code>parse</code> 耦合非常紧密，一旦你改变了其中一个，你很可能也需要改变另一个。我们可以将它们打包进一个结构体中，用来描述要加载的资源。和函数一样，这个结构体也可以是泛型的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Resource</span>&lt;<span class="type">A</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> path: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> parse: (<span class="keyword">Any</span>) -&gt; <span class="type">A</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">loadSynchronously</span>(<span class="params">callback</span>: (<span class="type">A</span>?) -&gt; ()) &#123;</span><br><span class="line">        <span class="keyword">let</span> resourceURL <span class="operator">=</span> webserviceURL.appendingPathComponent(path)</span><br><span class="line">        <span class="keyword">let</span> data <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">Data</span>(contentsOf: resourceURL)</span><br><span class="line">        <span class="keyword">let</span> json <span class="operator">=</span> data.flatMap &#123;</span><br><span class="line">            <span class="keyword">try?</span> <span class="type">JSONSerialization</span>.jsonObject(with: <span class="variable">$0</span>, options: [])</span><br><span class="line">        &#125;</span><br><span class="line">        callback(json.flatMap(parse))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">loadAsynchronously</span>(<span class="params">callback</span>: <span class="keyword">@escaping</span> (<span class="type">A</span>?) -&gt; ()) &#123;</span><br><span class="line">        <span class="keyword">let</span> resourceURL <span class="operator">=</span> webserviceURL.appendingPathComponent(path)</span><br><span class="line">        <span class="keyword">let</span> session <span class="operator">=</span> <span class="type">URLSession</span>.shared</span><br><span class="line">        session.dataTask(with: resourceURL) &#123; data, response, error <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> json <span class="operator">=</span> data.flatMap &#123;</span><br><span class="line">                <span class="keyword">try?</span> <span class="type">JSONSerialization</span>.jsonObject(with: <span class="variable">$0</span>, options: [])</span><br><span class="line">            &#125;</span><br><span class="line">            callback(json.flatMap(<span class="keyword">self</span>.parse))</span><br><span class="line">            &#125;.resume()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于之前的用顶层函数来定义资源，我们现在可以定义 <code>Resource</code> 结构体实例，这让我们可以很容易地添加新的资源，而不必创建新的函数。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>多任务卡片动画实现原理</title>
    <url>/2018/04/04/20180404-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%A1%E7%89%87%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><hr>
<p><img src="/my_pictures/20180404/1.gif"></p>
<h3 id="控件-—-UICollectionView"><a href="#控件-—-UICollectionView" class="headerlink" title="控件 — UICollectionView"></a>控件 — UICollectionView</h3><hr>
<p>这个动画是用 <code>UICollectionView</code> 实现的，简单讲下 <code>UICollectionView</code> 的工作原理。这里用到的 <code>UICollectionView</code> 也就3部分：<code>ViewController</code>（简称VC）、<code>UICollectionViewCell</code>、<code>UICollectionViewLayout</code>。</p>
<ol>
<li><p><code>ViewController</code> ：<br>在VC里，<code>UICollectionView</code> 的用法跟 <code>UITableView</code> 的用法类似。这里的初始化方法与 <code>UITableview</code> 有所不同，多了个 <code>collectionViewLayout</code> 属性，每个 <code>collectionView</code> 都会绑定一个 <code>UICollectionViewLayout</code> 对象， <code>collectionView</code> 根据这个 <code>layout</code> 对象来布局 <code>cell</code> 。</p>
</li>
<li><p><code>UICollectionViewCell</code> ：<br>这里用的 <code>Cell</code> 实现起来和 <code>UITableViewCell</code> 没什么大区别，我们只要实现它的 <code>initwithFrame</code> 的初始化方法即可，然后实现你想要的布局。</p>
</li>
</ol>
<span id="more"></span>

<ol start="3">
<li><code>UICollectionViewLayout</code> ：<br><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL3JlZmVyZW5jZS91aWtpdC91aWNvbGxlY3Rpb252aWV3bGF5b3V0">UICollectionViewLayout<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<p><code>UICollectionViewLayout</code> 是让 <code>UICollectionView</code> 千变万化的精髓所在，所以上面的动画的重点也就是在 <code>layout</code> 里实现的。<br>系统提供了一个 <code>UICollectionViewFlowLayout</code> ，是一个流式布局，可以通过设置 <code>scrollDirection</code> 来指定滚动方向，如果这个系统提供的布局不能满足我们的需求，那我们就要自己实现一个 <code>UICollectionViewLayout </code> 的子类来达到我们想要的效果了，接下来说下自定义的 <code>layout</code> 需要重写哪几个方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当layout第一次展示时调用，显式或隐式地调用invalidatedlayout也会调用prepareLayout，During each layout update, the collection view calls this method first to give your layout object a chance to prepare for the upcoming layout operation</span></span><br><span class="line">- (<span class="type">void</span>)prepareLayout；</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回collectionView的contentSize，来决定collectionView的滚动范围</span></span><br><span class="line">- (CGSize)collectionViewContentSize；</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns the content offset to use after an animated layout update or change。如果你的动画有两个layout的切换，那么这个方法至关重要，用它来返回一个目标contentOffset，能保证动画的正常表现。</span></span><br><span class="line">-(CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset；</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns the layout attributes for all of the cells and views in the specified rectangle.</span></span><br><span class="line">- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect；</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重中之重的方法，用来计算指定indexPath所对应的布局信息。这里的布局信息是一个UICollectionViewLayoutAttributes对象，我们可以通过frame、center、transform3D、transform来控制cell的表现状态。最后将这个attributes对象返回给上层使用。</span></span><br><span class="line">-(UICollectionViewLayoutAttributes*)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath；</span><br></pre></td></tr></table></figure>

<h3 id="动画实现细节"><a href="#动画实现细节" class="headerlink" title="动画实现细节"></a>动画实现细节</h3><hr>
<p>上面是关于 <code>UICollectionView</code> 的一些初步介绍，还有很多使用细节待君探索。接下来说下我们这个动画的实现细节吧。</p>
<p>上面的动画中，包括了位移、缩放、透明度三个方面的变化，我们先来谈谈重点的位移部分吧。</p>
<p>思路：动画的效果是，随着手指的滑动， <code>cell</code> 从上往下慢慢位移，位移的过程中速度越来越快；相反，如果往上滑动， <code>cell</code> 移动的速度就慢慢变小。这里的自变量是  <code>collectionView.contentOffset.y</code>（竖直方向），因变量是 <code>cell.center.y</code> （或者说 <code>cell.frame.origin.y</code> ），所以需要为他们之间找一个函数，这个函数需要满足上面的动画效果。</p>
<p>根据变化的规律，先确定一个初步的函数：</p>
<p><img src="/my_pictures/20180404/2.png"></p>
<p>它符合从小到大变化递增的特性，可以通过一些在线工具查看函数的图像来比较直观的看到函数的变化规律</p>
<p>可以看到这个函数是有两段的，那我们需要的只是左边这部分，因为当我们手指下滑的时候， <code>collectionView.contentOffset.y</code> 实际上是变小的，而 <code>cell.origin.y</code> 却是在变大的，所以左边半部分的变化正是我们想要的。</p>
<p>然而 </p>
<p><img src="/my_pictures/20180404/3.png"> </p>
<p>并不能满足要求，需要将它①向右拉伸m个点、②向上拉伸n个点，也就是要构造一个函数：</p>
<p><img src="/my_pictures/20180404/4.png"></p>
<p>这里解释一下m、n的值的含义。</p>
<p>将 </p>
<p><img src="/my_pictures/20180404/5.png"></p>
<p>做上述两步变化，m &#x3D; 600，n &#x3D; 500，生成如下函数</p>
<p><img src="/my_pictures/20180404/6.png"></p>
<p>函数与 x 轴交点是 (600,0)，与 y 轴交点是 (0,500)。<br>(0,500) 比较好理解，就是当 <code>collectionView.contentOffset.y</code> 等于 0 的时候， <code>cell</code> 对应的y坐标为 500。<br>(600,0) 也不难理解，就是当我们手指往上滑 600 个点，使 <code>collectionView.contentOffset.y=600</code> 时，这个时候 <code>cell.origin.y</code> 会等于 0。</p>
<h3 id="函数的具体应用"><a href="#函数的具体应用" class="headerlink" title="函数的具体应用"></a>函数的具体应用</h3><hr>
<h4 id="定义第-0-个-cell-的位移函数"><a href="#定义第-0-个-cell-的位移函数" class="headerlink" title="定义第 0 个 cell 的位移函数"></a>定义第 0 个 <code>cell</code> 的位移函数</h4><p>假设第 0 个 <code>cell</code>（简称 <code>cell0</code> ）对应函数的 m、n 分别为 n0 &#x3D; 250，m0 &#x3D; 1000，即当 <code>collectionView.contentOffset.y=0</code> 时， <code>cell0.origin.y=250</code> ；当我们往上滑1000个点， <code>collectionView.contentOffset.y=1000</code> 时， <code>cell0.origin.y=0</code> 。同理，<br><strong>ni 则表示当 <code>contentOffset.y=0</code> 时，第 i 个 <code>cell</code> 的 y 坐标。mi 则表示当 <code>contentOffset.y=mi</code> 时，第 i 个 <code>cell</code> 的 y 坐标为 0。</strong></p>
<p>所以对于第 0 个 <code>cell</code> ，我们可以给出一个函数来计算它的 y 坐标：</p>
<p><img src="/my_pictures/20180404/7.png"></p>
<p>这里 x 是指 <code>collectionView.contentOffset.y</code> ，y0 是指 <code>cell0.origin.y</code> ；</p>
<h4 id="生成第-i-个-cell-的位移函数"><a href="#生成第-i-个-cell-的位移函数" class="headerlink" title="生成第 i 个 cell 的位移函数"></a>生成第 i 个 cell 的位移函数</h4><p>定义了cell0 的位置函数，就可以以一定规律生成 cell1、cell2…… 的位置函数了，也就是生成每个cell 的 m、n 值。</p>
<h4 id="mi-的计算"><a href="#mi-的计算" class="headerlink" title="mi 的计算"></a>mi 的计算</h4><p><strong>我们可以定义，当手指往下滑动140个点时，第1个 cell 会运动到第2个 cell的位置</strong>，以此类推，每个 <code>cell</code> 会运动到下一个 <code>cell</code> 的位置。所以我们定义 $m_i&#x3D;m_{i-1}+140$ 也就是 $m_i&#x3D;m_0 + itimes140$; （ps:这里140决定了 cell 之间的间距，当然可以根据需求改变这个值来调整视觉效果）</p>
<h4 id="ni-的计算"><a href="#ni-的计算" class="headerlink" title="ni 的计算"></a>ni 的计算</h4><p>需要通过 $y_0&#x3D;((1000-x)&#x2F;1000)^4times250$ 来计算。我们知道，当 x&#x3D;0 时，$y_0&#x3D;n_0&#x3D;250$。在上一步计算时，我们定义了手指往下滑140时第0个 <code>cell</code> 会运动到第1个 <code>cell</code> 的位置，也就是说 <code>cell1</code> 的位置 $n_1$ 可以由 $y_0&#x3D;((1000-x)&#x2F;1000)^4times250$ 得到，**这里 x 的值应该是手指从 0 下滑140个点，也就是 <code>collectionView.contentOffset.y=-140</code> ，所以x&#x3D;(-140)**。（ps：往下滑动时 <code>contentOffset.y</code> 是递减的，所以这里的x是负的140。）所以</p>
<p><img src="/my_pictures/20180404/8.png"></p>
<p>同理，可以推出 ni 的公式：</p>
<p><img src="/my_pictures/20180404/9.png">、</p>
<h4 id="yi-的公式"><a href="#yi-的公式" class="headerlink" title="yi 的公式"></a>yi 的公式</h4><p>ok，mi 和ni 都可由 m0、n0 得到，那么 yi 的公式</p>
<p><img src="/my_pictures/20180404/10.png"></p>
<p>就可以转化成 m0 和 n0 的表达式，即</p>
<p><img src="/my_pictures/20180404/11.png"></p>
<p>虽然这个函数看起来挺长的，但是其中 m0和n0 都是我们定的初始值，140 也是我们定义的常量。变量 x 就是 <code>contentOffset.y</code> 。所以到此我们已经能根据手指的滑动，计算出每个 <code>cell</code> 的 y 坐标，从而实现了这个滚动动画。</p>
<h4 id="公式体现在下面的函数里"><a href="#公式体现在下面的函数里" class="headerlink" title="公式体现在下面的函数里"></a>公式体现在下面的函数里</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark -- 公式</span></span><br><span class="line"><span class="comment">//根据下标、当前偏移量来获取对应的y坐标</span></span><br><span class="line">-(CGFloat)getOriginYWithOffsetY:(CGFloat)offsetY row:(NSInteger)row</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 公式： y0 = ((m0 - x)/m0)^4*n0</span></span><br><span class="line">    <span class="comment">// 公式:  yi=((m0 + i*140-x)/(m0 + i*140))^4*((m0+140*i)/m0)^4*n0</span></span><br><span class="line">    CGFloat x = offsetY;    <span class="comment">//这里offsetY就是自变量x</span></span><br><span class="line">    CGFloat ni = [self defaultYWithRow:row];</span><br><span class="line">    CGFloat mi = self.m0+row*self.deltaOffsetY;</span><br><span class="line">    CGFloat tmp = mi - x;</span><br><span class="line">    tmp = fmaxf(<span class="number">0</span>, tmp);    <span class="comment">//不小于0</span></span><br><span class="line">    CGFloat y = powf((tmp)/mi, <span class="number">4</span>)*ni;</span><br><span class="line"><span class="comment">//    NSLog(@&quot;%d--y:%f &quot;,(int)row,y);</span></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当contentOffset.y=0时每个cell的y值</span></span><br><span class="line">-(CGFloat)defaultYWithRow:(NSInteger)row</span><br><span class="line">&#123;</span><br><span class="line">    CGFloat x0 = <span class="number">0</span>;     <span class="comment">//初始状态</span></span><br><span class="line">    CGFloat xi = x0 - self.deltaOffsetY*row;</span><br><span class="line">    CGFloat ni = powf((self.m0 - xi)/self.m0, <span class="number">4</span>)*self.n0;</span><br><span class="line"><span class="comment">//    NSLog(@&quot;defaultY-%d: %f&quot;,(int)row,ni);</span></span><br><span class="line">    <span class="keyword">return</span> ni;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转自"><a href="#转自" class="headerlink" title="转自"></a>转自</h3><ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5jb2RlNGFwcC5jb20vdGhyZWFkLTExOTcxLTEtMS5odG1s">仿多任务卡片动画<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>转帖</category>
      </categories>
      <tags>
        <tag>转帖日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 进阶【九】协议</title>
    <url>/2018/04/08/20180408-Swift%20%E8%BF%9B%E9%98%B6%E3%80%90%E4%B9%9D%E3%80%91%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>Swift 的协议和 Objective-C 的协议不同。<strong>Swift 协议可以被用作代理，也可以让你对接口进行抽象 (比如 <code>IteratorProtocol</code> 和 <code>Sequence</code> )。它们和 Objective-C 协议的最大不同在于我们可以让结构体和枚举类型满足协议。除此之外，Swift 协议还可以有关联类型。我们还可以通过协议扩展的方式为协议添加方法实现。</strong>我们会在面向协议编程的部分讨论所有这些内容。</p>
<p>协议允许我们进行动态派发，也就是说，在运行时程序会根据消息接收者的类型去选择正确的方法实现。</p>
<p>在面向对象编程中，子类是在多个类之间共享代码的有效方式。不过在 Swift 中，<code>Sequence</code> 中的代码共享是通过协议和协议扩展来实现的。通过这么做，<code>Sequence</code> 协议和它的扩展在结构体和枚举这样的值类型中依然可用，而这些值类型是不支持子类继承的。</p>
<p>协议扩展是一种可以在不共享基类的前提下共享代码的方法。协议定义了一组最小可行的方法集合，以供类型进行实现。而类型通过扩展的方式在这些最小方法上实现更多更复杂的特性。</p>
<span id="more"></span>

<h3 id="面向协议编程"><a href="#面向协议编程" class="headerlink" title="面向协议编程"></a>面向协议编程</h3><hr>
<p>比如在一个图形应用中，我们想要进行两种渲染：我们会将图形使用 <code>Core Graphics</code> 的 <code>CGContext</code> 渲染到屏幕上，或者创建一个 SVG 格式的图形文件。我们可以从定义绘图 API 的最小功能集的协议开始进行实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Drawing</span> &#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">addEllipse</span>(<span class="params">rect</span>: <span class="type">CGRect</span>, <span class="params">fill</span>: <span class="type">UIColor</span>)</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">addRectangle</span>(<span class="params">rect</span>: <span class="type">CGRect</span>, <span class="params">fill</span>: <span class="type">UIColor</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>协议的最强大的特性之一就是我们可以以追溯的方式来修改任意类型，让它们满足协议。对于 <code>CGContext</code>，我们可以添加扩展来让它满足 <code>Drawing</code> 协议。对于 <code>SVG</code> 我们一样可以通过扩展让它满足 <code>Drawing</code> 协议。</p>
<p>我们现在就可以写出独立于渲染目标的代码了；下面的代码只对 <code>context</code> 变量实现了 <code>Drawing</code> 协议进行了假设。如果我们决定使用 <code>CGContext</code> 来初始化一个 <code>context</code>，我们并不需要改变代码的任何部分：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> context: <span class="type">Drawing</span> <span class="operator">=</span> <span class="type">SVG</span>()</span><br><span class="line"><span class="keyword">let</span> rect1 <span class="operator">=</span> <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line"><span class="keyword">let</span> rect2 <span class="operator">=</span> <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">50</span>, height: <span class="number">50</span>)</span><br><span class="line">context.addRectangle(rect: rect1, fill: .yellow)</span><br><span class="line">context.addEllipse(rect: rect2, fill: .blue)</span><br><span class="line">context</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;svg&gt;</span></span><br><span class="line"><span class="comment">&lt;rect cy=&quot;0.0&quot; fill=&quot;#010100&quot; ry=&quot;100.0&quot; rx=&quot;100.0&quot; cx=&quot;0.0&quot;/&gt;</span></span><br><span class="line"><span class="comment">&lt;ellipse cy=&quot;0.0&quot; fill=&quot;#000001&quot; ry=&quot;50.0&quot; rx=&quot;50.0&quot; cx=&quot;0.0&quot;/&gt;</span></span><br><span class="line"><span class="comment">&lt;/svg&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="协议扩展"><a href="#协议扩展" class="headerlink" title="协议扩展"></a>协议扩展</h4><p>Swift 的协议的另一个强大特性是我们可以使用完整的方法实现来扩展一个协议。你可以扩展你自己的协议，也可以对已有协议进行扩展。</p>
<p>通过在扩展中添加 <code>addCircle</code>，我们就可以在 <code>CGContext</code> 和   中使用它了。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Drawing</span> &#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">addCircle</span>(<span class="params">center</span>: <span class="type">CGPoint</span>, <span class="params">radius</span>: <span class="type">CGFloat</span>, <span class="params">fill</span>: <span class="type">UIColor</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> diameter <span class="operator">=</span> radius <span class="operator">*</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">let</span> origin <span class="operator">=</span> <span class="type">CGPoint</span>(x: center.x <span class="operator">-</span> radius, y: center.y <span class="operator">-</span> radius)</span><br><span class="line">        <span class="keyword">let</span> size <span class="operator">=</span> <span class="type">CGSize</span>(width: diameter, height: diameter)</span><br><span class="line">        <span class="keyword">let</span> rect <span class="operator">=</span> <span class="type">CGRect</span>(origin: origin, size: size)</span><br><span class="line">        addEllipse(rect: rect, fill: fill)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过协议进行代码共享相比与通过继承的共享，有这几个优势：</strong></p>
<ul>
<li>我们不需要被强制使用某个父类。</li>
<li>我们可以让已经存在的类型满足协议 (比如我们让 <code>CGContext</code> 满足了 <code>Drawing</code> )。子类就没那么灵活了，如果 <code>CGContext</code> 是一个类的话，我们无法以追溯的方式去变更它的父类。</li>
<li>协议既可以用于类，也可以用于结构体，而父类就无法和结构体一起使用了。</li>
<li>最后，当处理协议时，我们无需担心方法重写或者在正确的时间调用 <code>super</code> 这样的问题。</li>
</ul>
<h4 id="在协议扩展中重写方法"><a href="#在协议扩展中重写方法" class="headerlink" title="在协议扩展中重写方法"></a>在协议扩展中重写方法</h4><p>作为协议的作者，当你想在扩展中添加一个协议方法，你有两种方法。首先，你可以只在扩展中进行添加，就像我们上面 <code>addCircle</code> 所做的那样。或者，你还可以在协议定义本身中添加这个方法的声明，让它成为协议要求的方法。协议要求的方法是动态派发的，而仅定义在扩展中的方法是静态派发的。它们的区别虽然很微小，但不论对于协议的作者还是协议的使用者来说，都十分重要。</p>
<p>首先，我们对 <code>SVG</code> 写一个 <code>addCircle</code> 扩展：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">SVG</span> &#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">addCircle</span>(<span class="params">center</span>: <span class="type">CGPoint</span>, <span class="params">radius</span>: <span class="type">CGFloat</span>, <span class="params">fill</span>: <span class="type">UIColor</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> attributes: [<span class="type">String</span>:<span class="type">String</span>] <span class="operator">=</span> [</span><br><span class="line">            <span class="string">&quot;cx&quot;</span>: <span class="string">&quot;<span class="subst">\(center.x)</span>&quot;</span>,</span><br><span class="line">            <span class="string">&quot;cy&quot;</span>: <span class="string">&quot;<span class="subst">\(center.y)</span>&quot;</span>,</span><br><span class="line">            <span class="string">&quot;r&quot;</span>: <span class="string">&quot;<span class="subst">\(radius)</span>&quot;</span>,</span><br><span class="line">        ]</span><br><span class="line">        attributes[<span class="string">&quot;fill&quot;</span>] <span class="operator">=</span> <span class="type">String</span>(hexColor: fill)</span><br><span class="line">        append(node: <span class="type">XMLNode</span>(tag: <span class="string">&quot;circle&quot;</span>, attributes: attributes))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在如果我们创建一个 <code>SVG</code> 实例并调用它的 <code>addCircle</code> 方法，结果将和你期待的一致：编译器将选择 <code>addCircle</code> 的最具体的版本，也就是定义在 <code>SVG</code> 扩展上的版本。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sample <span class="operator">=</span> <span class="type">SVG</span>()</span><br><span class="line">sample.addCircle(center: .zero, radius: <span class="number">20</span>, fill: .red)</span><br><span class="line"><span class="built_in">print</span>(sample)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> &lt;svg&gt;</span></span><br><span class="line"><span class="comment"> &lt;circle cy=&quot;0.0&quot; fill=&quot;#010000&quot; r=&quot;20.0&quot; cx=&quot;0.0&quot;/&gt;</span></span><br><span class="line"><span class="comment"> &lt;/svg&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>如果像下面这样调用的话，它并不会使用 <code>SVG</code> 的 <code>addCircle</code> 方法。它调用的是 <code>Drawing</code> 中的 <code>addCircle</code> 方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> otherSample: <span class="type">Drawing</span> <span class="operator">=</span> <span class="type">SVG</span>()</span><br><span class="line">otherSample.addCircle(center: .zero, radius: <span class="number">20</span>, fill: .red)</span><br><span class="line"><span class="built_in">print</span>(otherSample)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> &lt;svg&gt;</span></span><br><span class="line"><span class="comment"> &lt;ellipse cy=&quot;-20.0&quot; fill=&quot;#010000&quot; ry=&quot;40.0&quot; rx=&quot;40.0&quot; cx=&quot;-20.0&quot;/&gt;</span></span><br><span class="line"><span class="comment"> &lt;/svg&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>我们可以这样考虑这个行为：当我们对存在容器调用 <code>addCircle</code> 时，方法是静态派发的，也就是说，它总是会使用 <code>Drawing</code> 的扩展。如果它是动态派发，那么它肯定需要将方法的接收者 <code>SVG</code> 类型考虑在内。</p>
<p>想要将 <code>addCircle</code> 变为动态派发，我们可以将它添加到协议定义里：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Drawing</span> &#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">addEllipse</span>(<span class="params">rect</span>: <span class="type">CGRect</span>, <span class="params">fill</span>: <span class="type">UIColor</span>)</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">addRectangle</span>(<span class="params">rect</span>: <span class="type">CGRect</span>, <span class="params">fill</span>: <span class="type">UIColor</span>)</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">addCircle</span>(<span class="params">center</span>: <span class="type">CGPoint</span>, <span class="params">radius</span>: <span class="type">CGFloat</span>, <span class="params">fill</span>: <span class="type">UIColor</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="协议的两种类型"><a href="#协议的两种类型" class="headerlink" title="协议的两种类型"></a>协议的两种类型</h3><hr>
<p>带有关联类型的协议和普通的协议是不同的。对于那些在协议定义中在任何地方使用了 <code>Self</code> 的协议来说也是如此。Swift 3 中，这样的协议不能被当作独立的类型来使用。这个限制可能会在今后实现了完整的泛型系统后被移除，但是在那之前，我们都必须要面对和处理这个限制。</p>
<h4 id="类型抹消"><a href="#类型抹消" class="headerlink" title="类型抹消"></a>类型抹消</h4><p>我们可以将 <code>Drawing</code> 作为一个类型来使用。但是，对于 <code>IteratorProtocol</code> 来说，因为存在关联类型，这是不可能的 (至少现在还不可能)。编译器会给出这样的错误：“‘ <code>IteratorProtocol</code> ’ 协议含有 <code>Self</code> 或者关联类型，因此它只能被当作泛型约束使用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> iterator: <span class="type">IteratorProtocol</span> <span class="operator">=</span> <span class="type">ConstantIterator</span>() <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>这就是说，将 <code>IteratorProtocol</code> 是一个不完整的类型。我们必须为它指明关联类型，否则单是关联类型的协议是没有意义的。</p>
<blockquote>
<p>Swift 团队指出过他们想要支持泛用存在 (generalized existentials)。这个特性将允许那些含有关联类型的协议也可以被当作独立的值来使用，这样它们就可以用来进行类型抹消了。如果你想要了解未来这方面会如何发展，你可以在 <span class="exturl" data-url="aHR0cHM6Ly9saXN0cy5zd2lmdC5vcmcvcGlwZXJtYWlsL3N3aWZ0LWV2b2x1dGlvbi9XZWVrLW9mLU1vbi0yMDE2MDIyOS8wMTE2NjYuaHRtbA==">Swift 泛型声明<i class="fa fa-external-link-alt"></i></span>一文中找到详细信息。  </p>
</blockquote>
<h3 id="带有-Self-的协议"><a href="#带有-Self-的协议" class="headerlink" title="带有 Self 的协议"></a>带有 Self 的协议</h3><hr>
<p>带有 Self 要求的协议在行为上和那些带有关联类型的协议很相似。最简单的带有 Self 的协议是 <code>Equatable</code>。它有一个 (运算符形式的) 方法，用来比较两个元素：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">==</span>(<span class="params">lhs</span>: <span class="keyword">Self</span>, <span class="params">rhs</span>: <span class="keyword">Self</span>) -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要为你自己的类型实现 <code>Equatable</code> 并不难。比如，我们有两个简单的 <code>MonetaryAmount</code> 结构体，我们可以通过比较它们的属性值来比较两个值：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MonetaryAmount</span>: <span class="title class_ inherited__">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> currency: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> amountInCents: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">==</span>(<span class="params">lhs</span>: <span class="type">MonetaryAmount</span>, <span class="params">rhs</span>: <span class="type">MonetaryAmount</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.currency <span class="operator">==</span> rhs.currency <span class="operator">&amp;&amp;</span></span><br><span class="line">            lhs.amountInCents <span class="operator">==</span> rhs.amountInCents</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们不能简单地用 <code>Equatable</code> 来作为类型进行变量声明：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误：因为 &#x27;Equatable&#x27; 中有 Self 或者关联类型的要求，</span></span><br><span class="line"><span class="comment">// 所以它只能被用作泛型约束</span></span><br><span class="line"><span class="keyword">let</span> x: <span class="type">Equatable</span> <span class="operator">=</span> <span class="type">MonetaryAmount</span>(currency: <span class="string">&quot;EUR&quot;</span>, amountInCents: <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>这个关联类型所面临的问题是一样的：在这个 (不正确) 的声明中，我们并不清楚 Self 到底应该是什么。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift 文档：Error Handling</title>
    <url>/2018/04/09/20180409-RxSwift%20%E6%96%87%E6%A1%A3%EF%BC%9AError%20Handling/</url>
    <content><![CDATA[<h2 id="Error-Handling-错误处理"><a href="#Error-Handling-错误处理" class="headerlink" title="Error Handling - 错误处理"></a>Error Handling - 错误处理</h2><hr>
<p>一旦序列里面产出了一个 <code>error</code> 事件，整个序列将被终止。RxSwift 主要有两种错误处理机制：</p>
<ul>
<li>retry - 重试</li>
<li>catch - 恢复</li>
</ul>
<h4 id="retryWhen"><a href="#retryWhen" class="headerlink" title="retryWhen"></a>retryWhen</h4><p>如果请求 <code>JSON</code> 失败，我们需要等待5秒后进行重试操作，重试4次如果全部失败则抛出错误：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求 JSON 失败时，等待 5 秒后重试，</span></span><br><span class="line"><span class="comment">// 重试 4 次后仍然失败，就将错误抛出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> maxRetryCount <span class="operator">=</span> <span class="number">4</span>       <span class="comment">// 最多重试 4 次</span></span><br><span class="line"><span class="keyword">let</span> retryDelay: <span class="type">Double</span> <span class="operator">=</span> <span class="number">5</span>  <span class="comment">// 重试延时 5 秒</span></span><br><span class="line"></span><br><span class="line">rxJson</span><br><span class="line">    .retryWhen &#123; (rxError: <span class="type">Observable</span>&lt;<span class="type">Error</span>&gt;) -&gt; <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt; <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> rxError.flatMapWithIndex &#123; (error, index) -&gt; <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt; <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> index <span class="operator">&lt;</span> maxRetryCount <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="type">Observable</span>.error(error)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.timer(retryDelay, scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe(<span class="operator">...</span>)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>我们用 <code>flatMapWithIndex</code> 这个操作符，因为它可以给我们提供错误的索引数 <code>index</code>。然后用这个索引数判断是否超过最大重试数，如果超过了，就将错误抛出。如果没有超过，就等待 5 秒后重试。</p>
<h4 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h4><p>如果我们只是想给用户一个错误提示，我们可以自定义一个 <code>Result</code> 枚举来进行处理：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义一个枚举类型 Result</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Result</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">case</span> success(<span class="type">T</span>)</span><br><span class="line">    <span class="keyword">case</span> failure(<span class="type">Swift</span>.<span class="type">Error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如如下的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当用户点击更新按钮时，</span></span><br><span class="line"><span class="comment">// 就立即取出修改后的用户信息。</span></span><br><span class="line"><span class="comment">// 然后发起网络请求，进行更新操作，</span></span><br><span class="line"><span class="comment">// 一旦操作失败就提示用户失败原因</span></span><br><span class="line"></span><br><span class="line">updateUserInfoButton.rx.tap</span><br><span class="line">    .withLatestFrom(rxUserInfo)</span><br><span class="line">    .flatMapLatest &#123; userInfo -&gt; <span class="type">Observable</span>&lt;<span class="type">Void</span>&gt; <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> update(userInfo)</span><br><span class="line">    &#125;</span><br><span class="line">    .observeOn(<span class="type">MainScheduler</span>.instance)</span><br><span class="line">    .subscribe(onNext: &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;用户信息更新成功&quot;</span>)</span><br><span class="line">    &#125;, onError: &#123; error <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;用户信息更新失败： <span class="subst">\(error.localizedDescription)</span>&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<p>修改之后：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">updateUserInfoButton.rx.tap</span><br><span class="line">    .withLatestFrom(rxUserInfo)</span><br><span class="line">    .flatMapLatest &#123; userInfo -&gt; <span class="type">Observable</span>&lt;<span class="type">Result</span>&lt;<span class="type">Void</span>&gt;&gt; <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> update(userInfo)</span><br><span class="line">            .map(<span class="type">Result</span>.success)  <span class="comment">// 转换成 Result</span></span><br><span class="line">            .catchError &#123; error <span class="keyword">in</span> <span class="type">Observable</span>.just(<span class="type">Result</span>.failure(error)) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .observeOn(<span class="type">MainScheduler</span>.instance)</span><br><span class="line">    .subscribe(onNext: &#123; result <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">switch</span> result &#123;           <span class="comment">// 处理 Result</span></span><br><span class="line">        <span class="keyword">case</span> .success:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;用户信息更新成功&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;用户信息更新失败： <span class="subst">\(error.localizedDescription)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<p>这样我们的错误事件被包装成了 <code>Result.failure(Error)</code> 元素。</p>
]]></content>
      <categories>
        <category>响应式框架</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift 文档：Observable 和 Observer</title>
    <url>/2018/04/09/20180409-RxSwift%20%E6%96%87%E6%A1%A3%EF%BC%9AObservable%20%E5%92%8C%20Observer/</url>
    <content><![CDATA[<h2 id="Observer-观察者"><a href="#Observer-观察者" class="headerlink" title="Observer - 观察者"></a>Observer - 观察者</h2><hr>
<h3 id="AnyObserver"><a href="#AnyObserver" class="headerlink" title="AnyObserver"></a>AnyObserver</h3><hr>
<p><code>AnyObserver</code> 可以用来描叙任意一种观察者。</p>
<p>例如：</p>
<p>打印网络请求结果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">URLSession</span>.shared.rx.data(request: <span class="type">URLRequest</span>(url: url))</span><br><span class="line">    .subscribe(onNext: &#123; data <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Data Task Success with count: <span class="subst">\(data.count)</span>&quot;</span>)</span><br><span class="line">    &#125;, onError: &#123; error <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Data Task Error: <span class="subst">\(error)</span>&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>可以看作是：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer: <span class="type">AnyObserver</span>&lt;<span class="type">Data</span>&gt; <span class="operator">=</span> <span class="type">AnyObserver</span> &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> event &#123;</span><br><span class="line">    <span class="keyword">case</span> .next(<span class="keyword">let</span> data):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Data Task Success with count: <span class="subst">\(data.count)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Data Task Error: <span class="subst">\(error)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">URLSession</span>.shared.rx.data(request: <span class="type">URLRequest</span>(url: url))</span><br><span class="line">    .subscribe(observer)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<p>用户名提示语是否隐藏：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">usernameValid</span><br><span class="line">    .bind(to: usernameValidOutlet.rx.isHidden)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<p>可以看做是：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer: <span class="type">AnyObserver</span>&lt;<span class="type">Bool</span>&gt; <span class="operator">=</span> <span class="type">AnyObserver</span> &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (event) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> event &#123;</span><br><span class="line">    <span class="keyword">case</span> .next(<span class="keyword">let</span> isHidden):</span><br><span class="line">        <span class="keyword">self</span><span class="operator">?</span>.usernameValidOutlet.isHidden <span class="operator">=</span> isHidden</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">usernameValid</span><br><span class="line">    .bind(to: observer)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h3 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h3><hr>
<p><code>Binder</code> 主要有以下两个特征：</p>
<ul>
<li>不会处理错误事件</li>
<li>确保绑定都是在给定 <code>Scheduler</code> 上执行（默认 <code>MainScheduler</code>）</li>
</ul>
<p>一旦产生错误事件，在调试环境下将执行 <code>fatalError</code>，在发布环境下将打印错误信息。</p>
<p>在 <code>AnyObserver</code> 时，我们举了一个这样的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer: <span class="type">AnyObserver</span>&lt;<span class="type">Bool</span>&gt; <span class="operator">=</span> <span class="type">AnyObserver</span> &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (event) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> event &#123;</span><br><span class="line">    <span class="keyword">case</span> .next(<span class="keyword">let</span> isHidden):</span><br><span class="line">        <span class="keyword">self</span><span class="operator">?</span>.usernameValidOutlet.isHidden <span class="operator">=</span> isHidden</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">usernameValid</span><br><span class="line">    .bind(to: observer)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<p>由于这个观察者是一个 <strong>UI 观察者</strong>，所以它在响应事件时，只会处理 <code>next</code> 事件，并且更新 <code>UI</code> 的操作需要在主线程上执行。</p>
<p>因此一个更好的方案就是使用 <code>Binder</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer: <span class="type">Binder</span>&lt;<span class="type">Bool</span>&gt; <span class="operator">=</span> <span class="type">Binder</span>(usernameValidOutlet) &#123; (view, isHidden) <span class="keyword">in</span></span><br><span class="line">    view.isHidden <span class="operator">=</span> isHidden</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">usernameValid</span><br><span class="line">    .bind(to: observer)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h4 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h4><p>由于页面是否隐藏是一个常用的观察者，所以应该让所有的 <code>UIView</code> 都提供这种观察者：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Reactive</span> <span class="keyword">where</span> <span class="type">Base</span>: <span class="type">UIView</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isHidden: <span class="type">Binder</span>&lt;<span class="type">Bool</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Binder</span>(<span class="keyword">self</span>.base) &#123; view, hidden <span class="keyword">in</span></span><br><span class="line">            view.isHidden <span class="operator">=</span> hidden</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">usernameValid</span><br><span class="line">    .bind(to: usernameValidOutlet.rx.isHidden)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<p>这样你不必为每个 UI 控件单独创建该观察者。这就是 <code>usernameValidOutlet.rx.isHidden</code> 的由来，许多 <code>UI</code> 观察者 都是这样创建的：</p>
<ul>
<li>按钮是否可点击 <code>button.rx.isEnabled</code></li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Reactive</span> <span class="keyword">where</span> <span class="type">Base</span>: <span class="type">UIControl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isEnabled: <span class="type">Binder</span>&lt;<span class="type">Bool</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Binder</span>(<span class="keyword">self</span>.base) &#123; control, value <span class="keyword">in</span></span><br><span class="line">            control.isEnabled <span class="operator">=</span> value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>label</code> 的当前文本 <code>label.rx.text</code></li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Reactive</span> <span class="keyword">where</span> <span class="type">Base</span>: <span class="type">UILabel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> text: <span class="type">Binder</span>&lt;<span class="type">String</span>?&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Binder</span>(<span class="keyword">self</span>.base) &#123; label, text <span class="keyword">in</span></span><br><span class="line">            label.text <span class="operator">=</span> text</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Observable-Observer-既是可被监听的序列也是观察者"><a href="#Observable-Observer-既是可被监听的序列也是观察者" class="headerlink" title="Observable &amp; Observer 既是可被监听的序列也是观察者"></a>Observable &amp; Observer 既是可被监听的序列也是观察者</h2><hr>
<p>在我们所遇到的事物中，有一部分非常特别。它们既是可被监听的序列也是观察者。</p>
<h3 id="AsyncSubject"><a href="#AsyncSubject" class="headerlink" title="AsyncSubject"></a>AsyncSubject</h3><hr>
<p><code>AsyncSubject</code> 将在源 <code>Observable</code> 产生完成事件后，发出最后一个元素（仅仅只有最后一个元素），如果源 <code>Observable</code> 没有发出任何元素，只有一个完成事件。那 <code>AsyncSubject</code> 也只有一个完成事件。<br>它会对随后的观察者发出最终元素。如果源 <code>Observable</code> 因为产生了一个 <code>error</code> 事件而中止， <code>AsyncSubject</code> 就不会发出任何元素，而是将这个 <code>error</code> 事件发送出来。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag <span class="operator">=</span> <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="keyword">let</span> subject <span class="operator">=</span> <span class="type">AsyncSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"></span><br><span class="line">subject</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>(<span class="string">&quot;Subscription: 1 Event:&quot;</span>, <span class="variable">$0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">&quot;🐶&quot;</span>)</span><br><span class="line">subject.onNext(<span class="string">&quot;🐱&quot;</span>)</span><br><span class="line">subject.onNext(<span class="string">&quot;🐹&quot;</span>)</span><br><span class="line">subject.onCompleted()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🐹)</span></span><br><span class="line"><span class="comment">// Subscription: 1 Event: completed</span></span><br></pre></td></tr></table></figure>

<h3 id="PublishSubject"><a href="#PublishSubject" class="headerlink" title="PublishSubject"></a>PublishSubject</h3><hr>
<p><code>PublishSubject</code> 将对观察者发送订阅后产生的元素，而在订阅前发出的元素将不会发送给观察者。如果你希望观察者接收到所有的元素，你可以通过使用 <code>Observable</code> 的 <code>create</code> 方法来创建 <code>Observable</code>，或者使用 <code>ReplaySubject</code>。</p>
<p>如果源 <code>Observable</code> 因为产生了一个 <code>error</code> 事件而中止， <code>PublishSubject</code> 就不会发出任何元素，而是将这个 <code>error</code> 事件发送出来。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag <span class="operator">=</span> <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="keyword">let</span> subject <span class="operator">=</span> <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"></span><br><span class="line">subject</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>(<span class="string">&quot;Subscription: 1 Event:&quot;</span>, <span class="variable">$0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">&quot;🐶&quot;</span>)</span><br><span class="line">subject.onNext(<span class="string">&quot;🐱&quot;</span>)</span><br><span class="line"></span><br><span class="line">subject</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>(<span class="string">&quot;Subscription: 2 Event:&quot;</span>, <span class="variable">$0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">&quot;🅰️&quot;</span>)</span><br><span class="line">subject.onNext(<span class="string">&quot;🅱️&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🐶)</span></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🐱)</span></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🅰️)</span></span><br><span class="line"><span class="comment">// Subscription: 2 Event: next(🅰️)</span></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🅱️)</span></span><br><span class="line"><span class="comment">// Subscription: 2 Event: next(🅱️)</span></span><br></pre></td></tr></table></figure>

<h3 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h3><hr>
<p><code>ReplaySubject</code> 将对观察者发送全部的元素，无论观察者是何时进行订阅的。</p>
<p>这里存在多个版本的 <code>ReplaySubject</code>，有的只会将最新的 <code>n</code> 个元素发送给观察者，有的只会将限制时间段内最新的元素发送给观察者。</p>
<p>如果把 <code>ReplaySubject</code> 当作观察者来使用，注意不要在多个线程调用 <code>onNext</code>, <code>onError</code> 或 <code>onCompleted</code>。这样会导致无序调用，将造成意想不到的结果。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag <span class="operator">=</span> <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="keyword">let</span> subject <span class="operator">=</span> <span class="type">ReplaySubject</span>&lt;<span class="type">String</span>&gt;.create(bufferSize: <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">subject</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>(<span class="string">&quot;Subscription: 1 Event:&quot;</span>, <span class="variable">$0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">&quot;🐶&quot;</span>)</span><br><span class="line">subject.onNext(<span class="string">&quot;🐱&quot;</span>)</span><br><span class="line"></span><br><span class="line">subject</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>(<span class="string">&quot;Subscription: 2 Event:&quot;</span>, <span class="variable">$0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">&quot;🅰️&quot;</span>)</span><br><span class="line">subject.onNext(<span class="string">&quot;🅱️&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🐶)</span></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🐱)</span></span><br><span class="line"><span class="comment">// Subscription: 2 Event: next(🐱)</span></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🅰️)</span></span><br><span class="line"><span class="comment">// Subscription: 2 Event: next(🅰️)</span></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🅱️)</span></span><br><span class="line"><span class="comment">// Subscription: 2 Event: next(🅱️)</span></span><br></pre></td></tr></table></figure>

<h3 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h3><hr>
<p>当观察者对 <code>BehaviorSubject</code> 进行订阅时，它会将源 <code>Observable</code> 中最新的元素发送出来（如果不存在最新的元素，就发出默认元素）。然后将随后产生的元素发送出来。<br>如果源 <code>Observable</code> 因为产生了一个 <code>error</code> 事件而中止， <code>BehaviorSubject</code> 就不会发出任何元素，而是将这个 <code>error</code> 事件发送出来。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag <span class="operator">=</span> <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="keyword">let</span> subject <span class="operator">=</span> <span class="type">BehaviorSubject</span>(value: <span class="string">&quot;🔴&quot;</span>)</span><br><span class="line"></span><br><span class="line">subject</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>(<span class="string">&quot;Subscription: 1 Event:&quot;</span>, <span class="variable">$0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">&quot;🐶&quot;</span>)</span><br><span class="line">subject.onNext(<span class="string">&quot;🐱&quot;</span>)</span><br><span class="line"></span><br><span class="line">subject</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>(<span class="string">&quot;Subscription: 2 Event:&quot;</span>, <span class="variable">$0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">&quot;🅰️&quot;</span>)</span><br><span class="line">subject.onNext(<span class="string">&quot;🅱️&quot;</span>)</span><br><span class="line"></span><br><span class="line">subject</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>(<span class="string">&quot;Subscription: 3 Event:&quot;</span>, <span class="variable">$0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">&quot;🍐&quot;</span>)</span><br><span class="line">subject.onNext(<span class="string">&quot;🍊&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🔴)</span></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🐶)</span></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🐱)</span></span><br><span class="line"><span class="comment">// Subscription: 2 Event: next(🐱)</span></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🅰️)</span></span><br><span class="line"><span class="comment">// Subscription: 2 Event: next(🅰️)</span></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🅱️)</span></span><br><span class="line"><span class="comment">// Subscription: 2 Event: next(🅱️)</span></span><br><span class="line"><span class="comment">// Subscription: 3 Event: next(🅱️)</span></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🍐)</span></span><br><span class="line"><span class="comment">// Subscription: 2 Event: next(🍐)</span></span><br><span class="line"><span class="comment">// Subscription: 3 Event: next(🍐)</span></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🍊)</span></span><br><span class="line"><span class="comment">// Subscription: 2 Event: next(🍊)</span></span><br><span class="line"><span class="comment">// Subscription: 3 Event: next(🍊)</span></span><br></pre></td></tr></table></figure>

<h3 id="ControlProperty"><a href="#ControlProperty" class="headerlink" title="ControlProperty"></a>ControlProperty</h3><hr>
<p><code>ControlProperty</code> 专门用于描述 UI 控件属性的，它具有以下特征：</p>
<ul>
<li>不会产生 <code>error</code> 事件</li>
<li>一定在 <code>MainScheduler</code> 订阅（主线程订阅）</li>
<li>一定在 <code>MainScheduler</code> 监听（主线程监听）</li>
<li>共享状态变化</li>
</ul>
]]></content>
      <categories>
        <category>响应式框架</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift 文档：Observable</title>
    <url>/2018/04/09/20180409-RxSwift%20%E6%96%87%E6%A1%A3%EF%BC%9AObservable/</url>
    <content><![CDATA[<h2 id="Observable-可被监听的序列"><a href="#Observable-可被监听的序列" class="headerlink" title="Observable - 可被监听的序列"></a>Observable - 可被监听的序列</h2><hr>
<h4 id="所有的事物都是序列"><a href="#所有的事物都是序列" class="headerlink" title="所有的事物都是序列"></a>所有的事物都是序列</h4><p><code>Observable</code> 可以用于描述元素异步产生的序列。这样我们生活中许多事物都可以通过它来表示。</p>
<h4 id="如何创建序列"><a href="#如何创建序列" class="headerlink" title="如何创建序列"></a>如何创建序列</h4><p>创建序列最直接的方法就是调用 <code>Observable.create</code>，然后在构建函数里面描述元素的产生过程。 <code>observer.onNext(0)</code> 就代表产生了一个元素，他的值是 <code>0</code>。后面又产生了 <code>9</code> 个元素分别是 <code>1, 2, ... 8, 9</code> 。最后，用 <code>observer.onCompleted()</code> 表示元素已经全部产生，没有更多元素了。</p>
<span id="more"></span>

<p>你可以用这种方式来封装功能组件，例如，闭包回调：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">JSON</span> <span class="operator">=</span> <span class="keyword">Any</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> json: <span class="type">Observable</span>&lt;<span class="type">JSON</span>&gt; <span class="operator">=</span> <span class="type">Observable</span>.create &#123; (observer) -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> task <span class="operator">=</span> <span class="type">URLSession</span>.shared.dataTask(with: <span class="operator">...</span>) &#123; data, <span class="keyword">_</span>, error <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> error <span class="operator">==</span> <span class="literal">nil</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            observer.onError(error<span class="operator">!</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> data <span class="operator">=</span> data,</span><br><span class="line">            <span class="keyword">let</span> jsonObject <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">JSONSerialization</span>.jsonObject(with: data, options: .mutableLeaves)</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                observer.onError(<span class="type">DataError</span>.cantParseJSON)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        observer.onNext(jsonObject)</span><br><span class="line">        observer.onCompleted()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    task.resume()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create &#123; task.cancel() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在闭包回调中，如果任务失败，就调用 <code>observer.onError(error!)</code>。如果获取到目标元素，就调用 <code>observer.onNext(jsonObject)</code>。由于我们的这个序列只有一个元素，所以在成功获取到元素后，就直接调用 <code>observer.onCompleted()</code> 来表示任务结束。最后 <code>Disposables.create &#123; task.cancel() &#125;</code> 说明如果数据绑定被清除（订阅被取消）的话，就取消网络请求。</p>
<p>这样一来我们就将传统的闭包回调转换成序列了。然后可以用 <code>subscribe</code> 方法来响应这个请求的结果。</p>
<h3 id="Single"><a href="#Single" class="headerlink" title="Single"></a>Single</h3><hr>
<p><code>Single</code> 是 <code>Observable</code> 的另外一个版本。不像 <code>Observable</code> 可以发出多个元素，它要么只能发出一个元素，要么产生一个 <code>error</code> 事件。</p>
<ul>
<li>发出一个元素，或一个 error 事件</li>
<li>不会共享状态变化</li>
</ul>
<p>一个比较常见的例子就是执行 <code>HTTP</code> 请求，然后返回一个应答或错误。不过你也可以用 <code>Single</code> 来描述任何只有一个元素的序列。</p>
<h4 id="如何创建-Single"><a href="#如何创建-Single" class="headerlink" title="如何创建 Single"></a>如何创建 Single</h4><p>创建 <code>Single</code> 和创建 <code>Observable</code> 非常相似：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getRepo</span>(<span class="keyword">_</span> <span class="params">repo</span>: <span class="type">String</span>) -&gt; <span class="type">Single</span>&lt;[<span class="type">String</span>: <span class="keyword">Any</span>]&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="type">Single</span>&lt;[<span class="type">String</span>: <span class="keyword">Any</span>]&gt;.create &#123; single <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://api.github.com/repos/<span class="subst">\(repo)</span>&quot;</span>)<span class="operator">!</span></span><br><span class="line">        <span class="keyword">let</span> task <span class="operator">=</span> <span class="type">URLSession</span>.shared.dataTask(with: url) &#123;</span><br><span class="line">            data, <span class="keyword">_</span>, error <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> error <span class="operator">=</span> error &#123;</span><br><span class="line">                single(.error(error))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> data <span class="operator">=</span> data,</span><br><span class="line">                <span class="keyword">let</span> json <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">JSONSerialization</span>.jsonObject(with: data, options: .mutableLeaves),</span><br><span class="line">                <span class="keyword">let</span> result <span class="operator">=</span> json <span class="keyword">as?</span> [<span class="type">String</span>: <span class="keyword">Any</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">                    single(.error(<span class="type">DataError</span>.cantParseJSON))</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            single(.success(result))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        task.resume()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="type">Disposables</span>.create &#123; task.cancel() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>订阅提供一个 <code>SingleEvent</code> 的枚举：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SingleEvent</span>&lt;<span class="type">Element</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">case</span> success(<span class="type">Element</span>)</span><br><span class="line">    <span class="keyword">case</span> error(<span class="type">Swift</span>.<span class="type">Error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意 <code>Single</code> 与普通 <code>Observable</code> 序列的事件枚举的不同。</strong></p>
<h3 id="Completable"><a href="#Completable" class="headerlink" title="Completable"></a>Completable</h3><hr>
<p><code>Completable</code> 是 <code>Observable</code> 的另外一个版本。不像 <code>Observable</code> 可以发出多个元素，它要么只能产生一个 <code>completed</code> 事件，要么产生一个 <code>error</code> 事件。</p>
<ul>
<li>发出零个元素</li>
<li>发出一个 <code>completed</code> 事件或者一个 <code>error</code> 事件</li>
<li>不会共享状态变化</li>
</ul>
<p><code>Completable</code> 适用于那种你只关心任务是否完成，而不需要在意任务返回值的情况。它和 <code>Observable&lt;Void&gt;</code> 有点相似。</p>
<h4 id="如何创建-Completable"><a href="#如何创建-Completable" class="headerlink" title="如何创建 Completable"></a>如何创建 Completable</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">cacheLocally</span>() -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Completable</span>.create &#123; completable <span class="keyword">in</span></span><br><span class="line">        <span class="comment">// Store some data locally</span></span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> success <span class="keyword">else</span> &#123;</span><br><span class="line">            completable(.error(<span class="type">CacheError</span>.failedCaching))</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Disposables</span>.create &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        completable(.completed)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Disposables</span>.create &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>订阅提供一个 <code>CompletableEvent</code> 的枚举：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">CompletableEvent</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> error(<span class="type">Swift</span>.<span class="type">Error</span>)</span><br><span class="line">    <span class="keyword">case</span> completed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Maybe"><a href="#Maybe" class="headerlink" title="Maybe"></a>Maybe</h3><hr>
<p><code>Maybe</code> 是 <code>Observable</code> 的另外一个版本。它介于 <code>Single</code> 和 <code>Completable</code> 之间，它要么只能发出一个元素，要么产生一个 <code>completed</code> 事件，要么产生一个 <code>error</code> 事件。</p>
<p>发出一个元素或者一个 <code>completed</code> 事件或者一个 <code>error</code> 事件<br>不会共享状态变化<br>如果你遇到那种可能需要发出一个元素，又可能不需要发出时，就可以使用 <code>Maybe</code>。</p>
<h4 id="如何创建-Maybe"><a href="#如何创建-Maybe" class="headerlink" title="如何创建 Maybe"></a>如何创建 Maybe</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">generateString</span>() -&gt; <span class="type">Maybe</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Maybe</span>&lt;<span class="type">String</span>&gt;.create &#123; maybe <span class="keyword">in</span></span><br><span class="line">        maybe(.success(<span class="string">&quot;RxSwift&quot;</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// OR</span></span><br><span class="line">        </span><br><span class="line">        maybe(.completed)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// OR</span></span><br><span class="line">        </span><br><span class="line">        maybe(.error(error))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="type">Disposables</span>.create &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h3><hr>
<p><code>Driver</code> 是一个精心准备的特征序列。它主要是为了简化 <code>UI</code> 层的代码。不过如果你遇到的序列具有以下特征，你也可以使用它：</p>
<ul>
<li>不会产生 <code>error</code> 事件</li>
<li>一定在 <code>MainScheduler</code> 监听（主线程监听）</li>
<li>共享状态变化</li>
</ul>
<p>这些都是驱动 <code>UI</code> 的序列所具有的特征。</p>
<h4 id="为什么要使用-Driver-？"><a href="#为什么要使用-Driver-？" class="headerlink" title="为什么要使用 Driver ？"></a>为什么要使用 Driver ？</h4><p>我们举个例子来说明一下，为什么要使用 <code>Driver</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> results <span class="operator">=</span> query.rx.text</span><br><span class="line">    .throttle(<span class="number">0.3</span>, scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">    .flatMapLatest &#123; query <span class="keyword">in</span></span><br><span class="line">        fetchAutoCompleteItems(query)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">    .map &#123; <span class="string">&quot;<span class="subst">\(<span class="variable">$0</span>.count)</span>&quot;</span> &#125;</span><br><span class="line">    .bind(to: resultCount.rx.text)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">    .bind(to: resultsTableView.rx.items(cellIdentifier: <span class="string">&quot;Cell&quot;</span>)) &#123;</span><br><span class="line">        (<span class="keyword">_</span>, result, cell) <span class="keyword">in</span></span><br><span class="line">        cell.textLabel<span class="operator">?</span>.text <span class="operator">=</span> <span class="string">&quot;<span class="subst">\(result)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<p>这段代码的主要目的是：</p>
<ul>
<li>取出用户输入稳定后的内容</li>
<li>向服务器请求一组结果</li>
<li>将返回的结果绑定到两个 <code>UI</code> 元素上：<code>tableView</code> 和 显示结果数量的<code>label</code></li>
</ul>
<p>那么这里存在什么问题？</p>
<ul>
<li>如果 <code>fetchAutoCompleteItems</code> 的序列产生了一个错误（网络请求失败），这个错误将取消所有绑定，当用户输入一个新的关键字时，是无法发起新的网络请求。</li>
<li>如果 <code>fetchAutoCompleteItems</code> 在后台返回序列，那么刷新页面也会在后台进行，这样就会出现异常崩溃。</li>
<li>返回的结果被绑定到两个 <code>UI</code> 元素上。那就意味着，每次用户输入一个新的关键字时，就会分别为两个 <code>UI</code> 元素发起 <code>HTTP</code> 请求，这并不是我们想要的结果。</li>
</ul>
<p>一个更好的方案是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> results <span class="operator">=</span> query.rx.text</span><br><span class="line">    .throttle(<span class="number">0.3</span>, scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">    .flatMapLatest &#123; query <span class="keyword">in</span></span><br><span class="line">        fetchAutoCompleteItems(query)</span><br><span class="line">            .observeOn(<span class="type">MainScheduler</span>.instance)  <span class="comment">// 结果在主线程返回</span></span><br><span class="line">            .catchErrorJustReturn([])           <span class="comment">// 错误被处理了，这样至少不会终止整个序列</span></span><br><span class="line">    &#125;</span><br><span class="line">    .share(replay: <span class="number">1</span>)                             <span class="comment">// HTTP 请求是被共享的</span></span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">    .map &#123; <span class="string">&quot;<span class="subst">\(<span class="variable">$0</span>.count)</span>&quot;</span> &#125;</span><br><span class="line">    .bind(to: resultCount.rx.text)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">    .bind(to: resultsTableView.rx.items(cellIdentifier: <span class="string">&quot;Cell&quot;</span>)) &#123;</span><br><span class="line">        (<span class="keyword">_</span>, result, cell) <span class="keyword">in</span></span><br><span class="line">        cell.textLabel<span class="operator">?</span>.text <span class="operator">=</span> <span class="string">&quot;<span class="subst">\(result)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以下是使用 <code>Driver</code> 优化后的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> results <span class="operator">=</span> query.rx.text.asDriver()        <span class="comment">// 将普通序列转换为 Driver</span></span><br><span class="line">    .throttle(<span class="number">0.3</span>, scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">    .flatMapLatest &#123; query <span class="keyword">in</span></span><br><span class="line">        fetchAutoCompleteItems(query)</span><br><span class="line">            .asDriver(onErrorJustReturn: [])  <span class="comment">// 仅仅提供发生错误时的备选返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">    .map &#123; <span class="string">&quot;<span class="subst">\(<span class="variable">$0</span>.count)</span>&quot;</span> &#125;</span><br><span class="line">    .drive(resultCount.rx.text)               <span class="comment">// 这里改用 `drive` 而不是 `bindTo`</span></span><br><span class="line">    .disposed(by: disposeBag)                 <span class="comment">// 这样可以确保必备条件都已经满足了</span></span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">    .drive(resultsTableView.rx.items(cellIdentifier: <span class="string">&quot;Cell&quot;</span>)) &#123;</span><br><span class="line">        (<span class="keyword">_</span>, result, cell) <span class="keyword">in</span></span><br><span class="line">        cell.textLabel<span class="operator">?</span>.text <span class="operator">=</span> <span class="string">&quot;<span class="subst">\(result)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<p>任何可被监听的序列都可以被转换为 <code>Driver</code>，只要他满足 3 个条件：</p>
<ul>
<li>不会产生 <code>error</code> 事件</li>
<li>一定在 <code>MainScheduler</code> 监听（主线程监听）</li>
<li>共享状态变化</li>
</ul>
<p>那么要如何确定条件都被满足？通过 Rx 操作符来进行转换。<code>asDriver(onErrorJustReturn: [])</code> 相当于以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> safeSequence <span class="operator">=</span> xs</span><br><span class="line">    .observeOn(<span class="type">MainScheduler</span>.instance)       <span class="comment">// 主线程监听</span></span><br><span class="line">    .catchErrorJustReturn(onErrorJustReturn) <span class="comment">// 无法产生错误</span></span><br><span class="line">    .share(replay: <span class="number">1</span>, scope: .whileConnected)<span class="comment">// 共享状态变化</span></span><br><span class="line"><span class="keyword">return</span> <span class="type">Driver</span>(raw: safeSequence)           <span class="comment">// 封装</span></span><br></pre></td></tr></table></figure>

<p>最后使用 <code>drive</code> 而不是 <code>bindTo</code></p>
<p><code>drive</code> 方法只能被 <code>Driver</code> 调用。这意味着，如果你发现代码所存在 <code>drive</code>，那么这个序列不会产生错误事件并且一定在主线程监听。这样你可以安全的绑定 <code>UI</code> 元素。</p>
<h3 id="ControlEvent"><a href="#ControlEvent" class="headerlink" title="ControlEvent"></a>ControlEvent</h3><hr>
<p><code>ControlEvent</code> 专门用于描述 UI 控件所产生的事件，它具有以下特征：</p>
<ul>
<li>不会产生 <code>error</code> 事件</li>
<li>一定在 <code>MainScheduler</code> 订阅（主线程订阅）</li>
<li>一定在 <code>MainScheduler</code> 监听（主线程监听）</li>
<li>共享状态变化</li>
</ul>
]]></content>
      <categories>
        <category>响应式框架</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift 文档：Schedulers</title>
    <url>/2018/04/09/20180409-RxSwift%20%E6%96%87%E6%A1%A3%EF%BC%9ASchedulers/</url>
    <content><![CDATA[<h2 id="Schedulers-调度器"><a href="#Schedulers-调度器" class="headerlink" title="Schedulers - 调度器"></a>Schedulers - 调度器</h2><hr>
<p><code>Schedulers</code> 是 Rx 实现多线程的核心模块，它主要用于控制任务在哪个线程或队列运行。</p>
<p>如果你曾经使用过 <code>GCD</code>， 那你对以下代码应该不会陌生：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后台取得数据，主线程处理结果</span></span><br><span class="line"><span class="type">DispatchQueue</span>.global(qos: .userInitiated).async &#123;</span><br><span class="line">    <span class="keyword">let</span> data <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">Data</span>(contentsOf: url)</span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">        <span class="keyword">self</span>.data <span class="operator">=</span> data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>如果用 <code>RxSwift</code> 来实现，大致是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> rxData: <span class="type">Observable</span>&lt;<span class="type">Data</span>&gt; <span class="operator">=</span> <span class="operator">...</span></span><br><span class="line">    </span><br><span class="line">rxData</span><br><span class="line">    .subscribeOn(<span class="type">ConcurrentDispatchQueueScheduler</span>(qos: .userInitiated))</span><br><span class="line">    .observeOn(<span class="type">MainScheduler</span>.instance)</span><br><span class="line">    .subscribe(onNext: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] data <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">self</span><span class="operator">?</span>.data <span class="operator">=</span> data</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h4 id="使用-subscribeOn"><a href="#使用-subscribeOn" class="headerlink" title="使用 subscribeOn"></a>使用 <code>subscribeOn</code></h4><p>我们用 <code>subscribeOn</code> 来决定数据序列的构建函数在哪个 <code>Scheduler</code> 上运行。以上例子中，由于获取 <code>Data</code> 需要花很长的时间，所以用 <code>subscribeOn</code> 切换到后台 <code>Scheduler</code> 来获取 <code>Data</code>。这样可以避免主线程被阻塞。</p>
<h4 id="使用-observeOn"><a href="#使用-observeOn" class="headerlink" title="使用 observeOn"></a>使用 <code>observeOn</code></h4><p>我们用 <code>observeOn</code> 来决定在哪个 <code>Scheduler</code> 监听这个数据序列。以上例子中，通过使用 <code>observeOn</code> 方法切换到主线程来监听并且处理结果。</p>
<p>一个比较典型的例子就是，在后台发起网络请求，然后解析数据，最后在主线程刷新页面。你就可以先用 <code>subscribeOn</code> 切到后台去发送请求并解析数据，最后用 <code>observeOn</code> 切换到主线程更新页面。</p>
<h4 id="MainScheduler"><a href="#MainScheduler" class="headerlink" title="MainScheduler"></a>MainScheduler</h4><p><code>MainScheduler</code> 代表主线程。如果你需要执行一些和 UI 相关的任务，就需要切换到该 <code>Scheduler</code> 运行。</p>
<h4 id="SerialDispatchQueueScheduler"><a href="#SerialDispatchQueueScheduler" class="headerlink" title="SerialDispatchQueueScheduler"></a>SerialDispatchQueueScheduler</h4><p><code>SerialDispatchQueueScheduler</code> 抽象了窜行 <code>DispatchQueue</code>。如果你需要执行一些窜行任务，可以切换到这个 <code>Scheduler</code> 运行。</p>
<h4 id="ConcurrentDispatchQueueScheduler"><a href="#ConcurrentDispatchQueueScheduler" class="headerlink" title="ConcurrentDispatchQueueScheduler"></a>ConcurrentDispatchQueueScheduler</h4><p><code>ConcurrentDispatchQueueScheduler</code> 抽象了并行 <code>DispatchQueue</code>。如果你需要执行一些并发任务，可以切换到这个 <code>Scheduler</code> 运行。</p>
<h4 id="OperationQueueScheduler"><a href="#OperationQueueScheduler" class="headerlink" title="OperationQueueScheduler"></a>OperationQueueScheduler</h4><p><code>OperationQueueScheduler</code> 抽象了 <code>NSOperationQueue</code>。</p>
<p>它具备 <code>NSOperationQueue</code> 的一些特点，例如，你可以通过设置 <code>maxConcurrentOperationCount</code>，来控制同时执行并发任务的最大数量。</p>
]]></content>
      <categories>
        <category>响应式框架</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift 文档：操作符</title>
    <url>/2018/04/11/20180411-RxSwift%20%E6%96%87%E6%A1%A3%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="just-、-from-和-of"><a href="#just-、-from-和-of" class="headerlink" title="just 、 from 和 of"></a>just 、 from 和 of</h2><hr>
<p><code>just</code> 和 <code>from</code> 都能够将元素转化为 <code>Observable</code> 但是他们有本质的区别：</p>
<h3 id="just"><a href="#just" class="headerlink" title="just"></a>just</h3><p>创建 <code>Observable</code> 发出<strong>唯一的一个元素</strong>。 <code>just</code> 操作符将某一个元素转换为 <code>Observable</code>。</p>
<p>示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oJust <span class="operator">=</span> <span class="type">Observable</span>.just([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">oJust.subscribe(onNext: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="variable">$0</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.dispose()</span><br><span class="line"></span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>相当于</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oJust <span class="operator">=</span> <span class="type">Observable</span>&lt;<span class="type">Array</span>&lt;<span class="type">Int</span>&gt;&gt;.create &#123; (observer) -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">    observer.onNext([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">    observer.onCompleted()</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="from"><a href="#from" class="headerlink" title="from"></a>from</h3><p>将其他类型或者数据结构转换为 <code>Observable</code> 。当你在使用 <code>Observable</code> 时，如果能够直接将其他类型转换为 <code>Observable</code>，这将是非常省事的。<code>from</code> 操作符就提供了这种功能。</p>
<p>示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oFrom <span class="operator">=</span> <span class="type">Observable</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">oFrom.subscribe(onNext: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="variable">$0</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.dispose()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>相当于</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oFrom <span class="operator">=</span> <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.create &#123; (observer) -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">    observer.onNext(<span class="number">1</span>)</span><br><span class="line">    observer.onNext(<span class="number">2</span>)</span><br><span class="line">    observer.onNext(<span class="number">3</span>)</span><br><span class="line">    observer.onNext(<span class="number">4</span>)</span><br><span class="line">    observer.onNext(<span class="number">5</span>)</span><br><span class="line">    observer.onCompleted()</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将一个值转化为 <code>Observable</code> 可以用 <code>Observable.from(optional: &lt;_?&gt;)</code> 方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">optional</span>: <span class="type">Int</span>? <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> value <span class="operator">=</span> <span class="type">Observable</span>.from(optional: <span class="keyword">optional</span>)</span><br></pre></td></tr></table></figure>

<p>相当于</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">optional</span>: <span class="type">Int</span>? <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> value <span class="operator">=</span> <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.create &#123; observer <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> element <span class="operator">=</span> <span class="keyword">optional</span> &#123;</span><br><span class="line">        observer.onNext(element)</span><br><span class="line">    &#125;</span><br><span class="line">    observer.onCompleted()</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="of"><a href="#of" class="headerlink" title="of"></a>of</h3><p>能将多个元素转化为 <code>Observable</code> 。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).subscribe(onNext: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="variable">$0</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.dispose()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h2 id="concat、combineLatest-和-zip"><a href="#concat、combineLatest-和-zip" class="headerlink" title="concat、combineLatest 和 zip"></a>concat、combineLatest 和 zip</h2><hr>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><p>让两个或多个 <code>Observables</code> <strong>按顺序</strong>串连起来。</p>
<p><code>concat</code> 操作符将多个 <code>Observables</code> 按顺序串联起来，当前一个 <code>Observable</code> 元素发送完毕后，后一个 <code>Observable</code> 才可以开始发出元素。</p>
<p><code>concat</code> 将等待前一个 <code>Observable</code> 产生完成事件后，才对后一个 <code>Observable</code> 进行订阅。如果后一个是“热” <code>Observable</code> ，在它前一个 <code>Observable</code> 产生完成事件前，所产生的元素将不会被发送出来。</p>
<p> <strong><code>startWith</code> 和它十分相似。但是 <code>startWith</code> 不是在后面添加元素，而是在前面插入元素。</strong></p>
<p><code>merge</code> 和它也是十分相似。**<code>merge</code> 并不是将多个 <code>Observables</code> 按顺序串联起来，而是将他们合并到一起，不需要 <code>Observables</code> 按先后顺序发出元素。**</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag <span class="operator">=</span> <span class="type">DisposeBag</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> subject1 <span class="operator">=</span> <span class="type">BehaviorSubject</span>(value: <span class="string">&quot;🍎&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> subject2 <span class="operator">=</span> <span class="type">BehaviorSubject</span>(value: <span class="string">&quot;🐶&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> variable <span class="operator">=</span> <span class="type">Variable</span>(subject1)</span><br><span class="line"></span><br><span class="line">variable.asObservable()</span><br><span class="line">    .concat()</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>(<span class="variable">$0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject1.onNext(<span class="string">&quot;🍐&quot;</span>)</span><br><span class="line">subject1.onNext(<span class="string">&quot;🍊&quot;</span>)</span><br><span class="line"></span><br><span class="line">variable.value <span class="operator">=</span> subject2</span><br><span class="line"></span><br><span class="line">subject2.onNext(<span class="string">&quot;I would be ignored&quot;</span>)</span><br><span class="line">subject2.onNext(<span class="string">&quot;🐱&quot;</span>)</span><br><span class="line"></span><br><span class="line">subject1.onCompleted()</span><br><span class="line"></span><br><span class="line">subject2.onNext(<span class="string">&quot;🐭&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// next(🍎)</span></span><br><span class="line"><span class="comment">// next(🍐)</span></span><br><span class="line"><span class="comment">// next(🍊)</span></span><br><span class="line"><span class="comment">// next(🐱)</span></span><br><span class="line"><span class="comment">// next(🐭)</span></span><br></pre></td></tr></table></figure>

<h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p>通过一个函数将多个 <code>Observables</code> 的元素组合起来，然后将每一个组合的结果发出来。</p>
<p><img src="/my_pictures/20180411/1.png"></p>
<p><code>zip</code> 操作符将多个(最多不超过8个) <code>Observables</code> 的元素通过一个函数组合起来，然后将这个组合的结果发出来。它会严格的按照序列的索引数进行组合。例如，返回的 <code>Observable</code> 的第一个元素，是由每一个源 <code>Observables</code> 的第一个元素组合出来的。它的第二个元素 ，是由每一个源 <code>Observables</code> 的第二个元素组合出来的。它的第三个元素 ，是由每一个源 <code>Observables</code> 的第三个元素组合出来的，以此类推。它的元素数量等于源 <code>Observables</code> 中元素数量最少的那个。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag <span class="operator">=</span> <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="keyword">let</span> first <span class="operator">=</span> <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> second <span class="operator">=</span> <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="type">Observable</span>.zip(first, second) &#123; <span class="variable">$0</span> <span class="operator">+</span> <span class="variable">$1</span> &#125;</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>(<span class="variable">$0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">first.onNext(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">second.onNext(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">first.onNext(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">second.onNext(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">second.onNext(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">second.onNext(<span class="string">&quot;D&quot;</span>)</span><br><span class="line">first.onNext(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">first.onNext(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">first.onNext(<span class="string">&quot;5&quot;</span>) <span class="comment">// 并没有输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1A</span></span><br><span class="line"><span class="comment">// 2B</span></span><br><span class="line"><span class="comment">// 3C</span></span><br><span class="line"><span class="comment">// 4D</span></span><br></pre></td></tr></table></figure>

<h3 id="combineLatest（可与-zip-比较学习）"><a href="#combineLatest（可与-zip-比较学习）" class="headerlink" title="combineLatest（可与 zip 比较学习）"></a>combineLatest（可与 zip 比较学习）</h3><p>当多个 <code>Observables</code> 中任何一个发出一个元素，就发出一个元素。这个元素是由这些 <code>Observables</code> 中最新的元素，通过一个函数组合起来的。</p>
<p><img src="/my_pictures/20180411/2.png"></p>
<p><code>combineLatest</code> 操作符将多个 <code>Observables</code> 中最新的元素通过一个函数组合起来，然后将这个组合的结果发出来。这些源 <code>Observables</code> 中任何一个发出一个元素，他都会发出一个元素（前提是，这些 <code>Observables</code> 曾经发出过元素）。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag <span class="operator">=</span> <span class="type">DisposeBag</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> first <span class="operator">=</span> <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> second <span class="operator">=</span> <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="type">Observable</span>.combineLatest(first, second) &#123; <span class="variable">$0</span> <span class="operator">+</span> <span class="variable">$1</span> &#125;</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>(<span class="variable">$0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">first.onNext(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">second.onNext(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">first.onNext(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">second.onNext(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">second.onNext(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">second.onNext(<span class="string">&quot;D&quot;</span>)</span><br><span class="line">first.onNext(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">first.onNext(<span class="string">&quot;4&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1A</span></span><br><span class="line"><span class="comment">// 2A</span></span><br><span class="line"><span class="comment">// 2B</span></span><br><span class="line"><span class="comment">// 2C</span></span><br><span class="line"><span class="comment">// 2D</span></span><br><span class="line"><span class="comment">// 3D</span></span><br><span class="line"><span class="comment">// 4D</span></span><br></pre></td></tr></table></figure>

<h2 id="flatMap-和-flatMapLatest"><a href="#flatMap-和-flatMapLatest" class="headerlink" title="flatMap 和 flatMapLatest"></a>flatMap 和 flatMapLatest</h2><hr>
<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p>将 <code>Observable</code> 的元素转换成其他的 <code>Observable</code>，然后将这些 <code>Observables</code> 合并。</p>
<p><code>flatMap</code> 操作符将源 <code>Observable</code> 的每一个元素应用一个转换方法，将他们转换成 <code>Observables</code>。 然后将这些 <code>Observables</code> 的元素合并之后再发送出来。</p>
<p>这个操作符是非常有用的，例如，当 <code>Observable</code> 的元素本生拥有其他的 <code>Observable</code> 时，你可以将所有子 <code>Observables</code> 的元素发送出来。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag <span class="operator">=</span> <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="keyword">let</span> first <span class="operator">=</span> <span class="type">BehaviorSubject</span>(value: <span class="string">&quot;👦🏻&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> second <span class="operator">=</span> <span class="type">BehaviorSubject</span>(value: <span class="string">&quot;🅰️&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> variable <span class="operator">=</span> <span class="type">Variable</span>(first)</span><br><span class="line"></span><br><span class="line">variable.asObservable()</span><br><span class="line">    .flatMap &#123; <span class="variable">$0</span> &#125;</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>(<span class="variable">$0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">first.onNext(<span class="string">&quot;🐱&quot;</span>)</span><br><span class="line">variable.value <span class="operator">=</span> second</span><br><span class="line">second.onNext(<span class="string">&quot;🅱️&quot;</span>)</span><br><span class="line">first.onNext(<span class="string">&quot;🐶&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 👦🏻</span></span><br><span class="line"><span class="comment">// 🐱</span></span><br><span class="line"><span class="comment">// 🅰️</span></span><br><span class="line"><span class="comment">// 🅱️</span></span><br><span class="line"><span class="comment">// 🐶</span></span><br></pre></td></tr></table></figure>

<h3 id="flatMapLatest"><a href="#flatMapLatest" class="headerlink" title="flatMapLatest"></a>flatMapLatest</h3><p>将 <code>Observable</code> 的元素转换成其他的 <code>Observable</code>，然后取这些 <code>Observables</code> 中<strong>最新的一个</strong>。</p>
<p><code>flatMapLatest</code> 操作符将源 <code>Observable</code> 的每一个元素应用一个转换方法，将他们转换成 <code>Observables</code>。一旦转换出一个新的 <code>Observable</code>，就只发出它的元素，旧的 <code>Observables</code> 的元素将被忽略掉。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag <span class="operator">=</span> <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="keyword">let</span> first <span class="operator">=</span> <span class="type">BehaviorSubject</span>(value: <span class="string">&quot;👦🏻&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> second <span class="operator">=</span> <span class="type">BehaviorSubject</span>(value: <span class="string">&quot;🅰️&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> variable <span class="operator">=</span> <span class="type">Variable</span>(first)</span><br><span class="line"></span><br><span class="line">variable.asObservable()</span><br><span class="line">    .flatMapLatest &#123; <span class="variable">$0</span> &#125;</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>(<span class="variable">$0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">first.onNext(<span class="string">&quot;🐱&quot;</span>)</span><br><span class="line">variable.value <span class="operator">=</span> second</span><br><span class="line">second.onNext(<span class="string">&quot;🅱️&quot;</span>)</span><br><span class="line">first.onNext(<span class="string">&quot;🐶&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 👦🏻</span></span><br><span class="line"><span class="comment">// 🐱</span></span><br><span class="line"><span class="comment">// 🅰️</span></span><br><span class="line"><span class="comment">// 🅱️</span></span><br></pre></td></tr></table></figure>

<h2 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h2><hr>
<p>持续的将 <code>Observable</code> 的每一个元素应用一个函数，然后发出每一次函数返回的结果。</p>
<p><code>scan</code> 操作符将对第一个元素应用一个函数，将结果作为第一个元素发出。然后，将结果作为参数填入到第二个元素的应用函数中，创建第二个元素。以此类推，直到遍历完全部的元素。</p>
<p>这种操作符在其他地方有时候被称作是 <code>accumulator</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag <span class="operator">=</span> <span class="type">DisposeBag</span>()</span><br><span class="line"></span><br><span class="line"><span class="type">Observable</span>.of(<span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>)</span><br><span class="line">    .scan(<span class="number">1</span>) &#123; aggregateValue, newValue <span class="keyword">in</span></span><br><span class="line">        aggregateValue <span class="operator">+</span> newValue</span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>(<span class="variable">$0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 11</span></span><br><span class="line"><span class="comment">// 111</span></span><br><span class="line"><span class="comment">// 1111</span></span><br></pre></td></tr></table></figure>

<h2 id="materialize-和-dematerialize"><a href="#materialize-和-dematerialize" class="headerlink" title="materialize 和 dematerialize"></a>materialize 和 dematerialize</h2><hr>
<h3 id="materialize"><a href="#materialize" class="headerlink" title="materialize"></a>materialize</h3><p>将任何 <code>Observable</code> 转换为其事件的可观察者。</p>
<p><img src="/my_pictures/20180411/3.png"></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span></span><br><span class="line">    .range(start: <span class="number">1</span>, count: <span class="number">3</span>)</span><br><span class="line">    .materialize()</span><br><span class="line">    .subscribe(onNext: &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable">$0</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: bag)</span><br><span class="line"></span><br><span class="line"><span class="comment">// next(1)</span></span><br><span class="line"><span class="comment">// next(2)</span></span><br><span class="line"><span class="comment">// next(3)</span></span><br><span class="line"><span class="comment">// completed</span></span><br></pre></td></tr></table></figure>

<p>作为对比</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span></span><br><span class="line">    .range(start: <span class="number">1</span>, count: <span class="number">3</span>)</span><br><span class="line">    .subscribe(onNext: &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable">$0</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: bag)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="dematerialize"><a href="#dematerialize" class="headerlink" title="dematerialize"></a>dematerialize</h3><p><code>dematerialize</code> 操作符将 <code>materialize</code> 转换后的元素还原</p>
<p><img src="/my_pictures/20180411/4.png"></p>
<h2 id="take-、-takeLast-和-elementAt"><a href="#take-、-takeLast-和-elementAt" class="headerlink" title="take 、 takeLast 和 elementAt"></a>take 、 takeLast 和 elementAt</h2><hr>
<h3 id="take"><a href="#take" class="headerlink" title="take"></a>take</h3><p>仅仅从 <code>Observable</code> 中发出头 n 个元素。通过 <code>take</code> 操作符你可以只发出头 n 个元素。并且忽略掉后面的元素，直接结束序列。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag <span class="operator">=</span> <span class="type">DisposeBag</span>()</span><br><span class="line"></span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">&quot;🐱&quot;</span>, <span class="string">&quot;🐰&quot;</span>, <span class="string">&quot;🐶&quot;</span>, <span class="string">&quot;🐸&quot;</span>, <span class="string">&quot;🐷&quot;</span>, <span class="string">&quot;🐵&quot;</span>)</span><br><span class="line">    .take(<span class="number">3</span>)</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>(<span class="variable">$0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 🐱</span></span><br><span class="line"><span class="comment">// 🐰</span></span><br><span class="line"><span class="comment">// 🐶</span></span><br></pre></td></tr></table></figure>

<h3 id="takeLast"><a href="#takeLast" class="headerlink" title="takeLast"></a>takeLast</h3><p>仅仅从 <code>Observable</code> 中发出尾部 n 个元素，通过 <code>takeLast</code> 操作符你可以只发出尾部 n 个元素。并且忽略掉前面的元素。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag <span class="operator">=</span> <span class="type">DisposeBag</span>()</span><br><span class="line"></span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">&quot;🐱&quot;</span>, <span class="string">&quot;🐰&quot;</span>, <span class="string">&quot;🐶&quot;</span>, <span class="string">&quot;🐸&quot;</span>, <span class="string">&quot;🐷&quot;</span>, <span class="string">&quot;🐵&quot;</span>)</span><br><span class="line">    .takeLast(<span class="number">3</span>)</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>(<span class="variable">$0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 🐸</span></span><br><span class="line"><span class="comment">// 🐷</span></span><br><span class="line"><span class="comment">// 🐵</span></span><br></pre></td></tr></table></figure>

<h3 id="elementAt"><a href="#elementAt" class="headerlink" title="elementAt"></a>elementAt</h3><p>只发出 <code>Observable</code> 中的第 n 个元素，<code>elementAt</code> 操作符将拉取 <code>Observable</code> 序列中指定索引数的元素，然后将它作为唯一的元素发出。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag <span class="operator">=</span> <span class="type">DisposeBag</span>()</span><br><span class="line"></span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">&quot;🐱&quot;</span>, <span class="string">&quot;🐰&quot;</span>, <span class="string">&quot;🐶&quot;</span>, <span class="string">&quot;🐸&quot;</span>, <span class="string">&quot;🐷&quot;</span>, <span class="string">&quot;🐵&quot;</span>)</span><br><span class="line">    .elementAt(<span class="number">3</span>)</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>(<span class="variable">$0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 🐸</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>响应式框架</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift 文档：如何选择操作符？</title>
    <url>/2018/04/11/20180411-RxSwift%20%E6%96%87%E6%A1%A3%EF%BC%9A%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="我想要创建一个-Observable"><a href="#我想要创建一个-Observable" class="headerlink" title="我想要创建一个 Observable"></a>我想要创建一个 <code>Observable</code></h3><ul>
<li>产生特定的一个元素： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9qdXN0Lmh0bWw=">just<i class="fa fa-external-link-alt"></i></span><ul>
<li>经过一段延时： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS90aW1lci5odG1s">timer<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li>从一个序列拉取元素： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9mcm9tLmh0bWw=">from<i class="fa fa-external-link-alt"></i></span></li>
<li>重复的产生某一个元素： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9yZXBlYXRFbGVtZW50Lmh0bWw=">repeatElement<i class="fa fa-external-link-alt"></i></span></li>
<li>存在自定义逻辑： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9jcmVhdGUuaHRtbA==">create<i class="fa fa-external-link-alt"></i></span></li>
<li>每次订阅时产生： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9kZWZlcnJlZC5odG1s">deferred<i class="fa fa-external-link-alt"></i></span></li>
<li>每隔一段时间，发出一个元素： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9pbnRlcnZhbC5odG1s">interval<i class="fa fa-external-link-alt"></i></span><ul>
<li>在一段延时后： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS90aW1lci5odG1s">timer<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li>一个空序列，只有一个完成事件： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9lbXB0eS5odG1s">empty<i class="fa fa-external-link-alt"></i></span></li>
<li>一个任何事件都没有产生的序列： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9uZXZlci5odG1s">never<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<span id="more"></span>

<h3 id="我想要创建一个-Observable-通过组合其他的-Observables"><a href="#我想要创建一个-Observable-通过组合其他的-Observables" class="headerlink" title="我想要创建一个 Observable 通过组合其他的 Observables"></a>我想要创建一个 <code>Observable</code> 通过组合其他的 <code>Observables</code></h3><ul>
<li>任意一个 <code>Observable</code> 产生了元素，就发出这个元素： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9tZXJnZS5odG1s">merge<i class="fa fa-external-link-alt"></i></span></li>
<li>让这些 <code>Observables</code> 一个接一个的发出元素，当上一个 <code>Observable</code> 元素发送完毕后，下一个 <code>Observable</code> 才能开始发出元素： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9jb25jYXQuaHRtbA==">concat<i class="fa fa-external-link-alt"></i></span></li>
<li>组合多个 <code>Observables</code> 的元素<ul>
<li>当每一个 <code>Observable</code> 都发出一个新的元素： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS96aXAuaHRtbA==">zip<i class="fa fa-external-link-alt"></i></span></li>
<li>当任意一个 <code>Observable</code> 发出一个新的元素： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9jb21iaW5lTGF0ZXN0Lmh0bWw=">combineLatest<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
</ul>
<h3 id="我想要转换-Observable的元素后，再将它们发出来"><a href="#我想要转换-Observable的元素后，再将它们发出来" class="headerlink" title="我想要转换 Observable的元素后，再将它们发出来"></a>我想要转换 <code>Observable</code>的元素后，再将它们发出来</h3><ul>
<li>对每个元素直接转换： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9tYXAuaHRtbA==">map<i class="fa fa-external-link-alt"></i></span></li>
<li>转换到另一个 <code>Observable</code> ： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9mbGF0TWFwLmh0bWw=">flatMap<i class="fa fa-external-link-alt"></i></span><ul>
<li>只接收最新的元素转换的 <code>Observable</code> 所产生的元素： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9mbGF0TWFwTGF0ZXN0Lmh0bWw=">flatMapLatest<i class="fa fa-external-link-alt"></i></span></li>
<li>每一个元素转换的 <code>Observable</code> 按顺序产生元素： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9jb25jYXRNYXAuaHRtbA==">concatMap<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li>基于所有遍历过的元素： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9zY2FuLmh0bWw=">scan<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="我想要将产生的每一个元素，拖延一段时间后再发出"><a href="#我想要将产生的每一个元素，拖延一段时间后再发出" class="headerlink" title="我想要将产生的每一个元素，拖延一段时间后再发出"></a>我想要将产生的每一个元素，拖延一段时间后再发出</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9kZWxheS5odG1s">delay<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="我想要将产生的事件封装成元素发送出来"><a href="#我想要将产生的事件封装成元素发送出来" class="headerlink" title="我想要将产生的事件封装成元素发送出来"></a>我想要将产生的事件封装成元素发送出来</h3><ul>
<li>将他们封装成 <code>Event&lt;Element&gt;</code> ： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9tYXRlcmlhbGl6ZS5odG1s">materialize<i class="fa fa-external-link-alt"></i></span><ul>
<li>然后解封出来： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9kZW1hdGVyaWFsaXplLmh0bWw=">dematerialize<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
</ul>
<h3 id="我想要忽略掉所有的-next-事件，只接收-completed-和-error-事件"><a href="#我想要忽略掉所有的-next-事件，只接收-completed-和-error-事件" class="headerlink" title="我想要忽略掉所有的 next 事件，只接收 completed 和 error 事件"></a>我想要忽略掉所有的 <code>next</code> 事件，只接收 <code>completed</code> 和 <code>error</code> 事件</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9pZ25vcmVFbGVtZW50cy5odG1s">ignoreElements<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="我想创建一个新的-Observable-在原有的序列前面加入一些元素"><a href="#我想创建一个新的-Observable-在原有的序列前面加入一些元素" class="headerlink" title="我想创建一个新的 Observable 在原有的序列前面加入一些元素"></a>我想创建一个新的 <code>Observable</code> 在原有的序列前面加入一些元素</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9zdGFydFdpdGguaHRtbA==">startWith<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="我想从-Observable-中收集元素，缓存这些元素之后在发出"><a href="#我想从-Observable-中收集元素，缓存这些元素之后在发出" class="headerlink" title="我想从 Observable 中收集元素，缓存这些元素之后在发出"></a>我想从 <code>Observable</code> 中收集元素，缓存这些元素之后在发出</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9idWZmZXIuaHRtbA==">buffer<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="我想将-Observable-拆分成多个-Observables"><a href="#我想将-Observable-拆分成多个-Observables" class="headerlink" title="我想将 Observable 拆分成多个 Observables"></a>我想将 <code>Observable</code> 拆分成多个 <code>Observables</code></h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS93aW5kb3cuaHRtbA==">window<i class="fa fa-external-link-alt"></i></span></li>
<li>基于元素的共同特征： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9ncm91cEJ5Lmh0bWw=">groupBy<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="我想只接收-Observable中特定的元素"><a href="#我想只接收-Observable中特定的元素" class="headerlink" title="我想只接收 Observable中特定的元素"></a>我想只接收 <code>Observable</code>中特定的元素</h3><ul>
<li>发出唯一的元素： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9zaW5nbGUuaHRtbA==">single<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="我想重新从-Observable中发出某些元素"><a href="#我想重新从-Observable中发出某些元素" class="headerlink" title="我想重新从 Observable中发出某些元素"></a>我想重新从 <code>Observable</code>中发出某些元素</h3><ul>
<li>通过判定条件过滤出一些元素： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9maWx0ZXIuaHRtbA==">filter<i class="fa fa-external-link-alt"></i></span></li>
<li>仅仅发出头几个元素： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS90YWtlLmh0bWw=">take<i class="fa fa-external-link-alt"></i></span></li>
<li>仅仅发出尾部的几个元素： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS90YWtlTGFzdC5odG1s">takeLast<i class="fa fa-external-link-alt"></i></span></li>
<li>仅仅发出第 n 个元素： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9lbGVtZW50QXQuaHRtbA==">elementAt<i class="fa fa-external-link-alt"></i></span></li>
<li>跳过头几个元素<ul>
<li>跳过头 n 个元素： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9za2lwLmh0bWw=">skip<i class="fa fa-external-link-alt"></i></span></li>
<li>跳过头几个满足判定的元素： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9za2lwV2hpbGUuaHRtbA==">skipWhile<i class="fa fa-external-link-alt"></i></span> ， <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9za2lwV2hpbGUuaHRtbA==">skipWhileWithIndex<i class="fa fa-external-link-alt"></i></span></li>
<li>跳过某段时间内产生的头几个元素： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9za2lwLmh0bWw=">skip<i class="fa fa-external-link-alt"></i></span></li>
<li>跳过头几个元素直到另一个 <code>Observable</code> 发出一个元素： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9za2lwVW50aWwuaHRtbA==">skipUntil<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li>只取头几个元素<ul>
<li>只取头几个满足判定的元素： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS90YWtlV2hpbGUuaHRtbA==">takeWhile<i class="fa fa-external-link-alt"></i></span> ， <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS90YWtlV2hpbGUuaHRtbA==">takeWhileWithIndex<i class="fa fa-external-link-alt"></i></span></li>
<li>只取某段时间内产生的头几个元素： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS90YWtlLmh0bWw=">take<i class="fa fa-external-link-alt"></i></span></li>
<li>只取头几个元素直到另一个 <code>Observable</code> 发出一个元素： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS90YWtlVW50aWwuaHRtbA==">takeUntil<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li>周期性的对 <code>Observable</code> 抽样： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9zYW1wbGUuaHRtbA==">sample<i class="fa fa-external-link-alt"></i></span></li>
<li>发出那些元素，这些元素产生后的特定的时间内，没有新的元素产生： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9kZWJvdW5jZS5odG1s">debounce<i class="fa fa-external-link-alt"></i></span></li>
<li>直到元素的值发生变化，才发出新的元素： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9kaXN0aW5jdFVudGlsQ2hhbmdlZC5odG1s">distinctUntilChanged<i class="fa fa-external-link-alt"></i></span><ul>
<li>并提供元素是否相等的判定函数： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9kaXN0aW5jdFVudGlsQ2hhbmdlZC5odG1s">distinctUntilChanged<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li>在开始发出元素时，延时后进行订阅： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9kZWxheVN1YnNjcmlwdGlvbi5odG1s">delaySubscription<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="我想要从一些-Observables-中，只取第一个产生元素的-Observable"><a href="#我想要从一些-Observables-中，只取第一个产生元素的-Observable" class="headerlink" title="我想要从一些 Observables 中，只取第一个产生元素的 Observable"></a>我想要从一些 <code>Observables</code> 中，只取第一个产生元素的 <code>Observable</code></h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9hbWIuaHRtbA==">amb<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="我想评估-Observable的全部元素"><a href="#我想评估-Observable的全部元素" class="headerlink" title="我想评估 Observable的全部元素"></a>我想评估 <code>Observable</code>的全部元素</h3><ul>
<li>并且对每个元素应用聚合方法，待所有元素都应用聚合方法后，发出结果： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9yZWR1Y2UuaHRtbA==">reduce<i class="fa fa-external-link-alt"></i></span></li>
<li>并且对每个元素应用聚合方法，每次应用聚合方法后，发出结果： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9zY2FuLmh0bWw=">scan<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="我想把-Observable转换为其他的数据结构：as…"><a href="#我想把-Observable转换为其他的数据结构：as…" class="headerlink" title="我想把 Observable转换为其他的数据结构：as…"></a>我想把 <code>Observable</code>转换为其他的数据结构：as…</h3><h3 id="我想在某个-Scheduler-应用操作符"><a href="#我想在某个-Scheduler-应用操作符" class="headerlink" title="我想在某个 Scheduler 应用操作符"></a>我想在某个 <a href="rxswift_core/schedulers.html">Scheduler</a> 应用操作符</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9zdWJzY3JpYmVPbi5odG1s">subscribeOn<i class="fa fa-external-link-alt"></i></span></li>
<li>在某个 <a href="rxswift_core/schedulers.html">Scheduler</a> 监听： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9vYnNlcnZlT24uaHRtbA==">observeOn<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="我想要-Observable-发生某个事件时-采取某个行动"><a href="#我想要-Observable-发生某个事件时-采取某个行动" class="headerlink" title="我想要 Observable 发生某个事件时, 采取某个行动"></a>我想要 <code>Observable</code> 发生某个事件时, 采取某个行动</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9kby5odG1s">do<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="我想要-Observable-发出一个-error-事件"><a href="#我想要-Observable-发出一个-error-事件" class="headerlink" title="我想要 Observable 发出一个 error 事件"></a>我想要 <code>Observable</code> 发出一个 <code>error</code> 事件</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9lcnJvci5odG1s">error<i class="fa fa-external-link-alt"></i></span></li>
<li>如果规定时间内没有产生元素： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS90aW1lb3V0Lmh0bWw=">timeout<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="我想要-Observable发生错误时，优雅的恢复"><a href="#我想要-Observable发生错误时，优雅的恢复" class="headerlink" title="我想要 Observable发生错误时，优雅的恢复"></a>我想要 <code>Observable</code>发生错误时，优雅的恢复</h3><ul>
<li>如果规定时间内没有产生元素，就切换到备选 <code>Observable</code> ： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS90aW1lb3V0Lmh0bWw=">timeout<i class="fa fa-external-link-alt"></i></span></li>
<li>如果产生错误，将错误替换成某个元素 ： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9jYXRjaEVycm9yLmh0bWw=">catchErrorJustReturn<i class="fa fa-external-link-alt"></i></span></li>
<li>如果产生错误，就切换到备选 <code>Observable</code> ： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9jYXRjaEVycm9yLmh0bWw=">catchError<i class="fa fa-external-link-alt"></i></span></li>
<li>如果产生错误，就重试 ： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9yZXRyeS5odG1s">retry<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="我创建一个-Disposable-资源，使它与-Observable-具有相同的寿命"><a href="#我创建一个-Disposable-资源，使它与-Observable-具有相同的寿命" class="headerlink" title="我创建一个 Disposable 资源，使它与 Observable 具有相同的寿命"></a>我创建一个 <code>Disposable</code> 资源，使它与 <code>Observable</code> 具有相同的寿命</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS91c2luZy5odG1s">using<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="我创建一个-Observable-，直到我通知它可以产生元素后，才能产生元素"><a href="#我创建一个-Observable-，直到我通知它可以产生元素后，才能产生元素" class="headerlink" title="我创建一个 Observable ，直到我通知它可以产生元素后，才能产生元素"></a>我创建一个 <code>Observable</code> ，直到我通知它可以产生元素后，才能产生元素</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9wdWJsaXNoLmh0bWw=">publish<i class="fa fa-external-link-alt"></i></span></li>
<li>并且，就算是在产生元素后订阅，也要发出全部元素： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9yZXBsYXkuaHRtbA==">replay<i class="fa fa-external-link-alt"></i></span></li>
<li>并且，一旦所有观察者取消观察，他就被释放掉： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9yZWZDb3VudC5odG1s">refCount<i class="fa fa-external-link-alt"></i></span></li>
<li>通知它可以产生元素了： <span class="exturl" data-url="aHR0cHM6Ly9iZWV0aDB2ZW4uZ2l0aHViLmlvL1J4U3dpZnQtQ2hpbmVzZS1Eb2N1bWVudGF0aW9uL2NvbnRlbnQvZGVjaXNpb25fdHJlZS9jb25uZWN0Lmh0bWw=">connect<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>响应式框架</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>KVC 和 Properties有什么区别？【译】</title>
    <url>/2018/04/13/20180413-KVC%E5%92%8CProperties%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="但是，我仍然不明白，KVC-和属性访问（property-accessor）方法有什么区别？"><a href="#但是，我仍然不明白，KVC-和属性访问（property-accessor）方法有什么区别？" class="headerlink" title="但是，我仍然不明白，KVC 和属性访问（property accessor）方法有什么区别？"></a>但是，我仍然不明白，KVC 和属性访问（property accessor）方法有什么区别？</h3><hr>
<p>KVC 是调用属性访问器方法或以其他方式访问属性的一种方法。</p>
<p><strong>“以其他方式访问”是什么意思？</strong></p>
<p>对于 KVC 而言，没有访问器方法的实例变量会被视为非正式属性。<br>如果没有找到匹配的访问器对，它将直接获取或设置实例变量的值。<br>（是的，在现代代码中这是不值得使用的，总是为任何你想访问的任何东西声明一个 <code>@property</code>，反之，不要使用 KVC 来访问任何不属于公共属性的东西。）</p>
<p>属性访问器方法是 KVC 在其存在的情况下会调用的方法（KVC 和每个理智的程序员都倾向于直接 ivar 访问）。访问者可以获取或设置实例变量，如合成访问者所做的那样，或者访问某些其他存储。 </p>
<p>访问器是实现，属性是接口，KVC 是使用它们的一种方式。</p>
<span id="more"></span>

<h3 id="如何区分调用-setValue：forKeyPath-的点和简单访问器？"><a href="#如何区分调用-setValue：forKeyPath-的点和简单访问器？" class="headerlink" title="如何区分调用 setValue：forKeyPath 的点和简单访问器？"></a>如何区分调用 <code>setValue：forKeyPath</code> 的点和简单访问器？</h3><hr>
<p>键路径是一个字符串，而属性访问表达式是一个表达式。编译器检测属性访问表达式并将其转换为一个或多个 Objective-C 消息，而键路径由 KVC 在运行时检测。</p>
<p>所以，当你使用键路径时：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[someObject setValue:theValue forKeyPath:@<span class="string">&quot;foo.bar.baz&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>你知道这是一个键路径，因为</p>
<ol>
<li>它是一个字符串，如本例中的字符串文字语法 <code>@“...”</code> 所示;</li>
<li>将密钥路径字符串传递给 <code>setValue：forKeyPath:</code> 检测。</li>
</ol>
<p>使用键路径是使用 KVC 来访问指定的属性。它会代表你发送任何相关的访问者消息。</p>
<p>当您使用属性访问表达式时：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">someObject.foo.bar.baz = theValue;</span><br></pre></td></tr></table></figure>

<p>你知道这是一个属性访问表达式，因为你没有用字符串标识属性。你正在使用自己的代码访问它们（发送访问者消息）。</p>
<p>没有太多理由以任何形式使用 KVC；当你在作者&#x2F;编译时知道该属性时，最好声明 <code>@property</code> 并自己访问属性，无论是使用属性访问表达式还是消息表达式（<code>[[[someObject foo] bar] setBaz：theValue]</code>）。使用 KVC 的时间是在运行时间之前不知道要访问的属性，这很少见。它主要是 KVO，Cocoa Bindings，Core Animation 等部分背后的构建块技术。 </p>
<p>大多数情况下，你只需要自己访问属性。</p>
<p>原文链接：<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODE5MTM3My93aGF0cy10aGUtZGlmZmVyZW5jZS1iZXR3ZWVuLWt2Yy1hbmQtcHJvcGVydGllcw==">What’s the difference between KVC and Properties?<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>文章翻译</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>为 Playground 手动运行添加快捷键</title>
    <url>/2018/04/13/20180413-%E4%B8%BA%20Playground%20%E6%89%8B%E5%8A%A8%E8%BF%90%E8%A1%8C%E6%B7%BB%E5%8A%A0%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p>我在使用 Playground 的时候，喜欢将自定运行（Automatically Run）修改为手动运行（Manually Run），因为自动运行有时会导致我的 Xcode 卡住，体验非常不好。但是 Playground 并没有相应的快捷键去手动执行 Playground，这又导致手动运行的时候操作繁琐，每次都要靠鼠标去点，作为一个程序员怎么能忍受这种没有效率的操作 😂。接下来我们为手动执行 Playground 添加一个快捷键。</p>
<h3 id="打开系统偏好设置中的快捷键设置"><a href="#打开系统偏好设置中的快捷键设置" class="headerlink" title="打开系统偏好设置中的快捷键设置"></a>打开系统偏好设置中的快捷键设置</h3><hr>
<p>系统偏好设置 -&gt; 键盘 -&gt; 快捷键</p>
<p>选中最后一个，<code>应用快捷键</code></p>
<p><img src="/my_pictures/20180413/1.png"></p>
<span id="more"></span>

<h3 id="设置快捷键"><a href="#设置快捷键" class="headerlink" title="设置快捷键"></a>设置快捷键</h3><hr>
<p>点击加号，添加一个快捷键。应用程序选择 Xcode，菜单标题填写 <code>Execute Playground</code>，快捷键设置为自己想要的快捷键即可。</p>
<ul>
<li>注意：快捷键不能设置成 <code>command + R</code> 因为这会和 Xcode 本身的运行快捷键冲突。</li>
</ul>
<p><img src="/my_pictures/20180413/2.png"></p>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift 文档：函数响应式编程</title>
    <url>/2018/04/09/20180409-RxSwift%20%E6%96%87%E6%A1%A3%EF%BC%9A%E5%87%BD%E6%95%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="函数响应式编程"><a href="#函数响应式编程" class="headerlink" title="函数响应式编程"></a>函数响应式编程</h3><hr>
<p>函数响应式编程是种编程范式。它是通过构建函数操作数据序列，然后对这些序列做出响应的编程方式。它结合了函数式编程以及响应式编程。</p>
<h4 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h4><p><strong>函数式编程是种编程范式，它需要我们将函数作为参数传递，或者作为返回值返还。我们可以通过组合不同的函数来得到想要的结果。</strong></p>
<p>函数试编程的优点：</p>
<ul>
<li>灵活</li>
<li>高复用</li>
<li>简洁</li>
<li>易维护</li>
<li>适应各种需求变化</li>
</ul>
<h4 id="函数式编程-函数响应式编程"><a href="#函数式编程-函数响应式编程" class="headerlink" title="函数式编程 -&gt; 函数响应式编程"></a>函数式编程 -&gt; 函数响应式编程</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设用户在进入页面到离开页面期间，总共点击按钮 3 次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按钮点击序列</span></span><br><span class="line"><span class="keyword">let</span> taps: <span class="type">Array</span>&lt;<span class="type">Void</span>&gt; <span class="operator">=</span> [(), (), ()]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次点击后弹出提示框</span></span><br><span class="line">taps.forEach &#123; showAlert() &#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>这样处理点击事件是非常理想的，但是问题是这个序列里面的元素（点击事件）是异步产生的，传统序列是无法描叙这种元素异步产生的情况。为了解决这个问题，于是就产生了可被监听的序列 <code>Observable&lt;Element&gt;</code> 。它也是一个序列，只不过这个序列里面的元素可以是同步产生的，也可以是异步产生的:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按钮点击序列</span></span><br><span class="line"><span class="keyword">let</span> taps: <span class="type">Observable</span>&lt;<span class="type">Void</span>&gt; <span class="operator">=</span> button.rx.tap.asObservable()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次点击后弹出提示框</span></span><br><span class="line">taps.subscribe(onNext: &#123; showAlert() &#125;)</span><br></pre></td></tr></table></figure>

<p>这里 <code>taps</code> 就是按钮点击事件的序列。然后我们通过弹出提示框，来对每一次点击事件做出响应。这种编程方式叫做响应式编程。我们结合函数式编程以及响应式编程就得到了函数响应式编程。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">passwordOutlet.rx.text.orEmpty</span><br><span class="line">    .map &#123; <span class="variable">$0</span>.characters.count <span class="operator">&gt;=</span> minimalPasswordLength &#125;</span><br><span class="line">    .bind(to: passwordValidOutlet.rx.isHidden)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<p><strong>我们通过不同的构建函数，来创建所需要的数据序列。最后通过适当的方式来响应这个序列。这就是函数响应式编程。</strong></p>
]]></content>
      <categories>
        <category>响应式框架</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 并发，锁，线程同步【一】GCD</title>
    <url>/2018/04/16/20180416-iOS%20%E5%B9%B6%E5%8F%91%EF%BC%8C%E9%94%81%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E3%80%90%E4%B8%80%E3%80%91GCD/</url>
    <content><![CDATA[<p>无并发，不编程。并发在开发中是非常重要的一个技术，运用并发技术，可以写出高性能的程序，并发能够有效地利用多核心 CPU 的优势来提高数据处理的速度。作为一个码农，学好并发是十分有必要的。iOS有四种多线程编程的技术，分别是：NSThread，Cocoa NSOperation，GCD（全称：Grand Central Dispatch）, pthread。今天我们就重点讲一讲 GCD 中的并发，锁和线程同步。</p>
<h2 id="GCD-中的并发"><a href="#GCD-中的并发" class="headerlink" title="GCD 中的并发"></a>GCD 中的并发</h2><hr>
<p>GCD 队列默认就是串行的（serial），在 GCD 中创建并发队列是如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> concurrent <span class="operator">=</span> <span class="type">DispatchQueue</span>(label: <span class="string">&quot;com.demo.concurrentQueue&quot;</span>, attributes: .concurrent)</span><br></pre></td></tr></table></figure>

<p><code>DispatchQueue</code> 的 <code>attributes</code> 参数还有一个取值：<code>initiallyInactive</code>，这是可以手动管理队列执行时间的参数。<br>当一个队列声明为 <code>initiallyInactive</code> 时，这个队列不会自动开始执行，必须要调用 <code>activate()</code> 方法。对应的还有 <code>suspend()</code> 和 <code>resume()</code>。</p>
<ul>
<li><code>activate()</code>：开始执行队列</li>
<li><code>suspend()</code>：挂起队列</li>
<li><code>resume()</code>：继续执行队列</li>
</ul>
<p>关于 <code>initiallyInactive</code> 到这里为止，我们继续说说并发队列。</p>
<span id="more"></span>

<h2 id="线程安全：锁"><a href="#线程安全：锁" class="headerlink" title="线程安全：锁"></a>线程安全：锁</h2><hr>
<p>在并发中，最重要的就是如何保证线程的安全。这就涉及到一个重要的知识点：锁。在 <code>Objective-C</code> 加锁的常见方式为 <code>@synchronized</code> 关键词和 <code>NSLock</code> 对象锁。Swift 的 GCD 中我们可以使用信号量 <code>DispatchSemaphore</code> 的方式实现加锁的目的。</p>
<p><strong>我们先来说说信号量加锁的方式。</strong></p>
<h4 id="DispatchSemaphore"><a href="#DispatchSemaphore" class="headerlink" title="DispatchSemaphore"></a>DispatchSemaphore</h4><p><code>DispatchSemaphore</code> 提供了传统计数信号量的高效实现，可用于控制跨多个执行上下文访问资源。</p>
<p>举个例子：线程 A 执行的前提是需要线程 B 执行的结果，但是 A，B 是两个异步线程。简单的来说就是如何串行的执行两个异步线程。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sema <span class="operator">=</span> <span class="type">DispatchSemaphore</span>(value: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">    sema.wait()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    sema.signal()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 1</span></span><br></pre></td></tr></table></figure>

<p>上面的代码如果不用信号量处理，输出的结果为 <code>1 2</code>，<code>wait()</code> 就是阻塞当前队列，<code>signal()</code> 发出信号。<code>DispatchSemaphore</code> 的 <code>value</code> 参数表示初始的信号量，不要设置成负数，否则会抛出 <code>EXC_BAD_INSTRUCTION</code> 异常。另一个就是要保证 <code>wait()</code> 和 <code>signal()</code> 的平衡，也就是成对的出现。</p>
<p>简单的介绍了一下 <code>DispatchSemaphore</code>，现在我们用它来实现我们的锁。</p>
<p>思考一下锁是为什么会存在？锁就是为了解决不同线程之间同时的访问同一数据可能会造成意想不到的错误而存在。那么我们用 <code>DispatchSemaphore</code> 实现的时候，就是要保证当线程 A 访问数据的时候我们需要阻塞下一个线程 B 对这一块数据的访问，当 A 完成对数据的访问时，我们才能允许线程 B 对这一块数据的访问。理清思路，下面我们就来转换成代码表示：</p>
<p>我们可以将锁的逻辑封装在一个方法中，充分利用 Swift 函数式编程的优点：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">synchronized</span>(<span class="keyword">_</span> <span class="params">closure</span>: () -&gt; ()) &#123;</span><br><span class="line">    sema.wait()</span><br><span class="line">    closure()</span><br><span class="line">    sema.signal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在声明 <code>DispatchSemaphore</code> 的时候，它的初始信号量 <code>value</code> 就不能是0了，必须是1（原因很简单）。所以我们必须这样声明：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sema <span class="operator">=</span> <span class="type">DispatchSemaphore</span>(value: <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>OK，锁“做”好了，我们就开始我们的并发。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">task</span>(<span class="keyword">_</span> <span class="params">idx</span>: <span class="type">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Start sync task <span class="subst">\(idx)</span>&quot;</span>)</span><br><span class="line">    synchronized() &#123;</span><br><span class="line">        ary.append(idx)</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;End sync task <span class="subst">\(idx)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Main queue Start&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> concurrent <span class="operator">=</span> <span class="type">DispatchQueue</span>(label: <span class="string">&quot;com.demo.concurrentQueue&quot;</span>,</span><br><span class="line">                               attributes: .concurrent)</span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="number">3</span> &#123;</span><br><span class="line">    concurrent.async &#123;</span><br><span class="line">        task(idx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Main queue End&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这样我们就能保证我们 <code>ary</code> 中的数据时正确的。</p>
<h4 id="Swift-中的-synchronized"><a href="#Swift-中的-synchronized" class="headerlink" title="Swift 中的 @synchronized"></a>Swift 中的 <code>@synchronized</code></h4><p>刚才我们介绍了信号量编写的锁，接下来我们来看看 Objective-C 中的 <code>@synchronized</code>，是的，Swift 中没有 <code>@synchronized</code> 这个东西，怎么办呢？其实 <code>@synchronized</code> 底层调用的是 <code>objc_sync_enter(_ obj: Any)</code> 和 <code>objc_sync_exit(_ obj: Any)</code>。我们就直接调用这两个方法就 OK。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">synchronized</span>(<span class="keyword">_</span> <span class="params">lock</span>: <span class="keyword">Any</span>, <span class="keyword">_</span> <span class="params">closure</span>: () -&gt; ()) &#123;</span><br><span class="line">    objc_sync_enter(lock)</span><br><span class="line">    closure()</span><br><span class="line">    objc_sync_exit(lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>lock</code> 参数表示要加锁的对象。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">synchronized(ary) &#123;</span><br><span class="line">    ary.append(idx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>顺便一提：</strong> <code>@synchronized</code> 是互斥锁，由于内部会进行异常处理，Objective-C 中性能一般。我们实现的 <code>DispatchSemaphore</code> 信号量锁，由于底层是 <code>C</code> 代码的封装，所以性能上要好点。</p>
<p>详细的解释可以参考我的另一篇文章：<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9lMzdlMmM0MWY2YmY=">Swift Lock<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h2><hr>
<p>线程的同步我们来介绍一下 GCD 中的 <code>DispatchGroup</code>。线程同步也可以用信号量的方式来实现，这里就不在啰嗦。</p>
<p>当我们想要在并发结束后输出 <code>ary</code> 中的数据的时候，我们就需要线程的同步了。首先我们声明一个 <code>DispatchGroup</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> group <span class="operator">=</span> <span class="type">DispatchGroup</span>()</span><br></pre></td></tr></table></figure>

<p>我们需要用到三个方法：<code>enter()</code>，<code>leave()</code>，<code>notify(...)</code>。</p>
<ul>
<li><code>enter()</code> 表示执行的开始</li>
<li><code>leave()</code> 表示执行的结束</li>
<li><code>notify(...)</code> 所有执行都结束后执行的函数</li>
</ul>
<p>我们执行的开始就是我们的并发函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">concurrent.async &#123;</span><br><span class="line">    group.enter()</span><br><span class="line">    task(idx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行的结束就是我们的task：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">task</span>(<span class="keyword">_</span> <span class="params">idx</span>: <span class="type">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Start sync task <span class="subst">\(idx)</span>&quot;</span>)</span><br><span class="line">    synchronized(ary) &#123;</span><br><span class="line">        ary.append(idx)</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;End sync task <span class="subst">\(idx)</span>&quot;</span>)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们执行输出 <code>ary</code> 信息的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">group.notify(queue: .main) &#123;</span><br><span class="line">    <span class="built_in">print</span>(ary)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift Runtime</title>
    <url>/2018/04/18/20180418-Swift%20Runtime/</url>
    <content><![CDATA[<p>我们都知道 Objective-C 是一门动态的语言，有的时候我们会使用 <code>Runtime</code> 处理一些在 Objective-C 上面无法实现或者很难实现的功能。例如：在扩展中添加属性；动态的获取属性的名称，方法名等。那么究竟什么是 <code>Runtime</code>？</p>
<p><strong>什么是 <code>Runtime</code> ？</strong></p>
<p><code>Runtime</code> 简称运行时。Objective-C 就是运行时机制，也就是在程序运行时候的一些机制，其中最主要的是消息机制。对于我们熟悉的C语言，函数的调用在编译的时候会决定调用哪个函数。但对于 Objective-C 的函数，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。</p>
<p>也就有了下面这两点结论：</p>
<ol>
<li>在编译阶段，Objective-C 可以调用任何函数，即使这个函数并未实现，只要声明过就不会报错。</li>
<li>在编译阶段，C语言调用未实现的函数就会报错。</li>
</ol>
<span id="more"></span>

<h3 id="Swift-中的-Runtime"><a href="#Swift-中的-Runtime" class="headerlink" title="Swift 中的 Runtime"></a>Swift 中的 Runtime</h3><hr>
<p>好了上面说了这么多都是在说 Objective-C 的 <code>Runtime</code>，那么 Swift 的 <code>Runtime</code> 是什么样的呢？我们来写几行代码看一下。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> address: <span class="type">String</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">myPrint</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Demo&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count: <span class="type">UInt32</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> demo <span class="operator">=</span> <span class="type">Demo</span>()</span><br><span class="line"><span class="keyword">let</span> list <span class="operator">=</span> class_copyPropertyList(object_getClass(demo), <span class="operator">&amp;</span>count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="built_in">numericCast</span>(count) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> item <span class="operator">=</span> list<span class="operator">?</span>[idx],</span><br><span class="line">        <span class="keyword">let</span> name <span class="operator">=</span> <span class="type">String</span>(utf8String: property_getName(item)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Property: <span class="subst">\(name)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>猜一下，会输出什么？当然，<strong>这里什么都不输出</strong>！为什么？因为我们创建的类 <code>Demo</code> 是一个纯 Swift 的类，因为 Swift 是一门静态语言，所以我们对其运用 <code>Runtime</code> 机制当然是不可能获取到 <code>Demo</code> 类的属性的。如果我非要在 Swift 代码中运用 <code>Runtime</code> 技术呢？当然是有办法的。我们可以在你要获取的属性（函数同理）前用 <code>@objc</code> 修饰即可（当然加上 <code>dynamic</code> 也是可以的，不过编译器会提示错误，必须要在 <code>dynamic</code> 前添加 <code>@objc</code>），就像如下这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">dynamic</span> <span class="keyword">var</span> address: <span class="type">String</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">func</span> <span class="title function_">myPrint</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Demo&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在添加如下的代码来打印出方法名：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fCount: <span class="type">UInt32</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> funcList <span class="operator">=</span> class_copyMethodList(object_getClass(demo), <span class="operator">&amp;</span>fCount)</span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="built_in">numericCast</span>(fCount) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> item <span class="operator">=</span> funcList<span class="operator">?</span>[idx] &#123;</span><br><span class="line">        <span class="keyword">let</span> name <span class="operator">=</span> <span class="type">NSStringFromSelector</span>(method_getName(item))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Method: <span class="subst">\(name)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Property</span>: name</span><br><span class="line"><span class="type">Property</span>: address</span><br><span class="line"><span class="type">Method</span>: address</span><br><span class="line"><span class="type">Method</span>: name</span><br><span class="line"><span class="type">Method</span>: setName:</span><br><span class="line"><span class="type">Method</span>: setAddress:</span><br><span class="line"><span class="type">Method</span>: myPrint</span><br></pre></td></tr></table></figure>

<p>为什么加上 <code>@objc</code> 就有 <code>Runtime</code> 机制了呢？Swift 不是静态语言吗？</p>
<p>我们来看一下官方文档里对 <code>@objc</code> 是怎么说的。</p>
<blockquote>
<p>把这个特性用到任何可以在 Objective-C 中表示的声明上——例如，非内嵌类，协议，非泛型枚举（原始值类型只能是整数），类和协议的属性、方法（包括 <code>setter</code> 和 <code>getter</code> ），初始化&gt; &gt; 器，反初始化器，下标。 <code>objc</code> 特性告诉编译器，这个声明在 Objective-C 代码中是可用的。</p>
<p>给扩展应用这个特性与为这个扩展中所有不显式标记为 nonobjc 特性的成员应用是一样的效果。</p>
<p>用 <code>objc</code> 特性标记的类必须继承自一个 Objective-C 中定义的类。如果你把 <code>objc</code> 用到类或协议中，它会隐式地应用于该类或协议中 Objective-C 兼容的成员上。如果一个类继承自另一个&gt; 带 <code>objc</code> 特性标记或 Objective-C 中定义的类，编译器也会隐式地给这个类添加 <code>objc</code> 特性。标记为 <code>objc</code> 特性的协议不能继承自非 <code>objc</code> 特性的协议。</p>
<p><code>objc</code> 特性同样会在下面的情况中隐式地添加：</p>
<ul>
<li>声明是子类的重写，并且父类的声明有 <code>objc</code> 特性；</li>
<li>声明满足的需求来自一个拥有 <code>objc</code> 特性的协议；</li>
<li>声明有 <code>IBAction</code> , <code>IBOutlet</code> , <code>IBDesignable</code> , <code>IBInspectable</code> , <code>NSManaged</code>, 或者 <code>GKInspectable</code> 特性。</li>
</ul>
<p>如果你在一个枚举中使用 <code>objc</code> 特性，枚举名和每个成员名串联起来，作为枚举成员暴露给 Objective-C 代码。成员名首字母大写。例如，一个 Swift  <code>Planet</code> 枚举成员叫做 <code>venus</code> ，&gt; 它作为一个叫 <code>PlanetVenus</code> 的成员暴露到 Objective-C 代码中。</p>
<p><code>objc</code> 特性可以接受一个特性实参，由一个标识符组成。当你想在 Objective-C 中为 <code>objc</code> 特性标记的实体暴露一个不同的名字时，用这个特性。你可以把这个实参用在命名类，枚举，枚举成&gt; 员，协议，方法，getter，setter，初始化器。下面的例子把 ExampleClass 中 enabled 属性的getter作为 isEnabled 暴露给 Objective-C 代码，而不仅仅是属性本身的名字。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@objc</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleClass</span>: <span class="title class_ inherited__">NSObject</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> enabled: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">@objc(isEnabled)</span> <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="comment">// Return the appropriate value</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>首先有 <code>@objc</code> 这个关键字，它是用来将 Swift 的 API 暴漏给 Objective-C 和 <code>Runtime</code> 使用的，文档里也很清楚的说明了，如果你类继承自 Objective-C 的类，这个标识符就会被自动加进去，加了这标识符的属性、方法无法保证都会被运行时调用，因为 Swift 会做静态优化，想要完全被声明成动态调用，必须使用 <code>dynamic</code> 标识符修饰，当然添加了 <code>dynamic</code> 的时候，它会自己在加上 <code>@objc</code> 这个标识符。</p>
<p>举个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>: <span class="title class_ inherited__">NSObject</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> dBool <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> dInt <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">demoTest</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;NSObject Class&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这时我们没有在 <code>dBool</code> 和 <code>dInt</code> 两个属性添加 <code>@objc</code> 修饰，但是 <code>Runtime</code> 时依然能够获取到，因为类继承了 Objective-C 中的 <code>NSObject</code>，他会隐式的在属相前面添加 <code>@objc</code>，同理，继承自 <code>UIViewController</code> 等的类，都有这个特性。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C 回顾【一】之 熟悉 Objective-C</title>
    <url>/2018/04/22/20180422-Objective-C%20%E5%9B%9E%E9%A1%BE%E3%80%90%E4%B8%80%E3%80%91%E4%B9%8B%20%E7%86%9F%E6%82%89%20Objective-C/</url>
    <content><![CDATA[<h3 id="Objective-C-语言的起源"><a href="#Objective-C-语言的起源" class="headerlink" title="Objective-C 语言的起源"></a>Objective-C 语言的起源</h3><hr>
<p>Objective-C 与 C++，Java 等面向对象的语言类似，不过在很多地方还是有所差别。Objective-C 使用“消息结构”（messaging structure）而非“函数调用”（function calling）。</p>
<p>消息结构的语言与函数调用的语言关键区别在于：</p>
<ul>
<li>使用消息结构的语言，其运行时所应执行的代码由运行环境决定，也就是说，在运行时才会检查对象类型。接收一条消息之后，究竟应执行何种代码，由运行期环境而非编译器来决定；</li>
<li>使用函数调用的语言，运行时所执行的代码由编译器决定；</li>
</ul>
<p><strong>要点：</strong></p>
<ul>
<li>Objective-C 为 C 语言添加了面向对象特性，是其超集。Objective-C 使用动态绑定的消息结构，也就是说，在运行时才会检查对象类型。接收一条消息之后，究竟应执行何种代码，由运行期环境而非编译器来决定。</li>
<li>理解 C 语言的核心概念有助于写好 Objective-C 程序。尤其要掌握内存模型与指针。</li>
</ul>
<h3 id="在类的头文件中尽量少引入其他头文件"><a href="#在类的头文件中尽量少引入其他头文件" class="headerlink" title="在类的头文件中尽量少引入其他头文件"></a>在类的头文件中尽量少引入其他头文件</h3><hr>
<p>在类的头文件中（.h）我们一般不需要知道引入的某个类的全部细节，这时候，我们可以用 <code>@class</code> 关键字去告诉编译器，知道有一个类名为 xxx 的类就好，不需要关注细节。</p>
<p>这叫做“向前声明”（forward declaring）该类。在实现文件（.m）中我们使用该类时就需要知道其所有细节，这时我们需要用 <code>#import</code> 关键字去导入 xxx 类的头文件。</p>
<p>将引入头文件的时机尽量延后，只有确有需要时才引入，这样就能减少类的使用者所需引入头文件的数量。这样能够一定程度上的<strong>减少编译的时间</strong>。</p>
<span id="more"></span>

<p>向前声明也解决了<strong>两个类相互引用的问题</strong>。如果 A 类的头文件中引用了 B 类，B 类的头文件中又引用了 A 类，那么意味着这两个类里有一个无法被正确编译。</p>
<p>但是在写继承和协议的时候，又不能避免的要在头文件中引用其他的头文件。最好的解决方式就是<strong>将协议放在一个单独的头文件中</strong>，这样就能避免如果协议是放在一个很大的头文件中的话，就需要引用那个头文件中的所有内容。这样不仅可能产生相互依赖的问题，还有可能会增加编译时间。</p>
<p><strong>要点：</strong></p>
<ul>
<li>除非确有必要，否则不要引入头文件。一般来说，应在某个类的头文件中使用向前声明来提及别的类，并在实现文件中引入那些类的头文件。这样做可以尽量降低类之间的耦合。</li>
<li>有时无法使用向前声明，比如要声明某个类遵循一项协议。这种情况下，尽量把“该类遵循某协议”的这条声明移至“class-continuation分类”中。如果不行的话，就把协议单独放在一个头文件中，然后将其引入。</li>
</ul>
<h3 id="多用字面量语法，少用与之等价的方法"><a href="#多用字面量语法，少用与之等价的方法" class="headerlink" title="多用字面量语法，少用与之等价的方法"></a>多用字面量语法，少用与之等价的方法</h3><hr>
<p><strong>要点：</strong></p>
<ul>
<li>应该使用字面量语法来创建字符串，数值，数组，字典。与创建此类对象的常规方法相比，这么做更加简明扼要。</li>
<li>应该通过取下标操作来访问数组下标或字典中的键所以对应的元素。</li>
<li>用字面量语法创建数组或字典时，若值中有nil，则会抛出异常。因此，务必确保值里不含nil。</li>
</ul>
<h3 id="多用类型常量，少用-define-预处理指令"><a href="#多用类型常量，少用-define-预处理指令" class="headerlink" title="多用类型常量，少用 #define 预处理指令"></a>多用类型常量，少用 #define 预处理指令</h3><hr>
<p>我们在写动画的时候，很多人喜欢将动画的持续时间常量写成预处理指令的形式，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ANIMATION_DURATION 0.3</span></span><br></pre></td></tr></table></figure>

<p>这样做并不算错，但是有两个问题：</p>
<ul>
<li>定义出来的常量没有类型信息。</li>
<li>预处理指令过程会把碰到的所有 <code>ANIMATION_DURATION</code> 一律替换成 0.3，这样的话，假设此指令声明在某个头文件中，那么所有引入了这个头文件的代码，其 <code>ANIMATION_DURATION</code> 都会被替换掉。</li>
</ul>
<p>改成下面的方式就会更好一点：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> kAnimationDuration = <span class="number">0.3</span>;</span><br></pre></td></tr></table></figure>

<p>这里有个命名习惯：</p>
<ul>
<li>若常量局限于某“编译单元”（translation unit，也就是“实现文件”，implementation file）之内，则在前面加字幕k。</li>
<li>若常量在类之外可见，则通常以类名为前缀。</li>
</ul>
<p>变量一定要同时用 <code>static</code> 和 <code>const</code> 来声明。如果试图修改由 <code>const</code> 修饰符所声明的变量，那么编译器就会报错。而 <code>static</code> 修饰符则意味着该变量仅在定义此变量的编译单元中可见。在 Objective-C 中”编译单元”一词通常指每个类的实现文件（以 .m 为后缀名）。如果不加 <code>static</code>，则编译器会为它创建一个“外部符号”（external symbol）。此时若是另一个编译单元中也声明了同名变量，那么编译器就抛出一条错误信息：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">duplicate symbol _kAnimationDuration <span class="keyword">in</span>：</span><br><span class="line">    xxx.o</span><br><span class="line">    aaa.o</span><br></pre></td></tr></table></figure>

<p>实际上，如果一个变量既声明为 <code>static</code>，又声明为 <code>const</code>，那么编译器根本不会创建符号，而是会像 <code>#define</code> 预处理指令一样，把所有遇到的变量都替换为常量。不过还是要记住：用这种方式定义的常量带有类型信息。</p>
<p>如果需要对外公开某个常量。需要将常量放在“全局符号表”（global symbol table）中，以便可以在定义该常量的编译单元之外使用。应该这样来定义：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头文件中</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> xxx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现文件中</span></span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> xxx = x;</span><br></pre></td></tr></table></figure>

<p><code>extern</code> 关键字是告诉编译器，在全局符号表中将会有一个名叫 <code>xxx</code> 的符号。也就是说，编译器无须查看其定义，即允许代码使用此常量。因为它知道，当链接成二进制文件之后，肯定能找到这个常量（如果不在实现文件中定义，编译器将会报错，二进制文件中找不到该常量）。</p>
<p><strong>要点：</strong></p>
<ul>
<li>不要用预处理指令定义常量。这样定义出来的常量不含类型信息，编译器只是会在编译前据此执行查找与替换操作。即使有人重新定义了常量值，编译器也不会产生警告信息，这将导致应用程序中的常量值不一致。</li>
<li>在实现文件中使用 <code>static const</code> 来定义“只在编译单元内可见的常量”（translation unit specific constant）。由于此类常量不在全局符号表中，所以无须为其名称加前缀。</li>
<li>在头文件中使用 <code>extern</code> 来声明全局常量，并在相关实现文件中定义其值。这种常量要出现在全局符号表中，所以其名称应加以区隔，通常与之相关的类名做前缀。</li>
</ul>
<h3 id="用枚举表示状态、选项、状态码"><a href="#用枚举表示状态、选项、状态码" class="headerlink" title="用枚举表示状态、选项、状态码"></a>用枚举表示状态、选项、状态码</h3><hr>
<p><strong>要点：</strong></p>
<ul>
<li>应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这些值起一个易懂的名字。</li>
<li>如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，那么就将各选项值定义为 2 的幂，以便通过按位或操作将其组合起来。</li>
<li>用 NS_ENUM 与 NS_OPTIONS 宏来定义枚举类型，并指明其底层数据类型。这样做可以确保枚举是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型。</li>
<li>在处理枚举类型的 <code>switch</code> 语句中不要实现 <code>default</code> 分支。这样的话，加入新枚举之后，编译器就会提示开发者：<code>switch</code> 语句并未处理所有枚举。</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C 回顾【二】之 对象、消息、运行期</title>
    <url>/2018/04/23/20180423-Objective-C%20%E5%9B%9E%E9%A1%BE%E3%80%90%E4%BA%8C%E3%80%91%E4%B9%8B%20%E5%AF%B9%E8%B1%A1%E3%80%81%E6%B6%88%E6%81%AF%E3%80%81%E8%BF%90%E8%A1%8C%E6%9C%9F/</url>
    <content><![CDATA[<p>用 Objective-C 等面向对象语言编程时，“对象”（object）就是“基本构造单元”（building block），开发者可以通过对象来存储并传递数据。在对象之间传递数据并执行任务的过程就叫做“消息传递”（Messaging）。若想编写出高效且易维护的代码，就一定要熟悉这两个特性的工作原理。</p>
<p>当应用程序运行起来以后，为其提供相关支持的代码叫做“Objective-C 运行期环境”（Objective-C runtime），它提供了一些使得对象之间能够传递消息的重要函数，并且包含创建类实例所用的全部逻辑。在理解了运行期环境中各个部分协同工作的原理之后，你的开发水平将会进一步提升。</p>
<h3 id="理解“属性”这一概念"><a href="#理解“属性”这一概念" class="headerlink" title="理解“属性”这一概念"></a>理解“属性”这一概念</h3><hr>
<p>“属性”（property）是 Objective-C 的一项特性，用于封装对象中的数据。Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”（access method）来访问，也就是 <code>getter</code> 和 <code>setter</code> 方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCPerson</span>: <span class="title">NSOjbect</span> </span>&#123;</span><br><span class="line"><span class="keyword">@public</span></span><br><span class="line">    <span class="built_in">NSString</span> *_firstName;</span><br><span class="line">    <span class="built_in">NSString</span> *_lastName;</span><br><span class="line"><span class="keyword">@private</span></span><br><span class="line">    <span class="built_in">NSString</span> *_someInternalData;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>上面的代码对于写过 Java 和 C++ 程序的人来说比较熟悉，但是 Objective-C 中却很少这么做。这种写法的问题是：对象布局在编译期已经固定了，只要碰到方位 <code>_firstName</code> 变量的代码，编译器就把其替换为“偏移量”（offset），这个偏移量是“硬编码”（hardcode），表示该变量距离存放对象的内存区域的起始地址有多远。这样做目前看来没什么问题，但是如果又加了一个实例变量，那就麻烦了。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCPerson</span>: <span class="title">NSOjbect</span> </span>&#123;</span><br><span class="line"><span class="keyword">@public</span></span><br><span class="line">    <span class="built_in">NSDate</span> *_dateOfBirth;</span><br><span class="line">    <span class="built_in">NSString</span> *_firstName;</span><br><span class="line">    <span class="built_in">NSString</span> *_lastName;</span><br><span class="line"><span class="keyword">@private</span></span><br><span class="line">    <span class="built_in">NSString</span> *_someInternalData;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>原来表示 <code>_firstName</code> 的偏移量现在却指向 <code>_dateOfBirth</code> 了。把偏移量硬编码于其中的那些代码都会读取到错误的值。如下图所示：</p>
<p><img src="/my_pictures/20180423/1.png"></p>
<p>如果代码使用了编译期计算出来的偏移量，那么在修改类定义之后必须重新编译，否则就会出错。例如，某个代码库中的代码使用了一份旧的类定义。如果和其相链接的代码使用了新的类定义，那么运行时就会出现不兼容的现象。</p>
<p>Objective-C 的解决方式：</p>
<ul>
<li>稳固的“应用程序二进制接口”（Application Binary Interface，ABI）。<ul>
<li>将实例变量当做一种存储偏移量所用的“特殊变量”，交由“类对象”保管。偏移量会在运行时期查找，如果类的定义变了，那么存储的偏移量也就变了，这样的话，无论何时访问实例变量，总能使用正确的偏移量。甚至可以在运行期向类中新增实例变量。</li>
</ul>
</li>
<li>尽量不要直接访问实例变量（在对象之外），而是通过存取方法来做。</li>
</ul>
<p>属性的优势：</p>
<ul>
<li>使用“点语法”相当于调用存取方法。</li>
<li>自动生成存取方法（前提是没有用 <code>@dynamic</code> 做限制）。<ul>
<li><code>@dynamic</code> 关键字会告诉编译器：不要自动创建属性所用的实例变量，也不要为其创建存取方法。而且，在编译访问属性代码时，即使编译器发现没有定义存取方法，也不会报错，它相信这些方法能在运行期找到。比方说，如果从 CoreData 框架中的 <code>NSManagedObject</code> 类里继承了一个子类，那么就需要在运行期动态创建存取方法。继承 <code>NSManagedObject</code> 时之所以要这样做，是因为子类的某些属性不是实例变量，其数据来自后端的数据库。</li>
</ul>
</li>
<li>自动生成加下划线的实例变量。</li>
<li>我们可以用 <code>@synthesize</code> 来指定实例变量的名字。（不推荐）</li>
</ul>
<h4 id="属性特质"><a href="#属性特质" class="headerlink" title="属性特质"></a>属性特质</h4><ul>
<li>原子性（atomic&#x2F;nonatomic）</li>
<li>读&#x2F;写权限（readwrite&#x2F;readonly）</li>
<li>内存管理语义<ul>
<li><code>assign</code>：针对于“纯量类型”（scalar type，例如：<code>CGFloat</code> 或 <code>NSInteger</code>等）的简单赋值操作。</li>
<li><code>strong</code>：定义了一种“拥有关系”。为这种属性设置新值时，设置方法会先保留新值，并释放旧值，然后再将新值设置上去。</li>
<li><code>weak</code>：定义了一种“非拥有关系”。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同 <code>assign</code> 类似，然后在属性所指的对象遭到摧毁时，属性值也会清空。</li>
<li><code>unsafe_unretained</code>：此特质的语义和 <code>assign</code> 相同，但是它适用于“对象类型”，该特质表达一种“非拥有关系”，当目标对象遭到摧毁时，属性值不会自动清空（“不安全”，unsafe），这一点与 <code>weak</code> 有区别。</li>
<li><code>copy</code>：此特质所表达的所属关系与 <code>strong</code> 类似。然而设置方法并不保留新值，而是将其“拷贝”（copy）。当属性类型为 <code>NSString*</code> 时，经常用此特质来保护其封装性。</li>
</ul>
</li>
<li>方法名<ul>
<li><code>getter=&lt;name&gt;</code> 指定“获取方法”的方法名。</li>
<li><code>setter=&lt;name&gt;</code> 指定“设置方法”的方法名。这种用法不太常见。</li>
</ul>
</li>
</ul>
<p><strong>要点：</strong></p>
<ul>
<li>可以用 <code>@property</code> 语法来定义对象中所封装的数据</li>
<li>通过“特质”来指定存储数据所需要的正确语义。</li>
<li>在设置属性所对应的实例变量时，一定要遵从该属性所声明的语义。</li>
<li>开发 iOS 程序时应该使用 <code>nonatomic</code> 属性，因为 <code>atomic</code> 属性会严重影响性能。</li>
</ul>
<h3 id="在对象内部尽量直接访问实例变量"><a href="#在对象内部尽量直接访问实例变量" class="headerlink" title="在对象内部尽量直接访问实例变量"></a>在对象内部尽量直接访问实例变量</h3><hr>
<p><strong>在读取实例变量的时候采用直接访问的形式，而在设置实例变量的时候通过属性来做。</strong>此办法既能提高读取操作的速度，又能控制对属性的写入操作。之所以要通过“设置方法”来写入实例变量，其首要原因在于，这样做能够确保相关属性的“内存管理语义”得以贯彻。选用这种做法时，需要注意两点：</p>
<ul>
<li>在初始化方法中应该如何设置属性值。这种情况下<strong>总是应该直接访问实例变量</strong>，因为子类可能会“覆写”设置方法。</li>
<li>“惰性初始化”：这种情况下<strong>必须通过“获取方法”来访问属性</strong>，否则，实例变量就永远不会初始化。</li>
</ul>
<p><strong>直接访问实例变量和通过属性访问有几点区别：</strong></p>
<ul>
<li>由于不经过 Objective-C 的“方法派发”步骤，所以直接访问实例变量的速度当然比较快。在这种情况下，编译器所生成的代码会直接访问保存对象实例变量的那块内存。</li>
<li>直接访问实例变量时，不会调用其“设置方法”，这就绕过了为相关属性所定义的“内存管理语义”。比方说，如果在 ARC 下直接访问一个声明为 <code>copy</code> 的属性，那么并不会拷贝该属性，只会保留新值并释放旧值。</li>
<li>如果直接访问实例变量，那么不会触发“键值观测”（KVO）通知。这样做是否会产生问题，还取决于具体的对象行为。</li>
<li>通过属性来访问有助于排查与之相关的错误，因为可以给“获取方法”和&#x2F;或“设置方法”中新增“断点”，监控该属性的调用者及其访问时机。</li>
</ul>
<p><strong>要点：</strong></p>
<ul>
<li>在对象内部读取数据时，应该直接通过实例变量来读取，而写入数据时，则应通过属性来写</li>
<li>在初始化方法及 <code>dealloc</code> 方法中，总是应该直接通过实例变量来读写数据。</li>
<li>有时会使用惰性初始化技术配置某分数据，这种情况下，需要通过属性来读取数据。</li>
</ul>
<h3 id="理解“对象等同性”这一概念"><a href="#理解“对象等同性”这一概念" class="headerlink" title="理解“对象等同性”这一概念"></a>理解“对象等同性”这一概念</h3><hr>
<p><strong>要点：</strong></p>
<ul>
<li>若想检测对象的等同性，请提供 <code>isEqual:</code> 与hash方法。</li>
<li>相同的对象必须具有相同的哈希码，但是两个哈希码相同的对象却未必相同。</li>
<li>不要盲目的逐个检测每条属性，而是应该依照具体需求来制定检测方案。</li>
<li>编写 hash 方法时，应该使用计算速度快而且哈希码碰撞几率低的算法。</li>
</ul>
<h3 id="在既有类中使用关联对象存放自定义数据"><a href="#在既有类中使用关联对象存放自定义数据" class="headerlink" title="在既有类中使用关联对象存放自定义数据"></a>在既有类中使用关联对象存放自定义数据</h3><hr>
<p>“关联对象”（Associated Object）可以给某对象关联许多其他对象，这些对象通过“键”来区分。存储对象值的时候，可以指明“存储策略”（storage policy），用以维护相应的“内存管理语义”。</p>
<table>
<thead>
<tr>
<th>关联类型</th>
<th>等效的@property属性</th>
</tr>
</thead>
<tbody><tr>
<td>OBJC_ASSOCIATION_ASSIGN</td>
<td>assign</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>
<td>nonatomic, retain</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY_NONATOMIC</td>
<td>nonatomic, copy</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN</td>
<td>retain</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY</td>
<td>copy</td>
</tr>
</tbody></table>
<p>下列方法可以管理关联对象：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> objc_setAssociatedObject(<span class="type">id</span> object, <span class="keyword">const</span> <span class="type">void</span> *key, <span class="type">id</span> value, objc_AssociationPolicy policy);</span><br></pre></td></tr></table></figure>
<p>此方法以给定的键和策略为某对象设置关联对象值。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">id</span> objc_getAssociatedObject(<span class="type">id</span> object, <span class="keyword">const</span> <span class="type">void</span> *key);</span><br></pre></td></tr></table></figure>
<p>此方法根据给定的键从某对象中获取相应的关联对象值。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> objc_removeAssociatedObjects(<span class="type">id</span> object);</span><br></pre></td></tr></table></figure>
<p>此方法移除指定对象的全部关联对象。</p>
<p>这种做法很有用，但是只应该在其他办法行不通时才去考虑用它。若是滥用，则很快就会令代码失控，使其难于调试。“保留环”产生的原因很难查明，因为关联对象之间的关系并没有正式的定义，其内存管理语义是在关联的时候才定义的，而不是在接口中预先定好的。使用这种写法时要小心，不能仅仅因为某处可以用该写法就一定要用它。</p>
<p><strong>要点：</strong></p>
<ul>
<li>可以通过“关联对象”机制来把两个对象连起来。</li>
<li>定义关联对象时可指定内存管理语义，用以模仿定义属性时所采用的“拥有关系”与“非拥有关系”。</li>
<li>只有在其他做法不可行时才应选用关联对象，因为这种做法通常会引入难于查找的bug。</li>
</ul>
<h3 id="理解-objc-msgSend-的作用"><a href="#理解-objc-msgSend-的作用" class="headerlink" title="理解 objc_msgSend 的作用"></a>理解 objc_msgSend 的作用</h3><hr>
<p>在对象上调用方法是 Objective-C 中经常使用的功能。用 Objective-C 的术语来说，这叫做消息传递。消息有“名称”（name）或“选择器”（selector），可以接受参数，而且可能还有返回值。</p>
<p>在 Objective-C 中，如果向某对象传递消息，那就会使用动态绑定机制来决定需要调用的方法。在底层，所有方法都是普通的 C 语言函数，然而对象收到消息后，究竟该调用哪个方法则完全于运行期决定，甚至可以在程序运行时改变，这些特性使得 Objective-C 成为一门真正的动态语言。</p>
<p>给对象发消息可以这样写：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">id</span> returnValue = [someObject messageName: parameter];</span><br></pre></td></tr></table></figure>

<p>在本例中，<code>someObject</code> 叫做“接收者”（receiver），<code>messageName</code> 叫做选择器。选择器与参数合起来称为消息。编译器看到此消息后，将其转换为一条标准的 C 语言函数调用，所调用的函数乃是消息传递机制中的核心函数，叫做 <code>objc_msgSend</code>，其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> objc_msgSend(<span class="type">id</span> <span class="keyword">self</span>, SEL cmd, ...)</span><br></pre></td></tr></table></figure>

<p>这是个可变参数函数，能接受两个或两个以上的参数。第一个参数代表接收者，第二个参数代表选择器（<code>SEL</code> 是选择器的类型），后续参数就是消息中的那些参数，其顺序不变。选择器指的是方法的名字。选择器和方法这两个词经常交替使用。编译器会把刚才那个例子中的消息转换为如下函数：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">id</span> returnValue = objc_msgSend(someObject, <span class="keyword">@selector</span>(messageName:), parameter);</span><br></pre></td></tr></table></figure>

<p><code>objc_msgSend</code> 函数会依据接收者与选择器的类型来调用适当的方法。为了完成此操作，<strong>该方法需要在接收者所属的类中搜寻其方法列表，如果能找到与选择器名称相符的方法，就跳至实现代码。若是找不到，那就沿着继承体系继续向上查找，等找到合适的方法之后再跳转。如果最终还是找不到相符的方法，那就执行消息转发操作。</strong></p>
<p>这么说来，想调用一个方法似乎需要很多步骤。所幸 <code>objc_msgSend</code> 会将匹配结果缓存在“快速映射表”（fast map）里面，每个类都有这样一块缓存，若是稍后还向该类发送与选择器相同的消息，那么执行起来就很快了。当然啦，这种“快速执行路径”(fast path)还是不如“静态绑定的函数调用操作”（statically bound function call）那样迅速，不过只要把选择器缓存起来了，也就不会慢很多，实际上，消息派发（message dispatch）并非应用程序的瓶颈所在。</p>
<p>前面讲的这部分内容只描述了部分消息的调用过程，其他“边界情况”（edge case）则需要交由 Objective-C 运行环境中的另一些函数来处理</p>
<ul>
<li><code>objc_msgSend_stret</code>：如果待发送的消息要返回结构体，那么可交由此函数处理。只有当 CPU 的寄存器能够容纳得下消息返回类型时，这个函数才能处理此消息。若是返回值无法容纳于 CPU 寄存器中（比如说返回的结构体太大了），那么就由另一个函数执行派发。此时，那个函数会通过分配在栈上的某个变量来处理消息所返回的结构体。</li>
<li><code>objc_msgSend_fpret</code>：如果消息返回的是浮点数，那么可交由此函数处理。在某些架构的 CPU 中调用函数时，需要对浮点数寄存器做特殊处理，也就是说，通常所用的 <code>objc_msgSend</code> 在这种情况下并不合适。这个函数是为了处理 x86 等架构 CPU 中某些令人稍觉惊讶的奇怪状况。</li>
<li><code>objc_msgSendSuper</code>：如果要给超类发消息，例如 <code>[super message: parameter]</code>，那么就交由此函数处理。也有另外两个与 <code>objc_msgSend_stret</code> 和 <code>objc_msgSend_fpret</code> 等效的函数，用于处理发给 <code>super</code> 的相应消息。</li>
</ul>
<p>刚才曾提到，<code>objc_msgSend</code> 等函数一旦找到应该调用的方法实现之后，就会跳转过去。之所以能这样做，是因为 Objective-C 对象的每个方法都可以视为简单的 C 函数，其原型如下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;retum_type&gt; Class_selector(<span class="type">id</span> <span class="keyword">self</span>, SEL _cmd, ...)</span><br></pre></td></tr></table></figure>

<p>真正的函数名和上面写的可能不太一样，笔者用类和选择器来命名是想解释其工作原理。每个类里都有一张表格，其中的指针都会指向这种函数，而选择器的名称则是査表时所用的“键”。<code>objc_msgSend</code> 等函数正是通过这张表格来寻找应该执行的方法并跳至其实现的。请注意，原型的样子和 <code>objc_msgSend</code> 函数很像。这不是巧合，而是为了利用尾调用优化（尾递归优化）技术。令<strong>跳至方法实现</strong>这一操作变得更简单些。</p>
<p>如果某函数的最后一项操作是调用另外一个函数，那么就可以运用尾调用优化技术。编译器会生成调转至另一函数所需的指令码，而且不会向调用堆栈中推人新的“栈帧”（frame stack）。只有当某函数的最后一个操作仅仅是调用其他函数而不会将其返回值另作他用时，才能执行尾调用优化。这项优化对 <code>objc_msgSend</code> 非常关健，如果不这么做的话，那么每次调用 Objective-C 方法之前，都需要为调用 <code>objc_msgSend</code> 函数准备栈帧。，大家在“栈踪迹”（stack trace）中可以看到这种“栈帧”。此外，若是不优化，还会过早地发生“栈溢出”现象。</p>
<p><strong>要点：</strong></p>
<ul>
<li>消息接收者、选择器及参数构成。给某对象发送消息也就相当于在该对象上调用方法。</li>
<li>发给某对象的全部消息都要由动态消息派发系统来处理，该系统会查出对应的方法，并执行其代码。</li>
</ul>
<h3 id="理解消息转发机制"><a href="#理解消息转发机制" class="headerlink" title="理解消息转发机制"></a>理解消息转发机制</h3><hr>
<p>若想令类能理解某条消息，我们必须用代码实现出对应的方法才行。但是，在编译期向类发送了其无法解读的消息并不会报错，因为在运行期可以继续向类中添加方法，所以编译器在编译时还无法确知类中到底会不会有某个方法实现。当对象接收到无法解读的消息<br>后，就会启动消息转发机制，程序员可经由此过程告诉对象应该如何处理未知消息。</p>
<p><strong>消息转发分为两大阶段：</strong></p>
<ul>
<li>第一阶段先征询接收者，所属的类，看其是否能动态添加方法，以处理当前这个未知的选择器，这叫做<strong>动态方法解析</strong>。</li>
<li>第二阶段涉及<strong>完整的消息转发机制</strong>。如果运行期系统已经把第一阶段执行完了，那么接收者自己就无法再以动态新增方法的手段来响应包含该选择器的消息了。此时，运行期系统会请求接收者以其他手段来处理与消息相关的方法调用。这又细分为两小步。<ul>
<li>首先，请接收者看看有没有其他对象能处理这条消息。若有，则运行期系统会把消息转给那个对象，于是消息转发过程结束，一切如常。</li>
<li>若没有备援的接收者，则启动完整的消息转发机制，运行期系统会把与消息有关的全部细节都封装到 <code>NSInvocation</code> 对象中，再给接收者最后一次机会，令其设法解决当前还未处理的这条消息。</li>
</ul>
</li>
</ul>
<h4 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h4><hr>
<p>对象在收到无法解读的消息后，首先将调用其所属类的下列类方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">BOOL</span>)resolveInstanceMethod:(SEL)sel</span><br></pre></td></tr></table></figure>

<p>该方法的参数就手那个未知的选择器，其返回值为 <code>Boolean</code> 类型。表示这个类是否能新增一个实例方法用以外理此选择器。在继续往下执行转发机制之前，本类有机会新增一个处理此选择器的方法。假如尚未实现的方法不是实例方法而是类方法，那么运行期系统就会调用另外一个方法，该方法与 <code>resolveInstanceMethod:</code> 类似，叫做 <code>resolveClassMethod:</code>。</p>
<p>使用这种办法的前提是：相关方法的实现代码已经写好，只等着运行的时候动态插入到类里面就可以了。此方案常用来实现 <code>@dynamic</code> 属性，比如说，要访问 <code>CoreData</code>框架中 <code>NSManagedObjects</code> 对象的属性时就可以这么做，因为实现这些属性所需的存取方法在编译期就能确定。</p>
<p>下列代码演示了如何用 <code>resolveInstanceMethod</code> 来实现 <code>@dynamic</code> 属性：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">id</span> dynmaicGetMethod(<span class="type">id</span> <span class="keyword">self</span>, SEL _cmd);</span><br><span class="line"><span class="type">void</span> dynmaicSetMethod(<span class="type">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="type">id</span> value);</span><br><span class="line"></span><br><span class="line">+ (<span class="type">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(sel);</span><br><span class="line">    <span class="keyword">if</span> ([selectorString hasPrefix:<span class="string">@&quot;set&quot;</span>]) &#123;</span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)dynmaicSetMethod, <span class="string">&quot;v@:@&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)dynmaicGetMethod, <span class="string">&quot;@@:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="备援接收者"><a href="#备援接收者" class="headerlink" title="备援接收者"></a>备援接收者</h4><p>当前接收者还有第二次机会能处理未知的选择器，在这一步中，运行期系统会问它：能不能把这条消息转给其他接收者来处理。与该步骤对应的处理方法如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">id</span>)forwardingTargetForSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure>

<p>方法参数代表未知的选择器，若当前接收者能找到备援对象，则将其返回，若找不到，就返回 <code>nil</code>。通过此方案，我们可以用“组合”(composition)来模拟出多重继承的某些特性。在一个对象内部，可能还有一系列其他对象，该对象可经由此方法将能够处理某选择器的相关内部对象返回，这样的话，在外界看来，好像是该对象亲自处理了这些消息似的。</p>
<p>请注意，<strong>我们无法操作经由这一步所转发的消息</strong>。若是想在发送给备援接收者之前先修改消息内容，那就得通过完整的消息转发机制来做了。</p>
<h4 id="完整的消息转发"><a href="#完整的消息转发" class="headerlink" title="完整的消息转发"></a>完整的消息转发</h4><p>如果转发算法巳经来到这一步的话，那么唯一能做的就是启用完整的消息转发机制了。首先创建 <code>NSInvocalion</code> 对象，把与尚未处理的那条消息有关的全部细节都封于其中，此对象包含选择器、目标（target）及参数。在触发 <code>NSInvocation</code> 对象时，消息派发系统将亲自出马，把消息指派给目标对象。</p>
<p>此步骤会调用下列方法来转发消息：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation</span><br></pre></td></tr></table></figure>

<p>这个方法可以实现得很简单：只需改变调用目标，使消息在新目标上得以调用即可。然而这样实现出来的方法与备援接收者方案所实现的方法等效，所以很少有人采用这么简单的实现方式。比较有用的实现方式为：在触发消息前，先以某种方式改变消息内容，比如追加另外一个参数，或是改换选择器，等等。</p>
<p>实现此方法时，若发现某调用操作不应由本类处理，则需调用超类的同名方法。这样的话，继承体系中的每个类都有机会处理此调用请求，直至 <code>NSObject</code>。如果最后调用了 <code>NSObject</code> 类的方法，那么该方法还会继而调用 <code>doesNotRecognizeSelector:</code> 以抛出异常，此异常表名选择器最终未能得到处理。</p>
<p><img src="/my_pictures/20180423/2.png"></p>
<h4 id="一个完整的例子"><a href="#一个完整的例子" class="headerlink" title="一个完整的例子"></a>一个完整的例子</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DemoHelper</span>: <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)myPrint:(<span class="built_in">NSString</span> *)message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DemoHelper</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)myPrint:(<span class="built_in">NSString</span> *)message &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;DemoHelper: %@&quot;</span>, message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Demo</span> ()</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">id</span> helper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *propertyDictionary;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Demo</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@dynamic</span> name, sex;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        helper = [[DemoHelper alloc] init];</span><br><span class="line">        _propertyDictionary = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">id</span> dynmaicGetMethod(<span class="type">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">NSString</span> *key = <span class="built_in">NSStringFromSelector</span>(_cmd);</span><br><span class="line">    Demo *typedSelf = (Demo *)<span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">return</span> [typedSelf.propertyDictionary objectForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> dynmaicSetMethod(<span class="type">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="type">id</span> value) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">NSString</span> *selectorName = <span class="built_in">NSStringFromSelector</span>(_cmd);</span><br><span class="line">    <span class="built_in">NSMutableString</span> *key = [selectorName mutableCopy];</span><br><span class="line">    [key deleteCharactersInRange:<span class="built_in">NSMakeRange</span>(key.length - <span class="number">1</span>, <span class="number">1</span>)];</span><br><span class="line">    [key deleteCharactersInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">3</span>)];</span><br><span class="line">    <span class="built_in">NSString</span> *firstCharacter = [[key substringToIndex:<span class="number">1</span>] lowercaseString];</span><br><span class="line">    [key replaceCharactersInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">1</span>) withString:firstCharacter];</span><br><span class="line">    <span class="comment">//处理字符串，比如吧setName:处理为name</span></span><br><span class="line">    Demo *typedSelf = (Demo *)<span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        typedSelf.propertyDictionary[key] = value;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        [typedSelf.propertyDictionary removeObjectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(setName:) || sel == <span class="keyword">@selector</span>(setSex:)) &#123;</span><br><span class="line">        <span class="comment">//是Set方法</span></span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)dynmaicSetMethod, <span class="string">&quot;v@:@&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(name) || sel == <span class="keyword">@selector</span>(sex)) &#123;</span><br><span class="line">        <span class="comment">//是get方法</span></span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)dynmaicGetMethod, <span class="string">&quot;@:@&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里注销 helper 返回值是为了消息继续向下传递，调用 forwardInvocation: 方法</span></span><br><span class="line">- (<span class="type">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __FUNCTION__);</span><br><span class="line"><span class="comment">//    if (aSelector == @selector(myPrint:)) &#123;</span></span><br><span class="line"><span class="comment">//        return helper;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 forwardInvocation: 方法前需要先调用此方法生成方法签名</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *signature = [<span class="variable language_">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">    <span class="keyword">if</span> (!signature) &#123;</span><br><span class="line">        <span class="comment">//生成方法签名</span></span><br><span class="line">        signature = [helper methodSignatureForSelector:aSelector];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="keyword">if</span> (!helper) &#123;</span><br><span class="line">        [<span class="keyword">self</span> doesNotRecognizeSelector: [anInvocation selector]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改参数</span></span><br><span class="line">    <span class="built_in">NSString</span> *message = <span class="string">@&quot;This is a message&quot;</span>;</span><br><span class="line">    [anInvocation setArgument:&amp;message atIndex:<span class="number">2</span>];</span><br><span class="line">    [anInvocation invokeWithTarget:helper];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>① 中所说的第四个参数是 <code>types</code>：描述方法参数类型的字符数组。有关可能的值，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvZXRjL3JlZGlyZWN0L3hjb2RlL2NvbnRlbnQvMTE4OS9kb2N1bWVudGF0aW9uL0NvY29hL0NvbmNlcHR1YWwvT2JqQ1J1bnRpbWVHdWlkZS9JbnRyb2R1Y3Rpb24vSW50cm9kdWN0aW9uLmh0bWwjLy9hcHBsZV9yZWYvZG9jL3VpZC9UUDQwMDA4MDQ4">Objective-C Runtime Programming Guide<i class="fa fa-external-link-alt"></i></span> &gt; <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvZXRjL3JlZGlyZWN0L3hjb2RlL2NvbnRlbnQvMTE4OS9kb2N1bWVudGF0aW9uL0NvY29hL0NvbmNlcHR1YWwvT2JqQ1J1bnRpbWVHdWlkZS9BcnRpY2xlcy9vY3J0VHlwZUVuY29kaW5ncy5odG1sIy8vYXBwbGVfcmVmL2RvYy91aWQvVFA0MDAwODA0OC1DSDEwMA==">Type Encodings<i class="fa fa-external-link-alt"></i></span>。由于函数至少需要两个参数 <code>self</code> 和 <code>_cmd</code>，所以第二个和第三个字符必须是“@：”（第一个字符是返回类型）。</p>
<p>举个例子：</p>
<p>“v@:”</p>
<ul>
<li>v：返回值为 <code>void</code></li>
<li>@：参数 <code>self</code></li>
<li>“:”：选择器 <code>SEL(_cmd)</code> </li>
<li>无参数</li>
</ul>
<p>“i@:@”</p>
<ul>
<li>i：返回值类型为 <code>int</code></li>
<li>@：同上</li>
<li>“:”：同上</li>
<li>@：参数（id）</li>
</ul>
<p>我们运行代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Demo *demo = [[Demo alloc] init];</span><br><span class="line">demo.name = <span class="string">@&quot;Tom&quot;</span>;</span><br><span class="line">demo.sex = <span class="string">@&quot;Male&quot;</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;name: %@, sex: %@&quot;</span>, demo.name, demo.sex);</span><br><span class="line"></span><br><span class="line">[demo myPrint:<span class="string">@&quot;demo print&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+[Demo resolveInstanceMethod:]</span><br><span class="line">dynmaicSetMethod</span><br><span class="line">+[Demo resolveInstanceMethod:]</span><br><span class="line">dynmaicSetMethod</span><br><span class="line">+[Demo resolveInstanceMethod:]</span><br><span class="line">dynmaicGetMethod</span><br><span class="line">+[Demo resolveInstanceMethod:]</span><br><span class="line">dynmaicGetMethod</span><br><span class="line">name: Tom, sex: Male</span><br><span class="line">+[Demo resolveInstanceMethod:]</span><br><span class="line">-[Demo forwardingTargetForSelector:]</span><br><span class="line">-[Demo methodSignatureForSelector:]</span><br><span class="line">+[Demo resolveInstanceMethod:]</span><br><span class="line">+[Demo resolveInstanceMethod:]</span><br><span class="line">-[Demo forwardInvocation:]</span><br><span class="line">DemoHelper: This is a message</span><br></pre></td></tr></table></figure>

<p><strong>要点：</strong></p>
<ul>
<li>若对象无法响应某个选择器，则进入消息转发流程。</li>
<li>通过运行期的动态方法解析功能，我们可以在需要用到某个方法时再将其加入类中。</li>
<li>对象可以把其无法解读的某些选择器转交给其他对象来处理。</li>
<li>经过上述两步之后，如果还是没办法处理选择器，那就启动完整的消息转发机制。</li>
</ul>
<h3 id="用方法调配（method-swizzling）技术调试“黑盒方法”"><a href="#用方法调配（method-swizzling）技术调试“黑盒方法”" class="headerlink" title="用方法调配（method swizzling）技术调试“黑盒方法”"></a>用方法调配（method swizzling）技术调试“黑盒方法”</h3><hr>
<p>与给定的选择器名称相对应的方法也是可以在运行期改变的。我们既不需要源代码，也不需要通过继承子类型来覆写方法就能改变这个类本身的功能。这样一来，新功能将在本类的所有实例中生效，而不是仅限于覆写了相关方法的那些子类实例。此方案经常称为“方法调配”（method swizzling）。</p>
<p>类方法列表会把选择器的名称映射到相关的方法之上，使得“动态消息派发系统”能够据此找到应该调用的方法。这些方法均以函数指针的形式来表示，这种指针叫做 IMP，其原型如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">id</span> (*IMP)(<span class="type">id</span>, SEL, ...)</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<p><code>Demo</code> 中有一个 <code>lowercase</code> 方法，现在我们在 <code>Demo</code> 的类别 <code>SubDemo</code> 中交换两个方法的实现。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Demo</span> (<span class="title">SubDemo</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">        </span><br><span class="line">        SEL originalSelector = <span class="keyword">@selector</span>(lowercase);</span><br><span class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(uppercase);</span><br><span class="line">        </span><br><span class="line">        Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  我们在这里使用 class_addMethod() 函数对 originalMethod 做了一层验证，如果 self 没有实现被交换的方法，会导致失败。</span></span><br><span class="line"><span class="comment">         *  而且 self 没有交换的方法实现，但是父类有这个方法，这样就会调用父类的方法，结果就不是我们想要的结果了。</span></span><br><span class="line"><span class="comment">         *  所以我们在这里通过 class_addMethod() 的验证，如果 self 实现了这个方法，class_addMethod() 函数将会返回 NO，我们就可以对其进行交换了。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Boolean didAddMethod = class_addMethod(<span class="keyword">class</span>,</span><br><span class="line">                                               originalSelector,</span><br><span class="line">                                               method_getImplementation(swizzledMethod),</span><br><span class="line">                                               method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">            class_addMethod(<span class="keyword">class</span>,</span><br><span class="line">                            swizzledSelector,</span><br><span class="line">                            method_getImplementation(originalMethod),</span><br><span class="line">                            method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)uppercase &#123;</span><br><span class="line">    <span class="comment">// 这时候调用的其实是 Demo 类的 lowercase 方法</span></span><br><span class="line">    [<span class="keyword">self</span> uppercase];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;SubDemo uppercase&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Demo lowercase</span><br><span class="line">SubDemo uppercase</span><br></pre></td></tr></table></figure>

<p><strong>要点：</strong></p>
<ul>
<li>在运行期，可以向类中新增或替换选择器所对应的方法实现。</li>
<li>使用另一份实现来替换原有的方法实现，这道工序叫做“方法调配”，开发者常用此技术向原有的实现中添加新功能。</li>
<li>一般来说，只有调试程序的时候才需要在运行期修改方法实现，这种做法不宜滥用。</li>
</ul>
<h3 id="理解“类对象”的用意"><a href="#理解“类对象”的用意" class="headerlink" title="理解“类对象”的用意"></a>理解“类对象”的用意</h3><hr>
<p>描述 Objective-C 对象所用的数据结构定义在运行期程序库的头文件里，<code>id</code> 类型本身也定义在这里：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125; *<span class="type">id</span>;</span><br></pre></td></tr></table></figure>

<p>由此可见，每个对象结构体的首个成员是 <code>Class</code> 类的变量。该变量定义了对象所属的类，通常称为“is a”指针。例如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@&quot;Some string&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>这里的对象“是一个”（is a）<code>NSString</code>，所以其“is a”指针就指向 <code>NSString</code>。</strong><code>Class</code> 对象也定义在运行期程序库的头文件中：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">    Class super_class;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">long</span> version;</span><br><span class="line">    <span class="type">long</span> info;</span><br><span class="line">    <span class="type">long</span> instance_size;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此结构体存放类的“元数据”（metadata），例如类的实力实现了几个方法，具备多少个实例变量等信息。此结构体的首个变量也是 <code>isa</code> 指针，这说明 <code>Class</code> 本身亦为 Objective-C 对象。结构体里还有个变量叫做 <code>super_class</code>，它定义了本类的超类。类对象所属的类型（也就是 <code>isa</code> 指针所指向的类型）是另外一个类，叫做“元类”（metaclass），用来表述类对象本身所具备的元数据。<strong>“类方法”就定义与此处</strong>，因为这些方法可以理解成类对象的实例方法。每个类仅有一个“类对象”，而每个“类对象”仅有一个与之相关的“元类”。</p>
<p>假设有个名为 <code>SomeClass</code> 的子类从 <code>NSObject</code> 中继承而来，则其继承体系如图所示：</p>
<p><img src="/my_pictures/20180423/3.png"></p>
<p><strong><code>super_class</code> 指针确立了继承关系，而 <code>isa</code> 指针描述了实例所属的类。</strong>通过这张布局关系图即可执行“类型信息查询”。我们可以查出对象是否能相应某个选择器，是否遵从某项协议，并且能看出此对象位于“类继承体系”的哪一部分。</p>
<h4 id="在类继承体系中查询类型信息"><a href="#在类继承体系中查询类型信息" class="headerlink" title="在类继承体系中查询类型信息"></a>在类继承体系中查询类型信息</h4><p><strong>可以用类型信息查询方法类检视类继承体系。<code>isMemberOfClass:</code>能够判断出对象是否为某个特定类的实例，而<code>isKindOfClass:</code>则能够判断出对象是否为其类或派生类的实例。</strong>例如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Demo *demo = [[Demo alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, [demo isMemberOfClass:[Demo <span class="keyword">class</span>]]); <span class="comment">// YES</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, [demo isMemberOfClass:[SubForDemo <span class="keyword">class</span>]]); <span class="comment">// NO</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, [demo isKindOfClass:[Demo <span class="keyword">class</span>]]); <span class="comment">// YES</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, [demo isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]); <span class="comment">// NO</span></span><br></pre></td></tr></table></figure>

<p><strong>要点：</strong></p>
<ul>
<li>每个实例都有一个指向 <code>Class</code> 对象的指针，用以表明其类型，而这些 <code>Class</code> 对象则构成了类的继承体系。</li>
<li>如果对象类型无法在编译期确定，那么就应该使用类型信息查询方法来探知。</li>
<li>尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 并发，锁，线程同步【二】Operation</title>
    <url>/2018/04/30/20180430-iOS%20%E5%B9%B6%E5%8F%91%EF%BC%8C%E9%94%81%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E3%80%90%E4%BA%8C%E3%80%91Operation/</url>
    <content><![CDATA[<p>在之前的一篇文章中【<a href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/2018/04/16/iOS-%E5%B9%B6%E5%8F%91-%E9%94%81-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-%E4%B8%80-GCD/">iOS 并发，锁，线程同步【一】GCD</a>】，我们讨论了一下 <code>GCD</code> 的并发，锁和线程同步的问题，今天，我们来讨论一下 <code>Operation</code> 的并发与线程同步。</p>
<p>在 <code>Operation</code> 中，我们一般是将所有的 <code>Operation</code> 添加到 <code>OperationQueue</code> 中进行执行，这里需要注意一点，**<code>Operation</code> 添加到队列当中，默认就是执行的并发操作。<strong>我们可以设置队列的最大并发数 <code>maxConcurrentOperationCount</code>。如果我们在 <code>OperationQueue</code> 中想要执行串行任务的话，很简单，将 <code>maxConcurrentOperationCount</code> 设置成为1即可。 <code>maxConcurrentOperationCount</code> 的默认值为-1，那么默认情况下的并发数是多少呢？</strong>这个是由系统内存和 CPU 决定的，可能内存多久开多一点，内存少就开少一点。**最大并发数建议 2~3，如果并发数太多会导致 UI 卡顿。</p>
<p>不添加到队列当中的 <code>Operation</code>，我们可以调用 <code>start()</code> 方法开始一个操作，也可以调用 <code>cancel()</code> 取消等待中的操作，注意：<strong>已经开始执行的操作是没法取消的。</strong>代码示例如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> opt <span class="operator">=</span> <span class="type">BlockOperation</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Operation&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">opt.start() <span class="comment">// 开始执行任务</span></span><br><span class="line">opt.cancel() <span class="comment">// 取消等待中的任务</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>如果我们需要进行线程同步该怎么做？GCD 中我们可以用 <code>DispatchGroup</code>，在 <code>Operation</code> 中我们可以用一个 <code>addDependency()</code> 的方法。这个方法意味着，某个任务的执行，依赖着其他任务执行完成后才回去执行。代码我们可以这么写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">OperationQueue</span>()</span><br><span class="line">queue.maxConcurrentOperationCount <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> a <span class="operator">=</span> <span class="type">BlockOperation</span> &#123;</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b <span class="operator">=</span> <span class="type">BlockOperation</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c <span class="operator">=</span> <span class="type">BlockOperation</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.addDependency(a)</span><br><span class="line">c.addDependency(b)</span><br><span class="line"></span><br><span class="line">queue.addOperation(c)</span><br><span class="line">queue.addOperation(a)</span><br><span class="line">queue.addOperation(b)</span><br></pre></td></tr></table></figure>

<p>这里的 <code>c</code> 操作，需要等到 <code>a</code>, <code>b</code> 完成之后才会执行。运行结果如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">b</span><br><span class="line">a</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<p>OK，接下来我们来一点在并发中进行数据写入的操作，代码作如下修改：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">OperationQueue</span>()</span><br><span class="line">queue.maxConcurrentOperationCount <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> ary: [<span class="type">Int</span>] <span class="operator">=</span> []</span><br><span class="line"><span class="keyword">let</span> a <span class="operator">=</span> <span class="type">BlockOperation</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="number">5</span> &#123;</span><br><span class="line">        ary.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b <span class="operator">=</span> <span class="type">BlockOperation</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> <span class="number">5</span><span class="operator">..&lt;</span><span class="number">10</span> &#123;</span><br><span class="line">        ary.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c <span class="operator">=</span> <span class="type">BlockOperation</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(ary.sorted())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.addDependency(a)</span><br><span class="line">c.addDependency(b)</span><br><span class="line"></span><br><span class="line">queue.addOperation(c)</span><br><span class="line">queue.addOperation(a)</span><br><span class="line">queue.addOperation(b)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<p>很明显，运行结果是错的。并发当中对同一个数据源进行写的操作时，一定要注意加锁。具体可以看我的上一遍文章：<a href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/2018/04/16/iOS-%E5%B9%B6%E5%8F%91-%E9%94%81-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-%E4%B8%80-GCD/">iOS 并发，锁，线程同步【一】GCD</a>，这里我就不在啰嗦。</p>
<p>接下来，我们做一点代码优化，如果我想要实现 n 个任务，每个任务都是向数组中添加数字，每个任务的循环范围按照 0<del>5，5</del>10，10~15 这样的规律，最后我们输出 <code>ary</code> 中的值。</p>
<p>很明显，向上面的写法太过笨拙。那么我们进行一个函数的抽象，我们先来写一个产生 task 的函数。</p>
<p>首先我们先来定义一个 task：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> task <span class="operator">=</span> () -&gt; ()</span><br></pre></td></tr></table></figure>

<p>接下来，我们需要将产生的 task 添加到数组中，这里需要充分利用函数式编程的优点，方法看起来是这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">makeTask</span>(<span class="params">taskCount</span>: <span class="type">Int</span>, <span class="params">opt</span>: <span class="keyword">@escaping</span> (<span class="keyword">_</span> currentIdx: <span class="type">Int</span>) -&gt; task) -&gt; [task] &#123;</span><br><span class="line">    <span class="comment">// 如果任务数为0，就返回空数组</span></span><br><span class="line">    <span class="keyword">guard</span> taskCount <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> tasks: [task] <span class="operator">=</span> []</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>taskCount &#123;</span><br><span class="line">        tasks.append(opt(idx))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tasks</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个参数 taskCount 是最大任务数，第二个参数 opt 是执行的任务，是一个闭包，<strong>因为任务会存到一个数组中，供后面的方法使用，所以这个闭包是可逃逸的。</strong>我们在执行闭包的时候，需要传入一个参数，这个参数表示了当前生成的是第几个 task，返回值也是个闭包，也就是我们最终要执行的 task。OK，经过函数化，我们就可以产生<strong>任意数量、任意操作</strong>的 task 了。</p>
<p>接下来我们来处理一下并发的方法，它看起来是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">concurrent</span>(<span class="params">tasks</span>: [task], <span class="params">complationHandle</span>: <span class="keyword">@escaping</span> () -&gt; ()) &#123;</span><br><span class="line">    <span class="keyword">let</span> sema <span class="operator">=</span> <span class="type">DispatchSemaphore</span>(value: <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">OperationQueue</span>()</span><br><span class="line">    queue.maxConcurrentOperationCount <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> <span class="type">BlockOperation</span> &#123;</span><br><span class="line">        complationHandle()</span><br><span class="line">    &#125;</span><br><span class="line">    tasks.forEach &#123; t <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> o <span class="operator">=</span> <span class="type">BlockOperation</span> &#123;</span><br><span class="line">            sema.wait()</span><br><span class="line">            t()</span><br><span class="line">            sema.signal()</span><br><span class="line">        &#125;</span><br><span class="line">        result.addDependency(o)</span><br><span class="line">        queue.addOperation(o)</span><br><span class="line">    &#125;</span><br><span class="line">    queue.addOperation(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理也很简单，我们在一个 <code>forEach</code> 当中设置好 <code>Operation</code> 的 task 与依赖关系。这里用了信号量锁，来保证数据的正确性。最后我们在 <code>complationHandle</code> 这个闭包中处理同步后的数据。</p>
<p>我们来使用一下，感受一下函数式的灵活、强大之处：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ary: [<span class="type">Int</span>] <span class="operator">=</span> []</span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> tasks <span class="operator">=</span> makeTask(taskCount: <span class="number">20</span>) &#123; idx <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;task idx: <span class="subst">\(idx)</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> (idx <span class="operator">*</span> <span class="number">5</span>)<span class="operator">..&lt;</span>(idx <span class="operator">*</span> <span class="number">5</span> <span class="operator">+</span> <span class="number">5</span>) &#123;</span><br><span class="line">            ary.append(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">concurrent(tasks: tasks) &#123;</span><br><span class="line">    <span class="built_in">print</span>(ary.sorted())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">task idx: <span class="number">0</span></span><br><span class="line">task idx: <span class="number">1</span></span><br><span class="line">task idx: <span class="number">2</span></span><br><span class="line">task idx: <span class="number">3</span></span><br><span class="line">task idx: <span class="number">5</span></span><br><span class="line">task idx: <span class="number">6</span></span><br><span class="line">task idx: <span class="number">4</span></span><br><span class="line">task idx: <span class="number">7</span></span><br><span class="line">task idx: <span class="number">9</span></span><br><span class="line">task idx: <span class="number">10</span></span><br><span class="line">task idx: <span class="number">11</span></span><br><span class="line">task idx: <span class="number">8</span></span><br><span class="line">task idx: <span class="number">13</span></span><br><span class="line">task idx: <span class="number">12</span></span><br><span class="line">task idx: <span class="number">14</span></span><br><span class="line">task idx: <span class="number">15</span></span><br><span class="line">task idx: <span class="number">18</span></span><br><span class="line">task idx: <span class="number">16</span></span><br><span class="line">task idx: <span class="number">17</span></span><br><span class="line">task idx: <span class="number">19</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>, <span class="number">38</span>, <span class="number">39</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>, <span class="number">51</span>, <span class="number">52</span>, <span class="number">53</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">56</span>, <span class="number">57</span>, <span class="number">58</span>, <span class="number">59</span>, <span class="number">60</span>, <span class="number">61</span>, <span class="number">62</span>, <span class="number">63</span>, <span class="number">64</span>, <span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>, <span class="number">68</span>, <span class="number">69</span>, <span class="number">70</span>, <span class="number">71</span>, <span class="number">72</span>, <span class="number">73</span>, <span class="number">74</span>, <span class="number">75</span>, <span class="number">76</span>, <span class="number">77</span>, <span class="number">78</span>, <span class="number">79</span>, <span class="number">80</span>, <span class="number">81</span>, <span class="number">82</span>, <span class="number">83</span>, <span class="number">84</span>, <span class="number">85</span>, <span class="number">86</span>, <span class="number">87</span>, <span class="number">88</span>, <span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>, <span class="number">92</span>, <span class="number">93</span>, <span class="number">94</span>, <span class="number">95</span>, <span class="number">96</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>]</span><br></pre></td></tr></table></figure>

<p>调用还是有点麻烦？没关系我们可以将两个方法合成一个，我们把 <code>makeTask</code> 与 <code>concurrent</code> 方法设置成为私有（private），接下来写一个开放接口方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">tasksToConcurrent</span>(<span class="params">taskCount</span>: <span class="type">Int</span>, <span class="params">opt</span>: <span class="keyword">@escaping</span> (<span class="keyword">_</span> currentIdx: <span class="type">Int</span>) -&gt; task, <span class="params">complationHandle</span>: <span class="keyword">@escaping</span> () -&gt; ()) &#123;</span><br><span class="line">    <span class="keyword">let</span> tasks <span class="operator">=</span> makeTask(taskCount: <span class="number">20</span>) &#123; idx <span class="keyword">in</span> <span class="keyword">return</span> opt(idx) &#125;</span><br><span class="line">    concurrent(tasks: tasks, complationHandle: complationHandle)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们就可以这样来调用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">tasksToConcurrent(taskCount: <span class="number">20</span>, opt: &#123; idx <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;task idx: <span class="subst">\(idx)</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> (idx <span class="operator">*</span> <span class="number">5</span>)<span class="operator">..&lt;</span>(idx <span class="operator">*</span> <span class="number">5</span> <span class="operator">+</span> <span class="number">5</span>) &#123;</span><br><span class="line">            ary.append(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="built_in">print</span>(ary.sorted())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>感觉比刚开始的写法简洁了不少！！！</p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C 回顾【三】之 内存管理</title>
    <url>/2018/05/11/20180511-Objective-C%20%E5%9B%9E%E9%A1%BE%E3%80%90%E4%B8%89%E3%80%91%E4%B9%8B%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="理解引用计数"><a href="#理解引用计数" class="headerlink" title="理解引用计数"></a>理解引用计数</h2><hr>
<p>Objective-C 语言使用引用计数来管理内存，也就是说，每个对象都有个可以递增或递减的计数器。如果想使某个对象继续存活，那就递增其引用计数；用完了之后，就递减其计数。计数变为 O，就表示没人关注此对象了，于是，就可以把它销毁。</p>
<h3 id="引用计数工作原理"><a href="#引用计数工作原理" class="headerlink" title="引用计数工作原理"></a>引用计数工作原理</h3><p>Objective-C 中，调用 <code>alloc</code> 方法所返回的对象由调用者所拥有。也就是说，调用者已通过 <code>alloc</code> 方法表达了想令该对象继续存活下去的意愿。不过请注意，这并不是说对象此时的保留计数必定是 1。在 <code>alloc</code> 或。<code>initWithInt:</code> 方法的实现代码中，也许还有其他对象也保留了此对象，所以，其保留计数可能会大于 1。能够肯定的是：保留计数至少为 1。保留计数这个概念就应该这样来理解才对。绝不应该说保留计数一定是某个值，只能说你所执行的操作是递增了该计数还是递减了该计数。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *array = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line"><span class="built_in">NSNumber</span> *number = [[<span class="built_in">NSNumber</span> alloc] initWithInt:<span class="number">1337</span>];</span><br><span class="line"></span><br><span class="line">[array addObject:number];</span><br><span class="line">[number release];</span><br><span class="line"></span><br><span class="line"><span class="comment">// do something with &#x27;array&#x27;</span></span><br><span class="line"></span><br><span class="line">[array release];</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>如上面的代码，创建完数组后，把 <code>number</code> 对象加人其中。调用数组的 <code>addobject:</code> 方法时，数组也会在 <code>number</code> 上调用 <code>retain</code> 方法，以期继续保留此对象。这时，保留计数至少为 2。接下来，代码不再需要 <code>number</code> 对象了，于是将其释放。现在的保留计数至少为 1。这样就不能照常使用 <code>number</code> 变量了。调用 <code>release</code> 之后，已经无法保证所指的对象仍然存活。当然，根据本例中的代码，我们显然知道 <code>number</code> 对象在调用了 <code>release</code> 之后仍然存活。因为数组还在引用着它。然而绝不应假设此对象一定存活，也就是说，不要像下面这样编写代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *number = [[<span class="built_in">NSNumber</span> alloc] initWithInt:<span class="number">1337</span>];</span><br><span class="line">[array addObject:number];</span><br><span class="line">[number release];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span> (<span class="string">@&quot;number = %@&quot;</span>, number);</span><br></pre></td></tr></table></figure>

<p>即便上述代码在本例中可以正常执行，也仍然不是个好办法。如果调用 <code>release</code> 之后，基于某些原因，其保留计数降至 O，那么 <code>number</code> 对象所占内存也许会回收，这样的话，再调用 <code>NSLog</code> 可能就将使程序崩溃了。笔者在这里只说“可能”，而没说“一定”，因为对象所占的内存在“解除分配”（deallocated）之后，只是放回“可用内存池”（avaiable pool）。如果执行 <code>NSLog</code> 时尚未覆写对象内存，那么该对象仍然有效，这时程序不会崩溃。由此可见：因过早释放对象而导致的 bug 很难调试。</p>
<p>为避免在不经意间使用了无效对象，一般调用完 <code>release</code> 之后都会清空指针。这就能保证不会出现可能指向无效对象的指针，这种指针通常称为“悬垂指针”。比方说，可以这样编写代码来防止此情况发生：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *number = [[<span class="built_in">NSNumber</span> alloc] initWithInt:<span class="number">1337</span>];</span><br><span class="line">[array addObject:number];</span><br><span class="line">[number release];</span><br><span class="line"></span><br><span class="line">number = <span class="literal">nil</span>;</span><br></pre></td></tr></table></figure>

<h3 id="属性存取方法中的内存管理"><a href="#属性存取方法中的内存管理" class="headerlink" title="属性存取方法中的内存管理"></a>属性存取方法中的内存管理</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setFoo:(<span class="type">id</span>)foo &#123;</span><br><span class="line">    [foo <span class="keyword">retain</span>];</span><br><span class="line">    [_foo release];</span><br><span class="line">    _foo = foo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法将保留新值并释放旧值，然后更新实例变量，令其指向新值。顺序很重要。假如还未保留新值就先把旧值释放了，而且两个值又指向同一个对象，那么，先执行的 <code>release</code> 操作就可能导致系统将此对象永久回收。而后续的 <code>retain</code> 操作则无法令这个已经彻底回收的对象“复生”，于是实例变量就成了悬垂指针（nil）。</p>
<h3 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h3><p><code>autorelease</code> 此方法会在稍后递减计数，通常是在下一次“事件循环”时递减，不过也可能执行得更早些。</p>
<p>此特性很有用，尤其是在方法中返回对象时更应该用它。比如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)stringValue &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] </span><br><span class="line">                        initWithFormat:<span class="string">@&quot;I am this: %@&quot;</span>, <span class="keyword">self</span>];</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里不能在方法内释放 <code>str</code> 否则还没等方法返回，系统就把该对象回收了。这里应该调用 <code>autorelease</code>，它会在稍后释放对象，从而给调用者留下了足够长的时间，使其可以在需要时先保留返回值。换句话说，此方法可以保证对象在跨越“方法调用边界”后一定存活。实际上，释放操作会在清空最外层的自动释放池时执行，除非你有自己的自动释放池，否则这个时机指的就是当前线程的下一次事件循环。改写 <code>stringValue</code> 方法，使用 <code>autorelease</code> 来释放对象：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)stringValue &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] </span><br><span class="line">                        initWithFormat:<span class="string">@&quot;I am this: %@&quot;</span>, <span class="keyword">self</span>];</span><br><span class="line">    <span class="keyword">return</span> [str autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改之后，<code>stringValue</code> 方法把 <code>NSString</code> 对象返回给调用者时，此对象必然存活。所以我们能够像下面这样使用它：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = [<span class="keyword">self</span> stringValue];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;The string is: %@&quot;</span>, str);</span><br></pre></td></tr></table></figure>

<p>因为自动释放池中的释放操作要等到下一次事件循环时才会执行，所以 <code>NSLog</code> 语句在使用 <code>str</code> 对象前不需要手工执行保留操作。但是，假如要持有此对象的话（比如将其设置给实例变量），那就需要保留，并于稍后释放：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">_instanceVariable = [[<span class="keyword">self</span> stringValue] <span class="keyword">retain</span>];</span><br><span class="line">[_instanceVariable release];</span><br></pre></td></tr></table></figure>

<p>由此可见，<code>autorelease</code> 能延长对象生命期，使其在跨越方法调用边界后依然可以存活一段时间。</p>
<p><strong>要点：</strong></p>
<ul>
<li>引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其保留计数至少为 1。若保留计数为正，则对象继续存活。当保留计数降为 0 时，对象就被销毁了。</li>
<li>在对象生命周期中，其余对象通过引用来保留或释放此对象。保留与释放操作分别会递增递减保留计数。</li>
</ul>
<h2 id="以-ARC-简化引用计数"><a href="#以-ARC-简化引用计数" class="headerlink" title="以 ARC 简化引用计数"></a>以 ARC 简化引用计数</h2><hr>
<h3 id="变量的内存管理语义"><a href="#变量的内存管理语义" class="headerlink" title="变量的内存管理语义"></a>变量的内存管理语义</h3><ul>
<li>__strong：默认语义，保留此值。</li>
<li>__unsafe_unretained：不保留此值，这么做可能不安全，因为等到再次使用变量时，其对象可能已经回收了。</li>
<li>__weak：不保留此值，但是变量可以安全使用，因为如果系统把这个对象回收了，那么变量也会自动清空。</li>
<li>__autoreleasing：把对象“按引用传递”给方法时，使用这个特殊的修饰符。此值在方法返回时自动释放。</li>
</ul>
<p>我们经常会给局部变量加上修饰符，用以打破由“块”所引入的“引用循环”。块会自动保留其所捕获的全部对象，而如果这其中有某个对象又保留了块本身，那么就可能导致“引用循环”。可以用 <code>__weak</code> 局部变量来打破这种“引用循环”。</p>
<p><strong>要点：</strong></p>
<ul>
<li>有 ARC 之后，程序员就无须担心内存管理问题了。使用 ARC 来编程，可以省去类中的许多“样板代码”。</li>
<li>ARC 管理对象生命期的办法基本上就是：在合适的地方插入“保留”及“释放”操作。在 ARC 环境下，变量的内存管理语义可以通过修饰符指明，而原来则需要手工执行“保留”及“释放”操作。</li>
<li>由方法所返回的对象，其内存管理语义总是通过方法名来体现。ARC 将此确定为开发者必须遵守的规则。</li>
<li>ARC 只负责管理 Objective-C 对象的内存。尤其要注意：CoreFoundation 对象不归 ARC 管理，开发者必须适时调用 CFRetain&#x2F;CFRelease。</li>
</ul>
<h2 id="在-dealloc-方法中只释放引用并解除监听"><a href="#在-dealloc-方法中只释放引用并解除监听" class="headerlink" title="在 dealloc 方法中只释放引用并解除监听"></a>在 dealloc 方法中只释放引用并解除监听</h2><hr>
<p><strong>要点：</strong></p>
<ul>
<li>在 <code>dealloc</code> 方法里，应该做的事情就是释放指向其他对象的引用，并取消原来订阅的“键值观测”（KVO）或 <code>NSNotificationCenter</code> 等通知，不要做其他事情。</li>
<li>如果对象持有文件描述符等系统资源，那么应该专门编写一个方法来释放此种资源。这样的类要和其使用者约定：用完资源后必须调用 <code>close</code> 方法。</li>
<li>执行异步任务的方法不应在 <code>dealloc</code> 里调用；只能在正常状态下执行的那些方法也不应在 <code>dealloc</code> 里调用，因为此时对象已处于正在回收的状态了。</li>
</ul>
<p>未完持续…</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>在 macOS 中用命令格式化 APFS 格式 U 盘</title>
    <url>/2018/05/21/20180521-%E5%9C%A8%20macOS%20%E4%B8%AD%E7%94%A8%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F%E5%8C%96%20APFS%20%E6%A0%BC%E5%BC%8F%20U%20%E7%9B%98/</url>
    <content><![CDATA[<p>今天需要去打印店打印东西，但是 U 盘被我格式化成了 <code>APFS</code> 格式，用磁盘管理工具无法格式化成其他的格式，选项中只有 <code>APFS</code> 的选项。我用如下的命令格式化 U 盘：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo diskutil eraseDisk JHFS+ san /dev/disk3</span><br></pre></td></tr></table></figure>

<p>但是执行命令会报错，错误信息大致是，无法格式化 <code>APFS</code> 容器。</p>
<p><code>/dev/disk3</code> 是我 U 盘的目录，在执行之前请先确认自己的目录，用如下的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diskutil list </span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><code>APFS</code> 格式是无法直接进行格式化的，我们需要首先删除 <code>APFS</code> 容器。执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo diskutil apfs deleteContainer /dev/disk3</span><br></pre></td></tr></table></figure>

<p>然后你就会发现，你的 U 盘格式自动变成了 Mac OS 扩展(日志式)，之后就可以格式化成 exFAT 格式了。但是打印店识别不了，最后还是要在 windows 下格式化成 FAT32。</p>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 4.2 中有什么新功能？【译】</title>
    <url>/2018/06/13/20180613-Swift%204.2%20%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B0%E5%8A%9F%E8%83%BD%E3%80%90%E8%AF%91%E3%80%91/</url>
    <content><![CDATA[<p>好消息：Swift 4.2 现已在 Xcode 10 beta 中提供！此版本更新重要的 Swift 4.1 功能，并改进语言以准备 ABI 稳定性。 </p>
<p>本教程介绍了 Swift 4.2 中最重要的变化。它需要 Xcode 10，因此请确保你在开始之前下载并安装 Xcode 的最新测试版。</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>Swift 4.2 与 Swift 4.1 的源代码兼容，但与任何其他版本不兼容。 Apple 设计的 Swift 4.2 是在 Swift 5 中实现 ABI 稳定性的中间步骤，它应该能够在不同 Swift 版本编译的应用和库中保持二进制兼容。在集成到最终的 <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQXBwbGljYXRpb25fYmluYXJ5X2ludGVyZmFjZQ==">ABI<i class="fa fa-external-link-alt"></i></span> 之前，ABI 功能会有大量的时间来获得来自社区的反馈。</p>
<p>本教程的部分包含 <span class="exturl" data-url="aHR0cHM6Ly9hcHBsZS5naXRodWIuaW8vc3dpZnQtZXZvbHV0aW9uLw==">Swift Evolution<i class="fa fa-external-link-alt"></i></span> 提案编号，如 <code>[SE-0001]</code> 。你可以通过点击每个提案的链接标签来浏览每个更改的详细信息。</p>
<span id="more"></span>

<p>如果你尝试了 <code>playground </code> 上的更改，你将从本教程中获得最大收益。启动 Xcode 10 并转到 <strong>File ▸ New ▸ Playgruond</strong>。选择 <code>iOS</code> 平台和 <code>Blank</code> 模版。把它命名为任何你喜欢的东西，然后把它保存在你想要的任何地方。你现在准备好开始了！</p>
<blockquote>
<p>Note: 需要重温 Swift 4.1 亮点？查看我们的 Swift 4.1 教程：<span class="exturl" data-url="aHR0cHM6Ly93d3cucmF5d2VuZGVybGljaC5jb20vMTg3ODI2L3doYXRzLW5ldy1pbi1zd2lmdC00LTE=">Swift 4.1 有哪些新特性？<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h3 id="语言的改进"><a href="#语言的改进" class="headerlink" title="语言的改进"></a>语言的改进</h3><hr>
<p>这个版本中有很多语言功能的改进，例如随机数生成器，动态成员查询等等。</p>
<h4 id="生成随机数字"><a href="#生成随机数字" class="headerlink" title="生成随机数字"></a>生成随机数字</h4><p>Swift 4.1 导入 C API 来生成随机数字，如下面的代码片段所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> digit <span class="operator">=</span> <span class="type">Int</span>(arc4random_uniform(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<p><code>arc4random_uniform(_:)</code> 返回 0 到 9 之间的随机数字。它需要你导入 <code>Foundation</code> 框架，并且不能工作在 Linux 上。<br>另一方面，所有基于 Linux 的方法都引入了<strong>模偏差（modulo bias）</strong>，这意味着某些数字比其他数字更频繁地产生。</p>
<p>Swift 4.2 通过向标准库 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0LWV2b2x1dGlvbi9ibG9iL21hc3Rlci9wcm9wb3NhbHMvMDIwMi1yYW5kb20tdW5pZmljYXRpb24ubWQ=">[SE-0202]<i class="fa fa-external-link-alt"></i></span> 添加随机API来解决这些问题：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1  </span></span><br><span class="line"><span class="keyword">let</span> digit <span class="operator">=</span> <span class="type">Int</span>.random(in: <span class="number">0</span><span class="operator">..&lt;</span><span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> anotherDigit <span class="operator">=</span> (<span class="number">0</span><span class="operator">..&lt;</span><span class="number">10</span>).randomElement() &#123;</span><br><span class="line">  <span class="built_in">print</span>(anotherDigit)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Empty range.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">let</span> double <span class="operator">=</span> <span class="type">Double</span>.random(in: <span class="number">0</span><span class="operator">..&lt;</span><span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> float <span class="operator">=</span> <span class="type">Float</span>.random(in: <span class="number">0</span><span class="operator">..&lt;</span><span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> cgFloat <span class="operator">=</span> <span class="type">CGFloat</span>.random(in: <span class="number">0</span><span class="operator">..&lt;</span><span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> bool <span class="operator">=</span> <span class="type">Bool</span>.random()</span><br></pre></td></tr></table></figure>

<p>这是做什么的：</p>
<ol>
<li>使用 <code>random(in:)</code> 从指定的范围生成随机数字。</li>
<li>如果范围是空的，<code>randomElement()</code> 返回 nil，所以需要用 <code>if let</code> 来处理 <code>Int?</code>。</li>
<li>可以使用 <code>random(in:)</code> 来产生一个随机的 <code>Double</code>，<code>Float</code> 或者 <code>CGFloat</code> 和 <code>random()</code> 来返回一个随机的 <code>Bool</code>。</li>
</ol>
<p><img src="/my_pictures/20180613/1.png" alt="Generating random numbers like a pro in Swift 4.2!"></p>
<p>Swift 4.1 还使用 C 函数从数组中生成随机值：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> playlist <span class="operator">=</span> [<span class="string">&quot;Nothing Else Matters&quot;</span>, <span class="string">&quot;Stairway to Heaven&quot;</span>, <span class="string">&quot;I Want to Break Free&quot;</span>, <span class="string">&quot;Yesterday&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> index <span class="operator">=</span> <span class="type">Int</span>(arc4random_uniform(<span class="type">UInt32</span>(playlist.count)))</span><br><span class="line"><span class="keyword">let</span> song <span class="operator">=</span> playlist[index]</span><br></pre></td></tr></table></figure>

<p>Swift 4.1 使用 <code>arc4random_uniform(_:)</code> 从 <code>playlist</code> 生成一个有效的索引（index）并返回相应的 <code>song</code>。<br>这个解决方案需要在 <code>Int</code> 和 <code>UInt32</code> 之间转换，并且还有所有前面提到的问题。</p>
<p>Swift 4.2 采用更直接的方式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> song <span class="operator">=</span> playlist.randomElement() &#123;</span><br><span class="line">  <span class="built_in">print</span>(song)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Empty playlist.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>playlist</code> 为空 <code>randomElement()</code> 将返回 <code>nil</code>，所以需要处理返回的 <code>String?</code>。</p>
<p>Swift 4.1 没有包含任何集合混洗算法（collection shuffling algorithms），所以必须使用迂回的方式来达到预期的结果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> shuffledPlaylist <span class="operator">=</span> playlist.sorted&#123; <span class="keyword">_</span>, <span class="keyword">_</span> <span class="keyword">in</span> arc4random_uniform(<span class="number">2</span>) <span class="operator">==</span> <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> names <span class="operator">=</span> [<span class="string">&quot;Cosmin&quot;</span>, <span class="string">&quot;Oana&quot;</span>, <span class="string">&quot;Sclip&quot;</span>, <span class="string">&quot;Nori&quot;</span>]</span><br><span class="line">names.sort &#123; <span class="keyword">_</span>, <span class="keyword">_</span> <span class="keyword">in</span> arc4random_uniform(<span class="number">2</span>) <span class="operator">==</span> <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这是在这段代码中所做的：</p>
<ol>
<li>可以使用 <code>arc4random_uniform(_:)</code> 来确定 <code>playlist</code> 的混排顺序，并用 <code>sorted(_:_:)</code> 函数返回 <code>shuffledPlaylist</code> 。</li>
<li>然后使用先前的技术将混乱的名称用 <code>sort(_:_:)</code> 函数排序。</li>
</ol>
<p>Swift 4.2 提供了更高效，可以说更优雅的<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyJUUyJTgwJTkzWWF0ZXNfc2h1ZmZsZQ==">混洗算法<i class="fa fa-external-link-alt"></i></span>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> shuffledPlaylist <span class="operator">=</span> playlist.shuffled()</span><br><span class="line">names.shuffle()</span><br></pre></td></tr></table></figure>

<p>在 4.2 中，只需使用 <code>shuffled()</code> 创建混洗播放列表（playlist）并在 <code>shuffled()</code> 上随机播放名称。<br>Boom！</p>
<p><img src="/my_pictures/20180613/2.png" alt="Shuffling playlists has never been easier thanks to Swift 4.2!"></p>
<h4 id="动态成员查询"><a href="#动态成员查询" class="headerlink" title="动态成员查询"></a>动态成员查询</h4><p>Swift 4.1 对自定义下标调用使用以下方括号语法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> age: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> details: [<span class="type">String</span>: <span class="type">String</span>]</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">age</span>: <span class="type">Int</span>, <span class="params">details</span>: [<span class="params">String</span>: <span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    <span class="keyword">self</span>.age <span class="operator">=</span> age</span><br><span class="line">    <span class="keyword">self</span>.details <span class="operator">=</span> details</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">subscript</span>(<span class="params">key</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> key &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;info&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="subst">\(name)</span> is <span class="subst">\(age)</span> years old.&quot;</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> details[key] <span class="operator">??</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> details <span class="operator">=</span> [<span class="string">&quot;title&quot;</span>: <span class="string">&quot;Author&quot;</span>, <span class="string">&quot;instrument&quot;</span>: <span class="string">&quot;Guitar&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> me <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;Cosmin&quot;</span>, age: <span class="number">32</span>, details: details)</span><br><span class="line">me[<span class="string">&quot;info&quot;</span>]   <span class="comment">// &quot;Cosmin is 32 years old.&quot;</span></span><br><span class="line">me[<span class="string">&quot;title&quot;</span>]  <span class="comment">// &quot;Author&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这种情况下，下标将根据个人的姓名和年龄从私人数据存储或自定义消息中返回内容。</p>
<p>Swift 4.2 使用动态成员查找（dynamic member lookup）为下标提供点语法，而不是 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0LWV2b2x1dGlvbi9ibG9iL21hc3Rlci9wcm9wb3NhbHMvMDE5NS1keW5hbWljLW1lbWJlci1sb29rdXAubWQ=">[SE-0195]<i class="fa fa-external-link-alt"></i></span>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">@dynamicMemberLookup</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> age: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> details: [<span class="type">String</span>: <span class="type">String</span>]</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">age</span>: <span class="type">Int</span>, <span class="params">details</span>: [<span class="params">String</span>: <span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    <span class="keyword">self</span>.age <span class="operator">=</span> age</span><br><span class="line">    <span class="keyword">self</span>.details <span class="operator">=</span> details</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">subscript</span>(<span class="params">dynamicMember</span> <span class="params">key</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> key &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;info&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="subst">\(name)</span> is <span class="subst">\(age)</span> years old.&quot;</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> details[key] <span class="operator">??</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">me.info   <span class="comment">// &quot;Cosmin is 32 years old.&quot; </span></span><br><span class="line">me.title  <span class="comment">// &quot;Author&quot;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>将 <code>Person</code> 标记为 <code>@dynamicMemberLookup</code> 以启用其自定义下标的点语法。</li>
<li>通过为类实现 <code>subscript(dynamicMember:)</code>，去掉用 <code>@dynamicMemberLookup</code>。</li>
<li>可以使用点语法调用先前自定义的下标。</li>
</ol>
<p>编译器会在运行时动态评估下标调用，这样可以写类型安全的代码，就像在 Python 或 Ruby 等脚本语言中编写类型安全的代码一样。 </p>
<p>动态成员查找不会混淆类属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">me.name <span class="comment">// &quot;Cosmin&quot;</span></span><br><span class="line">me.age <span class="comment">// 32</span></span><br></pre></td></tr></table></figure>

<p>在这种情况下，使用点语法来调用 <code>名称</code> 和 <code>age</code>，而不是下标。 </p>
<p>此外，派生类继承了动态成员查找的基础：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@dynamicMemberLookup</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> brand: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> year: <span class="type">Int</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">init</span>(<span class="params">brand</span>: <span class="type">String</span>, <span class="params">year</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.brand <span class="operator">=</span> brand</span><br><span class="line">    <span class="keyword">self</span>.year <span class="operator">=</span> year</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">subscript</span>(<span class="params">dynamicMember</span> <span class="params">key</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;<span class="subst">\(brand)</span> made in <span class="subst">\(year)</span>.&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>: <span class="title class_ inherited__">Vehicle</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car <span class="operator">=</span> <span class="type">Car</span>(brand: <span class="string">&quot;BMW&quot;</span>, year: <span class="number">2018</span>)</span><br><span class="line">car.info  <span class="comment">// &quot;BMW made in 2018.&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以使用点语法来调用汽车的下标，因为任何 <code>Car</code> 都是 <code>Vehicle</code>，并且 <code>Vehicle</code> 实现了 <code>@dynamicMemberLookup</code> 。</p>
<p>可以使用 <code>protocol extensions</code> 将动态成员查找添加到现有类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">@dynamicMemberLookup</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">Random</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Random</span> &#123;</span><br><span class="line">  <span class="keyword">subscript</span>(<span class="params">dynamicMember</span> <span class="params">key</span>: <span class="type">String</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Int</span>.random(in: <span class="number">0</span><span class="operator">..&lt;</span><span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Int</span>: <span class="title class_ inherited__">Random</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="keyword">let</span> number <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> randomDigit <span class="operator">=</span> <span class="type">String</span>(number.digit)</span><br><span class="line"><span class="keyword">let</span> noRandomDigit <span class="operator">=</span> <span class="type">String</span>(number).filter &#123; <span class="type">String</span>(<span class="variable">$0</span>) <span class="operator">!=</span> randomDigit &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用 <code>@dynamicMemberLookup</code> 注释 <code>Random</code> 以启用其下标的点语法。 </li>
<li>可以通过实现 <code>subscript(dynamicMember:)</code> 来扩展协议并使其符合 <code>@dynamicMemberLookup</code>。下标使用 <code>random(in:)</code> 来返回 0 到 9 之间的随机数字。 </li>
<li>扩展 <code>Int</code> 并使其符合 <code>Random</code>。 </li>
<li>使用点语法来生成一个随机数字并从 <code>number</code> 中过滤出来。</li>
</ol>
<h4 id="枚举案例集合"><a href="#枚举案例集合" class="headerlink" title="枚举案例集合"></a>枚举案例集合</h4><hr>
<p>Swift 4.1 默认情况下不提供对枚举案例的访问。这样就留下了一些相当不雅的解决方案，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Seasons</span>: <span class="title class_ inherited__">String</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> spring <span class="operator">=</span> <span class="string">&quot;Spring&quot;</span>, summer <span class="operator">=</span> <span class="string">&quot;Summer&quot;</span>, autumn <span class="operator">=</span> <span class="string">&quot;Autumn&quot;</span>, winter <span class="operator">=</span> <span class="string">&quot;Winter&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">SeasonType</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> equinox</span><br><span class="line">  <span class="keyword">case</span> solstice</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> seasons <span class="operator">=</span> [<span class="type">Seasons</span>.spring, .summer, .autumn, .winter]</span><br><span class="line"><span class="keyword">for</span> (index, season) <span class="keyword">in</span> seasons.enumerated() &#123;</span><br><span class="line">  <span class="keyword">let</span> seasonType <span class="operator">=</span> index <span class="operator">%</span> <span class="number">2</span> <span class="operator">==</span> <span class="number">0</span> <span class="operator">?</span> <span class="type">SeasonType</span>.equinox : .solstice</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(season.rawValue)</span> <span class="subst">\(seasonType)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，将 <code>Seasons</code> 添加到 <code>seasons</code>，并循环访问数组以获取每个季节的名称和类型。</p>
<p>但 Swift 4.2 可以做的更好！</p>
<p>Swift 4.2 将枚举案例数组添加到枚举中 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0LWV2b2x1dGlvbi9ibG9iL21hc3Rlci9wcm9wb3NhbHMvMDE5NC1kZXJpdmVkLWNvbGxlY3Rpb24tb2YtZW51bS1jYXNlcy5tZA==">[SE-0194]<i class="fa fa-external-link-alt"></i></span>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Seasons</span>: <span class="title class_ inherited__">String</span>, <span class="title class_ inherited__">CaseIterable</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> spring <span class="operator">=</span> <span class="string">&quot;Spring&quot;</span>, summer <span class="operator">=</span> <span class="string">&quot;Summer&quot;</span>, autumn <span class="operator">=</span> <span class="string">&quot;Autumn&quot;</span>, winter <span class="operator">=</span> <span class="string">&quot;Winter&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">SeasonType</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> equinox</span><br><span class="line">  <span class="keyword">case</span> solstice</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">for</span> (index, season) <span class="keyword">in</span> <span class="type">Seasons</span>.allCases.enumerated() &#123;</span><br><span class="line">  <span class="keyword">let</span> seasonType <span class="operator">=</span> index <span class="operator">%</span> <span class="number">2</span> <span class="operator">==</span> <span class="number">0</span> <span class="operator">?</span> <span class="type">SeasonType</span>.equinox : .solstice</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(season.rawValue)</span> <span class="subst">\(seasonType)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是如何在 Swift 4.2 中完成同样的事情：</p>
<ol>
<li>使 <code>Seasons</code> 继承 <code>CaseIterable</code> 以创建枚举案例。</li>
<li>循环浏览所有 <code>case</code> 并打印每个季节的名称和类型。</li>
</ol>
<p>可以选择仅将某些情况添加到枚举案例数组中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Months</span>: <span class="title class_ inherited__">CaseIterable</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> january, february, march, april, may, june, july, august, september, october, november, december          </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> allCases: [<span class="type">Months</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> [.june, .july, .august]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里只添加夏季月份，因为它们是一年中最阳光的季节！</p>
<p><img src="/my_pictures/20180613/3.png" alt="Summer is all over the place in Swift 4.2 enumerations!"></p>
<p>如果枚举包含 <code>unavailable</code> 的元素，则应手动将所有 <code>available</code> 添加到数组中:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Days</span>: <span class="title class_ inherited__">CaseIterable</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> monday, tuesday, wednesday, thursday, friday</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@available</span>(<span class="operator">*</span>, unavailable)</span><br><span class="line">  <span class="keyword">case</span> saturday, sunday</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> allCases: [<span class="type">Days</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> [.monday, .tuesday, .wednesday, .thursday, .friday]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只能将 <code>工作日</code> 添加到 <code>allCases</code>, 因为这里将 <code>.saturday</code> 和 <code>.sunday</code> 标记为了 <code>unavailable</code>，所以在任何版本和平台都是 <code>unavailable</code>。</p>
<p>还可以将具有关联值的 <code>case</code> 添加到枚举 <code>case</code> 数组中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">BlogPost</span>: <span class="title class_ inherited__">CaseIterable</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> article</span><br><span class="line">  <span class="keyword">case</span> tutorial(updated: <span class="type">Bool</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> allCases: [<span class="type">BlogPost</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> [.article, .tutorial(updated: <span class="literal">true</span>), .tutorial(updated: <span class="literal">false</span>)]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在本例中，将网站上的所有博客类型添加到 <code>allCases:</code>，文章，新教程和更新。</p>
<h4 id="新的序列方法（Squence-Methods）"><a href="#新的序列方法（Squence-Methods）" class="headerlink" title="新的序列方法（Squence Methods）"></a>新的序列方法（Squence Methods）</h4><p>Swift 4.1 定义了用于确定某个元素的第一个索引或者满足特定条件的第一个元素的序列方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ages <span class="operator">=</span> [<span class="string">&quot;ten&quot;</span>, <span class="string">&quot;twelve&quot;</span>, <span class="string">&quot;thirteen&quot;</span>, <span class="string">&quot;nineteen&quot;</span>, <span class="string">&quot;eighteen&quot;</span>, <span class="string">&quot;seventeen&quot;</span>, <span class="string">&quot;fourteen&quot;</span>,  <span class="string">&quot;eighteen&quot;</span>, </span><br><span class="line">            <span class="string">&quot;fifteen&quot;</span>, <span class="string">&quot;sixteen&quot;</span>, <span class="string">&quot;eleven&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstTeen <span class="operator">=</span> ages.first(where: &#123; <span class="variable">$0</span>.hasSuffix(<span class="string">&quot;teen&quot;</span>) &#125;), </span><br><span class="line">   <span class="keyword">let</span> firstIndex <span class="operator">=</span> ages.index(where: &#123; <span class="variable">$0</span>.hasSuffix(<span class="string">&quot;teen&quot;</span>) &#125;), </span><br><span class="line">   <span class="keyword">let</span> firstMajorIndex <span class="operator">=</span> ages.index(of: <span class="string">&quot;eighteen&quot;</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Teenager number <span class="subst">\(firstIndex <span class="operator">+</span> <span class="number">1</span>)</span> is <span class="subst">\(firstTeen)</span> years old.&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Teenager number <span class="subst">\(firstMajorIndex <span class="operator">+</span> <span class="number">1</span>)</span> isn&#x27;t a minor anymore.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;No teenagers around here.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Swift 4.1 的做法是使用 <code>first(where:)</code> 来查找第一个青少年的年龄（ages），<code>index(where:)</code> 为第一个青少年的索引，<code>index(of:)</code> 为第一个18岁的青少年的索引<br>。</p>
<p>Swift 4.2重新命名了这些方法中的一部分以实现一致性<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0LWV2b2x1dGlvbi9ibG9iL21hc3Rlci9wcm9wb3NhbHMvMDIwNC1hZGQtbGFzdC1tZXRob2RzLm1k">[SE-0204]<i class="fa fa-external-link-alt"></i></span>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstTeen <span class="operator">=</span> ages.first(where: &#123; <span class="variable">$0</span>.hasSuffix(<span class="string">&quot;teen&quot;</span>) &#125;), </span><br><span class="line">   <span class="keyword">let</span> firstIndex <span class="operator">=</span> ages.firstIndex(where: &#123; <span class="variable">$0</span>.hasSuffix(<span class="string">&quot;teen&quot;</span>) &#125;), </span><br><span class="line">   <span class="keyword">let</span> firstMajorIndex <span class="operator">=</span> ages.firstIndex(of:  <span class="string">&quot;eighteen&quot;</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Teenager number <span class="subst">\(firstIndex <span class="operator">+</span> <span class="number">1</span>)</span> is <span class="subst">\(firstTeen)</span> years old.&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Teenager number <span class="subst">\(firstMajorIndex <span class="operator">+</span> <span class="number">1</span>)</span> isn&#x27;t a minor anymore.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;No teenagers around here.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>index(where:)</code> 变成了 <code>firstIndex(where:)</code>，而 <code>index(of:)</code> 变成了 <code>firstIndex(of:)</code> 与 <code>first(where:)</code> 保持一致。</p>
<p>Swift 4.1 也没有定义任何 <code>Collection</code> 方法来查找某个元素的最后一个索引或匹配给定谓词的最后一个元素。以下是 4.1 中的处理方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> reversedAges <span class="operator">=</span> ages.reversed()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> lastTeen <span class="operator">=</span> reversedAges.first(where: &#123; <span class="variable">$0</span>.hasSuffix(<span class="string">&quot;teen&quot;</span>) &#125;), </span><br><span class="line">   <span class="keyword">let</span> lastIndex <span class="operator">=</span> reversedAges.index(where: &#123; <span class="variable">$0</span>.hasSuffix(<span class="string">&quot;teen&quot;</span>) &#125;)<span class="operator">?</span>.base, </span><br><span class="line">   <span class="keyword">let</span> lastMajorIndex <span class="operator">=</span> reversedAges.index(of: <span class="string">&quot;eighteen&quot;</span>)<span class="operator">?</span>.base &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Teenager number <span class="subst">\(lastIndex)</span> is <span class="subst">\(lastTeen)</span> years old.&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Teenager number <span class="subst">\(lastMajorIndex)</span> isn&#x27;t a minor anymore.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;No teenagers around here.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看这部分：</p>
<ol>
<li>我们使用 <code>reversed()</code> 方法，创建了一个 <code>ages</code> 的翻转版本。</li>
<li>我们使用 <code>first(where:)</code> 来确定 <code>reversedAges</code> 中最后一名青少年的年龄，<code>index(where:)</code> 是最后一名青少年的索引，<code>index(of:)</code> 是最后一名18岁青少年的索引。</li>
</ol>
<p>Swift 4.2 添加了相应的 <code>Sequence</code> 方法，将上面的方法折叠为如下形式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> lastTeen <span class="operator">=</span> ages.last(where: &#123; <span class="variable">$0</span>.hasSuffix(<span class="string">&quot;teen&quot;</span>) &#125;), </span><br><span class="line">   <span class="keyword">let</span> lastIndex <span class="operator">=</span> ages.lastIndex(where: &#123; <span class="variable">$0</span>.hasSuffix(<span class="string">&quot;teen&quot;</span>) &#125;), </span><br><span class="line">   <span class="keyword">let</span> lastMajorIndex <span class="operator">=</span> ages.lastIndex(of: <span class="string">&quot;eighteen&quot;</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Teenager number <span class="subst">\(lastIndex <span class="operator">+</span> <span class="number">1</span>)</span> is <span class="subst">\(lastTeen)</span> years old.&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Teenager number <span class="subst">\(lastMajorIndex <span class="operator">+</span> <span class="number">1</span>)</span> isn&#x27;t a minor anymore.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;No teenagers around here.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以简单的使用 <code>last(where:)</code>，<code>lastIndex(where:)</code> 和 <code>lastIndex(of:)</code> 去找到之前的元素和年龄的具体指数。</p>
<h4 id="测试序列元素"><a href="#测试序列元素" class="headerlink" title="测试序列元素"></a>测试序列元素</h4><p>Swift 4.1 中缺少一个相当简单的例程来检查序列中的所有元素是否满足特定条件。尽管如此，您仍然可以制定自己的方法，例如你必须确定所有元素是否是偶数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values <span class="operator">=</span> [<span class="number">10</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">20</span>]</span><br><span class="line"><span class="keyword">let</span> allEven <span class="operator">=</span> <span class="operator">!</span>values.contains &#123; <span class="variable">$0</span> <span class="operator">%</span> <span class="number">2</span> <span class="operator">==</span> <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>

<p>看起来并不是很优雅，不是吗？Swift 4.2 为序列添加了这一个缺失的方法<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0LWV2b2x1dGlvbi9ibG9iL21hc3Rlci9wcm9wb3NhbHMvMDIwNy1jb250YWluc09ubHkubWQ=">[SE-0207]<i class="fa fa-external-link-alt"></i></span>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> allEven <span class="operator">=</span> values.allSatisfy &#123; <span class="variable">$0</span> <span class="operator">%</span> <span class="number">2</span> <span class="operator">==</span> <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure>

<p>看起来好多了，这简化了代码，并且具有更好的可读性。</p>
<h4 id="条件一致性更新"><a href="#条件一致性更新" class="headerlink" title="条件一致性更新"></a>条件一致性更新</h4><p>Swift 4.2 在标准库的扩展中增加了一些条件一致性的改进<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0LWV2b2x1dGlvbi9ibG9iL21hc3Rlci9wcm9wb3NhbHMvMDE0My1jb25kaXRpb25hbC1jb25mb3JtYW5jZXMubWQ=">[SE-0143]<i class="fa fa-external-link-alt"></i></span>。</p>
<h5 id="扩展中的条件一致性"><a href="#扩展中的条件一致性" class="headerlink" title="扩展中的条件一致性"></a>扩展中的条件一致性</h5><p>Swift 4.1 无法将扩展中的 <code>Equatable</code> 的条件一致性综合起来。以下面的 Swift 4.1 代码片段为例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tutorial</span> : <span class="title class_ inherited__">Equatable</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> title: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> author: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Screencast</span>&lt;<span class="type">Tutorial</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> author: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> tutorial: <span class="type">Tutorial</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Screencast</span>: <span class="title class_ inherited__">Equatable</span> <span class="keyword">where</span> <span class="title class_ inherited__">Tutorial</span>: <span class="title class_ inherited__">Equatable</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">==</span>(<span class="params">lhs</span>: <span class="type">Screencast</span>, <span class="params">rhs</span>: <span class="type">Screencast</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.author <span class="operator">==</span> rhs.author <span class="operator">&amp;&amp;</span> lhs.tutorial <span class="operator">==</span> rhs.tutorial</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="keyword">let</span> swift41Tutorial <span class="operator">=</span> <span class="type">Tutorial</span>(title: <span class="string">&quot;What&#x27;s New in Swift 4.1?&quot;</span>, author: <span class="string">&quot;Cosmin Pupăză&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> swift42Tutorial <span class="operator">=</span> <span class="type">Tutorial</span>(title: <span class="string">&quot;What&#x27;s New In Swift 4.2?&quot;</span>, author: <span class="string">&quot;Cosmin Pupăză&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> swift41Screencast <span class="operator">=</span> <span class="type">Screencast</span>(author: <span class="string">&quot;Jessy Catterwaul&quot;</span>, tutorial: swift41Tutorial)</span><br><span class="line"><span class="keyword">let</span> swift42Screencast <span class="operator">=</span> <span class="type">Screencast</span>(author: <span class="string">&quot;Jessy Catterwaul&quot;</span>, tutorial: swift42Tutorial)</span><br><span class="line"><span class="keyword">let</span> sameScreencast <span class="operator">=</span> swift41Screencast <span class="operator">==</span> swift42Screencast</span><br></pre></td></tr></table></figure>

<ol>
<li>这里让 <code>Tutorial</code> 继承自 <code>Equatable</code>。</li>
<li>让 <code>Screencast</code> 成为通用的，因为网站作者将他们的截屏作为发布教程的基础。</li>
<li>对于截屏你可以实现 <code>==(lhs:rhs:)</code> ，因为只要 <code>Tutorial</code> 符合 <code>Equatable</code> 那么 <code>Screencast</code> 也会符合 <code>Equatable</code>。</li>
</ol>
<p>在 Swift 4.2 中为一个扩展添加 <code>Equatable</code> 的默认实现如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Screencast</span>: <span class="title class_ inherited__">Equatable</span> <span class="keyword">where</span> <span class="title class_ inherited__">Tutorial</span>: <span class="title class_ inherited__">Equatable</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>此功能也适用于扩展中的 <code>Hashable</code> 和 <code>Codable</code> 一致性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tutorial</span>: <span class="title class_ inherited__">Hashable</span>, <span class="title class_ inherited__">Codable</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> title: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> author: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Screencast</span>&lt;<span class="type">Tutorial</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> author: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> tutorial: <span class="type">Tutorial</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Screencast</span>: <span class="title class_ inherited__">Hashable</span> <span class="keyword">where</span> <span class="title class_ inherited__">Tutorial</span>: <span class="title class_ inherited__">Hashable</span> &#123;&#125;</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Screencast</span>: <span class="title class_ inherited__">Codable</span> <span class="keyword">where</span> <span class="title class_ inherited__">Tutorial</span>: <span class="title class_ inherited__">Codable</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">let</span> screencastsSet: <span class="type">Set</span> <span class="operator">=</span> [swift41Screencast, swift42Screencast]</span><br><span class="line"><span class="keyword">let</span> screencastsDictionary <span class="operator">=</span> [swift41Screencast: <span class="string">&quot;Swift 4.1&quot;</span>, swift42Screencast: <span class="string">&quot;Swift 4.2&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> screencasts <span class="operator">=</span> [swift41Screencast, swift42Screencast]</span><br><span class="line"><span class="keyword">let</span> encoder <span class="operator">=</span> <span class="type">JSONEncoder</span>()</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> encoder.encode(screencasts)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(error)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个代码块中：</p>
<ol>
<li>让 <code>Tutorial</code> 继承自 <code>Hashable</code> 和 <code>Codable</code>。</li>
<li>如果教程这么做的话，那么也将会让 <code>Screencast</code> 继承自 <code>Hashable</code> 和 <code>Codable</code>。</li>
<li>你可以将截图添加到集合字典中并对他们进行编码。</li>
</ol>
<h5 id="条件一致性运行时查询"><a href="#条件一致性运行时查询" class="headerlink" title="条件一致性运行时查询"></a>条件一致性运行时查询</h5><p>Swift 4.2 实现了条件一致性的<strong>动态查询</strong>。您可以在以下代码中看到这一点：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Instrument</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> brand: <span class="type">String</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">init</span>(<span class="params">brand</span>: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.brand <span class="operator">=</span> brand</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">Tuneable</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">tune</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Keyboard</span>: <span class="title class_ inherited__">Instrument</span>, <span class="title class_ inherited__">Tuneable</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">tune</span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(brand)</span> keyboard tuning.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span>: <span class="title class_ inherited__">Tuneable</span> <span class="keyword">where</span> <span class="title class_ inherited__">Element</span>: <span class="title class_ inherited__">Tuneable</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">tune</span>() &#123;</span><br><span class="line">    forEach &#123; <span class="variable">$0</span>.tune() &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="keyword">let</span> instrument <span class="operator">=</span> <span class="type">Instrument</span>()</span><br><span class="line"><span class="keyword">let</span> keyboard <span class="operator">=</span> <span class="type">Keyboard</span>(brand: <span class="string">&quot;Roland&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> instruments <span class="operator">=</span> [instrument, keyboard]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> keyboards <span class="operator">=</span> instruments <span class="keyword">as?</span> <span class="type">Tuneable</span> &#123;</span><br><span class="line">  keyboards.tune()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Can&#x27;t tune instrument.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是上述的内容：</p>
<ol>
<li>定义了一个 <code>Instrument</code> 类，并且他有一个成员变量 <code>brand</code>。</li>
<li>为所有可调的乐器声明了一个接口 <code>Tuneable</code>。</li>
<li>我们在 <code>Keyboard</code> 类中重写了 <code>tune()</code> 方法，并且返回键盘的标准调整。</li>
<li>我们使用 <code>where</code> 关键词来约束 <code>Array</code> 的元素满足 <code>Tuneable</code>。</li>
<li>我们将 <code>Instrument</code> 和 <code>Keyboard</code> 添加到 <code>instruments</code> 中。</li>
<li>如果 <code>if</code> 条件满足，这里会检查 <code>instruments</code> 是否能实现了 <code>Tuneable</code>，然后调用 <code>tune()</code>方法。在这里例子中，数组不能转化为 <code>Tuneable</code>，因为 <code>Instrument</code> 类型不满足 <code>Tuneable</code>。如果你创建有两个 <code>Keyboard</code> 元素的数组，则 <code>if</code> 条件会满足，并且会调用 <code>tune()</code> 方法。</li>
</ol>
<h5 id="标准库中哈希一致性改进"><a href="#标准库中哈希一致性改进" class="headerlink" title="标准库中哈希一致性改进"></a>标准库中哈希一致性改进</h5><p>可选项，数组，字典和范围（range）在 Swift 4.2 中是 <code>Hashable</code>，当它们的元素是 <code>Hashable</code> 时：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Chord</span>: <span class="title class_ inherited__">Hashable</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> description: <span class="type">String</span>?</span><br><span class="line">  <span class="keyword">let</span> notes: [<span class="type">String</span>]</span><br><span class="line">  <span class="keyword">let</span> signature: [<span class="type">String</span>: [<span class="type">String</span>]<span class="operator">?</span>]</span><br><span class="line">  <span class="keyword">let</span> frequency: <span class="type">CountableClosedRange</span>&lt;<span class="type">Int</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cMajor <span class="operator">=</span> <span class="type">Chord</span>(name: <span class="string">&quot;C&quot;</span>, description: <span class="string">&quot;C major&quot;</span>, notes: [<span class="string">&quot;C&quot;</span>, <span class="string">&quot;E&quot;</span>,  <span class="string">&quot;G&quot;</span>], </span><br><span class="line">                   signature: [<span class="string">&quot;sharp&quot;</span>: <span class="literal">nil</span>,  <span class="string">&quot;flat&quot;</span>: <span class="literal">nil</span>], frequency: <span class="number">432</span><span class="operator">...</span><span class="number">446</span>)</span><br><span class="line"><span class="keyword">let</span> aMinor <span class="operator">=</span> <span class="type">Chord</span>(name: <span class="string">&quot;Am&quot;</span>, description: <span class="string">&quot;A minor&quot;</span>, notes: [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;E&quot;</span>], </span><br><span class="line">                   signature: [<span class="string">&quot;sharp&quot;</span>: <span class="literal">nil</span>, <span class="string">&quot;flat&quot;</span>: <span class="literal">nil</span>], frequency: <span class="number">440</span><span class="operator">...</span><span class="number">446</span>)</span><br><span class="line"><span class="keyword">let</span> chords: <span class="type">Set</span> <span class="operator">=</span> [cMajor, aMinor]</span><br><span class="line"><span class="keyword">let</span> versions <span class="operator">=</span> [cMajor: <span class="string">&quot;major&quot;</span>, aMinor: <span class="string">&quot;minor&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>这里将 <code>cMajor</code> 和 <code>aMinor</code> 放在 <code>chords</code> 和 <code>versions</code> 中。这在 Swift 4.2 之前是不可能的，因为 <code>String?</code>, <code>[String]</code>, <code>[String: [String]?]</code> 和 <code>CountableClosedRange&lt;Int&gt;</code> 他们不满足 <code>Hashable</code></p>
<h4 id="哈希改进"><a href="#哈希改进" class="headerlink" title="哈希改进"></a>哈希改进</h4><p>在 Swift 4.1 中为下面的例子实现一个类的自定义<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRm93bGVyJUUyJTgwJTkzTm9sbCVFMiU4MCU5M1ZvX2hhc2hfZnVuY3Rpb24=">散列函数<i class="fa fa-external-link-alt"></i></span>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Country: Hashable &#123;</span><br><span class="line">  let name: String</span><br><span class="line">  let capital: String</span><br><span class="line">  </span><br><span class="line">  init(name: String, capital: String) &#123;</span><br><span class="line">    self.name = name</span><br><span class="line">    self.capital = capital</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  static func ==(lhs: Country, rhs: Country) -&gt; Bool &#123;</span><br><span class="line">    return lhs.name == rhs.name &amp;&amp; lhs.capital == rhs.capital</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  var hashValue: Int &#123;</span><br><span class="line">    return name.hashValue ^ capital.hashValue &amp;* 16777619</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let france = Country(name: &quot;France&quot;, capital: &quot;Paris&quot;)</span><br><span class="line">let germany = Country(name: &quot;Germany&quot;, capital: &quot;Berlin&quot;)</span><br><span class="line">let countries: Set = [france, germany]</span><br><span class="line">let countryGreetings = [france: &quot;Bonjour&quot;, germany: &quot;Guten Tag&quot;]</span><br></pre></td></tr></table></figure>

<p>由于它们是继承自 <code>Hashable</code>，因此您可以在这里将国家添加到集合（sets）和词典中。但是 <code>hashValue</code> 实现很难理解，并且对于不可信的源值不够有效。</p>
<p>Swift 4.2 通过定义通用哈希函数修复了这个问题<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0LWV2b2x1dGlvbi9ibG9iL21hc3Rlci9wcm9wb3NhbHMvMDIwNi1oYXNoYWJsZS1lbmhhbmNlbWVudHMubWQ=">[SE-0206]<i class="fa fa-external-link-alt"></i></span>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Country</span>: <span class="title class_ inherited__">Hashable</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> capital: <span class="type">String</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">capital</span>: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    <span class="keyword">self</span>.capital <span class="operator">=</span> capital</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">==</span>(<span class="params">lhs</span>: <span class="type">Country</span>, <span class="params">rhs</span>: <span class="type">Country</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.name <span class="operator">==</span> rhs.name <span class="operator">&amp;&amp;</span> lhs.capital <span class="operator">==</span> rhs.capital</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">hash</span>(<span class="params">into</span> <span class="params">hasher</span>: <span class="keyword">inout</span> <span class="type">Hasher</span>) &#123;</span><br><span class="line">    hasher.combine(name)</span><br><span class="line">    hasher.combine(capital)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，用 <code>hash(into:)</code> 函数替换了 <code>Country</code> 中原来的 <code>hashValue</code>。该函数使用 <code>combine()</code> 将类属性提供给 <code>hasher</code>。这很容易实现，它提高了以前所有版本的性能。</p>
<img src="/my_pictures/20180613/4.png" alt="Hashing sets and dictionaries like a pro in Swift 4.2!" style="zoom:33%;" />


<h4 id="从集合中删除元素"><a href="#从集合中删除元素" class="headerlink" title="从集合中删除元素"></a>从集合中删除元素</h4><p>我们通常会想要从集合中删除所有出现的特定元素。在 Swift 4.1 中我们可以使用 <code>filter(_:)</code> 来实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> greetings <span class="operator">=</span> [<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Hi&quot;</span>, <span class="string">&quot;Goodbye&quot;</span>, <span class="string">&quot;Bye&quot;</span>]</span><br><span class="line">greetings <span class="operator">=</span> greetings.filter &#123; <span class="variable">$0</span>.count <span class="operator">&lt;=</span> <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这里过滤 <code>greetings</code> 中的元素，只返回元素字符数小于或等于 3 的元素。这并不影响原始数组。所以你不得不把它再赋值给 <code>greetings</code>。</p>
<p>Swift 4.2 添加了 <code>removeAll(_:)</code> 方法<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0LWV2b2x1dGlvbi9ibG9iL21hc3Rlci9wcm9wb3NhbHMvMDE5Ny1yZW1vdmUtd2hlcmUubWQ=">[SE-0197]<i class="fa fa-external-link-alt"></i></span>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">greetings.removeAll &#123; <span class="variable">$0</span>.count <span class="operator">&gt;</span> <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这里将执行移除操作。再一次，我们又简化了代码并且增加了可读性。</p>
<h4 id="切换布尔值状态"><a href="#切换布尔值状态" class="headerlink" title="切换布尔值状态"></a>切换布尔值状态</h4><p>切换布尔值状态！谁在 Swift 4.1 中没有这样用过：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Bool</span> &#123;</span><br><span class="line">  <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">toggle</span>() &#123;</span><br><span class="line">    <span class="keyword">self</span> <span class="operator">=</span> <span class="operator">!</span><span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isOn <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">isOn.toggle()</span><br></pre></td></tr></table></figure>

<p>Swift 4.2 为 <code>Bool</code> 添加了 <code>toggle()</code> 函数 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0LWV2b2x1dGlvbi9ibG9iL21hc3Rlci9wcm9wb3NhbHMvMDE5OS1ib29sLXRvZ2dsZS5tZA==">[SE-0199]<i class="fa fa-external-link-alt"></i></span>：</p>
<h4 id="新的编译指令"><a href="#新的编译指令" class="headerlink" title="新的编译指令"></a>新的编译指令</h4><p>Swift 4.2 定义了一些编译器指令，用于在代码中标识出问题<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0LWV2b2x1dGlvbi9ibG9iL21hc3Rlci9wcm9wb3NhbHMvMDE5Ni1kaWFnbm9zdGljLWRpcmVjdGl2ZXMubWQ=">[SE-0196]<i class="fa fa-external-link-alt"></i></span>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">#warning</span>(<span class="string">&quot;There are shorter implementations out there.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> numbers <span class="operator">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> sum <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">  sum <span class="operator">+=</span> number</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(sum)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">#error</span>(<span class="string">&quot;Please fill in your credentials.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> username <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">let</span> password <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">switch</span> (username.filter &#123; <span class="variable">$0</span> <span class="operator">!=</span> <span class="string">&quot; &quot;</span> &#125;, password.filter &#123; <span class="variable">$0</span> <span class="operator">!=</span> <span class="string">&quot; &quot;</span> &#125;) &#123;</span><br><span class="line">  <span class="keyword">case</span> (<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Invalid username and password.&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> (<span class="string">&quot;&quot;</span>, <span class="keyword">_</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Invalid username.&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> (<span class="keyword">_</span>, <span class="string">&quot;&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Invalid password.&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> (<span class="keyword">_</span>, <span class="keyword">_</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Logged in succesfully.&quot;</span>)</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>

<p>这里是如何工作的：</p>
<ol>
<li>这里用 <code>#warning</code> 来进行一个提醒，在 <code>numbers</code> 中添加元素的功能方法比命令式方法短。</li>
<li>用 <code>#error</code> 来让其他开发者在登陆之前输入用户名和密码。</li>
</ol>
<h4 id="新的指针功能"><a href="#新的指针功能" class="headerlink" title="新的指针功能"></a>新的指针功能</h4><p><code>withUnsafeBytes(of:_:)</code> 和 <code>withUnsafePointer(to:_:)</code> 只适用于 Swift 4.1 中的可变变量：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">copy</span> <span class="operator">=</span> value</span><br><span class="line">withUnsafeBytes(of: <span class="operator">&amp;</span><span class="keyword">copy</span>) &#123; pointer <span class="keyword">in</span> <span class="built_in">print</span>(pointer.count) &#125;</span><br><span class="line"><span class="built_in">withUnsafePointer</span>(to: <span class="operator">&amp;</span><span class="keyword">copy</span>) &#123; pointer <span class="keyword">in</span> <span class="built_in">print</span>(pointer.hashValue) &#125;</span><br></pre></td></tr></table></figure>

<p>所以我们必须创建一个值的副本（copy of value）才能使这两个函数正常工作。 Swift 4.2 为常量重载这些函数，所以你不再需要保存它们的值<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0LWV2b2x1dGlvbi9ibG9iL21hc3Rlci9wcm9wb3NhbHMvMDIwNS13aXRoVW5zYWZlUG9pbnRlci1mb3ItbGV0cy5tZA==">[SE-0205]<i class="fa fa-external-link-alt"></i></span>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">withUnsafeBytes(of: value) &#123; pointer <span class="keyword">in</span> <span class="built_in">print</span>(pointer.count) &#125;</span><br><span class="line"><span class="built_in">withUnsafePointer</span>(to: value) &#123; pointer <span class="keyword">in</span> <span class="built_in">print</span>(pointer.hashValue) &#125;</span><br></pre></td></tr></table></figure>

<h4 id="内存布局更新"><a href="#内存布局更新" class="headerlink" title="内存布局更新"></a>内存布局更新</h4><p>Swift 4.2 使用键路径查询存储属性的内存布局<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0LWV2b2x1dGlvbi9ibG9iL21hc3Rlci9wcm9wb3NhbHMvMDIxMC1rZXktcGF0aC1vZmZzZXQubWQ=">[SE-0210]<i class="fa fa-external-link-alt"></i></span>。以下是它的工作原理：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> x, y: <span class="type">Double</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> center: <span class="type">Point</span></span><br><span class="line">  <span class="keyword">var</span> radius: <span class="type">Double</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> circumference: <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> <span class="operator">*</span> .pi <span class="operator">*</span> radius</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> area: <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> .pi <span class="operator">*</span> radius <span class="operator">*</span> radius</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> xOffset <span class="operator">=</span> <span class="type">MemoryLayout</span>.offset(of: \<span class="type">Circle</span>.center.x), </span><br><span class="line">   <span class="keyword">let</span> yOffset <span class="operator">=</span> <span class="type">MemoryLayout</span>.offset(of: \<span class="type">Circle</span>.center.y), </span><br><span class="line">   <span class="keyword">let</span> radiusOffset <span class="operator">=</span> <span class="type">MemoryLayout</span>.offset(of: \<span class="type">Circle</span>.radius) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(xOffset)</span> <span class="subst">\(yOffset)</span> <span class="subst">\(radiusOffset)</span>&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Nil offset values.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> circumferenceOffset <span class="operator">=</span> <span class="type">MemoryLayout</span>.offset(of: \<span class="type">Circle</span>.circumference), </span><br><span class="line">   <span class="keyword">let</span> areaOffset <span class="operator">=</span> <span class="type">MemoryLayout</span>.offset(of: \<span class="type">Circle</span>.area) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(circumferenceOffset)</span> <span class="subst">\(areaOffset)</span>&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Nil offset values.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来一步一步的解析：</p>
<ol>
<li>我们定义了该点的水平和垂直坐标。</li>
<li>我们声明了一个圆的中心，圆周，面积和半径。</li>
<li>我们使用键路径来获取圆的存储属性的偏移量。</li>
<li>由于它们不是以内联方式存储的，因此我们将返回nil作为圆的计算属性的偏移量。</li>
</ol>
<h4 id="模块中的内联函数"><a href="#模块中的内联函数" class="headerlink" title="模块中的内联函数"></a>模块中的内联函数</h4><p>在 Swift 4.1 中我们不能在我们的模型中声明内联函数。点击 <strong>View ▸ Navigators ▸ Show Project Navigator</strong>，右键点击 <strong>Source</strong> 并且选择 <strong>新建文件</strong>。重命名为 <code>FactorialKit.swift</code> 然后用下面的代码来替换它的内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomFactorial</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> customDecrement: <span class="type">Bool</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">customDecrement</span>: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.customDecrement <span class="operator">=</span> customDecrement</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> randomDecrement: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arc4random_uniform(<span class="number">2</span>) <span class="operator">==</span> <span class="number">0</span> <span class="operator">?</span> <span class="number">2</span> : <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">factorial</span>(<span class="keyword">_</span> <span class="params">n</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> n <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> decrement <span class="operator">=</span> customDecrement <span class="operator">?</span> randomDecrement : <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n <span class="operator">*</span> factorial(n <span class="operator">-</span> decrement)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们已经创建了阶乘实现的自定义版本。切换回 <code>playground</code> 并在底部添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> standard <span class="operator">=</span> <span class="type">CustomFactorial</span>()</span><br><span class="line">standard.factorial(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">let</span> custom <span class="operator">=</span> <span class="type">CustomFactorial</span>(<span class="literal">true</span>)</span><br><span class="line">custom.factorial(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>这里，生成默认的阶乘和随机的阶乘。跨模块函数在 Swift 4.2<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0LWV2b2x1dGlvbi9ibG9iL21hc3Rlci9wcm9wb3NhbHMvMDE5My1jcm9zcy1tb2R1bGUtaW5saW5pbmctYW5kLXNwZWNpYWxpemF0aW9uLm1k">[SE-0193]<i class="fa fa-external-link-alt"></i></span>中内嵌时更有效率，因此将 <code>FactorialKit.swift</code> 中的代码用以下方法替换 <code>CustomFactorial</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomFactorial</span> &#123;</span><br><span class="line">  <span class="keyword">@usableFromInline</span> <span class="keyword">let</span> customDecrement: <span class="type">Bool</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">customDecrement</span>: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.customDecrement <span class="operator">=</span> customDecrement</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">@usableFromInline</span> <span class="keyword">var</span> randomDecrement: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Bool</span>.random() <span class="operator">?</span> <span class="number">2</span> : <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">@inlinable</span> <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">factorial</span>(<span class="keyword">_</span> <span class="params">n</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> n <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> decrement <span class="operator">=</span> customDecrement <span class="operator">?</span> randomDecrement : <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n <span class="operator">*</span> factorial(n <span class="operator">-</span> decrement)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们做了这些：</p>
<ol>
<li>将 <code>customDecrement</code> 和 <code>randomDecrement</code> 都设置为 <code>internal</code>，并将它们标记为 <code>@usableFromInline</code>，因为我们在内联因子实现中使用它们。</li>
<li>我们用 <code>@inlinable</code> 注释 <code>factorial(_:)</code> 以使其成为内联。这是可以的，因为我们声明这个函数是 <code>public</code>。</li>
</ol>
<h3 id="其他的变化"><a href="#其他的变化" class="headerlink" title="其他的变化"></a>其他的变化</h3><hr>
<p>这里还有一些你应该知道的 Swift 4.2 的一些其他变化。</p>
<h4 id="Swift-的包管理器更新"><a href="#Swift-的包管理器更新" class="headerlink" title="Swift 的包管理器更新"></a>Swift 的包管理器更新</h4><p>Swift 4.2 为包管理加入了一些改进。</p>
<h5 id="定义包的-Swift-语言版本"><a href="#定义包的-Swift-语言版本" class="headerlink" title="定义包的 Swift 语言版本"></a>定义包的 Swift 语言版本</h5><p>Swift 4.1 在 <code>Package.swift</code> 文件中，定义了一个 <code>[Int]</code> 类型的 <code>swiftLanguageVersions</code> 变量。所以你可以只声明你的包的主要版本：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">package</span> <span class="operator">=</span> <span class="type">Package</span>(name: <span class="string">&quot;Package&quot;</span>, swiftLanguageVersions: [<span class="number">4</span>])</span><br></pre></td></tr></table></figure>

<p>Swift 4.2 可以通过 <code>SwiftVersion</code>枚举定义小版本<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0LWV2b2x1dGlvbi9ibG9iL21hc3Rlci9wcm9wb3NhbHMvMDIwOS1wYWNrYWdlLW1hbmFnZXItc3dpZnQtbGFuZy12ZXJzaW9uLXVwZGF0ZS5tZA==">[SE-0209]<i class="fa fa-external-link-alt"></i></span>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">package</span> <span class="operator">=</span> <span class="type">Package</span>(name: <span class="string">&quot;Package&quot;</span>, swiftLanguageVersions: [.v4_2])</span><br></pre></td></tr></table></figure>

<p>我们还可以使用 <code>.version(_:)</code> 声明未来版本：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">package</span> <span class="operator">=</span> <span class="type">Package</span>(name: <span class="string">&quot;Package&quot;</span>, swiftLanguageVersions: [.version(<span class="string">&quot;5&quot;</span>)])</span><br></pre></td></tr></table></figure>

<h5 id="声明包的本地依赖关系"><a href="#声明包的本地依赖关系" class="headerlink" title="声明包的本地依赖关系"></a>声明包的本地依赖关系</h5><p>在 Swift 4.1 中，使用存储库链接声明了包的依赖关系。如果有互连的包这将增加开销，所以 Swift 4.2 在这种情况下使用本地路径代替<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0LWV2b2x1dGlvbi9ibG9iL21hc3Rlci9wcm9wb3NhbHMvMDIwMS1wYWNrYWdlLW1hbmFnZXItbG9jYWwtZGVwZW5kZW5jaWVzLm1k">[SE-0201]<i class="fa fa-external-link-alt"></i></span>。</p>
<h5 id="将系统库目标（system-library-targets）添加到包中"><a href="#将系统库目标（system-library-targets）添加到包中" class="headerlink" title="将系统库目标（system library targets）添加到包中"></a>将系统库目标（system library targets）添加到包中</h5><p><code>System-module packages</code> 在 Swift 4.1 中需要单独的存储库。这使得包管理器难以使用，因此 Swift 4.2 将它们替换为 <code>system library targets</code><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0LWV2b2x1dGlvbi9ibG9iL21hc3Rlci9wcm9wb3NhbHMvMDIwOC1wYWNrYWdlLW1hbmFnZXItc3lzdGVtLWxpYnJhcnktdGFyZ2V0cy5tZA==">[SE-0208]<i class="fa fa-external-link-alt"></i></span>。</p>
<h4 id="删除隐式解包的选项"><a href="#删除隐式解包的选项" class="headerlink" title="删除隐式解包的选项"></a>删除隐式解包的选项</h4><p>在 Swift 4.1 中，可以在嵌套类型中使用隐式解包：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> favoriteNumbers: [<span class="type">Int</span>!] <span class="operator">=</span> [<span class="number">10</span>, <span class="literal">nil</span>, <span class="number">7</span>, <span class="literal">nil</span>]</span><br><span class="line"><span class="keyword">let</span> favoriteSongs: [<span class="type">String</span>: [<span class="type">String</span>]<span class="operator">!</span>] <span class="operator">=</span> [<span class="string">&quot;Cosmin&quot;</span>: [<span class="string">&quot;Nothing Else Matters&quot;</span>, <span class="string">&quot;Stairway to Heaven&quot;</span>], </span><br><span class="line">                                          <span class="string">&quot;Oana&quot;</span>: <span class="literal">nil</span>] </span><br><span class="line"><span class="keyword">let</span> credentials: (usermame: <span class="type">String</span>!, password: <span class="type">String</span>!) <span class="operator">=</span> (<span class="string">&quot;Cosmin&quot;</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<p>Swift 4.2 将它们从数组，字典和元组中删除<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0LWV2b2x1dGlvbi9ibG9iL21hc3Rlci9wcm9wb3NhbHMvMDA1NC1hYm9saXNoLWl1by5tZA==">[SE-0054]<i class="fa fa-external-link-alt"></i></span>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> favoriteNumbers: [<span class="type">Int</span>?] <span class="operator">=</span> [<span class="number">10</span>, <span class="literal">nil</span>, <span class="number">7</span>, <span class="literal">nil</span>]</span><br><span class="line"><span class="keyword">let</span> favoriteSongs: [<span class="type">String</span>: [<span class="type">String</span>]<span class="operator">?</span>] <span class="operator">=</span> [<span class="string">&quot;Cosmin&quot;</span>: [<span class="string">&quot;Nothing Else Matters&quot;</span>, <span class="string">&quot;Stairway to Heaven&quot;</span>], </span><br><span class="line">                                          <span class="string">&quot;Oana&quot;</span>: <span class="literal">nil</span>] </span><br><span class="line"><span class="keyword">let</span> credentials: (usermame: <span class="type">String</span>?, password: <span class="type">String</span>?) <span class="operator">=</span> (<span class="string">&quot;Cosmin&quot;</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<h3 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h3><hr>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucmF5d2VuZGVybGljaC5jb20vMTk0MDY2L3doYXRzLW5ldy1pbi1zd2lmdC00LTI=">What’s New in Swift 4.2?<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>文章翻译</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>在正确的线程上使用Observable【译】</title>
    <url>/2018/06/17/20180617-%E5%9C%A8%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%BD%BF%E7%94%A8Observable%E3%80%90%E8%AF%91%E3%80%91/</url>
    <content><![CDATA[<p>尽管很多人了解 RxJava 的基本逻辑，但是在 Observable 链和操作符究竟运行在哪个线程，仍然会有许多困惑。</p>
<p>首先，让我们梳理清晰，在 RxJava 中 <code>.subsribeOn()</code> 和 <code>.observeOn()</code> 区别：</p>
<ol>
<li><code>.subsribeOn()</code> 操作符可以改变 Observable 应该在哪个调度器上执行任务。</li>
<li><code>.observeOn()</code> 操作符可以改变 Observable 将在哪个调度器上发送通知。</li>
<li>另外，你需要知道，默认情况下，链上的操作符将会在调用 <code>.subsribeOn()</code> 的那个线程上执行任务。</li>
</ol>
<span id="more"></span>

<h3 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h3><hr>
<h4 id="主线程或者-subscribe-所在线程"><a href="#主线程或者-subscribe-所在线程" class="headerlink" title="主线程或者 .subscribe() 所在线程"></a>主线程或者 .subscribe() 所在线程</h4><p>如果在 Android 的 <code>Activity下onCreate()</code> 方法中，也就是主线程中使用如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    .subscribe( );</span><br></pre></td></tr></table></figure>

<p>表现会像这样：</p>
<p><img src="/my_pictures/20180617/1.png"></p>
<h4 id="调用-subscribeOn"><a href="#调用-subscribeOn" class="headerlink" title="调用 .subscribeOn()"></a>调用 .subscribeOn()</h4><p>尽管代码片段在主线程中，但是整个代码块将运行在 <code>.subscribeOn()</code> 定义的线程上：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    .subscribeOn(<span class="type">Schedulers</span>.newThread())</span><br><span class="line">    .subscribe();</span><br></pre></td></tr></table></figure>

<p>表现会像这样：</p>
<p><img src="/my_pictures/20180617/2.png"></p>
<h4 id="调用-observeOn"><a href="#调用-observeOn" class="headerlink" title="调用 .observeOn()"></a>调用 .observeOn()</h4><p>如果你的代码片段在主线程中，默认情况下Observable的创建是在 <code>.subscribeOn()</code> 定义的线程上，但是，调用 <code>.observeOn()</code> 之后，余下的代码将会执行在 <code>.observeOn()</code> 所定义的线程上：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    .observeOn(<span class="type">Schedulers</span>.newThread())</span><br><span class="line">    .subscribe();</span><br></pre></td></tr></table></figure>

<p><img src="/my_pictures/20180617/3.png"></p>
<h4 id="合并逻辑"><a href="#合并逻辑" class="headerlink" title="合并逻辑"></a>合并逻辑</h4><p>照理合并操作符，放在一起就像这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    .subscribeOn(<span class="type">Schedulers</span>.newThread())</span><br><span class="line">    .observeOn(<span class="type">Schedulers</span>.newThread())</span><br><span class="line">    .subscribe();</span><br></pre></td></tr></table></figure>

<p><img src="/my_pictures/20180617/4.png"></p>
<h3 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h3><hr>
<h4 id="UI-线程运行异常"><a href="#UI-线程运行异常" class="headerlink" title="UI 线程运行异常"></a>UI 线程运行异常</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    .subscribeOn(<span class="type">Schedulers</span>.newThread())</span><br><span class="line">    .subscribe(<span class="comment">/** 与UI线程相关的逻辑 **/</span><span class="operator">/</span>);</span><br></pre></td></tr></table></figure>

<p>很明显，这是错的。</p>
<h4 id="保证逻辑运行在工作线程中"><a href="#保证逻辑运行在工作线程中" class="headerlink" title="保证逻辑运行在工作线程中"></a>保证逻辑运行在工作线程中</h4><p>如果存在以下代码片段：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    .subscribeOn(<span class="type">Schedulers</span>.newThread())</span><br><span class="line">    .observeOn(<span class="type">AndroidSchedulers</span>.mainThread())</span><br><span class="line"> </span><br><span class="line">    .flatMap(<span class="comment">/** 与UI线程无关的逻辑**/</span><span class="operator">/</span>)</span><br><span class="line"> </span><br><span class="line">    .subscribe();</span><br></pre></td></tr></table></figure>

<p>请用以下代码替代：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    .subscribeOn(<span class="type">Schedulers</span>.newThread())</span><br><span class="line"> </span><br><span class="line">    .flatMap(<span class="comment">/** 与UI线程无关的逻辑**/</span><span class="operator">/</span>)</span><br><span class="line"> </span><br><span class="line">    .observeOn(<span class="type">AndroidSchedulers</span>.mainThread())</span><br><span class="line">    .subscribe();</span><br></pre></td></tr></table></figure>

<p>通过用第二段代码代替第一段，<code>.flatMap()</code> 操作符（或者在这一点的其他逻辑操作符）将运行在后台线程。这样做就不会阻塞 UI 线程，同时可以防患 ANR 或其他类似问题的发生。看起来有点像 <code>AsyncTask</code> 模式，尽可能的把逻辑放在的 <code>.doInBackground()</code> 中，而不是 <code>.onPostExecute()</code> 。</p>
<h4 id="取决于更早的-subscribeOn"><a href="#取决于更早的-subscribeOn" class="headerlink" title="取决于更早的 .subscribeOn()"></a>取决于更早的 .subscribeOn()</h4><p>以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    .subscribeOn(thread1)</span><br><span class="line">    .subscribeOn(thread2)</span><br><span class="line">    .subscribe();</span><br></pre></td></tr></table></figure>

<p>因为 <code>thread1</code> 的逻辑将会覆盖 <code>thread2</code>，所以 <code>Observable</code> 的创建和 <code>.subscribe()</code> 的逻辑处理都将运行在 <code>thread1</code> 中。因此，根本没有必要写多个 <code>.subscribeOn()</code> 操作符。</p>
<h4 id="原文链接："><a href="#原文链接：" class="headerlink" title="原文链接："></a>原文链接：</h4><p><span class="exturl" data-url="aHR0cHM6Ly9sb3JlbnR6b3MuY29tL29ic2VydmUtaW4tdGhlLWNvcnJlY3QtdGhyZWFkLTE5MzliYjliYjlkMg==">Observe on the correct thread<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>文章翻译</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>Charles 如何对 HTTPS 进行抓包？</title>
    <url>/2018/06/21/20180621-Charles%20%E5%A6%82%E4%BD%95%E5%AF%B9%20HTTPS%E8%BF%9B%E8%A1%8C%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<p>对 http 的抓包非常的简单，但是对 https 的抓包就有点麻烦了，主要麻烦在证书的安装与设置上。昨天由于有需要去抓https 的包，但是装好证书后，手机一直连不上，特此记录一下。</p>
<p>想要抓取 https 包，首先我们需要在电脑上安装一个 Charles Proxy 的证书</p>
<h3 id="安装-Charles-Root-Certificate"><a href="#安装-Charles-Root-Certificate" class="headerlink" title="安装 Charles Root Certificate"></a>安装 Charles Root Certificate</h3><hr>
<p>1、依次点击：Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate</p>
<p><img src="/my_pictures/20180621/1.png"></p>
<span id="more"></span>

<p>2、打开我们系统的 <code>钥匙串</code> 应用，找到如下的证书（老版本的证书名字可能有所不同）：</p>
<p><img src="/my_pictures/20180621/2.png"></p>
<p>3、右键证书 -&gt; 显示简介 -&gt; 将信任设置成【始终信任】，如下所示：</p>
<p><img src="/my_pictures/20180621/3.png"></p>
<p>至此，macOS 系统的证书安装完毕。</p>
<h3 id="在-iOS-上安装证书"><a href="#在-iOS-上安装证书" class="headerlink" title="在 iOS 上安装证书"></a>在 iOS 上安装证书</h3><hr>
<p>1、将手机 WiFi 的配置代理一项设置成手动，服务器一栏输入自己电脑的 IP 地址，端口一栏输入 8888，保存返回。</p>
<p>2、打开手机的浏览器，输入 <code>chls.pro/ssl</code> 打开这个网址，提示框选择允许，如下：</p>
<p><img src="/my_pictures/20180621/4.PNG"></p>
<p>3、安装证书</p>
<p><img src="/my_pictures/20180621/5.PNG"></p>
<p>4、信任证书【此步容易忘，注意】，设置 -&gt; 通用 -&gt; 关于本机 -&gt; 证书信任设置</p>
<p><img src="/my_pictures/20180621/6.PNG"></p>
<h3 id="SSL-Proxying-Settings"><a href="#SSL-Proxying-Settings" class="headerlink" title="SSL Proxying Settings"></a>SSL Proxying Settings</h3><hr>
<p>1、Proxy -&gt; SSL Proxying Settings 点击 add 按钮，按如下方式添加：</p>
<p><img src="/my_pictures/20180621/7.png"></p>
<p>2、如果连接还是加密状态的话，右键选择连接，点击 <code>Enable SSL Proxying</code>：</p>
<p><img src="/my_pictures/20180621/8.png"></p>
<p>现在就可以对任何的 https 连接进行抓包了。</p>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 iOS 导航栏隐藏和显示</title>
    <url>/2018/06/22/20180622-%E8%A7%A3%E5%86%B3%20iOS%20%E5%AF%BC%E8%88%AA%E6%A0%8F%E9%9A%90%E8%97%8F%E5%92%8C%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>今天在项目中遇到了隐藏 <code>navigationbar</code> 功能的问题，例如：从 A push到 B 页面，A 页面的 <code>navigationbar</code> 是隐藏的，但是 B 页面的 <code>navigationbar</code> 是需要显示的。</p>
<p>一开始我在 A 页面调用 <code>setNavigationBarHidden(true, animated: true)</code> 方法，在 B 页面调用 <code>setNavigationBarHidden(false, animated: true)</code> 方法，虽然能够达到想要的效果，但是对于项目来说是灾难性的。因为如果有多个地方出现这种情况的话，你的代码将会变得十分的杂乱臃肿。</p>
<p>一种好的解决方式是调用 <code>navigationcontroller</code> 的代理：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">navigationController(<span class="keyword">_</span>:willShow:animated:)</span><br></pre></td></tr></table></figure>

<p>将这个代理放在项目控制器的基类中，在这里我是放在我的基类 <code>BaseViewController</code> 中。为什么这么做？因为这样可以很好的去掉冗余的代码，不用写的到处都是，我的所有控制器都是继承自 <code>BaseViewController</code> 的，<code>BaseViewController</code> 继承自 <code>UIViewController</code>。</p>
<p>下面到了 Show Code 的时候了</p>
<span id="more"></span>

<h3 id="基类实现代理方法"><a href="#基类实现代理方法" class="headerlink" title="基类实现代理方法"></a>基类实现代理方法</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">BaseViewController</span>: <span class="title class_ inherited__">UINavigationControllerDelegate</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">navigationController</span>(<span class="keyword">_</span> <span class="params">navigationController</span>: <span class="type">UINavigationController</span>, <span class="params">willShow</span> <span class="params">viewController</span>: <span class="type">UIViewController</span>, <span class="params">animated</span>: <span class="type">Bool</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 这里判断是否是当前代理控制器，如果是当前代理控制器的话，则是需要隐藏 navigationbar 的</span></span><br><span class="line">        <span class="keyword">if</span> viewController <span class="operator">==</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            navigationController.setNavigationBarHidden(<span class="literal">true</span>, animated: <span class="literal">true</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/// 系统相册不能隐藏，所有就直接 return</span></span><br><span class="line">            <span class="keyword">if</span> navigationController.isKind(of: <span class="type">UIImagePickerController</span>.<span class="keyword">self</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/// 不是当前代理控制器的话，显示真正的 navbar</span></span><br><span class="line">            navigationController.setNavigationBarHidden(<span class="literal">false</span>, animated: <span class="literal">true</span>)</span><br><span class="line">            <span class="comment">/// 当不显示本页时，要么就 push 到下一页，要么就被 pop 了，那么就将 delegate 设置为 nil，防止出现 BAD ACCESS</span></span><br><span class="line">            <span class="comment">/// 之前将这段代码放在 viewDidDisappear 和 dealloc 中，这两种情况可能已经被 pop 了，self.navigationController 为 nil，这里采用手动持有 navigationController 的引用来解决</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> delegate <span class="operator">=</span> navigationController.delegate, delegate <span class="operator">===</span> <span class="keyword">self</span> &#123;</span><br><span class="line">                <span class="comment">/// 如果 delegate 是自己才设置为 nil，因为 viewWillAppear 调用的比此方法较早，</span></span><br><span class="line">                <span class="comment">/// 其他 controller 如果设置了 delegate 就可能会被误伤</span></span><br><span class="line">                navigationController.delegate <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在需要隐藏-navigationbar-的地方，添加如下代码"><a href="#在需要隐藏-navigationbar-的地方，添加如下代码" class="headerlink" title="在需要隐藏 navigationbar 的地方，添加如下代码"></a>在需要隐藏 navigationbar 的地方，添加如下代码</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.navigationController<span class="operator">?</span>.delegate <span class="operator">=</span> <span class="keyword">self</span></span><br></pre></td></tr></table></figure>

<p>这样就能解决显示&#x2F;隐藏的问题了。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8zYWYxNWU3ZDAyYzc=">iOS 开发 完美解决navigationBar隐藏&#x2F;显示<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包实现addTarget方法-面向协议编程</title>
    <url>/2018/06/25/20180625-%E9%97%AD%E5%8C%85%E5%AE%9E%E7%8E%B0addTarget%E6%96%B9%E6%B3%95-%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>Swift 是一门面向协议的编程语言，为什么这么说，请看 WWDC 视频 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL3ZpZGVvcy9wbGF5L3d3ZGMyMDE1LzQwOC8=">Protocol-Oriented Programming in Swift<i class="fa fa-external-link-alt"></i></span>。</p>
<p>通过闭包的方式为 <code>UIControl</code> 添加 <code>action</code> 的实现方式有很多种，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">UIControl</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">listen</span>(<span class="keyword">_</span> <span class="params">action</span>: <span class="keyword">@escaping</span> () -&gt; (), <span class="params">for</span> <span class="params">controlEvents</span>: <span class="type">UIControlEvents</span>) -&gt; <span class="type">AnyObject</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> sleeve <span class="operator">=</span> <span class="type">ClosureSleeve</span>(attachTo: <span class="keyword">self</span>, closure: action, controlEvents: controlEvents)</span><br><span class="line">        addTarget(sleeve, action: <span class="keyword">#selector</span>(<span class="type">ClosureSleeve</span>.invoke), for: controlEvents)</span><br><span class="line">        <span class="keyword">return</span> sleeve</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">listenOnce</span>(<span class="keyword">_</span> <span class="params">action</span>: <span class="keyword">@escaping</span> () -&gt; (), <span class="params">for</span> <span class="params">controlEvents</span>: <span class="type">UIControlEvents</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> sleeve <span class="operator">=</span> <span class="type">ClosureSleeve</span>(attachTo: <span class="keyword">self</span>, closure: action, controlEvents: controlEvents)</span><br><span class="line">        addTarget(sleeve, action: <span class="keyword">#selector</span>(<span class="type">ClosureSleeve</span>.invokeOnce), for: controlEvents)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">unlisten</span>(<span class="params">sleeve</span>: <span class="type">AnyObject</span>) &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> sleeve <span class="operator">=</span> sleeve <span class="keyword">as?</span> <span class="type">ClosureSleeve</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.removeTarget(sleeve, action: <span class="keyword">#selector</span>(<span class="type">ClosureSleeve</span>.invoke), for: sleeve.controlEvents)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ClosureSleeve</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> closure: () -&gt; ()</span><br><span class="line">    <span class="keyword">let</span> controlEvents:<span class="type">UIControlEvents</span></span><br><span class="line">    <span class="keyword">let</span> attachedTo: <span class="type">AnyObject</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">attachTo</span>: <span class="type">AnyObject</span>, <span class="params">closure</span>: <span class="keyword">@escaping</span> () -&gt; (), <span class="params">controlEvents</span>:<span class="type">UIControlEvents</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.attachedTo <span class="operator">=</span> attachTo</span><br><span class="line">        <span class="keyword">self</span>.closure <span class="operator">=</span> closure</span><br><span class="line">        <span class="keyword">self</span>.controlEvents <span class="operator">=</span> controlEvents</span><br><span class="line">        objc_setAssociatedObject(attachTo, <span class="string">&quot;[<span class="subst">\(arc4random())</span>]&quot;</span>, <span class="keyword">self</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">func</span> <span class="title function_">invoke</span>() &#123;</span><br><span class="line">        closure()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">func</span> <span class="title function_">invokeOnce</span>() &#123;</span><br><span class="line">        closure()</span><br><span class="line">        attachedTo.unlisten(sleeve: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>这种实现方式看起来似乎没有问题，用法如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Register listener, keep the reference to unregister the listener</span></span><br><span class="line"><span class="keyword">let</span> listener <span class="operator">=</span> button.listenOnce(&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I will say this every time you tap the button&quot;</span>)</span><br><span class="line">&#125;, for: [.touchUpInside])</span><br><span class="line"></span><br><span class="line"><span class="comment">// … later …</span></span><br><span class="line">button.unlisten(listener)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listen once for the control events, automatically unlisten when the block is performed</span></span><br><span class="line">button.listenOnce(&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I will only say this once&quot;</span>)</span><br><span class="line">&#125;, for: [.touchUpInside, .touchDragExit])</span><br></pre></td></tr></table></figure>

<p>使用起来也是简洁可读性好，但是如果我们这样用</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">attachedTo.unlisten(sleeve: <span class="keyword">self</span>)</span><br></pre></td></tr></table></figure>

<p>会导致崩溃，因为 <code>attachedTo</code> 是一个 <code>AnyObject</code> 类型，如果我们在其他对象上调用的话会出现崩溃的现象。我们也可以用 <code>respondsToSelector</code> 来判断。或者将 <code>attachedTo</code> 变量改为 <code>UIControl</code>，但是如果你想在其他的控件上使用 <code>ClosureSleeve</code> 的话，它将不起作用。这时我们可以使用协议来解决。</p>
<p>在此之前，我们应将闭包包装成一个 <code>class</code>，让闭包能作为关联对象存储。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Container class for closures, so that closure can be stored as an associated object</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ClosureContainer</span>&lt;<span class="type">T</span>: <span class="type">Closurable</span>&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> closure: (<span class="type">T</span>) -&gt; <span class="type">Void</span></span><br><span class="line">    <span class="keyword">var</span> sender: <span class="type">T</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">closure</span>: <span class="keyword">@escaping</span> (<span class="type">T</span>) -&gt; <span class="type">Void</span>, <span class="params">sender</span>: <span class="type">T</span>?) &#123;</span><br><span class="line">        <span class="keyword">self</span>.closure <span class="operator">=</span> closure</span><br><span class="line">        <span class="keyword">self</span>.sender <span class="operator">=</span> sender</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// method for the target action, visible to UIKit classes via @objc</span></span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">func</span> <span class="title function_">processHandler</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> sender <span class="operator">=</span> sender &#123;</span><br><span class="line">            closure(sender)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// target action</span></span><br><span class="line">    <span class="keyword">var</span> action: <span class="type">Selector</span> &#123; <span class="keyword">return</span> <span class="keyword">#selector</span>(processHandler) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们来实现我们的协议</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ************** Protocol ***************</span></span><br><span class="line"><span class="comment">/// Closurable protocol</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">Closurable</span>: <span class="keyword">class</span> &#123;&#125;</span><br><span class="line"><span class="comment">// restrict protocol to only classes =&gt; can refer to the class instance in the protocol extension</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Closurable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Create container for closure, store it and return it</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">getContainer</span>(<span class="params">for</span> <span class="params">closure</span>: <span class="keyword">@escaping</span> (<span class="keyword">Self</span>) -&gt; <span class="type">Void</span>) -&gt; <span class="type">ClosureContainer</span>&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">weak</span> <span class="keyword">var</span> weakSelf <span class="operator">=</span> <span class="keyword">self</span></span><br><span class="line">        <span class="keyword">let</span> container <span class="operator">=</span> <span class="type">ClosureContainer</span>(closure: closure, sender: weakSelf)</span><br><span class="line">        <span class="comment">// store the container so that it can be called later, we do not need to explicitly retrieve it.</span></span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, <span class="type">Unmanaged</span>.passUnretained(<span class="keyword">self</span>).toOpaque(), container, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">        <span class="keyword">return</span> container</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我想让 <code>UIButton</code> 能够使用闭包进行 <code>addTarget</code> 操作，我们只需要让 <code>UIButton</code> 满足 <code>Closurable</code> 协议即可：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">UIButton</span>: <span class="title class_ inherited__">Closurable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">addTarget</span>(<span class="params">forControlEvents</span>: <span class="type">UIControlEvents</span> <span class="operator">=</span> .touchUpInside, <span class="params">closure</span>: <span class="keyword">@escaping</span> (<span class="type">UIButton</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> container <span class="operator">=</span> getContainer(for: closure)</span><br><span class="line">        addTarget(container, action: container.action, for: forControlEvents)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方式如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> btn <span class="operator">=</span> <span class="type">UIButton</span>()</span><br><span class="line">btn.addTarget &#123; (sender) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;click button&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">btn.addTarget(forControlEvents: .touchUpInside) &#123; (sender) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;click button&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就避免了如上的错误可能，可扩展性也不错。并且我们不仅可以用于 <code>UIControl</code> 类型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// extension for UIBarButtonItem - actions with closure</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">UIBarButtonItem</span>: <span class="title class_ inherited__">Closurable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(<span class="params">image</span>: <span class="type">UIImage</span>?, <span class="params">style</span>: <span class="type">UIBarButtonItemStyle</span> <span class="operator">=</span> .plain, <span class="params">closure</span>: <span class="keyword">@escaping</span> (<span class="type">UIBarButtonItem</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(image: image, style: style, target: <span class="literal">nil</span>, action: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">let</span> container <span class="operator">=</span> getContainer(for: closure)</span><br><span class="line">        target <span class="operator">=</span> container</span><br><span class="line">        action <span class="operator">=</span> container.action</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(<span class="params">title</span>: <span class="type">String</span>?, <span class="params">style</span>: <span class="type">UIBarButtonItemStyle</span> <span class="operator">=</span> .plain, <span class="params">closure</span>: <span class="keyword">@escaping</span> (<span class="type">UIBarButtonItem</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(title: title, style: style, target: <span class="literal">nil</span>, action: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">let</span> container <span class="operator">=</span> getContainer(for: closure)</span><br><span class="line">        target <span class="operator">=</span> container</span><br><span class="line">        action <span class="operator">=</span> container.action</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vUEVaL2U0YTc5MDg3MDg1NWEwYmIzYTQ1ZGEyZGE4ZjcxYWEz">UIControl+ListenBlock.swift<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vTW94aW1pbGxpYW4vNWY2ZDYwZTJjZDEyMjJlNTU3NTQ3YTQyNTU4NjY5YWU=">ClosureProtocolExtensions.swift<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 配置测试用推送通知证书</title>
    <url>/2018/06/29/20180629-iOS%20%E9%85%8D%E7%BD%AE%E6%B5%8B%E8%AF%95%E7%94%A8%E6%8E%A8%E9%80%81%E9%80%9A%E7%9F%A5%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<p>最近做通知的时候需要对通知进行测试，之前没有做证书的经验，这次尝试了一下，写这篇文章备忘。</p>
<p>测试用的工具叫做 Pusher，下载地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25vb2RsZXdlcmsvTldQdXNoZXI=">NWPusher<i class="fa fa-external-link-alt"></i></span>。非常的好用。</p>
<h3 id="创建测试用-Push-证书"><a href="#创建测试用-Push-证书" class="headerlink" title="创建测试用 Push 证书"></a>创建测试用 Push 证书</h3><hr>
<p>1、打开苹果开发者页面：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tLw==">Developer<i class="fa fa-external-link-alt"></i></span>，登录账户。</p>
<p>2、在账户的 <code>Certificates, Identifiers &amp; Profiles</code> 页面找到 <code>Identifiters</code>，选择 <code>App IDs</code>。</p>
<p>3、找到自己 App，点击打开，能看到如下所示。</p>
<p><img src="/my_pictures/20180629/1.png"></p>
<p>如果你没有配置 <code>Push Notifications</code>，那么它的 <code>Development</code> 和 <code>Distribution</code> 都是 <code>Configurable</code> 状态。点击 <code>Edit</code> 按钮。</p>
<p>我们要创建测试用的证书就点击 <code>Development SSL Certificate</code> 下面的 <code>Create Certificate</code>。</p>
<span id="more"></span>

<p><img src="/my_pictures/20180629/2.png"></p>
<p>直接 <code>Continue</code>，接下来的页面需要我们上传 <code>.certSigningRequest</code> 的文件，这个文件需要在我们自己的电脑上制作。</p>
<h3 id="制作-certSigningRequest-文件"><a href="#制作-certSigningRequest-文件" class="headerlink" title="制作 certSigningRequest 文件"></a>制作 certSigningRequest 文件</h3><hr>
<p>1、打开电脑上的钥匙串应用。</p>
<p>2、点击钥匙串访问 -&gt; 证书助理 -&gt; 从证书颁发机构请求证书…</p>
<p><img src="/my_pictures/20180629/3.png"></p>
<p>3、填写相关信息，生成 <code>.certSigningRequest</code> 文件。</p>
<p><img src="/my_pictures/20180629/4.png"></p>
<h3 id="完成证书制作"><a href="#完成证书制作" class="headerlink" title="完成证书制作"></a>完成证书制作</h3><hr>
<p>1、刚才制作证书那里，上传我们生成的 <code>.certSigningRequest</code> 文件。</p>
<p>2、证书制作完成，下载证书，双击安装到我们的钥匙串中。</p>
<p><img src="/my_pictures/20180629/5.png"></p>
<p>3、因为我们需要的是一个 <code>.p12</code> 的文件，所以我们右键钥匙串刚安装的 <code>Apple Development IOS Push Services</code> 证书，选择导出。</p>
<p><img src="/my_pictures/20180629/6.png"></p>
<p>这样，我们的 Push 证书就做好了。</p>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Swift 4 中 NavigationBar 不同颜色时的转场</title>
    <url>/2018/07/06/20180706-NavigationBar%20%E4%B8%8D%E5%90%8C%E9%A2%9C%E8%89%B2%E6%97%B6%E7%9A%84%E8%BD%AC%E5%9C%BA/</url>
    <content><![CDATA[<p>我们在项目中，往往会遇到两个 Navigation Bar 样式不同的问题，如果直接用苹果官方的控件，会出现各种各样的 bug，因为苹果官方的 Navigation Bar 是共用的，所以在两个不同样式的 Navigation Bar 中做转场操作的时候就会出现各种问题。</p>
<p>今天我们就用 Method Swizzling 的方式来修改一下系统的 Navigation Bar 转场时的样式，最终效果如下图所示：</p>
<p><img src="/my_pictures/20180706/1.gif"></p>
<h3 id="设置导航栏的背景颜色"><a href="#设置导航栏的背景颜色" class="headerlink" title="设置导航栏的背景颜色"></a>设置导航栏的背景颜色</h3><hr>
<p>我们来为 <code>UIViewController</code> 添加一个扩展，用于存储与设置 <code>Navigation Bar</code> 各种属性。首先，我们来为我们的 <code>UIViewController</code> 添加一个 <code>navBarBgColor</code> 的计算属性。<br>这里运用了 <code>runtime</code> 的关联方法 <code>objc_getAssociatedObject:</code> 和 <code>objc_setAssociatedObject:</code> 来存取所设置的背景颜色。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">UIViewController</span> &#123;</span><br><span class="line">    <span class="comment">/// 设置导航栏的背景颜色</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">var</span> navBarBgColor: <span class="type">UIColor</span> &#123;</span><br><span class="line">		<span class="keyword">get</span> &#123;</span><br><span class="line">		    <span class="keyword">if</span> <span class="keyword">let</span> color <span class="operator">=</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="operator">&amp;</span><span class="type">DefaultValue</span>.navBarBgColor) <span class="keyword">as?</span> <span class="type">UIColor</span> &#123;</span><br><span class="line">		        <span class="keyword">return</span> color</span><br><span class="line">		    &#125;</span><br><span class="line">		    <span class="keyword">return</span> <span class="type">DefaultValue</span>.navBarBgColor</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">set</span> &#123;</span><br><span class="line">		    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="operator">&amp;</span><span class="type">DefaultValue</span>.navBarBgColor, newValue, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">		    navigationController<span class="operator">?</span>.navBarBackgroundColor(newValue)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>这时我们就可以存储与设置导航栏的背景色了。</p>
<p>然后我们再为 <code>NavigationController</code> 添加一个扩展，用来调用 <code>Navigationbar</code> 的具体设置方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">UINavigationController</span> &#123;</span><br><span class="line">    <span class="comment">/// 设置背景色</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">func</span> <span class="title function_">navBarBackgroundColor</span>(<span class="keyword">_</span> <span class="params">color</span>: <span class="type">UIColor</span>) &#123;</span><br><span class="line">        navigationBar.backgroundColor(color)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后我们在扩展 <code>Navigationbar</code>，添加具体的设置逻辑。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">UINavigationBar</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 导航栏背景视图</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> backgroundView: <span class="type">UIView</span>? &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> bgView <span class="operator">=</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="operator">&amp;</span><span class="type">DefaultValue</span>.backgroundView) <span class="keyword">as?</span> <span class="type">UIView</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> bgView</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            objc_setAssociatedObject(<span class="keyword">self</span>, <span class="operator">&amp;</span><span class="type">DefaultValue</span>.backgroundView, newValue, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 设置导航栏背景色</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">func</span> <span class="title function_">backgroundColor</span>(<span class="keyword">_</span> <span class="params">color</span>: <span class="type">UIColor</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> backgroundView <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 添加一个透明背景的 image 到 _UIBarBackground</span></span><br><span class="line">            setBackgroundImage(<span class="type">UIImage</span>(), for: .default)</span><br><span class="line">            <span class="keyword">let</span> height <span class="operator">=</span> <span class="type">DeviceInfo</span>.deviceName <span class="operator">==</span> .iPhoneX <span class="operator">?</span> <span class="number">64</span> : <span class="number">88</span></span><br><span class="line">            backgroundView <span class="operator">=</span> <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="type">Int</span>(bounds.width), height: height))</span><br><span class="line">            backgroundView<span class="operator">?</span>.autoresizingMask <span class="operator">=</span> .flexibleWidth</span><br><span class="line">            <span class="comment">// _UIBarBackground 是 navigationBar 的第一个子视图</span></span><br><span class="line">            subviews.first<span class="operator">?</span>.insertSubview(backgroundView <span class="operator">??</span> <span class="type">UIView</span>(), at: <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        backgroundView<span class="operator">?</span>.backgroundColor <span class="operator">=</span> color</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们是直接插入一个 <code>View</code> 到 <code>NavigationBar</code> 的 <code>_UIBarBackground </code> 中，我们直接在这个 <code>View</code> 上面修改颜色即可。至此，设置 <code>NavigationBar</code> 的背景色告一段落，下来我们来看看转场如何做到颜色的均匀过度。</p>
<h3 id="颜色过度-runtime"><a href="#颜色过度-runtime" class="headerlink" title="颜色过度 - runtime"></a>颜色过度 - runtime</h3><hr>
<p>要想做到在右滑进行 <code>pop</code> 操作的时候导航栏颜色均匀的过度需要替换一个系统方法 <code>_updateInteractiveTransition:</code>，这个方法是用来监听手势的返回进度的，我们可以在这个方法中计算每一个进度时候导航栏颜色的变化。</p>
<p>大家都知道，在 <code>Objective-C</code> 中进行 <code>Method Swizzling</code> 的时候都需要将替换逻辑放在 <code>dispatch_once</code> 中去执行，保证其执行一次。在 Swift 中，现在已经去掉了 <code>dispatch_once</code> 方法，那么我们应该如何做呢？</p>
<p>苹果文档说道，声明为 <code>static let</code> 和 <code>lazy</code> 的变量具有 <code>dispatch_once</code> 的效果。所以我们就可以用更加 Swift 的方式去实现自己的逻辑，不需要去再造一个 <code>dispatch_once</code> 出来。代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Swift 中 static let 具备 dispatch once 特性，所以可以用这种方式声明，</span></span><br><span class="line"><span class="comment"> * 闭包的形式声明一个代码块，默认是懒加载</span></span><br><span class="line"><span class="comment"> * 类似于 Objective-c 中的 dispatch once</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">let</span> swizzle: () <span class="operator">=</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> needSwizzleSelectorAry <span class="operator">=</span> [</span><br><span class="line">        <span class="type">NSSelectorFromString</span>(<span class="string">&quot;_updateInteractiveTransition:&quot;</span>),</span><br><span class="line">        <span class="keyword">#selector</span>(popToViewController(<span class="keyword">_</span>:animated:)),</span><br><span class="line">        <span class="keyword">#selector</span>(popToRootViewController(animated:))</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">let</span> swizzleSelectorAry <span class="operator">=</span> [</span><br><span class="line">        <span class="keyword">#selector</span>(em_updateInteractiveTransition(<span class="keyword">_</span>:)),</span><br><span class="line">        <span class="keyword">#selector</span>(em_popToViewController(<span class="keyword">_</span>:animated:)),</span><br><span class="line">        <span class="keyword">#selector</span>(em_popToRootViewControllerAnimated(<span class="keyword">_</span>:))</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> sel <span class="keyword">in</span> needSwizzleSelectorAry &#123;</span><br><span class="line">        <span class="keyword">let</span> str <span class="operator">=</span> (<span class="string">&quot;em_&quot;</span> <span class="operator">+</span> sel.description).replacingOccurrences(of: <span class="string">&quot;__&quot;</span>, with: <span class="string">&quot;_&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> originMethod <span class="operator">=</span> class_getInstanceMethod(<span class="type">UINavigationController</span>.<span class="keyword">self</span>, sel),</span><br><span class="line">            <span class="keyword">let</span> swizzleMethod <span class="operator">=</span> class_getInstanceMethod(<span class="type">UINavigationController</span>.<span class="keyword">self</span>, <span class="type">Selector</span>(str)) &#123;</span><br><span class="line">            </span><br><span class="line">            method_exchangeImplementations(originMethod, swizzleMethod)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>这样就可以实现 <code>dispatch_once</code> 的效果。</p>
<p>接下来又是一个棘手的问题，Swift 中已经没有了 <code>+load</code> 方法怎么办，甚至 Swift 3.1 之后 <code>+initialize</code> 方法都已经不能用了。这可如何是好。经过 Google，发现了一个替代的方案，用 Swift 的协议来进行实现：<span class="exturl" data-url="aHR0cDovL2pvcmRhbnNtaXRoLmlvL2hhbmRsaW5nLXRoZS1kZXByZWNhdGlvbi1vZi1pbml0aWFsaXplLw==">Handling the Deprecation of initialize()<i class="fa fa-external-link-alt"></i></span></p>
<p>JORDAN SMITH 想法其实很简单，是通过 <code>runtime</code> 获取到所有类的列表，然后向所有遵循 <code>SelfAware</code> 协议的类发送消息，并且他把这些操作放到了 <code>UIApplication</code> 的 <code>next</code> 属性的调用中，同时发现了 <code>next</code> 属性会在 <code>applicationDidFinishLaunching</code> 之前被调用。 </p>
<p>代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">protocol</span> <span class="title class_">SelfAware</span>: <span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">awake</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">NothingToSeeHere</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">harmlessFunction</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> typeCount <span class="operator">=</span> <span class="type">Int</span>(objc_getClassList(<span class="literal">nil</span>, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">let</span> types <span class="operator">=</span> <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">AnyClass</span>?&gt;.allocate(capacity: typeCount)</span><br><span class="line">        <span class="keyword">let</span> autoreleasingTypes <span class="operator">=</span> <span class="type">AutoreleasingUnsafeMutablePointer</span>&lt;<span class="type">AnyClass</span>&gt;(types)</span><br><span class="line">        objc_getClassList(autoreleasingTypes, <span class="type">Int32</span>(typeCount))</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>typeCount &#123; (types[index] <span class="keyword">as?</span> <span class="type">SelfAware</span>.<span class="keyword">Type</span>)<span class="operator">?</span>.awake() &#125;</span><br><span class="line">        types.deallocate()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">UIApplication</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 启动只执行一次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">let</span> runOnce: <span class="type">Void</span> <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="type">NothingToSeeHere</span>.harmlessFunction()</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">open</span> <span class="keyword">var</span> next: <span class="type">UIResponder</span>? &#123;</span><br><span class="line">        <span class="comment">/// Called before applicationDidFinishLaunching</span></span><br><span class="line">        <span class="type">UIApplication</span>.runOnce</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在别人的帮助下，我们也算是优雅的实现了需要的功能，我们将 <code>swizzle</code> 方法放在 <code>awake()</code> 中去执行。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">UINavigationController</span>: <span class="title class_ inherited__">SelfAware</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">awake</span>() &#123;</span><br><span class="line">        <span class="comment">/// 判断是否是其子类</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">self</span> <span class="operator">!==</span> <span class="type">UINavigationController</span>.<span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.swizzle</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="计算颜色的过度"><a href="#计算颜色的过度" class="headerlink" title="计算颜色的过度"></a>计算颜色的过度</h3><hr>
<p>接下来我们需要一个方法来计算颜色的过度：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算颜色的过度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">averageColor</span>(<span class="params">fromColor</span>: <span class="type">UIColor</span>, <span class="params">toColor</span>: <span class="type">UIColor</span>, <span class="params">percent</span>: <span class="type">CGFloat</span>) -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> fromRed: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> fromGreen: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> fromBlue: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> fromAlpha: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    fromColor.getRed(<span class="operator">&amp;</span>fromRed, green: <span class="operator">&amp;</span>fromGreen, blue: <span class="operator">&amp;</span>fromBlue, alpha: <span class="operator">&amp;</span>fromAlpha)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> toRed: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> toGreen: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> toBlue: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> toAlpha: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    toColor.getRed(<span class="operator">&amp;</span>toRed, green: <span class="operator">&amp;</span>toGreen, blue: <span class="operator">&amp;</span>toBlue, alpha: <span class="operator">&amp;</span>toAlpha)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> nowRed <span class="operator">=</span> fromRed <span class="operator">+</span> (toRed <span class="operator">-</span> fromRed) <span class="operator">*</span> percent</span><br><span class="line">    <span class="keyword">let</span> nowGreen <span class="operator">=</span> fromGreen <span class="operator">+</span> (toGreen <span class="operator">-</span> fromGreen) <span class="operator">*</span> percent</span><br><span class="line">    <span class="keyword">let</span> nowBlue <span class="operator">=</span> fromBlue <span class="operator">+</span> (toBlue <span class="operator">-</span> fromBlue) <span class="operator">*</span> percent</span><br><span class="line">    <span class="keyword">let</span> nowAlpha <span class="operator">=</span> fromAlpha <span class="operator">+</span> (toAlpha <span class="operator">-</span> fromAlpha) <span class="operator">*</span> percent</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIColor</span>(red: nowRed, green: nowGreen, blue: nowBlue, alpha: nowAlpha)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现我们自己的 <code>_updateInteractiveTransition:</code> 方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 用于替换系统的 _updateInteractiveTransition: 方法，监听返回手势进度</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="keyword">func</span> <span class="title function_">em_updateInteractiveTransition</span>(<span class="keyword">_</span> <span class="params">percentComplete</span>: <span class="type">CGFloat</span>) &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">self</span>.isKind(of: <span class="type">EMNavigationController</span>.<span class="keyword">self</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="keyword">let</span> topVC <span class="operator">=</span> <span class="keyword">self</span>.topViewController</span><br><span class="line">    <span class="comment">/// transitionCoordinator 带有两个 VC 的转场上下文</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> coor <span class="operator">=</span> topVC<span class="operator">?</span>.transitionCoordinator,</span><br><span class="line">        <span class="keyword">let</span> fromVC <span class="operator">=</span> coor.viewController(forKey: .from) <span class="keyword">as?</span> <span class="type">EMViewController</span>,</span><br><span class="line">        <span class="keyword">let</span> toVC <span class="operator">=</span> coor.viewController(forKey: .to) <span class="keyword">as?</span> <span class="type">EMViewController</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> fromAlpha <span class="operator">=</span> fromVC.navBarBgAlpha</span><br><span class="line">        <span class="keyword">let</span> toAlpha <span class="operator">=</span> toVC.navBarBgAlpha</span><br><span class="line">        <span class="keyword">let</span> nowAlpha <span class="operator">=</span> fromAlpha <span class="operator">+</span> (toAlpha <span class="operator">-</span> fromAlpha) <span class="operator">*</span> percentComplete</span><br><span class="line">        <span class="keyword">self</span>.navBarBackgroundAlpha(nowAlpha)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> fromTintColor <span class="operator">=</span> fromVC.navBarTintColor</span><br><span class="line">        <span class="keyword">let</span> toTintColor <span class="operator">=</span> toVC.navBarTintColor</span><br><span class="line">        <span class="keyword">let</span> nowTintColor <span class="operator">=</span> averageColor(fromColor: fromTintColor, toColor: toTintColor, percent: percentComplete)</span><br><span class="line">        <span class="keyword">self</span>.navBarTintColor(nowTintColor)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> fromColor <span class="operator">=</span> fromVC.navBarBgColor</span><br><span class="line">        <span class="keyword">let</span> toColor <span class="operator">=</span> toVC.navBarBgColor</span><br><span class="line">        <span class="keyword">let</span> nowColor <span class="operator">=</span> averageColor(fromColor: fromColor, toColor: toColor, percent: percentComplete)</span><br><span class="line">        <span class="keyword">self</span>.navBarBackgroundColor(nowColor)</span><br><span class="line">    &#125;</span><br><span class="line">    em_updateInteractiveTransition(percentComplete)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们的过度效果算是搞定一半，还有另外一半就是处理手势取消了。我们需要在 <code>navigationBar:shouldPopItem:</code> 方法中来处理我们的手势取消操作。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">UINavigationController</span>: <span class="title class_ inherited__">UINavigationBarDelegate</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// pop</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">navigationBar</span>(<span class="keyword">_</span> <span class="params">navigationBar</span>: <span class="type">UINavigationBar</span>,</span><br><span class="line">                              <span class="params">shouldPop</span> <span class="params">item</span>: <span class="type">UINavigationItem</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> topVC <span class="operator">=</span> topViewController,</span><br><span class="line">            <span class="keyword">let</span> coor <span class="operator">=</span> topVC.transitionCoordinator,</span><br><span class="line">            coor.initiallyInteractive &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">#available</span>(<span class="keyword">iOS</span> <span class="number">10.0</span>, <span class="operator">*</span>) &#123;</span><br><span class="line">                coor.notifyWhenInteractionChanges(&#123; (context) <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">self</span>.dealInteractionChanges(context)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                coor.notifyWhenInteractionEnds(&#123; (context) <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">self</span>.dealInteractionChanges(context)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> itemCount <span class="operator">=</span> navigationBar.items<span class="operator">?</span>.count <span class="operator">??</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> n <span class="operator">=</span> viewControllers.count <span class="operator">&gt;=</span> itemCount <span class="operator">?</span> <span class="number">2</span> : <span class="number">1</span></span><br><span class="line">        <span class="keyword">let</span> popToVC <span class="operator">=</span> viewControllers[viewControllers.count <span class="operator">-</span> n]</span><br><span class="line">        </span><br><span class="line">        popToViewController(popToVC, animated: <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 处理返回手势中断的情况</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">dealInteractionChanges</span>(<span class="keyword">_</span> <span class="params">context</span>: <span class="type">UIViewControllerTransitionCoordinatorContext</span>) &#123;</span><br><span class="line">        <span class="comment">/// 设置动画</span></span><br><span class="line">        <span class="keyword">let</span> animations: (<span class="type">UITransitionContextViewControllerKey</span>) -&gt; () <span class="operator">=</span> &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> vc <span class="operator">=</span> context.viewController(forKey: <span class="variable">$0</span>) <span class="keyword">as?</span> <span class="type">EMViewController</span> &#123;</span><br><span class="line">                <span class="keyword">self</span><span class="operator">?</span>.updateAllStyle(vc)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> context.isCancelled &#123;</span><br><span class="line">            <span class="comment">/// 手势取消</span></span><br><span class="line">            <span class="keyword">let</span> cancelDuration: <span class="type">TimeInterval</span> <span class="operator">=</span> context.transitionDuration <span class="operator">*</span> <span class="type">Double</span>(context.percentComplete)</span><br><span class="line">            <span class="type">UIView</span>.animate(withDuration: cancelDuration) &#123;</span><br><span class="line">                animations(.from)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/// 手势完成</span></span><br><span class="line">            <span class="keyword">let</span> finishDuration: <span class="type">TimeInterval</span> <span class="operator">=</span> context.transitionDuration <span class="operator">*</span> <span class="type">Double</span>(<span class="number">1</span> <span class="operator">-</span> context.percentComplete)</span><br><span class="line">            <span class="type">UIView</span>.animate(withDuration: finishDuration) &#123;</span><br><span class="line">                animations(.to)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们的导航栏过度效果基本完成，还有一些其他的细节处理，请看我的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1RvbWF0b3NYL0VNTmF2aWdhdGlvbkJhclRyYW5zaXRpb24=">GitHub<i class="fa fa-external-link-alt"></i></span> 源码吧。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cubGVhbm90ZS5jb20vcG9zdC95YW9saS8lRTUlQTYlODIlRTQlQkQlOTUlRTQlQkMlOTglRTklOUIlODUlRTUlOUMlQjAlRTUlOUMlQThTd2lmdDQlRTQlQjglQUQlRTUlQUUlOUUlRTclOEUlQjBNZXRob2QtU3dpenpsaW5n">如何优雅地在Swift4中实现Method Swizzling<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2pvcmRhbnNtaXRoLmlvL2hhbmRsaW5nLXRoZS1kZXByZWNhdGlvbi1vZi1pbml0aWFsaXplLw==">Handling the Deprecation of initialize()<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDI4MjQ1NDEvc3dpZnQtMy0xLWRlcHJlY2F0ZXMtaW5pdGlhbGl6ZS1ob3ctY2FuLWktYWNoaWV2ZS10aGUtc2FtZS10aGluZyNjb21tZW50NzMzNDEwMjlfNDI4MjQ1NDI=">Swift 3.1 deprecates initialize(). How can I achieve the same thing?<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzc4MDE0MDcvd2hpdGhlci1kaXNwYXRjaC1vbmNlLWluLXN3aWZ0LTM=">Whither dispatch_once in Swift 3?<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC80NTRiMDY1OTBjZjE=">导航栏的平滑显示和隐藏 - 个人页的自我修养（1）<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC81NDBhN2U2ZjdiNDA=">超简单！！！ iOS设置状态栏、导航栏按钮、标题、颜色、透明度，偏移等<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 11 中 UIRefreshControll 消失【译】</title>
    <url>/2018/07/07/20180707-iOS11%E4%B8%ADUIRefreshControll%E6%B6%88%E5%A4%B1%E3%80%90%E8%AF%91%E3%80%91/</url>
    <content><![CDATA[<h3 id="问"><a href="#问" class="headerlink" title="问"></a>问</h3><hr>
<p>我有一个带有 <code>largeTitle</code> 和 <code>searchcontroller</code> 的 <code>navigationBar</code> ，我的 <code>tableView</code> 有一个 <code>refreshcontrol</code> 。 </p>
<p>当我拉动刷新时，<code>refreshcontrol</code> 的 <code>activityIndicator</code> 消失了，但是刷新过程仍然在继续，即使进程完成并且我调用 <code>UIRefreshControll</code> 的 <code>endRefreshing()</code> 方法，导航栏也不会恢复到正常大小。</p>
<p><img src="/my_pictures/20180707/1.gif"></p>
<p>有人遇到过同样的问题吗？</p>
<span id="more"></span>

<h3 id="答"><a href="#答" class="headerlink" title="答"></a>答</h3><hr>
<p>我已经找了几个星期，今天我终于找到了解决方案，终于成功了。解决的方式非常简单，我不敢相信我竟然没有早点找到。</p>
<p>我正在使用带有 <code>UITableView</code> 的普通 <code>UIViewController</code>。我将约束设置成上与下都是 0，如图所示：</p>
<p><img src="/my_pictures/20180707/2.png"></p>
<p>一次，我改变了约束，将 <code>UITableView</code> 约束相对于 <code>Superview</code> 的所有边缘，值均为0，然后它竟然开始工作了：</p>
<p><img src="/my_pictures/20180707/3.png"></p>
<p>我甚至没有设置任何其他东西。我非常希望这能为你解决这个问题，因为它太烦人了……</p>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDY3OTM3MTYvaW9zLTExLXVpcmVmcmVzaGNvbnRyb2wtd2l0aC1uYXZpZ2F0aW9uYmFyLWxhcmdldGl0bGUtYW5kLXNlYXJjaGNvbnRyb2xsZXItZGlzYXA=">iOS 11 UIRefreshControl with NavigationBar LargeTitle and SearchController disappearing
<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>文章翻译</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>处理 initialize() 的弃用【译】</title>
    <url>/2018/07/08/20180708-%E5%A4%84%E7%90%86%20initialize()%20%E7%9A%84%E5%BC%83%E7%94%A8%E3%80%90%E8%AF%91%E3%80%91/</url>
    <content><![CDATA[<p>在将项目迁移到 Swift 3.1 后，我受到了几个警告的欢迎。它们似乎都没有特别难以修复，只是除了这个之外：</p>
<blockquote>
<p>Method ‘initialize()’ defines Objective-C class method ‘initialize’, which is not guaranteed to be invoked by Swift and will be disallowed in future versions.</p>
</blockquote>
<p>Ouch。一些类重写了 <code>NSObject</code> 的 <code>initialize()</code> 函数，警告清楚地表明这已不在合适（或者至少，但它应该不会很快发生）。一个非常类似的方法 - <code>load()</code>，它自 Swift 1.2 以来一直没有，所以看起来初始化将很快跟进。它扮演着一个独特的角色，如 <code>NSObject</code> <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2RvY3VtZW50YXRpb24vb2JqZWN0aXZlYy9uc29iamVjdC8xNDE4NjM5LWluaXRpYWxpemU=">文档<i class="fa fa-external-link-alt"></i></span>所述：</p>
<blockquote>
<p>The runtime sends <code>initialize()</code> to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program.</p>
</blockquote>
<span id="more"></span>

<h3 id="为什么用-initialize-？"><a href="#为什么用-initialize-？" class="headerlink" title="为什么用 initialize()？"></a>为什么用 <code>initialize()</code>？</h3><hr>
<p>如果你处于相同的情况，首先要问的问题可能是“我真的需要这个吗？”。如果你不需要的话，将逻辑移到其他地方，省去麻烦，并调用它。您通常是不需要它提供的行为的，但是自从 Swift 1.2 以后就不再支持 <code>load()</code>了，也没有任何明显的其他选择。在我的例子中，<code>initialize()</code> 被用作 <a href="http://nshipster.com/swift-objc-runtime/"><code>method swizzling</code></a> 的入口点（可能是 <code>initialize()</code> 的最常用的用例了）。Swizzling 允许我修补 iOS 中导致多次崩溃的错误。如果你从未听说过 <code>method swizzling</code>，请不要强迫自己…我只建议在特殊情况下使用它。</p>
<h3 id="一个简单的解决方式"><a href="#一个简单的解决方式" class="headerlink" title="一个简单的解决方式"></a>一个简单的解决方式</h3><hr>
<p>在考虑到这一点之前，<code>load()</code>和 <code>initialize()</code> 的一个简单替代方法是从应用程序执行你的逻辑<code>application(_:didFinishLaunchingWithOptions:)</code>。我建议保留相关类中包含的逻辑，并从 <code>application delegate</code> 中获取。从功能上讲，这个解决方案比 <code>initialize()</code> 更类似于 <code>load()</code>，但在大多数情况下，这是完全足够的。</p>
<p>这是相当直接的一种解决方式，在大多数情况下，为了简单起见，我建议这么做。但是，有一两个小警告。您可能有很多类要执行此操作，因此从应用程序委托中执行此操作会有点笨拙。也许您无权访问应用程序委托，或者您可能希望解决方案看起来比当前建议更具结构性。</p>
<h3 id="一个不那么简单的解决方案"><a href="#一个不那么简单的解决方案" class="headerlink" title="一个不那么简单的解决方案"></a>一个不那么简单的解决方案</h3><hr>
<p>以下功能也比 <code>initialize()</code> 更接近 <code>load()</code>。目标是为类定义一种简单的方法来采用一个函数，并在使用该类之前调用​​该函数。虽然内部不那么简单，但它可以很好地扩展，并且是完全自包含的 - 否定了向应用程序委托添加代码的任何要求。</p>
<p>首先，定义以下 Swift 代码。目的是为任何您想要类似初始化行为的类提供一个简单的入口点 - 现在可以通过符合 <code>SelfAware</code> 协议来完成。它还提供单个函数来为每个符合要求的类启动此行为。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SelfAware</span>: <span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">awake</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NothingToSeeHere</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">harmlessFunction</span>() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> typeCount <span class="operator">=</span> <span class="type">Int</span>(objc_getClassList(<span class="literal">nil</span>, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">let</span> types <span class="operator">=</span> <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">AnyClass</span>?&gt;.allocate(capacity: typeCount)</span><br><span class="line">        <span class="keyword">let</span> safeTypes <span class="operator">=</span> <span class="type">AutoreleasingUnsafeMutablePointer</span>&lt;<span class="type">AnyClass</span>?&gt;(types)</span><br><span class="line">        objc_getClassList(safeTypes, <span class="type">Int32</span>(typeCount))</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span> <span class="operator">..&lt;</span> typeCount &#123; (types[index] <span class="keyword">as?</span> <span class="type">SelfAware</span>.<span class="keyword">Type</span>)<span class="operator">?</span>.awake() &#125;</span><br><span class="line">        types.deallocate(capacity: typeCount)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们仍然需要一种方法来运行我们定义的函数，即 <code>NothingToSeeHere.harmlessFunction()</code>，在应用程序启动时。您可以从应用程序委托调用此方法，但如果您希望确保解决方案是自包含的，则以下提供了一种为 iOS 执行此操作的方法。对于没有 <code>UIApplication</code> 的 macOS 或其他平台，将需要以下变体。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">UIApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">let</span> runOnce: <span class="type">Void</span> <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="type">NothingToSeeHere</span>.harmlessFunction()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">open</span> <span class="keyword">var</span> next: <span class="type">UIResponder</span>? &#123;</span><br><span class="line">        <span class="comment">// Called before applicationDidFinishLaunching</span></span><br><span class="line">        <span class="type">UIApplication</span>.runOnce</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用此代码，符合协议 <code>SelfAware</code> 将授予任何类所需的行为。这样做相当容易和结构化，所以虽然这个解决方案的内部工作“不那么简单”，但我们现在有一个非常简洁的方法来向任何类添加类似初始化的行为。</p>
<h3 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h3><hr>
<p><span class="exturl" data-url="aHR0cDovL2pvcmRhbnNtaXRoLmlvL2hhbmRsaW5nLXRoZS1kZXByZWNhdGlvbi1vZi1pbml0aWFsaXplLw==">Handling the Deprecation of initialize()<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>文章翻译</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>WKWebView 中注入 cookie</title>
    <url>/2018/07/14/20180714-WKWebView%E4%B8%AD%E6%B3%A8%E5%85%A5cookie/</url>
    <content><![CDATA[<p>在项目中，往往有这样的要求，用 API 进行登录之后在某个 <code>WKWebView</code> 的页面需要用 <code>cookie</code> 去验证身份（虽然我更喜欢用 <code>accesstoken</code> 去验证🙃）。<code>WKWebView</code> 是苹果官方建议的控件来替代老旧的 <code>UIWebView</code>。但是 <code>WKWebView</code> 的 <code>cookie</code> 无法共享 <code>NSHTTPCookieStorage</code>，所以这时候就需要我们自己去管理 <code>cookie</code>。（iOS 11 上新增了 <code>WKHTTPCookieStore</code> 来管理）</p>
<p>首先我们先解析获取到的 <code>cookie</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 解析 cookie</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">analysisCookie</span>(<span class="params">response</span>: <span class="type">HTTPURLResponse</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> fields <span class="operator">=</span> response.allHeaderFields <span class="keyword">as?</span> [<span class="type">String</span>: <span class="type">String</span>],</span><br><span class="line">        <span class="keyword">let</span> url <span class="operator">=</span> response.url</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> cookies <span class="operator">=</span> <span class="type">HTTPCookie</span>.cookies(withResponseHeaderFields: fields,</span><br><span class="line">                                         for: url)</span><br><span class="line">        <span class="keyword">let</span> storage <span class="operator">=</span> <span class="type">HTTPCookieStorage</span>.shared</span><br><span class="line">        <span class="keyword">for</span> cookie <span class="keyword">in</span> cookies &#123;</span><br><span class="line">            <span class="comment">/// 将 cookie 存入本地</span></span><br><span class="line">            storage.setCookie(cookie)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>在 <code>WKWebView</code> 中注入 <code>cookie</code> 有两种方式，第一种，通过请求带过去</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> reqURL <span class="operator">=</span> <span class="type">URLRequest</span>(url: url)</span><br><span class="line">    <span class="keyword">let</span> cookie <span class="operator">=</span> (<span class="type">HTTPCookieStorage</span>.shared.cookies <span class="operator">??</span> []).strCookie</span><br><span class="line">    reqURL.addValue(cookie, forHTTPHeaderField: <span class="string">&quot;cookie&quot;</span>)</span><br><span class="line">    webView.load(reqURL)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方式，<code>js</code> 注入</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">createWeb</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> config <span class="operator">=</span> <span class="type">WKWebViewConfiguration</span>()</span><br><span class="line">    <span class="keyword">let</span> cookie <span class="operator">=</span> (<span class="type">HTTPCookieStorage</span>.shared.cookies <span class="operator">??</span> []).userScript</span><br><span class="line">    <span class="keyword">let</span> user <span class="operator">=</span> <span class="type">WKUserContentController</span>()</span><br><span class="line">    <span class="keyword">let</span> cookieScript <span class="operator">=</span> <span class="type">WKUserScript</span>(source: cookie,</span><br><span class="line">                                    injectionTime: .atDocumentStart,</span><br><span class="line">                                    forMainFrameOnly: <span class="literal">false</span>)</span><br><span class="line">    user.addUserScript(cookieScript)</span><br><span class="line">    config.userContentController <span class="operator">=</span> user</span><br><span class="line">    webView <span class="operator">=</span> <span class="type">WKWebView</span>(frame: <span class="keyword">self</span>.view.bounds, configuration: config)</span><br><span class="line">    <span class="keyword">self</span>.view.addSubview(webView)</span><br><span class="line">    webView.load(requestURL)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>moya 的用法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> headers: [<span class="type">String</span> : <span class="type">String</span>]<span class="operator">?</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> .login, .checkUpdate, .idCodeImg:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">HTTPCookieStorage</span>.shared.cookies <span class="operator">??</span> []).moya</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们需要将 <code>HTTPCookie</code> 类型转换一下，我们给 <code>Array</code> 添加几个扩展</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span> <span class="keyword">where</span> <span class="type">Element</span>: <span class="type">HTTPCookie</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 返回 moya 使用格式 cookie</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> moya: [<span class="type">String</span>: <span class="type">String</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> cookie: [<span class="type">String</span>: <span class="type">String</span>] <span class="operator">=</span> [:]</span><br><span class="line">        cookie[<span class="string">&quot;Cookie&quot;</span>] <span class="operator">=</span> <span class="keyword">self</span>.map &#123; <span class="string">&quot;<span class="subst">\(<span class="variable">$0</span>.name)</span>=<span class="subst">\(<span class="variable">$0</span>.value)</span>&quot;</span> &#125;.joined(separator: <span class="string">&quot;;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> cookie</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 返回 js 注入的字符串格式 cookie</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> userScript: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.map &#123; <span class="string">&quot;document.cookie=&#x27;<span class="subst">\(<span class="variable">$0</span>.name)</span>=<span class="subst">\(<span class="variable">$0</span>.value)</span>&#x27;&quot;</span> &#125;.joined(separator: <span class="string">&quot;;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 返回字符串类型 cookie</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> strCookie: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.map &#123; <span class="string">&quot;<span class="subst">\(<span class="variable">$0</span>.name)</span>=<span class="subst">\(<span class="variable">$0</span>.value)</span>&quot;</span> &#125;.joined(separator: <span class="string">&quot;;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我的项目中通过第二种方式实现了验证成功。</p>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 面向协议 - 为类提供基于 Storyboard 的初始化方法</title>
    <url>/2018/07/27/20180727-Swift%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE-%E4%B8%BA%E7%B1%BB%E6%8F%90%E4%BE%9B%E5%9F%BA%E4%BA%8EStoryboard%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>之前我们说过了运用面向协议的思想为控件添加 <code>action</code> 今天我们再来写一个基于 <code>Storyboard</code> 的初始化方法。在我的项目中，我没有将所有的 <code>controller</code> 都放在一个 <code>Storyboard</code> 文件中，原因有两个：</p>
<ul>
<li>当 <code>Controller</code> 很多的时候不方便查找对应的 <code>Storyboard</code>。</li>
<li>打开 <code>Storyboard</code> 会非常卡。</li>
</ul>
<p>所以我将 <code>Controller</code> 拆分成一个个的 <code>Storyboard</code> 文件。在对应的类中，我需要在每个类都写上一个初始化方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">instantiate</span>() -&gt; <span class="type">HomeViewController</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIStoryboard</span>(name: .home)</span><br><span class="line">        .instantiateViewControllerWithClass(type: <span class="type">HomeViewController</span>.<span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>当你的 App 页面非常多的时候你会发现到处都是 <code>instantiate()</code> 方法，所以我们需要用 Swift 中强大的 <code>Protocol</code> 思想进行一次优化了。</p>
<p>首先我们需要声明一个协议 <code>StoryboardLoadable</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">StoryboardLoadable</span> <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="type">UIViewController</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在协议中我们可以什么都不用写。接下来我们扩展这个协议：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">StoryboardLoadable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">instantiate</span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="comment">/// 移除类的 viewcontroller 后缀，创建 storyboard 名</span></span><br><span class="line">        <span class="keyword">let</span> sbName <span class="operator">=</span> <span class="string">&quot;<span class="subst">\(<span class="keyword">self</span>)</span>&quot;</span>.removingSuffix(<span class="string">&quot;ViewController&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIStoryboard</span>(name: sbName).instantiateViewControllerWithClass(type: <span class="keyword">Self</span>.<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子，我的登录页面的控制器名称为 <code>LoginViewController</code>，对应的 <code>Storyboard</code> 名称为 <code>Login</code>，所以我需要执行 <code>let sbName = &quot;\(self)&quot;.removingSuffix(&quot;ViewController&quot;)</code> 来生成 <code>Storyboard</code> 名称。</p>
<p>然后我们在我们的类中遵循这个协议即可。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LoginViewController</span>: <span class="title class_ inherited__">StoryboardLoadable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以后就可以在其他地方这样初始化你的类了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> loginVC <span class="operator">=</span> <span class="type">LoginViewController</span>.instantiate()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 页面卡死，但并不是 Crash 的问题解决</title>
    <url>/2018/09/27/20180927-iOS%E9%A1%B5%E9%9D%A2%E5%8D%A1%E6%AD%BB%EF%BC%8C%E4%BD%86%E5%B9%B6%E4%B8%8D%E6%98%AFCrash%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>最近在做的一款 App 测试中出现了一个非常诡异的问题，偶尔的界面卡死，但是又并不是 Crash，没有抛出任何异常，把 App 切到后台然后在点开又恢复了，只不过转场的时候十分诡异，似乎完全没有动画，转场背景还是黑的。</p>
<p>什么原因呢？死循环？不可能；内存泄漏？也不可能？😂；手势冲突？很有可能🧐。无意中我发现了，在 UINavigationController 根视图上进行右滑返回上级页面时，页面就会卡死。原因找到了，一定是手势冲突。</p>
<h2 id="问题原因描述"><a href="#问题原因描述" class="headerlink" title="问题原因描述"></a>问题原因描述</h2><hr>
<p>在我的项目中有一个基类 <code>BaseViewController</code>，由于项目中有时候需要隐藏 <code>NavigationBar</code> 所以我使用了 <code>setNavigationBarHidden()</code> 方法，使用这个方法会导致右滑返回上级页面的操作失效。所以我在 <code>BaseViewController</code> 中加入了如下的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.navigationController<span class="operator">?</span>.interactivePopGestureRecognizer<span class="operator">?</span>.delegate <span class="operator">=</span> <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">BaseViewController</span>: <span class="title class_ inherited__">UIGestureRecognizerDelegate</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我没有实现任何 <code>UIGestureRecognizerDelegate</code> 的方法，也就是用的都是默认情况。右滑时，具体的操作是将导航栏堆栈最顶部的 <code>Controller</code> 进行 <code>pop</code> 操作，但是当栈顶没有 <code>Controller</code> 时，也就是 <code>Controller</code> 为 <code>rootViewController</code> 时，这时候去开启右滑就会出问题了。导致页面完全卡死。</p>
<span id="more"></span>

<h2 id="问题修复"><a href="#问题修复" class="headerlink" title="问题修复"></a>问题修复</h2><hr>
<p>我们为我们的控制器基类 <code>BaseViewController</code> 添加一个 <code>public</code> 的属性，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> disableSideSliding <span class="operator">=</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>我们实现 <code>UIGestureRecognizerDelegate</code> 代理中的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">BaseViewController</span>: <span class="title class_ inherited__">UIGestureRecognizerDelegate</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">gestureRecognizerShouldBegin</span>(<span class="keyword">_</span> <span class="params">gestureRecognizer</span>: <span class="type">UIGestureRecognizer</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="operator">!</span>disableSideSliding</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我们所有的根视图，也就是 <code>rootViewController</code> 的 <code>viewDidLoad()</code> 方法中将右滑操作禁止，即设置 <code>disableSideSliding</code> 属性值为 <code>true</code>。</p>
<p>Ok，问题解决。</p>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>iOS工作日志</tag>
      </tags>
  </entry>
  <entry>
    <title>observeOn vs. subscribeOn【译】</title>
    <url>/2018/09/29/20180929-observeOnvssubscribeOn%E3%80%90%E8%AF%91%E3%80%91/</url>
    <content><![CDATA[<p>跨线程订阅的问题似乎在 <code>RxSwift Slack</code> 上一次又一次的被提到。这个解释起来也是非常的简单所以我觉得放在博客当中是一个好主意，无论你在何时需要，都可以通过连接进行访问，我也不用一次又一次的回复。</p>
<h2 id="可观察序列的订阅（Observable-subscriptions）"><a href="#可观察序列的订阅（Observable-subscriptions）" class="headerlink" title="可观察序列的订阅（Observable subscriptions）"></a>可观察序列的订阅（Observable subscriptions）</h2><hr>
<p><code>subscribing</code>（订阅） 和 <code>observing</code>（观察） 方面的术语还有一点混乱，所以让我们先来解决这个问题（不要跳过本章节！）。</p>
<p>让我们看看 <code>observable subscription</code> 的工作原理。我们可以将订阅分成 3 个部分：</p>
<img src="/my_pictures/20180929/1.png" style="zoom:50%;" />

<span id="more"></span>

<ol>
<li>首先，你定义了一个 <code>Observable</code>，在某些情况下，你在闭包中提供一些代码来执行工作并向任何观察者（observers）发出元素。当你创建了一个可观察序列的时候，代码将会被保存以供将来使用，但是不会立即执行。如果没有观察者 - <code>Observable</code> 只是坐着等待并不做任何事情。</li>
<li>在为订阅建模时，你可以使用一些运算符（如 <code>map</code>，<code>filter</code> 等）来处理发出的元素。</li>
<li>只有当你在一个 <code>Observable</code> 上调用 <code>subscribe(...)</code> 方法时，你才能“打开它”。调用 <code>subscribe(...)</code> 实际上将执行你在第1部分（上面）的块中提供的代码。</li>
</ol>
<p>所以从这个意义上说，这里有两个要点：</p>
<ol>
<li><code>subscription code</code> 是从你的 <code>subscribe()</code> 中调用并且位于 <code>Observable.create &#123; ... &#125;</code> 中的代码。这是创建订阅并且生成元素的代码。</li>
<li><code>observation code</code> 是你观察元素的地方 - 这是你在 <code>onNext: &#123; ... &#125;</code>，<code>onCompleted: &#123;...&#125;</code> 等提供的代码。这是你进行观察的地方。</li>
</ol>
<p><img src="/my_pictures/20180929/2.png"></p>
<h2 id="调度程序（Schedulers）"><a href="#调度程序（Schedulers）" class="headerlink" title="调度程序（Schedulers）"></a>调度程序（Schedulers）</h2><hr>
<p>RxSwift 附带了许多预定义的调度程序，可以在大多数情况下满足你的所有需求。这个主题有一个简短的文档：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9SeFN3aWZ0L2Jsb2IvbWFzdGVyL0RvY3VtZW50YXRpb24vU2NoZWR1bGVycy5tZA==">schedulers at RxSwift repo.<i class="fa fa-external-link-alt"></i></span></p>
<p>在这片文章中，我们将使用两个调度程序：</p>
<ul>
<li><code>MainScheduler.instance</code> 工作于主线程上。</li>
<li><code>ConcurrentDispatchQueueScheduler</code> 它使用 GCD 在给定队列上执行工作。</li>
</ul>
<h2 id="Subscribing-and-subscribeOn"><a href="#Subscribing-and-subscribeOn" class="headerlink" title="Subscribing and subscribeOn"></a>Subscribing and subscribeOn</h2><hr>
<p>接下来让我们来看一下 <code>subscribeOn</code> 操作 - 它允许你更改将在其上执行订阅代码（subscription code）的调度程序。</p>
<p><img src="/my_pictures/20180929/3.png"></p>
<p>默认情况下，订阅代码将在与调用 <code>subscribe()</code> 的代码相同的线程上运行，除非你使用 <code>subscribeOn(...)</code> 更改上下文。</p>
<p>例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.create &#123; observer <span class="keyword">in</span></span><br><span class="line">    observer.onNext(<span class="number">1</span>)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    observer.onNext(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">&#125;</span><br><span class="line">.subscribe(onNext: &#123; el <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="type">Thread</span>.isMainThread)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果将此代码放在 <code>viewDidLoad</code> 中，则会因为在订阅代码中使用了 <code>sleep</code> 而阻塞主线程。</p>
<p>你的 <code>onNext</code> 中的代码将会输出 <code>true</code>，因为它一直在主线程上运行。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[main] subscribe() -&gt; [main] create&#123; <span class="operator">...</span> &#125; -&gt; [main] onNext &#123; <span class="operator">...</span> &#125;</span><br></pre></td></tr></table></figure>

<p>现在你可以通过插入 <code>subscribeOn</code> 来更改你订阅的调度程序：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.create &#123; observer <span class="keyword">in</span></span><br><span class="line">    observer.onNext(<span class="number">1</span>)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    observer.onNext(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">&#125;</span><br><span class="line">.subscribeOn(<span class="type">ConcurrentDispatchQueueScheduler</span>(qos: .background))</span><br><span class="line">.subscribe(onNext: &#123; el <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="type">Thread</span>.isMainThread)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这次你将在订阅时切换线程：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[main] subscribe() -&gt; [background] create&#123; <span class="operator">...</span> &#125; -&gt; [background] onNext &#123; <span class="operator">...</span> &#125;</span><br></pre></td></tr></table></figure>

<p><code>onNext</code> 将会输出 <code>false</code>。</p>
<h2 id="Observing-and-observeOn"><a href="#Observing-and-observeOn" class="headerlink" title="Observing and observeOn"></a>Observing and observeOn</h2><hr>
<p>现在让我们来观察序列的元素。这部分涉及你的观察代码。</p>
<p><img src="/my_pictures/20180929/4.png"></p>
<p>在我们之前的例子中，你将订阅切换到了后台，因为它执行了一些阻塞线程的操作。但你实际上想要的是在主线程上运行 <code>onNext &#123;..&#125;</code> 中的代码，以便更新应用程序的 UI。</p>
<p>这可以通过使用 <code>observeOn</code> 来实现。顺便说一句，你可以将 <code>observeOn</code> 和 <code>subscribeOn</code> 放在响应链的任何地方 - 顺序并不重要。</p>
<p>RxSwift 包含一个使用主线程 <code>MainScheduler.instance</code> 的共享调度程序，因此你可以使用它来轻松地观察元素：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.create &#123; observer <span class="keyword">in</span></span><br><span class="line">    observer.onNext(<span class="number">1</span>)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    observer.onNext(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">&#125;</span><br><span class="line">.observeOn(<span class="type">MainScheduler</span>.instance)</span><br><span class="line">.subscribeOn(<span class="type">ConcurrentDispatchQueueScheduler</span>(qos: .background))</span><br><span class="line">.subscribe(onNext: &#123; el <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="type">Thread</span>.isMainThread)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这将执行如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[main] subscribe() -&gt; [background] create&#123; <span class="operator">...</span> &#125; -&gt; [main] onNext &#123; <span class="operator">...</span> &#125;</span><br></pre></td></tr></table></figure>

<p>如果你做了很多异步工作，那么这是一种你经常会使用的模式，，所以早点习惯它 - 最好。</p>
<p>我希望这篇简短的文章能够清楚地说明命名和用法。</p>
<p>原文地址：<span class="exturl" data-url="aHR0cDovL3J4LW1hcmluLmNvbS9wb3N0L29ic2VydmVvbi12cy1zdWJzY3JpYmVvbi8=">observeOn vs. subscribeOn<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>文章翻译</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 下使用 SQLite 教程：入门【译】</title>
    <url>/2018/08/02/20180802-Swift%E4%B8%8B%E4%BD%BF%E7%94%A8SQLite%E6%95%99%E7%A8%8B%EF%BC%9A%E5%85%A5%E9%97%A8%E3%80%90%E8%AF%91%E3%80%91/</url>
    <content><![CDATA[<blockquote>
<p>更新说明：本教程已由 Nikolas Burk 更新为 Xcode 9，iOS 11 和 Swift 4。最初的教程由 Chris Wagner 编写。</p>
</blockquote>
<p>这篇教程向你展示了如何在 Swift 平台上使用流行的数据库 SQLite。在软件开发的领域，你需要很长时间才能保存应用数据。在很多情况下，这是以数据结构形式出现的。但是，如何有效的存储它 – 什么是有效的存储？</p>
<p>幸运的是，一些伟大的思想家已经开发出用于在数据库中存储结构化数据和编写语言功能以访问数据的解决方案。SQLite 默认在 iOS 中是可用的。实际上，如果你以前使用过 Core Data，那么你实际上已经使用过 SQLite，因为 Core Data 只是 SQLite 上的一个层封装，它提供了更方便的API。</p>
<p>通过这篇教程，你将学习到如何执行以下数据库的操作：</p>
<ul>
<li>创建和连接一个数据库</li>
<li>创建一个表</li>
<li>插入一行</li>
<li>更新一行</li>
<li>删除一行</li>
<li>查询数据库</li>
<li>处理 SQLite 错误</li>
</ul>
<p>在学习如何执行这些基本操作之后，你将看到如何以类似 Swift 的方式将它们包装起来。这将允许你为应用程序编写抽象 API，以便你（大多数）可以避免去直接使用 SQLite 的 C API 的痛苦！:]</p>
<p>最后，我将简要介绍一下流行的开源 Swift 包装器 SQLite.swift，以便你能大致的了解一下底层框架是如何工作的。</p>
<blockquote>
<p>注意：数据库，甚至只是 SQLite 本身，都是一个非常大的主题，因此它们大多超出了本教程的范围。本教程假设你对关系数据库意识形态有基本的了解，并且你主要在这里学习如何在 Swift 下使用 SQLite。</p>
</blockquote>
<span id="more"></span>

<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><hr>
<p>下载工程：<span class="exturl" data-url="aHR0cHM6Ly9rb2VuaWctbWVkaWEucmF5d2VuZGVybGljaC5jb20vdXBsb2Fkcy8yMDE3LzA5L3NxbGl0ZS1zdGFydGVyLTEuemlw">starter project for this SQLite with Swift tutorial<i class="fa fa-external-link-alt"></i></span> 并打开 <code>SQLiteTutorial.xcworkspace</code>。<br>从 <code>Project Navigator</code> 打开教程的 <code>playground</code> 文件。</p>
<blockquote>
<p>注意：项目打包在 Xcode 工作区中，因为它使用 SQLite3 依赖项作为嵌入式二进制文件。此二进制文件包含你将在本教程中编写的 SQLite 代码的所有功能。 </p>
</blockquote>
<p>请注意，请将你的 <code>Playground</code> 配置为手动而不是自动运行：</p>
<p><img src="/my_pictures/20180802/1.png"></p>
<p>这意味着它只会在你通过点击“运行”按钮的时候执行。</p>
<p>你可能还会看到在页面的顶部我们调用了 <code>destroyPart1Database()</code>；你可以放心的忽略这一点，因为 Playground 每次运行的时候都会销毁这个文件。这可以确保在 Swift 教程浏览此 SQLite 时，所有的语句都能成功的执行。</p>
<p>你的 Playground 需要在你的文件系统上编写 SQLite 数据库文件，在终端中运行以下命令以创建游乐场数据库目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/Documents/Shared\ Playground\ Data/SQLiteTutorial</span><br></pre></td></tr></table></figure>

<h2 id="为什么选择-SQLite？"><a href="#为什么选择-SQLite？" class="headerlink" title="为什么选择 SQLite？"></a>为什么选择 SQLite？</h2><hr>
<p>没错，SQLite 不是在 iOS 上保留数据的唯一方法。除了 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvaW9zL2RvY3VtZW50YXRpb24vQ29jb2EvQ29uY2VwdHVhbC9Db3JlRGF0YS9pbmRleC5odG1s">Core Data<i class="fa fa-external-link-alt"></i></span>，还有许多其他数据持久性替代方案，包括 <span class="exturl" data-url="aHR0cHM6Ly9yZWFsbS5pby8=">Realm<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cDovL2RldmVsb3Blci5jb3VjaGJhc2UuY29tL21vYmlsZS8jY291Y2hiYXNlLWxpdGU=">Couchbase Lite<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3Mv">Firebase<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cDovL25zaGlwc3Rlci5jb20vbnNjb2Rpbmcv">NSCoding<i class="fa fa-external-link-alt"></i></span>。</p>
<p>每个都有自己的优点和缺点 - 包括 SQLite 本身，数据持久性没有灵丹妙药，作为开发人员，你可以根据应用程序的要求确定哪个选项超过其他选项。</p>
<p>SQLite 确实有一些优点：</p>
<ul>
<li>随 iOS 一起提供，因此它不会为你的应用程序包增加任何开销。</li>
<li>试过并经过测试; 1.0 版于 2000 年 8 月发布。</li>
<li>开源。</li>
<li>适用于数据库开发人员和管理员的熟悉查询语言。</li>
<li>跨平台</li>
</ul>
<p>SQLite 的缺点可能是非常主观和自以为是，所以我们将把研究留给你了！:]</p>
<h2 id="C-的-API"><a href="#C-的-API" class="headerlink" title="C 的 API"></a>C 的 API</h2><hr>
<p>这部分 SQLite with Swift 教程将引导你完成最常见和最基本的 SQLite API。你很快就会意识到在 Swift 方法中包装 C API 将是理想的选择，但要紧紧抓住并首先完成 C 代码； 你将在本教程的第二部分做一些包装。</p>
<h2 id="打开连接"><a href="#打开连接" class="headerlink" title="打开连接"></a>打开连接</h2><hr>
<p>在做任何事情之前，你首先需要创建一个数据库连接。<br>在 <code>Playground</code> 的“Getting Started”部分下添加以下方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">openDatabase</span>() -&gt; <span class="type">OpaquePointer</span>? &#123;</span><br><span class="line">  <span class="keyword">var</span> db: <span class="type">OpaquePointer</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">if</span> sqlite3_open(part1DbPath, <span class="operator">&amp;</span>db) <span class="operator">==</span> <span class="type">SQLITE_OK</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Successfully opened connection to database at <span class="subst">\(part1DbPath)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> db</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unable to open database. Verify that you created the directory described &quot;</span> <span class="operator">+</span></span><br><span class="line">      <span class="string">&quot;in the Getting Started section.&quot;</span>)</span><br><span class="line">    <span class="type">PlaygroundPage</span>.current.finishExecution()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法调用 <code>sqlite3_open()</code>。这将打开或创建一个新的数据库文件，如果打开成功，它将会返回一个 <code>OpaquePointer</code>；这是一个用于 C 指针的 Swift 类型，无法直接在 Swift 中表示，当你调用这个方法时，你必须捕获返回的指针才能与数据库进行交互。</p>
<p>许多 SQLite 函数返回 <code>Int32</code> 结果代码。这些代码中的大多数都被定义为 SQLite 库中的常量。例如，<code>SQLITE_OK</code> 表示结果代码 0。在这里你能找到不同的结果代码的列表：<span class="exturl" data-url="aHR0cHM6Ly93d3cuc3FsaXRlLm9yZy9yZXNjb2RlLmh0bWw=">on the main SQLite site<i class="fa fa-external-link-alt"></i></span>。</p>
<p>要打开数据库，请将下面的代码添加到 <code>Playground</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> db <span class="operator">=</span> openDatabase()</span><br></pre></td></tr></table></figure>

<p>点击 <code>Play</code> 按钮运行 <code>Playground</code>并在控制台查看输出，如果控制台没有打开，请点击 <code>Play</code> 左侧的按钮：</p>
<p><img src="/my_pictures/20180802/2.png"></p>
<p>如果 <code>openDatabase()</code> 运行成功，你将看到如下的输出：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Successfully</span> opened connection to database at <span class="regexp">/Users/</span>username<span class="regexp">/Documents/</span><span class="type">Shared</span> <span class="type">Playground</span> <span class="type">Data</span><span class="regexp">/SQLiteTutorial/</span><span class="type">Part1</span>.sqlite</span><br></pre></td></tr></table></figure>

<p>这里的 <code>username</code> 是你的 <code>Home</code> 目录。</p>
<h2 id="创建一个表"><a href="#创建一个表" class="headerlink" title="创建一个表"></a>创建一个表</h2><hr>
<p>现在你已经连接到数据库文件，你可以创建一个表。你将使用一个非常简单的表来存储联系人。</p>
<p>这个表将包含两列；<code>Id</code> 是一个 <code>Int</code> 类型并且是一个主键 <code>PRIMARY KEY</code>；<code>name</code> 是一个 <code>CHAR(255)</code> 类型。</p>
<p><img src="/my_pictures/20180802/3.png"></p>
<p>添加以下字符串，其中包含创建表所需的 SQL 语句：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> createTableString <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">CREATE TABLE Contact(</span></span><br><span class="line"><span class="string">Id INT PRIMARY KEY NOT NULL,</span></span><br><span class="line"><span class="string">Name CHAR(255));</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>请注意，你正在使用 Swift 4 的便捷多语法来编写此语句！</p>
<p>接下来，添加执行 <code>CREATE TABLE</code> SQL 语句的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">createTable</span>() &#123;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">var</span> createTableStatement: <span class="type">OpaquePointer</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">if</span> sqlite3_prepare_v2(db, createTableString, <span class="operator">-</span><span class="number">1</span>, <span class="operator">&amp;</span>createTableStatement, <span class="literal">nil</span>) <span class="operator">==</span> <span class="type">SQLITE_OK</span> &#123;</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">if</span> sqlite3_step(createTableStatement) <span class="operator">==</span> <span class="type">SQLITE_DONE</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Contact table created.&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Contact table could not be created.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;CREATE TABLE statement could not be prepared.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 4</span></span><br><span class="line">  sqlite3_finalize(createTableStatement)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来一步一步的分析：</p>
<ol>
<li>首先，在下一步中创建一个指针。</li>
<li><code>sqlite3_prepare_v2()</code> 将 SQL 语句编译为字节代码并返回状态代码 - 在对数据库执行任意语句之前的重要步骤。如果你有兴趣，可以在<span class="exturl" data-url="aHR0cHM6Ly93d3cuc3FsaXRlLm9yZy9jM3JlZi9wcmVwYXJlLmh0bWw=">这里<i class="fa fa-external-link-alt"></i></span>找到更多信息。检查返回的状态代码以确保语句编译成功。如果是，则该过程转到步骤3; 否则，你打印一条消息，指出该语句无法编译。</li>
<li><code>sqlite3_step()</code> 运行已编译的语句。在这种情况下，你只需“步进”一次，因为此语句只有一个结果。稍后在本教程中，你将看到何时需要多次执行单个语句。</li>
<li>你必须始终在编译语句上调用 <code>sqlite3_finalize()</code> 以删除它并避免资源泄漏。一旦声明完成，你就不应该再次使用它。</li>
</ol>
<p>现在，将以下方法调用添加到 <code>Playground</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">createTable()</span><br></pre></td></tr></table></figure>

<p>运行你的 <code>Playground</code>；你应该看到控制台输出中出现以下内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Contact</span> table created.</span><br></pre></td></tr></table></figure>

<p>现在你有了一个表，是时候向它添加一些数据了。你将添加 <code>Id</code> 为 1 且 <code>Name</code> 为“Ray”的单行。</p>
<h2 id="插入一些数据"><a href="#插入一些数据" class="headerlink" title="插入一些数据"></a>插入一些数据</h2><hr>
<p>将以下 SQL 语句添加到 <code>Playground</code> 的底部：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> insertStatementString <span class="operator">=</span> <span class="string">&quot;INSERT INTO Contact (Id, Name) VALUES (?, ?);&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果你没有太多的 SQL 经验，这可能看起来有点奇怪。为什么 <code>values</code> 由问号代表？</p>
<p>在使用 <code>sqlite3_prepare_v2()</code> 编译语句时，请记住上面的内容？这个 <code>?</code> 语法告诉编译器在实际执行语句时将提供实际值。</p>
<p>这有性能方面的考虑，并且允许你提前编译语句，这可以提高性能，因为编译是一项代价高昂的操作。然后可以使用不同的值重复使用已编译的语句。</p>
<p>接下来，在你的 <code>Playground</code> 中创建以下方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">insert</span>() &#123;</span><br><span class="line">  <span class="keyword">var</span> insertStatement: <span class="type">OpaquePointer</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">if</span> sqlite3_prepare_v2(db, insertStatementString, <span class="operator">-</span><span class="number">1</span>, <span class="operator">&amp;</span>insertStatement, <span class="literal">nil</span>) <span class="operator">==</span> <span class="type">SQLITE_OK</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">Int32</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">NSString</span> <span class="operator">=</span> <span class="string">&quot;Ray&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    sqlite3_bind_int(insertStatement, <span class="number">1</span>, id)</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    sqlite3_bind_text(insertStatement, <span class="number">2</span>, name.utf8String, <span class="operator">-</span><span class="number">1</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">if</span> sqlite3_step(insertStatement) <span class="operator">==</span> <span class="type">SQLITE_DONE</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Successfully inserted row.&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Could not insert row.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;INSERT statement could not be prepared.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 5</span></span><br><span class="line">  sqlite3_finalize(insertStatement)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是上述方法的工作原理：</p>
<ol>
<li>首先，编译语句并验证一切正常；</li>
<li>在这里，你为值定义一个 <code>?</code> 占位符。函数的名称 - <code>sqlite3_bind_int()</code> - 意味着你将 <code>Int</code> 值绑定到语句。函数的第一个参数是要绑定的语句，而第二个参数是基于非零的索引 <code>?</code> 的位置。第三个也是最后一个参数是值本身。此绑定调用返回状态代码，但现在你认为它成功；</li>
<li>执行相同的绑定过程，但这次是文本值。此次调用还有两个附加参数；出于本教程的目的，你可以简单地为它们传递 <code>-1</code> 和 <code>nil</code>。如果你愿意，可这里<span class="exturl" data-url="aHR0cHM6Ly93d3cuc3FsaXRlLm9yZy9jM3JlZi9iaW5kX2Jsb2IuaHRtbA==">此处<i class="fa fa-external-link-alt"></i></span>阅读有关绑定参数的更多信息；</li>
<li>使用 <code>sqlite3_step()</code>函数执行语句并验证它是否已完成；</li>
<li>一如既往，最后执行 <code>finalize</code> 语句。如果你要插入多个联系人，则可能会保留该语句并使用不同的值重新使用它。</li>
</ol>
<p>接下来，通过将以下内容添加到 <code>Playground</code> 中来调用你的新方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">insert()</span><br></pre></td></tr></table></figure>

<p>运行你的 <code>Playground</code> 并验证你在控制台输出中看到以下内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Successfully</span> inserted row.</span><br></pre></td></tr></table></figure>

<h2 id="挑战：多个插入"><a href="#挑战：多个插入" class="headerlink" title="挑战：多个插入"></a>挑战：多个插入</h2><hr>
<p>挑战的时间！你的任务是更新 <code>insert()</code> 以插入联系人数组。</p>
<p>作为提示，你需要在再次执行之前调用 <code>sqlite3_reset()</code> 将已编译的语句重置回其初始状态。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">insert</span>() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> insertStatement: <span class="type">OpaquePointer</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">let</span> names: [<span class="type">NSString</span>] <span class="operator">=</span> [<span class="string">&quot;Ray&quot;</span>, <span class="string">&quot;Chris&quot;</span>, <span class="string">&quot;Martha&quot;</span>, <span class="string">&quot;Danielle&quot;</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> sqlite3_prepare_v2(db, insertStatementString, <span class="operator">-</span><span class="number">1</span>, <span class="operator">&amp;</span>insertStatement, <span class="literal">nil</span>) <span class="operator">==</span> <span class="type">SQLITE_OK</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">for</span> (index, name) <span class="keyword">in</span> names.enumerated() &#123;</span><br><span class="line">      <span class="comment">// 3</span></span><br><span class="line">      <span class="keyword">let</span> id <span class="operator">=</span> <span class="type">Int32</span>(index <span class="operator">+</span> <span class="number">1</span>)</span><br><span class="line">      sqlite3_bind_int(insertStatement, <span class="number">1</span>, id)</span><br><span class="line">      sqlite3_bind_text(insertStatement, <span class="number">2</span>, name.utf8String, <span class="operator">-</span><span class="number">1</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> sqlite3_step(insertStatement) <span class="operator">==</span> <span class="type">SQLITE_DONE</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Successfully inserted row.&quot;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Could not insert row.&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 4</span></span><br><span class="line">      sqlite3_reset(insertStatement)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqlite3_finalize(insertStatement)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;INSERT statement could not be prepared.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如你所看到的，代码与你已有的代码非常相似，但具有以下显着差异：</p>
<ol>
<li>现在有一系列联系人，而不是一个常数；</li>
<li>对每个联系人列出一次数组；</li>
<li>现在，索引是从枚举的索引生成的，该索引对应于数组中联系人姓名的位置；</li>
<li>SQL 语句在每个枚举结束时重置，以便下一个可以使用它。</li>
</ol>
<h3 id="查询联系人"><a href="#查询联系人" class="headerlink" title="查询联系人"></a>查询联系人</h3><hr>
<p>既然你已经插入了一两行，那么确定它们真的存在就确实很好！:]</p>
<p>将以下内容添加到 <code>Playground</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> queryStatementString <span class="operator">=</span> <span class="string">&quot;SELECT * FROM Contact;&quot;</span></span><br></pre></td></tr></table></figure>

<p>此查询只是从联系人表中检索所有记录。使用 <code>*</code> 表示将返回所有列。</p>
<p>添加以下方法以执行查询：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">query</span>() &#123;</span><br><span class="line">  <span class="keyword">var</span> queryStatement: <span class="type">OpaquePointer</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">if</span> sqlite3_prepare_v2(db, queryStatementString, <span class="operator">-</span><span class="number">1</span>, <span class="operator">&amp;</span>queryStatement, <span class="literal">nil</span>) <span class="operator">==</span> <span class="type">SQLITE_OK</span> &#123;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">if</span> sqlite3_step(queryStatement) <span class="operator">==</span> <span class="type">SQLITE_ROW</span> &#123;</span><br><span class="line">      <span class="comment">// 3</span></span><br><span class="line">      <span class="keyword">let</span> id <span class="operator">=</span> sqlite3_column_int(queryStatement, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 4</span></span><br><span class="line">      <span class="keyword">let</span> queryResultCol1 <span class="operator">=</span> sqlite3_column_text(queryStatement, <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">let</span> name <span class="operator">=</span> <span class="type">String</span>(cString: queryResultCol1<span class="operator">!</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 5</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Query Result:&quot;</span>)</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(id)</span> | <span class="subst">\(name)</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Query returned no results&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;SELECT statement could not be prepared&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6</span></span><br><span class="line">  sqlite3_finalize(queryStatement)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依次记录每个编号的评论：</p>
<ol>
<li>准备声明。</li>
<li>执行该语句。请注意，你现在正在检查状态代码 <code>SQLITE_ROW</code>，这意味着你在逐步执行结果时检索了一行。</li>
<li>是时候从返回的行中读取值了。根据你对表的结构和查询的了解，你可以逐列访问行的值。第一列是 <code>Int</code>，因此你使用 <code>sqlite3_column_int()</code>并传入语句和从零开始的列索引。你将返回的值分配给本地范围的 <code>id</code> 常量。</li>
<li>接下来，从 <code>Name</code> 列中获取文本值。由于 C API，这有点乱。首先，将值捕获为 <code>queryResultCol1</code>，以便在下一行将其转换为正确的 Swift 字符串。</li>
<li>打印出结果。</li>
<li>执行 <code>finalize</code> 语句。</li>
</ol>
<p>现在，通过将以下内容添加到 <code>Playground</code> 的底部来调用你的新方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">query()</span><br></pre></td></tr></table></figure>

<p>运行你的 <code>Playground</code>，你将会在控制台看到如下的输出：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Query</span> <span class="type">Result</span>:</span><br><span class="line"><span class="number">1</span> <span class="operator">|</span> <span class="type">Ray</span></span><br></pre></td></tr></table></figure>

<p>W00t！看起来你的数据已经录入到数据库中！</p>
<h2 id="挑战：打印每一行"><a href="#挑战：打印每一行" class="headerlink" title="挑战：打印每一行"></a>挑战：打印每一行</h2><hr>
<p>你的任务是更新 <code>query()</code> 以打印出表中的每个联系人。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">query</span>() &#123;</span><br><span class="line">  <span class="keyword">var</span> queryStatement: <span class="type">OpaquePointer</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">if</span> sqlite3_prepare_v2(db, queryStatementString, <span class="operator">-</span><span class="number">1</span>, <span class="operator">&amp;</span>queryStatement, <span class="literal">nil</span>) <span class="operator">==</span> <span class="type">SQLITE_OK</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (sqlite3_step(queryStatement) <span class="operator">==</span> <span class="type">SQLITE_ROW</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> id <span class="operator">=</span> sqlite3_column_int(queryStatement, <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">let</span> queryResultCol1 <span class="operator">=</span> sqlite3_column_text(queryStatement, <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">let</span> name <span class="operator">=</span> <span class="type">String</span>(cString: queryResultCol1<span class="operator">!</span>)</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Query Result:&quot;</span>)</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(id)</span> | <span class="subst">\(name)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;SELECT statement could not be prepared&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  sqlite3_finalize(queryStatement)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，不是像前面那样使用单个步骤来检索第一行，而是这次使用 <code>while</code> 循环来执行步骤，只要返回代码是 <code>SQLITE_ROW</code> 就会发生。当你到达最后一行时，返回代码将通过 <code>SQLITE_DONE</code>，循环将中断。</p>
<h2 id="更新联系人"><a href="#更新联系人" class="headerlink" title="更新联系人"></a>更新联系人</h2><hr>
<p>下一个自然的进展是更新现有行。你应该开始看到一种模式出现了。</p>
<p>首先，创建 <code>UPDATE</code> 语句：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> updateStatementString <span class="operator">=</span> <span class="string">&quot;UPDATE Contact SET Name = &#x27;Chris&#x27; WHERE Id = 1;&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这里使用真正的值来代替占位符 <code>？</code>。通常你会使用占位符并执行适当的语句绑定，但为了简洁起见，你可以在这里跳过它。</p>
<p>接下来，将以下方法添加到 <code>Playground</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">update</span>() &#123;</span><br><span class="line">  <span class="keyword">var</span> updateStatement: <span class="type">OpaquePointer</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">if</span> sqlite3_prepare_v2(db, updateStatementString, <span class="operator">-</span><span class="number">1</span>, <span class="operator">&amp;</span>updateStatement, <span class="literal">nil</span>) <span class="operator">==</span> <span class="type">SQLITE_OK</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> sqlite3_step(updateStatement) <span class="operator">==</span> <span class="type">SQLITE_DONE</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Successfully updated row.&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Could not update row.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;UPDATE statement could not be prepared&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  sqlite3_finalize(updateStatement)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这与你之前看到的类似：<code>prepare</code>，<code>step</code>，<code>finalize</code>！并将以下内容添加到你的 <code>Playground</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">update()</span><br><span class="line">query()</span><br></pre></td></tr></table></figure>

<p>这将执行你的新方法，然后调用你先前定义的 <code>query()</code> 方法，以便你可以看到结果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Successfully</span> updated row.</span><br><span class="line"><span class="type">Query</span> <span class="type">Result</span>:</span><br><span class="line"><span class="number">1</span> <span class="operator">|</span> <span class="type">Chris</span></span><br></pre></td></tr></table></figure>

<p>恭喜你成功更新一行数据！非常容易的对吧？：]</p>
<h2 id="删除联系人"><a href="#删除联系人" class="headerlink" title="删除联系人"></a>删除联系人</h2><hr>
<p>成为 <code>SQLite</code> 忍者的最后一步是删除你创建的行。再次，你将使用熟悉的 <code>prepare</code>，<code>step</code> 和 <code>finalize</code>。</p>
<p>将以下的内容添加到 <code>Playground</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> deleteStatementStirng <span class="operator">=</span> <span class="string">&quot;DELETE FROM Contact WHERE Id = 1;&quot;</span></span><br></pre></td></tr></table></figure>

<p>现在添加以下方法来执行语句：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">delete</span>() &#123;</span><br><span class="line">  <span class="keyword">var</span> deleteStatement: <span class="type">OpaquePointer</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">if</span> sqlite3_prepare_v2(db, deleteStatementStirng, <span class="operator">-</span><span class="number">1</span>, <span class="operator">&amp;</span>deleteStatement, <span class="literal">nil</span>) <span class="operator">==</span> <span class="type">SQLITE_OK</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> sqlite3_step(deleteStatement) <span class="operator">==</span> <span class="type">SQLITE_DONE</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Successfully deleted row.&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Could not delete row.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;DELETE statement could not be prepared&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  sqlite3_finalize(deleteStatement)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你现在感觉到了吗？<code>Prepare</code>，<code>step</code> 和 <code>finalize</code>！：]</p>
<p>执行这个新方法，然后调用 <code>query()</code>，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">delete()</span><br><span class="line">query()</span><br></pre></td></tr></table></figure>

<p>现在运行你的 <code>Playground</code>，你应该在你的控制台中看到以下输出：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Successfully</span> deleted row.</span><br><span class="line"><span class="type">Query</span> returned no results</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果你完成了上面的“多个插入”挑战，由于表中仍存在其他数据，因此输出可能与上面的内容略有不同。</p>
</blockquote>
<h2 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h2><hr>
<p>到目前为止，希望你已经设法避免 SQLite 错误。但是，当你调用一个没有意义的函数，或者根本无法编译时，就将会出现错误。在发生这些事情时处理错误消息可以节省大量的开发时间;<br>它还使你有机会向用户显示有意义的错误消息。将以下声明 - 这个错误是故意的 - 添加到你的 Playground：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> malformedQueryString <span class="operator">=</span> <span class="string">&quot;SELECT Stuff from Things WHERE Whatever;&quot;</span></span><br></pre></td></tr></table></figure>

<p>现在添加一个方法来执行这个格式错误的语句：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">prepareMalformedQuery</span>() &#123;</span><br><span class="line">  <span class="keyword">var</span> malformedStatement: <span class="type">OpaquePointer</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">if</span> sqlite3_prepare_v2(db, malformedQueryString, <span class="operator">-</span><span class="number">1</span>, <span class="operator">&amp;</span>malformedStatement, <span class="literal">nil</span>) <span class="operator">==</span> <span class="type">SQLITE_OK</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This should not have happened.&quot;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">let</span> errorMessage <span class="operator">=</span> <span class="type">String</span>.<span class="keyword">init</span>(cString: sqlite3_errmsg(db))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Query could not be prepared! <span class="subst">\(errorMessage)</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  sqlite3_finalize(malformedStatement)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是你将如何强制执行错误：</p>
<ol>
<li><code>Prepare</code> 语句，这将会发生错误而且不应该返回 <code>SQLITE_OK</code>；</li>
<li>使用 <code>sqlite3_errmsg()</code> 从数据库中获取错误消息；此函数返回最近错误的文本描述。然后，你将错误打印到控制台;</li>
<li>一如既往，<code>finalize</code>。</li>
</ol>
<p>调用该方法以查看错误消息：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> prepareMalformedQuery()</span><br></pre></td></tr></table></figure>

<p>运行你的 <code>Playground</code>，你将会在控制台看到如下的输出：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Query</span> could not be prepared<span class="operator">!</span> no such table: <span class="type">Things</span></span><br></pre></td></tr></table></figure>

<p>嗯，这实际上很有帮助 - 你显然无法在不存在的表上运行 <code>SELECT</code> 语句！</p>
<h2 id="关闭数据库连接"><a href="#关闭数据库连接" class="headerlink" title="关闭数据库连接"></a>关闭数据库连接</h2><hr>
<p>完成数据库连接后，你将负责关闭它。但请注意 - 在成功关闭数据库之前，必须执行许多操作，如<span class="exturl" data-url="aHR0cHM6Ly93d3cuc3FsaXRlLm9yZy9jM3JlZi9jbG9zZS5odG1s">SQLite文档<i class="fa fa-external-link-alt"></i></span>中所述。</p>
<p>调用 <code>close</code> 函数，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> sqlite3_close(db)</span><br></pre></td></tr></table></figure>

<p>运行你的 Playground；你应该在 Playground 的右侧结果视图中看到状态代码 0；这表示 <code>SQLITE_OK</code>，这意味着数据库关闭成功。</p>
<p>你已经成功创建了一个数据库，添加了一个表，向表中添加了行，查询并更新了这些行，甚至删除了一行 - 所有这些都使用了 Swift 的 SQLite C API。做得好！</p>
<p>在下一节中，你将学习如何在 Swift 中使用 SQLite。</p>
<h2 id="SQLite-与-Swift"><a href="#SQLite-与-Swift" class="headerlink" title="SQLite 与 Swift"></a>SQLite 与 Swift</h2><hr>
<p>作为 Swift 开发人员，你可能会对本教程第一部分中发生的事情感到有些不安。那个 C API 有点痛苦，但好消息是你可以利用 Swift 的力量包装那些 C 例程来让事情变得更容易。</p>
<p><img src="/my_pictures/20180802/4.png"></p>
<p>对于本教程的这部分内容，点击 Playground 底部的 <code>Making it Swift</code> 连接打开这部分的 Playground。</p>
<p><img src="/my_pictures/20180802/5.png"></p>
<h2 id="包装错误"><a href="#包装错误" class="headerlink" title="包装错误"></a>包装错误</h2><hr>
<p>作为一个 Swift 开发者，从 C API 捕获错误有点尴尬。在这个美丽的新世界中，检查结果码然后调用另一个方法是没有意义的。如果方法能够抛出错误那将会更有意义。</p>
<p>将下面的代码添加到你的 Playground：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SQLiteError</span>: <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">OpenDatabase</span>(message: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Prepare</span>(message: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Step</span>(message: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Bind</span>(message: <span class="type">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个自定义的错误枚举，涵盖了你正在使用的四个可能失败的主要操作。请注意，每个 <code>case</code> 都有一个关联值 <code>message</code>。</p>
<h2 id="包装数据库连接"><a href="#包装数据库连接" class="headerlink" title="包装数据库连接"></a>包装数据库连接</h2><hr>
<p>另外一个不那么 <code>Swifty</code> 的方面就是使用那些恶心的 <code>OpaquePointer</code> 类型。在自己的类中包装数据库的连接指针，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SQLiteDatabase</span> &#123;</span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="keyword">let</span> dbPointer: <span class="type">OpaquePointer</span>?</span><br><span class="line"></span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="keyword">init</span>(<span class="params">dbPointer</span>: <span class="type">OpaquePointer</span>?) &#123;</span><br><span class="line">    <span class="keyword">self</span>.dbPointer <span class="operator">=</span> dbPointer</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">deinit</span> &#123;</span><br><span class="line">    sqlite3_close(dbPointer)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样看起来好多了，当你需要一个数据库连接的时候，你能创建一个更有意义的 <code>SQLiteDatabase</code> 的引用，而不是 <code>OpaquePointer</code>。</p>
<p>你会注意到，初始化是 <code>fileprivate</code>；那是因为你不希望你的 Swift 开发者传入那个 <code>OpaquePointer</code>。相反，你让他们用数据库文件的路径实例化这个类。</p>
<p>将以下静态方法添加到 <code>SQLiteDatabase</code>，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">open</span>(<span class="params">path</span>: <span class="type">String</span>) <span class="keyword">throws</span> -&gt; <span class="type">SQLiteDatabase</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> db: <span class="type">OpaquePointer</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">if</span> sqlite3_open(path, <span class="operator">&amp;</span>db) <span class="operator">==</span> <span class="type">SQLITE_OK</span> &#123;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">SQLiteDatabase</span>(dbPointer: db)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> db <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">        sqlite3_close(db)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> errorPointer <span class="operator">=</span> sqlite3_errmsg(db) &#123;</span><br><span class="line">      <span class="keyword">let</span> message <span class="operator">=</span> <span class="type">String</span>.<span class="keyword">init</span>(cString: errorPointer)</span><br><span class="line">      <span class="keyword">throw</span> <span class="type">SQLiteError</span>.<span class="type">OpenDatabase</span>(message: message)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="type">SQLiteError</span>.<span class="type">OpenDatabase</span>(message: <span class="string">&quot;No error message provided from sqlite.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里发生了这些事情；</p>
<ol>
<li>尝试在提供的路径上打开数据库；</li>
<li>如果成功，则返回 <code>SQLiteDatabase</code> 的新实例；</li>
<li>否则，如果状态代码不是 <code>SQLITE_OK</code>，则推迟关闭数据库并抛出错误。</li>
</ol>
<p>现在，您可以使用更清晰的语法创建和打开数据库连接。</p>
<p>将下面的代码添加到你的 PLayground：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> db: <span class="type">SQLiteDatabase</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  db <span class="operator">=</span> <span class="keyword">try</span> <span class="type">SQLiteDatabase</span>.open(path: part2DbPath)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Successfully opened connection to database.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">SQLiteError</span>.<span class="type">OpenDatabase</span>(<span class="keyword">let</span> message) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Unable to open database. Verify that you created the directory described in the Getting Started section.&quot;</span>)</span><br><span class="line">  <span class="type">PlaygroundPage</span>.current.finishExecution()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Ah，我太喜欢 Swift 了。这里，尝试打开数据库的代码被包装在 <code>do-try-catch</code> 中，并且 SQLite 会将错误的信息传递给 <code>catch</code> 块儿，这要感谢你之前创建的自定义枚举。</p>
<p>运行你的 Playground 并查看控制台的输出；你将会看到如下的内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Successfully</span> opened connection to database.</span><br></pre></td></tr></table></figure>

<p>现在，您可以使用并检查数据库实例作为正确且有意义的类型。</p>
<p>在继续编写执行语句之前，如果 <code>SQLiteDatabase</code> 允许您轻松访问SQLite错误消息，那将是很好的。</p>
<p>将以下计算属性添加到 <code>SQLiteDatabase</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">var</span> errorMessage: <span class="type">String</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> errorPointer <span class="operator">=</span> sqlite3_errmsg(dbPointer) &#123;</span><br><span class="line">    <span class="keyword">let</span> errorMessage <span class="operator">=</span> <span class="type">String</span>(cString: errorPointer)</span><br><span class="line">    <span class="keyword">return</span> errorMessage</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;No error message provided from sqlite.&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，您添加了一个计算属性，它只返回 SQLite 知道的最新错误。如果没有错误，它只会返回一条声明的通用消息。</p>
<h2 id="包装-Prepare-语句的调用"><a href="#包装-Prepare-语句的调用" class="headerlink" title="包装 Prepare 语句的调用"></a>包装 Prepare 语句的调用</h2><hr>
<p>既然你经常这样做，像其他方法一样包装它将会更有意义。在你进行开发并且向 <code>SQLiteDatabase</code> 中添加功能时，你会用到类的扩展。</p>
<p>添加如下的扩展，将来的方法将使用它来调用 SQL 语句上的 <code>sqlite3_prepare_v2()</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">SQLiteDatabase</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">prepareStatement</span>(<span class="params">sql</span>: <span class="type">String</span>) <span class="keyword">throws</span> -&gt; <span class="type">OpaquePointer</span>? &#123;</span><br><span class="line">    <span class="keyword">var</span> statement: <span class="type">OpaquePointer</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">guard</span> sqlite3_prepare_v2(dbPointer, sql, <span class="operator">-</span><span class="number">1</span>, <span class="operator">&amp;</span>statement, <span class="literal">nil</span>) <span class="operator">==</span> <span class="type">SQLITE_OK</span> <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="type">SQLiteError</span>.<span class="type">Prepare</span>(message: errorMessage)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> statement</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里你定义的 <code>prepareStatement(_:)</code> 函数能够抛出错误，然后当 <code>sqlite3_prepare_v2()</code> 出错时使用 <code>guard</code> 语句来抛出错误。就像之前一样，你将 SQLite中 的错误消息传递给自定义枚举的相关案例。</p>
<h2 id="创建-Contact-结构体"><a href="#创建-Contact-结构体" class="headerlink" title="创建 Contact 结构体"></a>创建 Contact 结构体</h2><hr>
<p>在这些例子中，你将使用与之前相同的 <code>Contact</code> 表，因此，定义一个适当的结构来表示联系人是有意义的。将以下内容添加到你的 Playground：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Contact</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> id: <span class="type">Int32</span></span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">NSString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="包装表的创建"><a href="#包装表的创建" class="headerlink" title="包装表的创建"></a>包装表的创建</h2><hr>
<p>您将完成与以前相同的数据库任务，但这次您将使用更 Swifter 的方法。</p>
<p>要创建一个表，你需要一个 <code>CREATE TABLE</code> 的 SQL 语句。<code>Contact</code> 定义自己的 <code>CREATE TABLE</code> 语句是有意义的。</p>
<p>为了这个目的，我们我们创建下面的协议：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SQLTable</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> createStatement: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，扩展 <code>Contact</code>，然后遵守这个协议：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Contact</span>: <span class="title class_ inherited__">SQLTable</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> createStatement: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    CREATE TABLE Contact(</span></span><br><span class="line"><span class="string">      Id INT PRIMARY KEY NOT NULL,</span></span><br><span class="line"><span class="string">      Name CHAR(255)</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，你可以编写以下方法来接受一个符合 <code>SQLTable</code> 的类型来创建表：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">SQLiteDatabase</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">createTable</span>(<span class="params">table</span>: <span class="type">SQLTable</span>.<span class="keyword">Type</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">let</span> createTableStatement <span class="operator">=</span> <span class="keyword">try</span> prepareStatement(sql: table.createStatement)</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">      sqlite3_finalize(createTableStatement)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">guard</span> sqlite3_step(createTableStatement) <span class="operator">==</span> <span class="type">SQLITE_DONE</span> <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="type">SQLiteError</span>.<span class="type">Step</span>(message: errorMessage)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(table)</span> table created.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里来分析发生了什么：</p>
<ol>
<li><code>prepareStatement()</code> 会抛出错误，所以你必须使用 <code>try</code> 语句。你并没有在 <code>do-try-catch</code> 块儿中执行此操作，因为这个方法本身会抛出错误，所以任何来自 <code>prepareStatement()</code> 的错误都会简单的抛出给调用者 <code>createTable()</code>；</li>
<li>凭借 <code>defer</code> 的力量，无论此方法如何退出其执行范围，你都可以确保你的 <code>sqlite3_finalize</code> 语句始终最终执行；</li>
<li><code>guard</code> 能让你写的检查 SQL 状态代码更具可读性。</li>
</ol>
<p>通过将以下的代码添加到 Playground 来尝试尝试新的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> db.createTable(table: <span class="type">Contact</span>.<span class="keyword">self</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(db.errorMessage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，您只需尝试创建联系人，并捕获错误（如果有的话）。</p>
<p>运行你的 Playground；你将会在你的控制台看到如下的输出：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Contact</span> table created.</span><br></pre></td></tr></table></figure>

<p>太棒了！这不是一个更清洁的 API 吗？</p>
<h2 id="包装数据插入"><a href="#包装数据插入" class="headerlink" title="包装数据插入"></a>包装数据插入</h2><hr>
<p>沿着右边移动，是时候向你的 <code>Contact</code> 表中插入一条数据了。添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">SQLiteDatabase</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">insertContact</span>(<span class="params">contact</span>: <span class="type">Contact</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> insertSql <span class="operator">=</span> <span class="string">&quot;INSERT INTO Contact (Id, Name) VALUES (?, ?);&quot;</span></span><br><span class="line">    <span class="keyword">let</span> insertStatement <span class="operator">=</span> <span class="keyword">try</span> prepareStatement(sql: insertSql)</span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">      sqlite3_finalize(insertStatement)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">NSString</span> <span class="operator">=</span> contact.name</span><br><span class="line">    <span class="keyword">guard</span> sqlite3_bind_int(insertStatement, <span class="number">1</span>, contact.id) <span class="operator">==</span> <span class="type">SQLITE_OK</span>  <span class="operator">&amp;&amp;</span></span><br><span class="line">      sqlite3_bind_text(insertStatement, <span class="number">2</span>, name.utf8String, <span class="operator">-</span><span class="number">1</span>, <span class="literal">nil</span>) <span class="operator">==</span> <span class="type">SQLITE_OK</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">SQLiteError</span>.<span class="type">Bind</span>(message: errorMessage)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> sqlite3_step(insertStatement) <span class="operator">==</span> <span class="type">SQLITE_DONE</span> <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="type">SQLiteError</span>.<span class="type">Step</span>(message: errorMessage)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Successfully inserted row.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然你已经得到了你的 SQLegs - 看看我在那里做了什么？:] - 这段代码不应该太令人惊讶。给定一个 <code>Contact</code> 实例，你准备一个语句，绑定值，执行然后 <code>finalize</code> 操作。同样，使用 <code>defer</code>，<code>guard</code> 和 <code>throw</code> 的强大组合可以让您充分利用现代语言 Swift 的功能。</p>
<p>编写代码来调用这个新方法，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> db.insertContact(contact: <span class="type">Contact</span>(id: <span class="number">1</span>, name: <span class="string">&quot;Ray&quot;</span>))</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(db.errorMessage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行你的 Playground；你将会在你的控制台看到如下的输出：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Successfully</span> inserted row.</span><br></pre></td></tr></table></figure>

<h2 id="包装读的操作"><a href="#包装读的操作" class="headerlink" title="包装读的操作"></a>包装读的操作</h2><hr>
<p>包装起来（抱歉，我无法抗拒！）的这部分是用 Swift 创建的数据库查询。</p>
<p>添加以下方法以查询联系人的数据库：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">SQLiteDatabase</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">contact</span>(<span class="params">id</span>: <span class="type">Int32</span>) -&gt; <span class="type">Contact</span>? &#123;</span><br><span class="line">    <span class="keyword">let</span> querySql <span class="operator">=</span> <span class="string">&quot;SELECT * FROM Contact WHERE Id = ?;&quot;</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> queryStatement <span class="operator">=</span> <span class="keyword">try?</span> prepareStatement(sql: querySql) <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">      sqlite3_finalize(queryStatement)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> sqlite3_bind_int(queryStatement, <span class="number">1</span>, id) <span class="operator">==</span> <span class="type">SQLITE_OK</span> <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> sqlite3_step(queryStatement) <span class="operator">==</span> <span class="type">SQLITE_ROW</span> <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> id <span class="operator">=</span> sqlite3_column_int(queryStatement, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> queryResultCol1 <span class="operator">=</span> sqlite3_column_text(queryStatement, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> name <span class="operator">=</span> <span class="type">String</span>(cString: queryResultCol1<span class="operator">!</span>) <span class="keyword">as</span> <span class="type">NSString</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="type">Contact</span>(id: id, name: name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法只接受联系人的 <code>id</code> 并返回该联系人，如果没有该 <code>id</code> 的联系人，则返回 <code>nil</code>。同样，这些语句现在应该有些熟悉了。</p>
<p>写一个查询第一个联系人的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> first <span class="operator">=</span> db.contact(id: <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(first<span class="operator">?</span>.id)</span> <span class="subst">\(first<span class="operator">?</span>.name)</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>运行你的 Playground；你应该能在控制台看到如下的输出：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Optional</span>(<span class="number">1</span>) <span class="type">Optional</span>(<span class="type">Ray</span>)</span><br></pre></td></tr></table></figure>

<p>到目前为止，您可能已经确定了一些可以用通用方式创建的调用，并将它们应用于完全不同的表。上述练习的目的是展示如何使用 Swift 来包装低级 C 的 API。对于 SQLite 来说，这不是一项简单的任务；SQLite 有很多错综复杂的内容，这里没有涉及。</p>
<p>你可能会想“没有人已经为此创建了一个包装器吗？” - 让我现在回答你的问题！</p>
<h2 id="SQLite-swift-的介绍"><a href="#SQLite-swift-的介绍" class="headerlink" title="SQLite.swift 的介绍"></a>SQLite.swift 的介绍</h2><hr>
<p>Stephen Celis 慷慨地为 SQLite 编写了一个名为 SQLite.swift 的全功能 Swift 包装器。如果您认为 SQLite 适合您应用中的数据存储，我强烈建议您查看一下。</p>
<p>SQLite.swift 提供了一种表示表的表达方式，让您可以开始使用 SQLite - 而无需担心 SQLite 的许多底层细节和特性。您甚至可以考虑包装SQLite.swift 本身，为您的应用程序的域模型创建一个高级 API。</p>
<p>查看编写良好的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3N0ZXBoZW5jZWxpcy9TUUxpdGUuc3dpZnQvYmxvYi9tYXN0ZXIvUkVBRE1FLm1k">README.md for SQLite.swift<i class="fa fa-external-link-alt"></i></span>，并自行决定它是否在您的个人代码工具箱中占有一席之地。</p>
<p>原文地址：<span class="exturl" data-url="aHR0cHM6Ly93d3cucmF5d2VuZGVybGljaC5jb20vMTY3NzQzL3NxbGl0ZS1zd2lmdC10dXRvcmlhbC1nZXR0aW5nLXN0YXJ0ZWQ=">SQLite With Swift Tutorial: Getting Started<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>文章翻译</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>SQLite</tag>
      </tags>
  </entry>
  <entry>
    <title>WKWebView 加载 TXT 文件编码问题</title>
    <url>/2018/10/11/20181011-WKWebView%E5%8A%A0%E8%BD%BDTXT%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>今天在做在线预览功能的时候碰到了一个蛋疼的问题，office 格式都可以完美的适配，但是 txt 格式出现了乱码。没办法只能进行一个转码，然后再输出内容。</p>
<h2 id="提取-TXT-文件内容并转码-utf8"><a href="#提取-TXT-文件内容并转码-utf8" class="headerlink" title="提取 TXT 文件内容并转码 utf8"></a>提取 TXT 文件内容并转码 utf8</h2><hr>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> encoding: <span class="type">String</span>.<span class="type">Encoding</span> <span class="operator">=</span> .utf8</span><br><span class="line">	<span class="keyword">let</span> body <span class="operator">=</span> <span class="keyword">try</span> <span class="type">String</span>(contentsOf: url, usedEncoding: <span class="operator">&amp;</span>encoding)</span><br><span class="line">	<span class="keyword">return</span> body</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们的 body 就是我们获取的内容，默认的我们用了 <code>utf8</code> 编码格式，如果转码错误，说明文件的编码格式为其他格式。</p>
<span id="more"></span>

<h2 id="对应中文编码"><a href="#对应中文编码" class="headerlink" title="对应中文编码"></a>对应中文编码</h2><hr>
<p>由于在 Swift 中，我并没有找到有关 <code>GBK</code>，<code>GBK18030</code> 等的转码写法，所以，这里我们使用 <code>NSString</code> 来进行中文简体和繁体的转码。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> body <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">NSString</span>(contentsOf: url, encoding: <span class="type">SimplifiedChinese</span>.<span class="type">GBK</span>) &#123;</span><br><span class="line">	<span class="comment">/// GBK &amp; GB2312</span></span><br><span class="line">	<span class="keyword">return</span> body <span class="keyword">as</span> <span class="type">String</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> body <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">NSString</span>(contentsOf: url, encoding: <span class="type">SimplifiedChinese</span>.<span class="type">GBK18030</span>) &#123;</span><br><span class="line">	<span class="comment">/// GBK18030</span></span><br><span class="line">	<span class="keyword">return</span> body <span class="keyword">as</span> <span class="type">String</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> body <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">NSString</span>(contentsOf: url, encoding: <span class="type">TraditionalChinese</span>.<span class="type">Big5</span>) &#123;</span><br><span class="line">	<span class="comment">/// Big5</span></span><br><span class="line">	<span class="keyword">return</span> body <span class="keyword">as</span> <span class="type">String</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> body <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">NSString</span>(contentsOf: url, encoding: <span class="type">TraditionalChinese</span>.<span class="type">Big5HKSCS</span>) &#123;</span><br><span class="line">	<span class="comment">/// Big5 HKSCS</span></span><br><span class="line">	<span class="keyword">return</span> body <span class="keyword">as</span> <span class="type">String</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相应编码的 <code>encoding</code> 如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 中文简体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SimplifiedChinese</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">GBK</span>: <span class="type">UInt</span> <span class="operator">=</span> <span class="number">0x80000632</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">GBK18030</span>: <span class="type">UInt</span> <span class="operator">=</span> <span class="number">0x80000631</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 中文繁体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TraditionalChinese</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">Big5</span>: <span class="type">UInt</span> <span class="operator">=</span> <span class="number">0x80000A03</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">Big5HKSCS</span>: <span class="type">UInt</span> <span class="operator">=</span> <span class="number">0x80000A06</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="显示-HTML"><a href="#显示-HTML" class="headerlink" title="显示 HTML"></a>显示 HTML</h2><hr>
<p>在显示内容的时候我发现字体格外的小，所以这个需要进行一个对应。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&lt;html&gt;&lt;header&gt;&lt;meta name=&#x27;viewport&#x27; content=&#x27;width=device-width, initial-scale=1.0, maximum-scale=2.0, minimum-scale=1.0, user-scalable=no&#x27;&gt;&lt;/header&gt;&lt;body&gt;<span class="subst">\(body)</span>&lt;/body&gt;&lt;/html&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>重要的是 <code>viewport meta</code> 标签，这里可以进行一个缩放。</p>
<p><code>device-width</code>：设备宽度<br><code>initial-scale</code>：初始缩放<br><code>maximum-scale</code>：最大缩放<br><code>minimum-scale</code>：最小缩放<br><code>user-scalable</code>：是否允许使用者缩放</p>
<p>OK，显示完美。</p>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>一键安装最新内核并开启 BBR 脚本</title>
    <url>/2018/10/20/20181020-%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E5%86%85%E6%A0%B8%E5%B9%B6%E5%BC%80%E5%90%AF%20BBR%20%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p><img src="/my_pictures/20181020/1.jpg"></p>
<p>最近，Google 开源了其 TCP BBR 拥塞控制算法，并提交到了 Linux 内核，从 4.9 开始，Linux 内核已经用上了该算法。根据以往的传统，Google 总是先在自家的生产环境上线运用后，才会将代码开源，此次也不例外。<br>根据实地测试，在部署了最新版内核并开启了 TCP BBR 的机器上，网速甚至可以提升好几个数量级。<br>于是我根据目前三大发行版的最新内核，开发了一键安装最新内核并开启 TCP BBR 脚本。</p>
<span id="more"></span>

<h2 id="本脚本适用环境"><a href="#本脚本适用环境" class="headerlink" title="本脚本适用环境"></a>本脚本适用环境</h2><hr>
<p>系统支持：CentOS 6+，Debian 7+，Ubuntu 12+<br>虚拟技术：OpenVZ 以外的，比如 KVM、Xen、VMware 等<br>内存要求：≥128M<br>日期　　：2018 年 06 月 09 日</p>
<h2 id="关于本脚本"><a href="#关于本脚本" class="headerlink" title="关于本脚本"></a>关于本脚本</h2><hr>
<p>1、本脚本已在 <span class="exturl" data-url="aHR0cHM6Ly90ZWRkeXN1bi5jb20vdC92dWx0cg==">Vultr<i class="fa fa-external-link-alt"></i></span> 上的 VPS 全部测试通过。<br>2、当脚本检测到 VPS 的虚拟方式为 OpenVZ 时，会提示错误，并自动退出安装。<br>3、脚本运行完重启发现开不了机的，打开 VPS 后台控制面板的 VNC, 开机卡在 grub 引导, 手动选择内核即可。<br>4、由于是使用最新版系统内核，最好请勿在生产环境安装，以免产生不可预测之后果。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><hr>
<p>使用 root 用户登录，运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; <span class="built_in">chmod</span> +x bbr.sh &amp;&amp; ./bbr.sh</span><br></pre></td></tr></table></figure>

<p>安装完成后，脚本会提示需要重启 VPS，输入 y 并回车后重启。<br>重启完成后，进入 VPS，验证一下是否成功安装最新内核并开启 TCP BBR，输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uname</span> -r</span><br></pre></td></tr></table></figure>

<p>查看内核版本，显示为最新版就表示 OK 了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br></pre></td></tr></table></figure>

<p>返回值一般为：</p>
<p><strong>net.ipv4.tcp_available_congestion_control &#x3D; bbr cubic reno</strong></p>
<p>或者为：</p>
<p><strong>net.ipv4.tcp_available_congestion_control &#x3D; reno cubic bbr</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_congestion_control</span><br></pre></td></tr></table></figure>

<p>返回值一般为：</p>
<p><strong>net.ipv4.tcp_congestion_control &#x3D; bbr</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl net.core.default_qdisc</span><br></pre></td></tr></table></figure>

<p>返回值一般为：</p>
<p><strong>net.core.default_qdisc &#x3D; fq</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure>

<p>返回值有 <code>tcp_bbr</code> 模块即说明 <code>bbr</code> 已启动。注意：并不是所有的 VPS 都会有此返回值，若没有也属正常。</p>
<h2 id="CentOS-下最新版内核-headers-安装方法"><a href="#CentOS-下最新版内核-headers-安装方法" class="headerlink" title="CentOS 下最新版内核 headers 安装方法"></a>CentOS 下最新版内核 headers 安装方法</h2><hr>
<p>本来打算在脚本里直接安装 <code>kernel-ml-headers</code>，但会出现和原版内核 <code>headers</code> 冲突的问题。因此在这里添加一个脚本执行完后，手动安装最新版内核 <code>headers</code> 之教程。<br>执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum --enablerepo=elrepo-kernel -y install kernel-ml-headers</span><br></pre></td></tr></table></figure>

<p>根据 CentOS 版本的不同，此时一般会出现类似于以下的错误提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Error: kernel-ml-headers conflicts with kernel-headers-2.6.32-696.20.1.el6.x86_64</span><br><span class="line">Error: kernel-ml-headers conflicts with kernel-headers-3.10.0-693.17.1.el7.x86_64</span><br></pre></td></tr></table></figure>

<p>因此需要先卸载原版内核 <code>headers</code> ，然后再安装最新版内核 <code>headers</code>。执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum remove kernel-headers</span><br></pre></td></tr></table></figure>

<p>确认无误后，输入 <code>y</code>，回车开始卸载。注意，有时候这么操作还会卸载一些对内核 <code>headers</code> 依赖的安装包，比如 <code>gcc</code>、<code>gcc-c++</code> 之类的。不过不要紧，我们可以在安装完最新版内核 <code>headers</code> 后再重新安装回来即可。<br>卸载完成后，再次执行上面给出的安装命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum --enablerepo=elrepo-kernel -y install kernel-ml-headers</span><br></pre></td></tr></table></figure>

<p>成功安装后，再把那些之前对内核 <code>headers</code> 依赖的安装包，比如 <code>gcc</code>、<code>gcc-c++</code> 之类的再安装一次即可。</p>
<p>为什么要安装最新版内核 <code>headers</code> 呢？<br>这是因为 <code>shadowsocks-libev</code> 版有个 <code>tcp fast open</code> 功能，如果不安装的话，这个功能是无法开启的。</p>
<h2 id="内核升级方法"><a href="#内核升级方法" class="headerlink" title="内核升级方法"></a>内核升级方法</h2><hr>
<p>如果是 CentOS 系统，执行如下命令即可升级内核：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install kernel-ml kernel-ml-devel</span><br></pre></td></tr></table></figure>

<p>如果你还手动安装了新版内核 <code>headers</code> ，那么还需要以下命令来升级 <code>headers</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install kernel-ml-headers</span><br></pre></td></tr></table></figure>

<p>CentOS 6 的话，执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/^default=.*/default=0/g&#x27;</span> /boot/grub/grub.conf</span><br></pre></td></tr></table></figure>

<p>CentOS 7 的话，执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grub2-set-default 0</span><br></pre></td></tr></table></figure>

<p>如果是 Debian&#x2F;Ubuntu 系统，则需要手动下载最新版内核来安装升级。<br>去这里下载最新版的内核 deb 安装包。<br>如果系统是 64 位，则下载 amd64 的 <code>linux-image</code> 中含有 <code>generic</code> 这个 <code>deb</code> 包；<br>如果系统是 32 位，则下载 i386 的 <code>linux-image</code> 中含有 <code>generic</code> 这个 <code>deb</code> 包；<br>安装的命令如下（以最新版的 64 位 4.12.4 举例而已，请替换为下载好的 deb 包）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -i linux-image-4.12.4-041204-generic_4.12.4-041204.201707271932_amd64.deb</span><br></pre></td></tr></table></figure>

<p>安装完成后，再执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/sbin/update-grub</span><br></pre></td></tr></table></figure>

<p>最后，重启 VPS 即可。</p>
<h2 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h2><hr>
<p>如果你使用的是 Google Cloud Platform （GCP）更换内核，有时会遇到重启后，整个磁盘变为只读的情况。只需执行以下命令即可恢复：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount -o remount rw /</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS Mojave：invalid active developer path【译】</title>
    <url>/2018/11/03/20181103-macOS%20Mojave-%20invalid%20active%20developer%20path%E3%80%90%E8%AF%91%E3%80%91/</url>
    <content><![CDATA[<p>我升级到 macOS Sierra（以及后来的 Mojave），我试着在终端运行 <code>git</code> 命令，但是它一直显示如下的错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun</span><br></pre></td></tr></table></figure>

<p>我该如何解决？</p>
<span id="more"></span>

<h2 id="答"><a href="#答" class="headerlink" title="答"></a>答</h2><hr>
<p>打开终端并且运行如下的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>

<p>这将会下载并且安装 Xcode 开发工具并且解决这个问题。安装的时候需要同意许可协议。作为后续步骤，如果你有多个版本或者希望<span class="exturl" data-url="aHR0cHM6Ly9hcHBsZS5zdGFja2V4Y2hhbmdlLmNvbS9hLzMxMDQ3MC81NDcy">命令行工具在没有 Xcode 的情况下运行<i class="fa fa-external-link-alt"></i></span>，则可能需要重置 Xcode 的路径。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcode-select --switch /Applications/Xcode.app</span><br><span class="line">xcode-select --switch /Library/Developer/CommandLineTools</span><br></pre></td></tr></table></figure>

<p>我在这个问题中找到了解决方案，<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMyODk0MzE0LzEzMjU1NzUlMjA=">命令行工具无效<i class="fa fa-external-link-alt"></i></span>。</p>
<p>您可能会收到一条错误消息：“无法安装该软件，因为它当前无法从软件更新服务器获得”。在这种情况下，<code>xcode-select --reset</code> 的工作方式与 akozin 相同</p>
<h2 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h2><hr>
<p><span class="exturl" data-url="aHR0cHM6Ly9hcHBsZS5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMjU0MzgwL21hY29zLW1vamF2ZS1pbnZhbGlkLWFjdGl2ZS1kZXZlbG9wZXItcGF0aA==">macOS Mojave: invalid active developer path<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>macOS</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS 安装/配置 Jenkins 小记</title>
    <url>/2019/01/16/20190116-macOS%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEJenkins%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<p>前阵子忙疯了，最近得空，来更新一下自己的博客 - 记一次 macOS 安装&#x2F;配置 Jenkins 的过程，方便以后使用。</p>
<p>由于 macOS 新系统 Mojave 字体实在让人看着眼疼，昨天重新装回了 <code>macOS High Sierra</code>，并且机智的用 <code>ThinBackup</code> 备份了自己的项目配置，避免麻烦，配置上面的东西还是挺多的。</p>
<span id="more"></span>

<h3 id="安装-JDK"><a href="#安装-JDK" class="headerlink" title="安装 JDK"></a>安装 JDK</h3><p>去官网下载 JDK 安装就行，太简单，略。</p>
<h3 id="安装-Jenkins"><a href="#安装-Jenkins" class="headerlink" title="安装 Jenkins"></a>安装 Jenkins</h3><p>建议用 <code>Homebrew</code> 安装，方便配置环境，方便启动与关闭。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install jenkins</span><br></pre></td></tr></table></figure>

<p>安装完成之后会默认启动，直接打开浏览器进入 <code>http://localhost:8080</code>，这时会让你输入初始密码，密码已经在终端显示出来，直接粘过来就行。接下来选择插件，由于我的配置已经在恢复文件中，所以这一步什么都不需要装，直接下一步，创建管理员账号，随便填，保存进入 <code>Jenkins</code>。</p>
<h3 id="恢复配置"><a href="#恢复配置" class="headerlink" title="恢复配置"></a>恢复配置</h3><ol>
<li>安装 <code>ThinBackup</code> 插件。</li>
<li>设置 <code>Backup directory</code>。</li>
<li>将备份文件夹放入第二步设置的路径。</li>
<li>进入 <code>Restore</code> 页面，勾选 <code>Restore next build number file (if found in backup)</code> 和 <code>Restore plugins</code> 两个选项。</li>
<li>点击 <code>Restore</code>。开始恢复。</li>
<li>备份完成后，终端关闭 <code>Jenkins</code> 并运行如下命令启动 <code>Jenkins</code>。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> java -jar /usr/local/Cellar/jenkins/2.159/libexec/jenkins.war --httpPort=8080</span><br></pre></td></tr></table></figure>

<p>2.159 为安装的 Jenkins 版本号，根据具体情况更改。</p>
<p>进行打包之前，请确认 Xcode 已经登录开发者账号并且相关证书齐全。</p>
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><h4 id="1、执行-xcodebuild-命令报错："><a href="#1、执行-xcodebuild-命令报错：" class="headerlink" title="1、执行 xcodebuild 命令报错："></a>1、执行 <code>xcodebuild</code> 命令报错：</h4><p>xcode-select: error: tool ‘xcodebuild’ requires Xcode, but active developer directory </p>
<p><code>/Library/Developer/CommandLineTools</code></p>
<p>is a command line tools instance</p>
<p>原因如下：</p>
<p>This problem happens when xcode-select developer directory was pointing to </p>
<p><code>/Library/Developer/CommandLineTools</code></p>
<p>when a full regular Xcode was required (happens when CommandLineTools are installed after Xcode)</p>
<p>这里我们需要手动指定 Xcode，运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcode-select -s /Applications/Xcode.app/Contents/Developer</span><br></pre></td></tr></table></figure>

<h4 id="2、-jenkins-文件夹下没有工作空间目录"><a href="#2、-jenkins-文件夹下没有工作空间目录" class="headerlink" title="2、.jenkins 文件夹下没有工作空间目录"></a>2、.jenkins 文件夹下没有工作空间目录</h4><p>在进行编译的时候，Jenkins 会首先去 git 上拉取最新的代码，并将代码保存到工作空间（workspace）文件夹中，但是项目安装并且恢复完毕后，并没有自动新建 <code>workspace</code> 文件夹，这里我们只需要手动的新建一个 <code>workspace</code> 文件夹即可。目录结构为 <code>~/.jenkins/workspace</code>。</p>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义数据结构 Multiset</title>
    <url>/2019/01/21/20190121-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Multiset/</url>
    <content><![CDATA[<p>实现一个名叫 <code>Multiset</code> 的集合数据结构，要具有如下的方法</p>
<ol>
<li><code>count(for:)</code> 返回相应数据的存储个数；</li>
<li><code>add(_:)</code> 添加数据；</li>
<li>删除数据<code>remove(_:)</code>。</li>
</ol>
<p>举例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">m <span class="operator">=</span> <span class="type">Multiset</span>()</span><br><span class="line">m.add(<span class="string">&quot;cat&quot;</span>)</span><br><span class="line">m.add(<span class="string">&quot;dog&quot;</span>)</span><br><span class="line">m.add(<span class="string">&quot;cat&quot;</span>)</span><br><span class="line"></span><br><span class="line">m.count(for: <span class="string">&quot;cat&quot;</span>) -&gt; <span class="number">2</span></span><br><span class="line">m.remove(<span class="string">&quot;cat&quot;</span>)</span><br><span class="line">m.count(for: <span class="string">&quot;cat&quot;</span>) -&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="实现一"><a href="#实现一" class="headerlink" title="实现一"></a>实现一</h3><p>我的第一感觉是像一个数组一样的数据结构，所以并没有考虑时间复杂度方面的问题，就直接往下继续了，实现细节如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Multiset</span>&lt;<span class="type">T</span>: <span class="type">Equatable</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> ary: [<span class="type">T</span>] <span class="operator">=</span> []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">add</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">T</span>) &#123;</span><br><span class="line">        ary.append(element)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">count</span>(<span class="params">for</span> <span class="params">element</span>: <span class="type">T</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> filterResult <span class="operator">=</span> ary.filter &#123; <span class="variable">$0</span> <span class="operator">==</span> element &#125;</span><br><span class="line">        <span class="keyword">return</span> filterResult.count</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">remove</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">T</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> idx <span class="operator">=</span> ary.firstIndex(of: element) &#123;</span><br><span class="line">            ary.remove(at: idx)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里时间复杂度确实有待优化的地方，下面我们换成字典的形式再来一次。</p>
<h3 id="实现二"><a href="#实现二" class="headerlink" title="实现二"></a>实现二</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Multiset</span>&lt;<span class="type">T</span>: <span class="type">Hashable</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> dict: [<span class="type">T</span>: <span class="type">Int</span>] <span class="operator">=</span> [:]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">add</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">T</span>) &#123;</span><br><span class="line">        dict[element, <span class="keyword">default</span>: <span class="number">0</span>] <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">count</span>(<span class="params">for</span> <span class="params">element</span>: <span class="type">T</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dict[element] <span class="operator">??</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">remove</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">T</span>) &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">var</span> count <span class="operator">=</span> dict[element] <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        count <span class="operator">-=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">            dict[element] <span class="operator">=</span> count</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dict.removeValue(forKey: element)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这回好多了。</p>
<p>路漫漫其修远兮，吾将上下而求索。</p>
<p>我写的可能有点简略，更详细的叙述请看这里：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JheXdlbmRlcmxpY2gvc3dpZnQtYWxnb3JpdGhtLWNsdWIvdHJlZS9tYXN0ZXIvTXVsdGlzZXQ=">Multiset<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS Mojave 中的字体</title>
    <url>/2019/01/30/20190130-macOS%20Mojave%20%E4%B8%AD%E7%9A%84%E5%AD%97%E4%BD%93/</url>
    <content><![CDATA[<p>我想在之前升级到 macOS Mojave 的同学都会经历过一条命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">defaults write -g CGFontRenderingFontSmoothingDisabled -bool NO</span><br></pre></td></tr></table></figure>

<p>执行如上命令会开启苹果之前的字体渲染方式 – <strong><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3VicGl4ZWxfcmVuZGVyaW5n">子像素抗锯齿<i class="fa fa-external-link-alt"></i></span><strong>。因为苹果在 Mojave 系统上启用了新的</strong>灰度抗锯齿</strong>模式，导致 Chrome 浏览器的字体实在无法直视，<strong>有幸今天 Chrome 浏览器更新到 72 版本后修复了这个问题</strong>。</p>
<span id="more"></span>


<h3 id="灰度抗锯齿与子像素抗锯齿科普"><a href="#灰度抗锯齿与子像素抗锯齿科普" class="headerlink" title="灰度抗锯齿与子像素抗锯齿科普"></a>灰度抗锯齿与子像素抗锯齿科普</h3><h4 id="macOS-10-14-Mojave-The-Ars-Technica-review"><a href="#macOS-10-14-Mojave-The-Ars-Technica-review" class="headerlink" title="macOS 10.14 Mojave: The Ars Technica review"></a><span class="exturl" data-url="aHR0cHM6Ly9hcnN0ZWNobmljYS5jb20vZmVhdHVyZXMvMjAxOC8wOS9tYWNvcy0xMC0xNC1tb2phdmUtdGhlLWFycy10ZWNobmljYS1yZXZpZXcvMTIvI2gz">macOS 10.14 Mojave: The Ars Technica review<i class="fa fa-external-link-alt"></i></span></h4><p><img src="/my_pictures/20190130/1.png"></p>
<h4 id="Understanding-Sub-Pixel-LCD-Screen-Anti-Aliased-Font-Rendering"><a href="#Understanding-Sub-Pixel-LCD-Screen-Anti-Aliased-Font-Rendering" class="headerlink" title="Understanding Sub-Pixel (LCD Screen) Anti-Aliased Font Rendering"></a><span class="exturl" data-url="aHR0cDovL2FsaWVucnlkZXJmbGV4LmNvbS9zdWJfcGl4ZWwv">Understanding Sub-Pixel (LCD Screen) Anti-Aliased Font Rendering<i class="fa fa-external-link-alt"></i></span></h4><p><img src="/my_pictures/20190130/2.png"></p>
<h4 id="Antialiasing-101"><a href="#Antialiasing-101" class="headerlink" title="Antialiasing 101"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2ludGVybmFscy9hbnRpYWxpYXNpbmctMTAxLw==">Antialiasing 101<i class="fa fa-external-link-alt"></i></span></h4><p><img src="/my_pictures/20190130/3.png"></p>
<h4 id="MDN-web-docs-font-smooth"><a href="#MDN-web-docs-font-smooth" class="headerlink" title="MDN web docs : font-smooth"></a><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2ZvbnQtc21vb3Ro">MDN web docs : font-smooth<i class="fa fa-external-link-alt"></i></span></h4><blockquote>
<p><code>subpixel-antialiased</code> - On most <strong>non-retina</strong> displays, this will give the <strong>sharpest</strong> text.</p>
<p><code>grayscale</code> - Render text with grayscale antialiasing, <strong>as opposed to the</strong> subpixel.</p>
</blockquote>
<h4 id="Emacs-里面不同级别的-次像素抗锯齿-渲染效果动图：LCD-Font-Smoothing-17"><a href="#Emacs-里面不同级别的-次像素抗锯齿-渲染效果动图：LCD-Font-Smoothing-17" class="headerlink" title="Emacs 里面不同级别的 次像素抗锯齿 渲染效果动图：LCD Font Smoothing #17"></a>Emacs 里面不同级别的 <strong>次像素抗锯齿</strong> 渲染效果动图：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tldmluU3V0dGxlL21hY09TLURlZmF1bHRzL2lzc3Vlcy8xNyNpc3N1ZWNvbW1lbnQtMjY2NjMzNTAx">LCD Font Smoothing #17<i class="fa fa-external-link-alt"></i></span></h4><p><img src="/my_pictures/20190130/4.gif"></p>
<p>参考：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sdmlpLmdpdGh1Yi5pby9zeXN0ZW0vMjAxOC0wOS0yNi1zZXR0aW5nLW1hY29zLW1vamF2ZS1mb250LXJlbmRlcmluZy1mcm9tLWdyYXlzY2FsZS10by1zdWJwaXhlbC1hbnRpYWxpYXNpbmcv">macOS Mojave 字体渲染由默认的灰度抗锯齿改回之前的次像素抗锯齿<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>macOS</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 学习一之基础</title>
    <url>/2019/02/07/20190207-Python%20%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B9%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><code>ord()</code> 函数获取字符的 ASCII 码值</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>))</span><br><span class="line"></span><br><span class="line">output: <span class="number">97</span></span><br><span class="line">output: <span class="number">65</span></span><br></pre></td></tr></table></figure>

<p><code>chr()</code> 函数把 ASCII 转换为对应的字符</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">66</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">97</span>))</span><br><span class="line"></span><br><span class="line">output: B</span><br><span class="line">output: a</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>由于 Python 的字符串类型是 <code>str</code>，在内存中以 Unicode 表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把 <code>str</code> 变为以字节为单位的 <code>bytes</code>。<code>Python</code> 对 <code>bytes</code> 类型的数据用带b前缀的单引号或双引号表示：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">b&quot;a&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">&quot;a&quot;</span>))</span><br><span class="line"></span><br><span class="line">output: &lt;<span class="keyword">class</span> <span class="string">&#x27;bytes&#x27;</span>&gt;</span><br><span class="line">output: &lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>简写的方式是用 <code>ASCII</code> 编码为 <code>bytes</code> 所以不能用于中文，如果是中文需要 <code>UTF-8</code> 编码</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">b&quot;中文&quot;</span>))</span><br><span class="line"></span><br><span class="line">output:  </span><br><span class="line">File <span class="string">&quot;基础.py&quot;</span>, line <span class="number">19</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">b&quot;中文&quot;</span>))</span><br><span class="line">              ^</span><br><span class="line">SyntaxError: <span class="built_in">bytes</span> can only contain ASCII literal characters.</span><br></pre></td></tr></table></figure>

<p>以 <code>Unicode</code> 表示的 <code>str</code> 通过 <code>encode()</code> 方法可以编码为指定的 <code>bytes</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">&quot;中文&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)))</span><br><span class="line"></span><br><span class="line">output: &lt;<span class="keyword">class</span> <span class="string">&#x27;bytes&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>要计算 <code>str</code> 包含多少个字符，可以用 <code>len()</code> 函数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(<span class="string">&quot;abc中文&quot;</span>))</span><br><span class="line"></span><br><span class="line">output: <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><code>len()</code> 函数计算的是 <code>str</code> 的字符数，如果换成 <code>bytes</code>，<code>len()</code> 函数就计算字节数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(<span class="string">&quot;abc中文&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)))</span><br><span class="line"></span><br><span class="line">output: <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p><code>%</code> 运算符就是用来格式化字符串的</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello %s, I&#x27;m %s, %d years old.&quot;</span> % (<span class="string">&quot;world&quot;</span>, <span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>))</span><br><span class="line"></span><br><span class="line">output: hello world, I<span class="string">&#x27;m Tom, 20 years old.</span></span><br></pre></td></tr></table></figure>

<h3 id="list-类型"><a href="#list-类型" class="headerlink" title="list 类型"></a>list 类型</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>获取最后一个和倒数第二个元素</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ary[-<span class="number">1</span>]</span><br><span class="line">ary[-<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>添加元素</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ary.append(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>删除最后一个元素</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ary.pop()</span><br></pre></td></tr></table></figure>

<p>删除指定元素</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ary.pop(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>初始化字符数组</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">strAry = <span class="built_in">list</span>(<span class="string">&quot;ary&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(t[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(t[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>只有 1 个元素的 <code>tuple</code> 定义时必须加一个逗号 <code>,</code> ，来消除歧义。<br>因为，括号 <code>()</code> 既可以表示 <code>tuple</code>，又可以表示数学公式中的小括号，这就产生了歧义。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">t1 = (<span class="number">1</span>,)</span><br><span class="line"><span class="built_in">print</span>(t1[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">output: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">age = <span class="number">13</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;adult&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt; <span class="number">6</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;teenager&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;kid&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>input()</code> 返回的数据类型是 <code>str</code>，所以这里需要转换为 <code>int</code> 类型。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">birth = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;birth: &quot;</span>))</span><br><span class="line"><span class="keyword">if</span> birth &lt; <span class="number">2000</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;00前&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;00后&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">20</span>, <span class="number">2</span>)):</span><br><span class="line">	<span class="built_in">print</span>(num)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">	<span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure>

<h3 id="字典类型，dict"><a href="#字典类型，dict" class="headerlink" title="字典类型，dict"></a>字典类型，dict</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;Michael&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;Bob&#x27;</span>: <span class="number">75</span>, <span class="string">&#x27;Tracy&#x27;</span>: <span class="number">85</span>&#125; <span class="comment"># 大括号声明</span></span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;Bob&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Bob&quot;</span> <span class="keyword">in</span> d) <span class="comment"># 判断 Bob是否在 d 中</span></span><br><span class="line">d.pop(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure>

<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">s = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment"># 用数组初始化</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(s))</span><br><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment"># 大括号声明为 set</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(s1))</span><br><span class="line">s1.add(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line">s1.remove(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"></span><br><span class="line">s1.add(<span class="number">8</span>)</span><br><span class="line">s1.add(<span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span>(s1 &amp; s) <span class="comment"># 交集</span></span><br><span class="line"><span class="built_in">print</span>(s1 | s) <span class="comment"># 并集</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 学习二之函数</title>
    <url>/2019/02/08/20190208-Python%20%E5%AD%A6%E4%B9%A0%E4%BA%8C%E4%B9%8B%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">abs</span></span><br><span class="line"><span class="built_in">print</span>(a(-<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">output: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><code>pass</code> 定义空函数，目的是为了让程序能够跑起来。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>():</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_abs</span>(<span class="params">x</span>):</span><br><span class="line">	<span class="comment"># 检查传入的参数是否正确，只允许 int 和 float 类型的参数</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(x, (<span class="built_in">int</span>, <span class="built_in">float</span>)):</span><br><span class="line">		<span class="keyword">raise</span> TypeError(<span class="string">&#x27;bad operand type&#x27;</span>)</span><br><span class="line">	<span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">x, y, step, angle=<span class="number">0</span></span>):</span><br><span class="line">	nx = x + step * math.cos(angle)</span><br><span class="line">	ny = y - step * math.sin(angle)</span><br><span class="line">	<span class="keyword">return</span> nx, ny</span><br></pre></td></tr></table></figure>

<p>返回值是一个 <code>tuple</code>。<br>返回一个 <code>tuple</code> 可以省略括号，而多个变量可以同时接收一个 <code>tuple</code>，按位置赋给对应的值。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">x, y = move(<span class="number">100</span>, <span class="number">100</span>, <span class="number">60</span>, math.pi / <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x:&quot;</span>, x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y:&quot;</span>, y)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x: &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(x))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y: &#123;yValue&#125;&quot;</span>.<span class="built_in">format</span>(yValue=y))</span><br><span class="line"></span><br><span class="line">coor = move(<span class="number">100</span>, <span class="number">100</span>, <span class="number">60</span>, math.pi / <span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(coor)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">x: <span class="number">151.96152422706632</span></span><br><span class="line">y: <span class="number">70.0</span></span><br><span class="line">x: <span class="number">151.96152422706632</span></span><br><span class="line">y: <span class="number">70.0</span></span><br><span class="line">(<span class="number">151.96152422706632</span>, <span class="number">70.0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">x</span>):</span><br><span class="line"><span class="comment">#	if not isinstance(x, (int, float)):</span></span><br><span class="line"><span class="comment">#		raise TypeError(&#x27;bad operand type&#x27;)</span></span><br><span class="line">	<span class="keyword">return</span> x * x</span><br><span class="line">	</span><br><span class="line"><span class="built_in">print</span>(power(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">power1</span>(<span class="params">x, n</span>):</span><br><span class="line">	s = <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">		n -= <span class="number">1</span></span><br><span class="line">		s = s * x</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line"><span class="built_in">print</span>(power1(<span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>设置默认参数时，有几点要注意</p>
<ol>
<li>是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）</li>
<li>是如何设置默认参数</li>
</ol>
<p>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</p>
<p>使用默认参数有什么好处？最大的好处是能降低调用函数的难度。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">power2</span>(<span class="params">x, n=<span class="number">2</span></span>):</span><br><span class="line">	s = <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">		n -= <span class="number">1</span></span><br><span class="line">		s = s * x</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line"><span class="built_in">print</span>(power2(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<h4 id="为什么默认参数不能放在必选参数的前面"><a href="#为什么默认参数不能放在必选参数的前面" class="headerlink" title="为什么默认参数不能放在必选参数的前面"></a>为什么默认参数不能放在必选参数的前面</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">p1, p2=<span class="number">6</span>, p3</span>):</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>因为调用函数时可能会产生歧义，比如调用上面的函数 <code>foo(1, 2)</code>，是该调用 <code>foo(1, 6, 2)</code> 呢？还是该调用 <code>foo(1, 6)</code> 呢？或者其它的什么呢？…</p>
<h4 id="默认参数的坑"><a href="#默认参数的坑" class="headerlink" title="默认参数的坑"></a>默认参数的坑</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_end</span>(<span class="params">L=[]</span>):</span><br><span class="line">	L.append(<span class="string">&#x27;END&#x27;</span>)</span><br><span class="line">	<span class="keyword">return</span> L</span><br><span class="line"><span class="built_in">print</span>(add_end())</span><br><span class="line"><span class="built_in">print</span>(add_end())</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">[<span class="string">&#x27;END&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;END&#x27;</span>, <span class="string">&#x27;END&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>原因解释如下：</p>
<p>Python 函数在定义的时候，默认参数L的值就被计算出来了，即 <code>[]</code>，因为默认参数L也是一个变量，它指向对象 <code>[]</code>，每次调用该函数，如果改变了 <code>L</code> 的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的 <code>[]</code> 了。</p>
<p><strong>所以，定义默认参数要牢记一点：默认参数必须指向不变对象！</strong></p>
<p>要修改上面的例子，我们可以用 <code>None</code> 这个不变对象来实现：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_end1</span>(<span class="params">L=<span class="literal">None</span></span>):</span><br><span class="line">	<span class="keyword">if</span> L <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">		L = []</span><br><span class="line">	L.append(<span class="string">&#x27;END&#x27;</span>)</span><br><span class="line">	<span class="keyword">return</span> L</span><br><span class="line"><span class="built_in">print</span>(add_end1())</span><br><span class="line"><span class="built_in">print</span>(add_end1())</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">[<span class="string">&#x27;END&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;END&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>定义可变参数和定义一个 <code>list</code> 或 <code>tuple</code> 参数相比，仅仅在参数前面加了一个 <code>*</code> 号。<br>在函数内部，参数 <code>numbers</code> 接收到的是一个 <code>tuple</code> ，因此，函数代码完全不变。<br>但是，调用该函数时，可以传入任意个参数，包括 0 个参数。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">*numbers</span>):</span><br><span class="line">	<span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">		<span class="built_in">sum</span> = <span class="built_in">sum</span> + n * n</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line"><span class="built_in">print</span>(calc(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p>Python 允许你在 <code>list</code> 或 <code>tuple</code> 前面加一个 <code>*</code> 号，把 <code>list</code> 或 <code>tuple</code> 的元素变成可变参数传进去。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">demo = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(calc(*demo))</span><br></pre></td></tr></table></figure>

<h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>关键字参数允许你传入 0 个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个 <code>dict</code>。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, **kw</span>):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;name:&#x27;</span>, name, <span class="string">&#x27;age:&#x27;</span>, age, <span class="string">&#x27;other:&#x27;</span>, kw)</span><br><span class="line">	</span><br><span class="line">person(<span class="string">&quot;Michael&quot;</span>, <span class="number">11</span>)</span><br><span class="line">person(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">35</span>, city=<span class="string">&#x27;Beijing&#x27;</span>)</span><br><span class="line">extra = &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>**extra</code> 表示把 <code>extra</code> 这个 <code>dict</code> 的所有 <code>key-value</code> 用关键字参数传入到函数的 <code>**kw</code> 参数， <code>kw</code> 将获得一个 <code>dict</code>，注意 <code>kw</code> 获得的 <code>dict</code> 是 <code>extra</code> 的一份拷贝，对 <code>kw</code> 的改动不会影响到函数外的 <code>extra</code>。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, **extra)</span><br></pre></td></tr></table></figure>

<h3 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h3><p>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收 <code>city</code> 和 <code>job</code> 作为关键字参数。这种方式定义的函数如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, *, city, job</span>):</span><br><span class="line">	<span class="built_in">print</span>(name, age, city, job)</span><br><span class="line">person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, city=<span class="string">&#x27;Beijing&#x27;</span>, job=<span class="string">&#x27;Engineer&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符 <code>*</code> 了。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">person1</span>(<span class="params">name, age, *args, city, job</span>):</span><br><span class="line">	<span class="built_in">print</span>(name, age, args, city, job)</span><br><span class="line">person1(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, city=<span class="string">&#x27;Beijing&#x27;</span>, job=<span class="string">&#x27;Engineer&#x27;</span>)</span><br><span class="line">person1(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, <span class="string">&quot;a&quot;</span>, city=<span class="string">&#x27;Beijing&#x27;</span>, job=<span class="string">&#x27;Engineer&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>命名关键字参数可以有缺省值，从而简化调用：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">person2</span>(<span class="params">name, age, *, city=<span class="string">&#x27;Beijing&#x27;</span>, job</span>):</span><br><span class="line">	<span class="built_in">print</span>(name, age, city, job)</span><br><span class="line">person2(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, job=<span class="string">&#x27;Engineer&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个 <code>*</code> 作为特殊分隔符。如果缺少 <code>*</code>，Python 解释器将无法识别位置参数和命名关键字参数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, city, job</span>):</span><br><span class="line">	<span class="comment"># 缺少 *，city和job被视为位置参数</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h3 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h3><p>在 Python 中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。<br>但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">a, b, c=<span class="number">0</span>, *args, **kw</span>):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;a =&#x27;</span>, a, <span class="string">&#x27;b =&#x27;</span>, b, <span class="string">&#x27;c =&#x27;</span>, c, <span class="string">&#x27;args =&#x27;</span>, args, <span class="string">&#x27;kw =&#x27;</span>, kw)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">a, b, c=<span class="number">0</span>, *, d, **kw</span>):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;a =&#x27;</span>, a, <span class="string">&#x27;b =&#x27;</span>, b, <span class="string">&#x27;c =&#x27;</span>, c, <span class="string">&#x27;d =&#x27;</span>, d, <span class="string">&#x27;kw =&#x27;</span>, kw)</span><br><span class="line"></span><br><span class="line">f1(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">f1(<span class="number">1</span>, <span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line">f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, x=<span class="number">99</span>)</span><br><span class="line">f2(<span class="number">1</span>, <span class="number">2</span>, d=<span class="number">99</span>, ext=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">kw = &#123;<span class="string">&#x27;d&#x27;</span>: <span class="number">99</span>, <span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;#&#x27;</span>&#125;</span><br><span class="line">f1(*args, **kw)</span><br><span class="line"></span><br><span class="line">args1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">kw1 = &#123;<span class="string">&#x27;d&#x27;</span>: <span class="number">88</span>, <span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;#&#x27;</span>&#125;</span><br><span class="line">f2(*args1, **kw1)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">0</span> args = () kw = &#123;&#125;</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = () kw = &#123;&#125;</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>) kw = &#123;&#125;</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>) kw = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">99</span>&#125;</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">0</span> d = <span class="number">99</span> kw = &#123;<span class="string">&#x27;ext&#x27;</span>: <span class="literal">None</span>&#125;</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="number">4</span>,) kw = &#123;<span class="string">&#x27;d&#x27;</span>: <span class="number">99</span>, <span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;#&#x27;</span>&#125;</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> d = <span class="number">88</span> kw = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;#&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n</span>):</span><br><span class="line">	<span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> n * fact(n - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(fact(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<p>使用递归函数需要注意防止栈溢出</p>
<p>在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。</p>
<p>解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。</p>
<p>尾递归是指，在函数返回的时候，调用自身本身，并且，<code>return</code> 语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</p>
<p>上面的 <code>fact(n)</code> 函数由于 <code>return n * fact(n - 1)</code> 引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fact1</span>(<span class="params">n</span>):</span><br><span class="line">	<span class="keyword">return</span> fact_iter(n, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fact_iter</span>(<span class="params">num, product</span>):</span><br><span class="line">	<span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> product</span><br><span class="line">	<span class="keyword">return</span> fact_iter(num - <span class="number">1</span>, num * product)</span><br><span class="line"><span class="built_in">print</span>(fact1(<span class="number">6</span>))</span><br></pre></td></tr></table></figure>

<p>尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。</p>
<p>遗憾的是，大多数编程语言没有针对尾递归做优化，Python 解释器也没有做优化，所以，即使把上面的 <code>fact(n)</code> 函数改成尾递归方式，也会导致栈溢出。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>layerClass</title>
    <url>/2019/04/02/20190402-layerClass/</url>
    <content><![CDATA[<p>今天在工作中遇到了需要让 <code>AVPlayerLayer</code> 支持 <code>autolayout</code> 的问题。因为我播放器的 <code>playerView</code> 是通过约束决定大小的，目的为了适应小屏手机。我需要让我的 <code>AVPlayerLayer</code> 充满我的 <code>playerView</code>，如果有 <code>autolayout</code> 这个问题就非常好解决，但是 <code>layer</code> 是不支持 <code>autolayout</code> 的，我想到了两种解决方式。</p>
<span id="more"></span>

<h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>自定义 <code>PlayerView</code> 继承自 <code>UIView</code>，然后重写 <code>layoutSubviews</code> 方法，让 <code>layoutSubviews </code> 去执行一个回调 <code>layoutCallback</code>，我们在这个回调中调整 <code>playerLayer</code> 的 <code>frame</code>。</p>
<p>代码大致如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PlayerView</span>: <span class="title class_ inherited__">UIView</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> layoutCallback: ((<span class="type">UIView</span>) -&gt; <span class="type">Void</span>)<span class="operator">?</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">layoutSubviews</span>() &#123;</span><br><span class="line">    layoutCallback<span class="operator">?</span>(<span class="keyword">self</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoViewController</span>: <span class="title class_ inherited__">UIViewController</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">@IBOutlet</span> <span class="keyword">private(set)</span> <span class="keyword">weak</span> <span class="keyword">var</span> playerView: <span class="type">PlayerView</span>!</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> playerLayer: <span class="type">AVPlayerLayer</span>!</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidLoad</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> player <span class="operator">=</span> <span class="type">AVPlayer</span>(url: <span class="type">URL</span>(string: <span class="string">&quot;&quot;</span>)<span class="operator">!</span>)</span><br><span class="line">    playerLayer <span class="operator">=</span> <span class="type">AVPlayerLayer</span>(player: player)</span><br><span class="line">    playerView.layoutCallback <span class="operator">=</span> &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">self</span><span class="operator">?</span>.playerLayer.frame <span class="operator">=</span> <span class="variable">$0</span>.frame</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样虽然能够解决问题，但是在加载的时候会明显看到 <code>playerLayer</code> 的 <code>frame</code> 被调整。这自然不是我们想要的。</p>
<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>我们将 <code>UIView</code> 的 <code>layer</code> 直接替换成 <code>AVPlayerLayer</code> 然后就不需要设置 <code>layer</code> 的 <code>frame</code> 它会自动充满整个 <code>View</code>。这样我们完全不需要去初始化一个新的 <code>AVPlayerLayer</code>，用起来也方便不少。</p>
<p>想要替换 <code>View</code> 的 <code>layer</code> 我们需要重写 <code>layerClass</code> 属性。官方对 <code>layerClass</code> 的解释如下：</p>
<blockquote>
<p>这个方法默认返回 <code>CALayer</code> 类对象。子类可以覆盖此方法，并根据需要返回不同的 <code>layer class</code>。例如，如果你的视图使用平铺显示一个大的可滚动区域，您可能希望覆盖此属性并返回 <code>CATiledLayer</code> 类。</p>
<p>在创建视图的早期只调用此方法一次，以便创建相应的 <code>layer</code> 对象。</p>
</blockquote>
<p>最后代码大致如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PlayerView</span>: <span class="title class_ inherited__">UIView</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">class</span> <span class="keyword">var</span> layerClass: <span class="type">AnyClass</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">AVPlayerLayer</span>.<span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> playerLayer: <span class="type">AVPlayerLayer</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.layer <span class="keyword">as?</span> <span class="type">AVPlayerLayer</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoViewController</span>: <span class="title class_ inherited__">UIViewController</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">@IBOutlet</span> <span class="keyword">private(set)</span> <span class="keyword">weak</span> <span class="keyword">var</span> playerView: <span class="type">PlayerView</span>!</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidLoad</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    </span><br><span class="line">    playerView.playerLayer<span class="operator">?</span>.player <span class="operator">=</span> <span class="type">AVPlayer</span>(url: <span class="type">URL</span>(string: <span class="string">&quot;&quot;</span>)<span class="operator">!</span>)</span><br><span class="line">    playerView.playerLayer<span class="operator">?</span>.videoGravity <span class="operator">=</span> .resizeAspectFill</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题完美解决。</p>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 数组中如何存储弱引用</title>
    <url>/2019/08/21/20190821-iOS%E6%95%B0%E7%BB%84%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E5%BC%B1%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>今天在项目中遇到了一个有趣的问题。项目中有一个监听的服务，监听需要将控制器放入一个数组中为其进行相应的操作。不过这引发了一个循环引用的问题。那么问题就变成了，如何在数组中存储弱引用呢？</p>
<p>数组中存储弱引用我们可以有两种解决方式：</p>
<ul>
<li>设置一个类来存储我们的控制器，这个类的中用于存储的属性自然是 <code>weak</code> 类型。</li>
<li>使用 <code>NSPointerArray</code>。</li>
</ul>
<span id="more"></span>

<h3 id="使用自定义类存储控制器"><a href="#使用自定义类存储控制器" class="headerlink" title="使用自定义类存储控制器"></a>使用自定义类存储控制器</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WeakObject</span>&lt;<span class="type">T</span>: <span class="type">AnyObject</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">weak</span> <span class="keyword">var</span> value: <span class="type">T</span>?</span><br><span class="line">  <span class="keyword">init</span>(<span class="params">value</span>: <span class="type">T</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.value <span class="operator">=</span> value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就不会出现相互持有的情况。详细代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DemoViewController</span>: <span class="title class_ inherited__">UIViewController</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> manager <span class="operator">=</span> <span class="type">ControllerManager</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidLoad</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    </span><br><span class="line">    setupUI()</span><br><span class="line">    </span><br><span class="line">    manager.addListener(to: <span class="keyword">self</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;DemoViewController deinit&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">DemoViewController</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">setupUI</span>() &#123;</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor <span class="operator">=</span> .white</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ControllerManager</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> viewControllers <span class="operator">=</span> [<span class="type">WeakObject</span>&lt;<span class="type">UIViewController</span>&gt;]()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">addListener</span>(<span class="params">to</span> <span class="params">viewController</span>: <span class="type">UIViewController</span>) &#123;</span><br><span class="line">    viewControllers.append(<span class="type">WeakObject</span>(value: viewController))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeakObject</span>&lt;<span class="type">T</span>: <span class="type">AnyObject</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">weak</span> <span class="keyword">var</span> value: <span class="type">T</span>?</span><br><span class="line">  <span class="keyword">init</span>(<span class="params">value</span>: <span class="type">T</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.value <span class="operator">=</span> value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-NSPointerArray"><a href="#使用-NSPointerArray" class="headerlink" title="使用 NSPointerArray"></a>使用 NSPointerArray</h3><p><code>NSPointerArray</code> 类是一个稀疏数组，工作起来与 <code>NSMutableArray</code> 相似，但可以存储 <code>NULL</code> 值，并且 <code>count</code> 方法会反应这些空点。可以用 <code>NSPointerFunctions</code> 对其进行各种设置，也有应对常见的使用场景的快捷构造函数 <code>strongObjectsPointerArray</code> 和 <code>weakObjectsPointerArray</code>。</p>
<p>在能使用 <code>insertPointer:atIndex:</code> 之前，我们需要通过直接设置 <code>count</code> 属性来申请空间，否则会产生一个异常。另一种选择是使用 <code>addPointer:</code>，这个方法可以自动根据需要增加数组的大小。</p>
<p>你可以通过 <code>allObjects</code> 将一个 <code>NSPointerArray</code> 转换成常规的 <code>NSArray</code>。这时所有的 <code>NULL</code> 值会被去掉，只有真正存在的对象被加入到数组 — 因此数组的对象索引很有可能会跟指针数组的不同。注意：如果向指针数组中存入任何非对象的东西，试图执行 <code>allObjects</code> 都会造成 <code>EXC_BAD_ACCESS</code> 崩溃，因为它会一个一个地去 <code>retain</code> 对象。</p>
<p>从调试的角度讲，<code>NSPointerArray</code> 没有受到太多欢迎。<code>description</code> 方法只是简单的返回了<code>&lt;NSConcretePointerArray: 0x17015ac50&gt;</code>。为了得到所有的对象需要执行 <code>[pointerArray allObjects]</code>，当然，如果存在 <code>NULL</code> 的话会改变索引。</p>
<p>这里我们只需要将上述的 <code>var viewControllers = [WeakObject&lt;UIViewController&gt;]()</code> 设置成 <code>var viewControllers = NSPointerArray(options: .weakMemory)</code> 即可。详细代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DemoViewController</span>: <span class="title class_ inherited__">UIViewController</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> manager <span class="operator">=</span> <span class="type">ControllerManager</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidLoad</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    </span><br><span class="line">    setupUI()</span><br><span class="line">    </span><br><span class="line">    manager.addListener(to: <span class="keyword">self</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;DemoViewController deinit&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">DemoViewController</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">setupUI</span>() &#123;</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor <span class="operator">=</span> .white</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ControllerManager</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> viewControllers <span class="operator">=</span> <span class="type">NSPointerArray</span>(options: .weakMemory)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">addListener</span>(<span class="params">to</span> <span class="params">viewController</span>: <span class="type">UIViewController</span>) &#123;</span><br><span class="line">    viewControllers.addPointer(<span class="type">Unmanaged</span>.passUnretained(<span class="keyword">self</span>).toOpaque())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这里使用 <code>NSPointerArray</code> 非常的方便，不过就性能来说，<code>NSPointerArray</code> 真的非常非常慢(不过这里数据量很小，到看不出与 <code>Array</code> 的差别)。</p>
<p>当你打算在一个很大的数据集合上使用它的时候一定要三思。在本测试中我们比较了使用 <code>NSNull</code> 作为空标记的 <code>NSMutableArray</code> ，而对 <code>NSPointerArray</code> 我们用 <code>NSPointerFunctionsStrongMemory</code> 来进行设置 (这样对象会被适当的 <code>retain</code>)。在一个有 10,000 个元素的数组中，我们每隔十个插入一个字符串 <code>Entry %d</code>。此测试包括了用 <code>NSNull.null</code> 填充 <code>NSMutableArray</code> 的总时间。对于 <code>NSPointerArray</code>，我们使用 <code>setCount:</code> 来代替:</p>
<table>
<thead>
<tr>
<th>类 &#x2F; 时间 [ms]</th>
<th align="center">10.000 elements</th>
</tr>
</thead>
<tbody><tr>
<td>NSMutableArray, adding</td>
<td align="center">15.28</td>
</tr>
<tr>
<td>NSPointerArray, adding</td>
<td align="center">3851.51</td>
</tr>
<tr>
<td>NSMutableArray, random access</td>
<td align="center">0.23</td>
</tr>
<tr>
<td>NSPointerArray, random access</td>
<td align="center">0.34</td>
</tr>
</tbody></table>
<p>注意 <code>NSPointerArray</code> 需要的时间比 <code>NSMutableArray</code> 多了超过 250 倍(!) 。这非常奇怪和意外。跟踪内存是比较困难的，所以按理说 <code>NSPointerArray</code> 会更高效才对。不过由于我们使用的是同一个 <code>NSNull</code> 来标记空对象，所以除了指针也没有什么更多的消耗。</p>
<h3 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9vYmpjY24uaW8vaXNzdWUtNy0xLw==">基础集合类<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>XCFramework 踩坑记</title>
    <url>/2020/12/21/20201221-XCFramework%20%E8%B8%A9%E5%9D%91%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>Building for iOS Simulator, but the embedded framework ‘xxx.framework’ was built for iOS + iOS Simulator.</p>
</blockquote>
<p>升级 Xcode 后就悲剧了，以上报错苹果在 Xcode 11 中已经给出 warring，在 Xcode 12.3 版本后会直接 error。</p>
<p>来自苹果工程师的回复：</p>
<blockquote>
<p>This framework isn’t built with a supported configuration – iOS and iOS Simulator code has never been supported in the same binary. The linker in Xcode 11 began identifying these incorrect configurations and issuing warnings, and Xcode 12 goes further in identifying these issues.</p>
<p>The only correct way to resolve this is to <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL3ZpZGVvcy9wbGF5L3d3ZGMyMDE5LzQxNi8=">rebuild the framework as an XCFramework.<i class="fa fa-external-link-alt"></i></span> If this is your framework, or owned by another group in your company, follow the information in the video and <span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmFwcGxlLmNvbS94Y29kZS9tYWMvY3VycmVudC8jL2RldjU0NGVmYWI5Ng==">the Xcode Help article.<i class="fa fa-external-link-alt"></i></span></p>
<p>If this framework is from a vendor, then you need to work with the vendor to get an updated version of the framework built with supported configuration.</p>
<p>In the discussion of this thread, there is a build script that attempts to resolve this error. Scripts like that – anything that tries to manipulate the output with commands like lipo – still produces an unsupported configuration in the binary. XCFrameworks are the way to go.</p>
</blockquote>
<span id="more"></span>

<p><strong>官方推荐方式（需要 new build system 支持）：</strong></p>
<p>将库打包成 xcframework 格式。</p>
<p>有关于 xcframework 内容可以参考苹果的 WWDC 视频 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL3ZpZGVvcy9wbGF5L3d3ZGMyMDE5LzQxNi8=">Binary Frameworks in Swift<i class="fa fa-external-link-alt"></i></span></p>
<p>Carthage 目前通过 homebrew 安装方式还不支持打包成 xcframework 格式，所以需要我们手动调用 xcodebuild 命令。为了使用方便，我们可以在工程中添加 Aggregated target，然后创建 script 方便我们生成 xcframework。完整的 script 如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">WORKSPACE_NAME=&quot;$&#123;PROJECT&#125;.xcworkspace&quot;</span><br><span class="line">SCHEME_NAME=$&#123;PROJECT&#125;</span><br><span class="line">FRAMEWORK_NAME=$&#123;PROJECT&#125;</span><br><span class="line">SIMULATOR_ARCHIVE_PATH=&quot;$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;/$&#123;FRAMEWORK_NAME&#125;-iphonesimulator.xcarchive&quot;</span><br><span class="line">DEVICE_ARCHIVE_PATH=&quot;$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;/$&#123;FRAMEWORK_NAME&#125;-iphoneos.xcarchive&quot;</span><br><span class="line">OUTPUT_DIC=&quot;./xcframework/&quot;</span><br><span class="line"> </span><br><span class="line">script=&quot;./xcodebuild.sh&quot;</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Simulator xcarchieve</span></span><br><span class="line">/bin/sh $&#123;script&#125; archive \</span><br><span class="line">  -workspace $&#123;WORKSPACE_NAME&#125; \</span><br><span class="line">  -scheme $&#123;SCHEME_NAME&#125; \</span><br><span class="line">  -archivePath $&#123;SIMULATOR_ARCHIVE_PATH&#125; \</span><br><span class="line">  -sdk iphonesimulator \</span><br><span class="line">  SKIP_INSTALL=NO</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Device xcarchieve</span></span><br><span class="line">xcodebuild archive \</span><br><span class="line">  -workspace $&#123;WORKSPACE_NAME&#125; \</span><br><span class="line">  -scheme $&#123;SCHEME_NAME&#125; \</span><br><span class="line">  -archivePath $&#123;DEVICE_ARCHIVE_PATH&#125; \</span><br><span class="line">  -sdk iphoneos \</span><br><span class="line">  SKIP_INSTALL=NO</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Clean up old output directory</span></span><br><span class="line">rm -rf &quot;$&#123;OUTPUT_DIC&#125;&quot;</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Create xcframwork combine of all frameworks</span></span><br><span class="line">xcodebuild -create-xcframework \</span><br><span class="line">  -framework $&#123;SIMULATOR_ARCHIVE_PATH&#125;/Products/Library/Frameworks/$&#123;FRAMEWORK_NAME&#125;.framework \</span><br><span class="line">  -framework $&#123;DEVICE_ARCHIVE_PATH&#125;/Products/Library/Frameworks/$&#123;FRAMEWORK_NAME&#125;.framework \</span><br><span class="line">  -output $&#123;OUTPUT_DIC&#125;/$&#123;FRAMEWORK_NAME&#125;.xcframework</span><br></pre></td></tr></table></figure>

<p>由于模拟器的编译在 Xcode 12.x 中有问题，所以新建了一个 xcodebuild.sh 文件，代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env bash</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">xcodebuild.sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Usage example: ./xcodebuild.sh archive</span></span><br><span class="line"> </span><br><span class="line">set -euo pipefail</span><br><span class="line"> </span><br><span class="line">xcconfig=$(mktemp /tmp/static.xcconfig.XXXXXX)</span><br><span class="line">trap &#x27;rm -f &quot;$xcconfig&quot;&#x27; INT TERM HUP EXIT</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">For Xcode 12 make sure EXCLUDED_ARCHS is <span class="built_in">set</span> to arm architectures otherwise</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">the build will fail on lipo due to duplicate architectures.</span></span><br><span class="line">echo &#x27;EXCLUDED_ARCHS__EFFECTIVE_PLATFORM_SUFFIX_simulator__NATIVE_ARCH_64_BIT_x86_64__XCODE_1200 = arm64 arm64e armv7 armv7s armv6 armv8&#x27; &gt;&gt; $xcconfig</span><br><span class="line">echo &#x27;EXCLUDED_ARCHS = $(inherited) $(EXCLUDED_ARCHS__EFFECTIVE_PLATFORM_SUFFIX_$(EFFECTIVE_PLATFORM_SUFFIX)__NATIVE_ARCH_64_BIT_$(NATIVE_ARCH_64_BIT)__XCODE_$(XCODE_VERSION_MAJOR))&#x27; &gt;&gt; $xcconfig</span><br><span class="line"> </span><br><span class="line">export XCODE_XCCONFIG_FILE=&quot;$xcconfig&quot;</span><br><span class="line">xcodebuild &quot;$@&quot;</span><br></pre></td></tr></table></figure>

<h4 id="两个临时修复方案："><a href="#两个临时修复方案：" class="headerlink" title="两个临时修复方案："></a>两个临时修复方案：</h4><ul>
<li>不使用 Xcode 12.3，换成 Xcode 12.2。</li>
<li>将工程的 Validate Workspace 设置成为 YES。</li>
</ul>
<h4 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h4><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NhcnRoYWdlL0NhcnRoYWdlL2lzc3Vlcy8yNzk5">Catalyst support<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2ZvcnVtcy90aHJlYWQvNjY5NDExP2Fuc3dlcklkPTY1MjQ4OTAyMiM2NTI0ODkwMjI=">Xcode 12.3 failed on some 3rd framework and librarys?<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NhcnRoYWdlL0NhcnRoYWdlL2lzc3Vlcy8zMDE5">Workaround that works with both Xcode 11 and 12<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NhcnRoYWdlL0NhcnRoYWdlL2lzc3Vlcy8yODkw">Roadmap Q4 2019 - Q1 2020<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg Xcode 环境搭建</title>
    <url>/2021/06/29/20210629-FFmpeg%20Xcode%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="安装-FFmpeg"><a href="#安装-FFmpeg" class="headerlink" title="安装 FFmpeg"></a>安装 FFmpeg</h2><p>根据 <span class="exturl" data-url="aHR0cHM6Ly90cmFjLmZmbXBlZy5vcmcvd2lraS9Db21waWxhdGlvbkd1aWRlL21hY09T">官方文档<i class="fa fa-external-link-alt"></i></span> 的描述，有三种安装 FFmpeg 的方式，这里我们选择最简单快速的一种，使用 <code>Homebrew</code> 命令安装。</p>
<p>如果还没有安装 <code>Homebrew</code> 的话，请先安装 <code>Homebrew</code>，<span class="exturl" data-url="aHR0cHM6Ly9icmV3LnNoLw==">点击跳转官方网站<i class="fa fa-external-link-alt"></i></span></p>
<p>我们执行如下命令即可安装好 FFmpeg：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install ffmpeg</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="Xcode-相关配置"><a href="#Xcode-相关配置" class="headerlink" title="Xcode 相关配置"></a>Xcode 相关配置</h2><h3 id="Build-Settings"><a href="#Build-Settings" class="headerlink" title="Build Settings"></a>Build Settings</h3><p>我们通过如下命令即可查看 FFmpeg 的相关信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew info ffmpeg</span><br></pre></td></tr></table></figure>

<p>会输出类似下面一样的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg: stable 4.4 (bottled), HEAD</span><br><span class="line">Play, record, convert, and stream audio and video</span><br><span class="line">https://ffmpeg.org/</span><br><span class="line">/usr/local/Cellar/ffmpeg/4.4_2 (276 files, 52.7MB) *</span><br><span class="line">  Poured from bottle on 2021-06-25 at 00:50:35</span><br><span class="line">From: https://github.com/Homebrew/homebrew-core/blob/HEAD/Formula/ffmpeg.rb</span><br><span class="line">License: GPL-2.0-or-later</span><br><span class="line">==&gt; Dependencies</span><br><span class="line">Build: nasm ✔, pkg-config ✔</span><br><span class="line">Required: aom ✔, dav1d ✔, fontconfig ✔, freetype ✔, frei0r ✔, gnutls ✔, lame ✔, libass ✔, libbluray ✔, libsoxr ✔, libvidstab ✔, libvorbis ✔, libvpx ✔, opencore-amr ✔, openjpeg ✔, opus ✔, rav1e ✔, rubberband ✔, sdl2 ✔, snappy ✔, speex ✔, srt ✔, tesseract ✔, theora ✔, webp ✔, x264 ✔, x265 ✔, xvid ✔, xz ✔, zeromq ✔, zimg ✔</span><br><span class="line">==&gt; Options</span><br><span class="line">--HEAD</span><br><span class="line">	Install HEAD version</span><br><span class="line">==&gt; Analytics</span><br><span class="line">install: 124,147 (30 days), 436,612 (90 days), 1,751,038 (365 days)</span><br><span class="line">install-on-request: 102,817 (30 days), 366,434 (90 days), 1,443,249 (365 days)</span><br><span class="line">build-error: 0 (30 days)</span><br></pre></td></tr></table></figure>

<p>我们在信息中可以找到 FFmpeg 的安装目录如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/local/Cellar/ffmpeg/4.4_2</span><br></pre></td></tr></table></figure>

<p>目录中包括两个文件夹 <code>lib</code> 和 <code>include</code>，这两个文件夹我们需要在 <code>Xcode</code> 中配置相关搜索路径。我们打开 <code>Xcode</code> 的 <code>Build Settings</code> 界面，配置 <code>Header Search Paths</code> 和 <code>Library Search Paths</code>。我的本地环境配置如下图所示：</p>
<img src="/my_pictures/20210629/1.png" style="zoom: 33%;" />

<h3 id="Library"><a href="#Library" class="headerlink" title="Library"></a>Library</h3><p>我们切换到 <code>General</code> 或 <code>Build Phases</code>，将 <code>FFmpeg</code> 目录下的 <code>lib</code> 文件夹中的 <code>.a</code> 文件按需添加，如下图：</p>
<img src="/my_pictures/20210629/2.png" style="zoom: 50%;" />
<img src="/my_pictures/20210629/3.png" style="zoom: 33%;" />
<img src="/my_pictures/20210629/4.png" style="zoom: 33%;" />

<p>此时我们的环境就算是配置完毕。</p>
<p>我们在类中随便加点代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Cocoa</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ViewController</span>: <span class="title class_ inherited__">NSViewController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidLoad</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        av_log_set_flags(<span class="type">AV_LOG_SKIP_REPEATED</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">#if</span> <span class="type">CONFIG_AVDEVICE</span></span><br><span class="line">            avdevice_register_all();</span><br><span class="line">        <span class="keyword">#endif</span></span><br><span class="line">        avformat_network_init()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> representedObject: <span class="keyword">Any</span><span class="operator">?</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>桥接文件</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;libavutil/avstring.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;libavutil/eval.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;libavutil/mathematics.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;libavutil/pixdesc.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;libavutil/imgutils.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;libavutil/dict.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;libavutil/fifo.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;libavutil/parseutils.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;libavutil/samplefmt.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;libavutil/avassert.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;libavutil/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;libavutil/bprint.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;libavdevice/avdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;libswscale/swscale.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;libavutil/opt.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;libavcodec/avfft.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;libswresample/swresample.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>此时我们 <code>Build</code> 一下，发现是可以编译通过的。</p>
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p><code>Build</code> 没问题了，我们 <code>run</code> 一下。此时我们可能碰到 <code>crash</code>，提示信息如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dyld: Library not loaded: /usr/local/opt/ffmpeg/lib/libswscale.5.dylib</span><br><span class="line">  Referenced from: /Users/jiafengwu/Library/Developer/Xcode/DerivedData/ffdemo-gqmgjyhlyiyktmdpikmfktmubkzg/Build/Products/Debug/ffdemo.app/Contents/MacOS/ffdemo</span><br><span class="line">  Reason: no suitable image found.  Did find:</span><br><span class="line">	/usr/local/opt/ffmpeg/lib/libswscale.5.dylib: code signature <span class="keyword">in</span> (/usr/local/opt/ffmpeg/lib/libswscale.5.dylib) not valid <span class="keyword">for</span> use <span class="keyword">in</span> process using Library Validation: mapped file has no cdhash, completely unsigned? Code has to be at least ad-hoc signed.</span><br><span class="line">	/usr/local/lib/libswscale.5.dylib: code signature <span class="keyword">in</span> (/usr/local/lib/libswscale.5.dylib) not valid <span class="keyword">for</span> use <span class="keyword">in</span> process using Library Validation: mapped file has no cdhash, completely unsigned? Code has to be at least ad-hoc signed.</span><br><span class="line">	/usr/local/Cellar/ffmpeg/4.4_2/lib/libswscale.5.9.100.dylib: code signature <span class="keyword">in</span> (/usr/local/Cellar/ffmpeg/4.4_2/lib/libswscale.5.9.100.dylib) not valid <span class="keyword">for</span> use <span class="keyword">in</span> process using Library Validation: mapped file has no cdhash, completely unsigned? Code has to be at least ad-hoc signed.</span><br></pre></td></tr></table></figure>

<p>从提示信息我们可知，是动态库没有签名。我们还需将其手动签名一下。顺便说一句，上面的报错是在 <code>FFmpeg</code> 目录中的 <code>lib</code> 目录下，我们将其签名后可能还有其他库需要签名，我的解决方式是，直接吧报错目录下的所有动态库批量签名。</p>
<p>我们从钥匙串中找到我们证书的名字，类似于：<code>Apple Development: xxx</code>。</p>
<p>我们打开终端，进入对应目录，执行如下签名命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codesign -f -s <span class="string">&quot;Apple Development: xxx&quot;</span> *.dylib</span><br></pre></td></tr></table></figure>

<p><strong>引号中的证书信息需要替换成自己的</strong></p>
<p>因为 <code>Xcode</code> 运行代码使用了系统的库，所以我就批量的进行了签名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codesign -f -s <span class="string">&quot;Mac Developer: xxx&quot;</span> /usr/local/opt/*/lib/*.dylib</span><br></pre></td></tr></table></figure>

<p>当我们签名完成之后，再次进行 <code>run</code>，发现就能跑起来了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>签名的相关命令</p>
<p>1、清除动态库的签名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codesign --remove-signature xxx.dylib</span><br></pre></td></tr></table></figure>

<p>2、查看签名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codesign -vv -d xxx.dylib</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codesign -dvvv xxx.dylib</span><br></pre></td></tr></table></figure>

<p>3、重新签名</p>
<p><code>codesign</code> 的 <code>-f</code> 参数就是强制签名的意思，本文使用的 <code>codesign -f -s</code> 就能直接重新签名。如果不想覆盖原来的签名，可以把 <code>-f</code> 参数去掉。</p>
]]></content>
      <categories>
        <category>视频技术</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>Carthage 新手教程</title>
    <url>/2019/03/09/20190309-Carthage%20%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="Carthage-与-Cocoapods-的不同"><a href="#Carthage-与-Cocoapods-的不同" class="headerlink" title="Carthage 与 Cocoapods 的不同"></a>Carthage 与 Cocoapods 的不同</h2><p>Cocoapods 是由来已久的 Cocoa 依赖管理工具，那么为什么 Carthage 项目被创建？</p>
<p>首先，Cocoapods（默认情况下）会自动的为你的应用程序和所有依赖创建和更新 <code>Xcode workspace</code>。Carthage 用 <code>xcodebuild</code> 构建框架（framework）的二进制文件，但是并没有将他们整合到用户项目中。Cocoapods 的目的是让用户使用起来更简单，而 Carthage 则是更灵活，减少对项目的侵入性。</p>
<p>Cocoapods 的目标在其<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NvY29hUG9kcy9Db2NvYVBvZHMvYmxvYi8xNzAzYTM0NjQ2NzRiYWVjZjU0YmQ3ZTc2NmY0YjM3ZWQ4ZmM0M2Y3L1JFQURNRS5tZA==">README<i class="fa fa-external-link-alt"></i></span>文件中有如下描述：</p>
<blockquote>
<p>… to improve discoverability of, and engagement in, third party open-source libraries, by creating a more centralized ecosystem.</p>
</blockquote>
<p>对比之下，Carthage 被创建成一个松散（decentralized）的依赖管理者，没有中心项目清单，这减少了维护工作并避免了任何中心故障点（通俗的讲就是去中心化）。然而，项目被发现就变的更加困难 – 用户必须去使用 GitHub 的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RyZW5kaW5nP2w9c3dpZnQ=">Trending<i class="fa fa-external-link-alt"></i></span> 页面或者其他类似的页面（Cocoapods 就比较简单的可以在终端搜索需要使用的库）。</p>
<span id="more"></span>

<p>Cocoapods 项目还必须具有所谓的 <code>podspec</code> 文件，其中包括有关项目的元数据，并指定应如何构建它。Carthage 使用 <code>xcodebuild</code> 去构建依赖，而不是将它们集成到单个工作区中，它没有类似的规范文件，但你的依赖项必须包含到自己的 Xcode 项目中，该项目描述了如何构建其产品。</p>
<p>最终，我们创建了 Carthage，因为我们想要一个最简单的工具 – 一个可以完成工作而不必承担 Xcode 责任的依赖管理器，并且并没有为框架作者创造额外的工作。Cocoapods 提供了许多惊人的功能，但是在 Carthage 中，这些功能永远不会出现，因为这会增加额外的复杂性。</p>
<h2 id="Carthage-安装"><a href="#Carthage-安装" class="headerlink" title="Carthage 安装"></a>Carthage 安装</h2><h3 id="使用-homebrew-安装"><a href="#使用-homebrew-安装" class="headerlink" title="使用 homebrew 安装"></a>使用 homebrew 安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install carthage</span><br></pre></td></tr></table></figure>

<h3 id="查看版本和升级"><a href="#查看版本和升级" class="headerlink" title="查看版本和升级"></a>查看版本和升级</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 查看版本：</span><br><span class="line">carthage version</span><br><span class="line">// 升级：</span><br><span class="line">brew upgrade carthage</span><br></pre></td></tr></table></figure>

<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew uninstall carthage</span><br></pre></td></tr></table></figure>

<h2 id="Carthage-配置第三方库（iOS，tvOS，watchOS）"><a href="#Carthage-配置第三方库（iOS，tvOS，watchOS）" class="headerlink" title="Carthage 配置第三方库（iOS，tvOS，watchOS）"></a>Carthage 配置第三方库（iOS，tvOS，watchOS）</h2><h3 id="创建-Cartfile-文件"><a href="#创建-Cartfile-文件" class="headerlink" title="创建 Cartfile 文件"></a>创建 Cartfile 文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd to your project</span><br><span class="line">touch Cartfile</span><br></pre></td></tr></table></figure>

<h3 id="用-Xcode-打开-编辑-Cartfile"><a href="#用-Xcode-打开-编辑-Cartfile" class="headerlink" title="用 Xcode 打开&#x2F;编辑 Cartfile"></a>用 Xcode 打开&#x2F;编辑 Cartfile</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open -a Xcode Cartfile</span><br></pre></td></tr></table></figure>

<h3 id="添加依赖库"><a href="#添加依赖库" class="headerlink" title="添加依赖库"></a>添加依赖库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">github &quot;Alamofire/Alamofire&quot; == 4.5</span><br><span class="line">github &quot;Alamofire/AlamofireImage&quot; ~&gt; 3.2</span><br></pre></td></tr></table></figure>

<p>现在支持的三个来源是 GitHub 存储库，Git 存储库和通过 https 提供的仅二进制框架。未来可能会添加其他可能的来源。如果你想看到具体的东西，请提 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NhcnRoYWdlL0NhcnRoYWdlL2lzc3Vlcy9uZXc=">issue<i class="fa fa-external-link-alt"></i></span>。</p>
<h4 id="GitHub-Repositories"><a href="#GitHub-Repositories" class="headerlink" title="GitHub Repositories"></a>GitHub Repositories</h4><p>使用 <code>github</code> 关键字指定 GitHub 存储库（<code>GitHub.com</code> 和 <code>GitHub Enterprise</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">github &quot;ReactiveCocoa/ReactiveCocoa&quot; # GitHub.com</span><br><span class="line">github &quot;https://enterprise.local/ghe/desktop/git-error-translations&quot; # GitHub Enterprise</span><br></pre></td></tr></table></figure>

<p><code>github</code> 源是用于 <code>owner/repo</code> 表单指定或通过其 <code>web API</code> 使用预构建的二进制下载功能，因此对 <code>github</code> 源 使用 <code>git</code> 或 <code>ssh</code> 协议是没有意义的，并且这是一个错误。</p>
<h4 id="Git-repositories"><a href="#Git-repositories" class="headerlink" title="Git repositories"></a>Git repositories</h4><p>其他 Git 存储库使用 <code>git</code> 关键字指定：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git &quot;https://enterprise.local/desktop/git-error-translations2.git&quot;</span><br></pre></td></tr></table></figure>

<h4 id="Binary-only-frameworks"><a href="#Binary-only-frameworks" class="headerlink" title="Binary only frameworks"></a>Binary only frameworks</h4><p>仅作为已编译的二进制文件 <code>.frameworks</code> 提供的依赖项使用 <code>binary</code> 关键字和 <code>https：//</code> 链接，<code>file：//</code> 链接，或没有方案的相对或绝对路径，返回<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NhcnRoYWdlL0NhcnRoYWdlL2Jsb2IvbWFzdGVyL0RvY3VtZW50YXRpb24vQXJ0aWZhY3RzLm1kI2JpbmFyeS1wcm9qZWN0LXNwZWNpZmljYXRpb24=">二进制项目规范<i class="fa fa-external-link-alt"></i></span>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">binary &quot;https://my.domain.com/release/MyFramework.json&quot;   // Remote Hosted</span><br><span class="line">binary &quot;file:///some/Path/MyFramework.json&quot;               // Locally hosted at file path</span><br><span class="line">binary &quot;relative/path/MyFramework.json&quot;                   // Locally hosted at relative path to CWD</span><br><span class="line">binary &quot;/absolute/path/MyFramework.json&quot;                  // Locally hosted at absolute path</span><br></pre></td></tr></table></figure>

<h3 id="版本要求"><a href="#版本要求" class="headerlink" title="版本要求"></a>版本要求</h3><p>Carthage 支持多种版本要求：</p>
<ol>
<li><code>&gt;= 1.0</code> 指“1.0 及以上版本”。</li>
<li><code>~&gt; 1.0</code> 指“1.x 版本”</li>
<li><code>== 1.0</code> 指“版本为 1.0”</li>
<li><code>&quot;some-branch-or-tag-or-commit&quot;</code> 特指 <code>git</code> 对象（<code>git rev-parse</code> 任何内容都被允许）。<ul>
<li>Note：<code>二进制源</code> 不支持这种形式。</li>
</ul>
</li>
</ol>
<p>如果没有指定任何版本，任何版本的依赖都将被允许（默认使用最新版本）。</p>
<h3 id="Example-Cartfile"><a href="#Example-Cartfile" class="headerlink" title="Example Cartfile"></a>Example Cartfile</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Require version 2.3.1 or later</span><br><span class="line">github &quot;ReactiveCocoa/ReactiveCocoa&quot; &gt;= 2.3.1</span><br><span class="line"></span><br><span class="line"># Require version 1.x</span><br><span class="line">github &quot;Mantle/Mantle&quot; ~&gt; 1.0    # (1.0 or later, but less than 2.0)</span><br><span class="line"></span><br><span class="line"># Require exactly version 0.4.1</span><br><span class="line">github &quot;jspahrsummers/libextobjc&quot; == 0.4.1</span><br><span class="line"></span><br><span class="line"># Use the latest version</span><br><span class="line">github &quot;jspahrsummers/xcconfigs&quot;</span><br><span class="line"></span><br><span class="line"># Use the branch</span><br><span class="line">github &quot;jspahrsummers/xcconfigs&quot; &quot;branch&quot;</span><br><span class="line"></span><br><span class="line"># Use a project from GitHub Enterprise</span><br><span class="line">github &quot;https://enterprise.local/ghe/desktop/git-error-translations&quot;</span><br><span class="line"></span><br><span class="line"># Use a project from any arbitrary server, on the &quot;development&quot; branch</span><br><span class="line">git &quot;https://enterprise.local/desktop/git-error-translations2.git&quot; &quot;development&quot;</span><br><span class="line"></span><br><span class="line"># Use a local project</span><br><span class="line">git &quot;file:///directory/to/project&quot; &quot;branch&quot;</span><br><span class="line"></span><br><span class="line"># A binary only framework</span><br><span class="line">binary &quot;https://my.domain.com/release/MyFramework.json&quot; ~&gt; 2.3</span><br><span class="line"></span><br><span class="line"># A binary only framework via file: url</span><br><span class="line">binary &quot;file:///some/local/path/MyFramework.json&quot; ~&gt; 2.3</span><br><span class="line"></span><br><span class="line"># A binary only framework via local relative path from Current Working Directory to binary project specification</span><br><span class="line">binary &quot;relative/path/MyFramework.json&quot; ~&gt; 2.3</span><br><span class="line"></span><br><span class="line"># A binary only framework via absolute path to binary project specification</span><br><span class="line">binary &quot;/absolute/path/MyFramework.json&quot; ~&gt; 2.3</span><br></pre></td></tr></table></figure>

<h2 id="安装-编辑-Cartfile-中的项目"><a href="#安装-编辑-Cartfile-中的项目" class="headerlink" title="安装&#x2F;编辑 Cartfile 中的项目"></a>安装&#x2F;编辑 Cartfile 中的项目</h2><h3 id="clone-项目，然后编译成-framework："><a href="#clone-项目，然后编译成-framework：" class="headerlink" title="clone 项目，然后编译成 framework："></a>clone 项目，然后编译成 <code>framework</code>：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 不指定 platform 会为所有的平台编译（Mac / iOS / tvOS / watchOS）</span><br><span class="line">// 查看更多关于 update 命令的选项：`carthage help update`</span><br><span class="line">carthage update --platform iOS</span><br></pre></td></tr></table></figure>

<p>Cartfile 利用 <code>xcode-select</code> 命令来编译 <code>framework</code>，如果你想用其他版的 Xcode 进行编译，执行下面这条命令，把 <code>xcode-select</code> 的路径改为另一版本 Xcode 就可以。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo xcode-select -s /Applications/Xcode-beta.app/Contents/Developer</span><br></pre></td></tr></table></figure>

<p>所有的文件会被编译到当前路径的 Carthage 文件夹中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 打开文件夹</span><br><span class="line">open Carthage</span><br></pre></td></tr></table></figure>

<h3 id="Carthage-文件夹中文件说明"><a href="#Carthage-文件夹中文件说明" class="headerlink" title="Carthage 文件夹中文件说明:"></a>Carthage 文件夹中文件说明:</h3><p><img src="/my_pictures/20190309/1.png"></p>
<h4 id="Cartfile-resolved"><a href="#Cartfile-resolved" class="headerlink" title="Cartfile.resolved"></a>Cartfile.resolved</h4><p>运行 <code>carthage update --platform iOS</code> 命令后，一个叫 <code>Cartfile.resolved</code> 的文件将会被创建到 Cartfile 同级目录下。此文件准确指定了每个依赖项选择的版本，并列出了所有依赖项（甚至是嵌套的版本）。</p>
<p>强烈建议将该文件加入到版本控制中，告知其他开发者，当前使用的版本。</p>
<p>虽然 <code>Cartfile.resolved</code> 文件是人类可读和可扩展的，但你不能修改它。文件的格式非常严格，列出依赖项的顺序对于构建过程很重要。</p>
<h4 id="Carthage-文件夹"><a href="#Carthage-文件夹" class="headerlink" title="Carthage 文件夹"></a>Carthage 文件夹</h4><ul>
<li>Build<br>  包含对应平台编译好的Framework</li>
<li>Checkouts<br>  包含编译 <code>framework</code> 所使用的源代码（除非你使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NhcnRoYWdlL0NhcnRoYWdlL2Jsb2IvbWFzdGVyL0RvY3VtZW50YXRpb24vQXJ0aWZhY3RzLm1kI3dpdGgtc3VibW9kdWxlcw==">submodules<i class="fa fa-external-link-alt"></i></span> ，否则不要修改这里的代码，<code>carthage update</code> 和 <code>carthage checkout</code> 会覆盖这里的代码，清除你的修改）。</li>
</ul>
<h4 id="With-submodules"><a href="#With-submodules" class="headerlink" title="With submodules"></a>With submodules</h4><p>如果在引导项目的依赖项时给出了 <code>--use-submodules</code> 标志，<code>updated</code> 或者 <code>checked out</code> <code>Carthage/Checkouts</code> 中的依赖项将作为 <code>Git</code> 子模块（submodules）提供。这允许你对依赖项进行更改，并提交这些更改。</p>
<h2 id="更新Framework的版本"><a href="#更新Framework的版本" class="headerlink" title="更新Framework的版本"></a>更新Framework的版本</h2><h3 id="打开-Cartfile"><a href="#打开-Cartfile" class="headerlink" title="打开 Cartfile"></a>打开 Cartfile</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open -a Xcode Cartfile</span><br></pre></td></tr></table></figure>

<h3 id="修改版本"><a href="#修改版本" class="headerlink" title="修改版本"></a>修改版本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// github &quot;Alamofire/Alamofire&quot; == 4.5</span><br><span class="line">github &quot;Alamofire/Alamofire&quot; ~&gt; 4.5.0</span><br></pre></td></tr></table></figure>

<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">carthage update --platform iOS</span><br></pre></td></tr></table></figure>

<h3 id="更新指定库"><a href="#更新指定库" class="headerlink" title="更新指定库"></a>更新指定库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">carthage update SVProgressHUD --platform iOS</span><br></pre></td></tr></table></figure>

<h2 id="引入-Carthage-依赖库到-Xcode"><a href="#引入-Carthage-依赖库到-Xcode" class="headerlink" title="引入 Carthage 依赖库到 Xcode"></a>引入 Carthage 依赖库到 Xcode</h2><ol>
<li>在 <code>Carthage -&gt; Build</code> 中找到需要添加的 <code>framework</code>。</li>
<li>拖拽对应的 <code>framework</code> 到 Xcode 工程的 <code>Linked Frameworks and Libraries</code> 中。</li>
</ol>
<p><img src="/my_pictures/20190309/2.gif"></p>
<ol start="3">
<li>进入工程的 <code>target -&gt; Build Phases</code>，点击 <code>+</code>，添加 <code>New Run Script Phase</code>:</li>
</ol>
<p><img src="/my_pictures/20190309/3.png"></p>
<p>添加如下脚本命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/bin/carthage copy-frameworks</span><br></pre></td></tr></table></figure>

<p>在 <code>Input Files</code> 下添加要使用的框架的路径。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(SRCROOT)/Carthage/Build/iOS/Alamofire.framework</span><br></pre></td></tr></table></figure>

<p>将复制框架的路径添加到 <code>Output Files</code>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(BUILT_PRODUCTS_DIR)/$(FRAMEWORKS_FOLDER_PATH)/Alamofire.framework</span><br></pre></td></tr></table></figure>

<p>为什么需要指定 <code>Output Files</code>。</p>
<p>使用 Carthage 来管理第三方库，在编译并运行 App 的时候，会有一个阶段叫：<code>Carthage Copy Frameworks</code>。这个阶段通过跑一个脚本的形式把所有依赖的第三方库都复制到 App 的目录里。</p>
<p>这个阶段通常会花 1~x 秒不等，这取决于你的 App 依赖的第三方库数量。默认情况下，每次你 <code>Build &amp; Run</code> 的时候，都会进行一次这个操作——尽管你的第三方库没有任何改变。</p>
<p>所以我们需要指定 <code>Output Files</code>，在 <code>Output Files</code> 指定输出文件的情况下，Xcode 只会在 <code>framework</code> 发生更改时去进行 <code>copy framework</code> 操作，这样就节省了时间。</p>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Carthage</tag>
      </tags>
  </entry>
  <entry>
    <title>XPC 详解</title>
    <url>/2021/11/03/20211103-XPC%20%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="监听者-Listener-，连接-Connection-和导出对象-Exported-Object"><a href="#监听者-Listener-，连接-Connection-和导出对象-Exported-Object" class="headerlink" title="监听者 (Listener)，连接 (Connection) 和导出对象 (Exported Object)"></a>监听者 (Listener)，连接 (Connection) 和导出对象 (Exported Object)</h2><p>在 App 端，我们有一个 connection 对象。每次将数据发给 service 时，我们需要调用  <code>remoteObjectProxyWithErrorHandler</code>  方法来创建一个远程对象代理 (remote object proxy)。</p>
<p>而在service端，则多了一层。首先需要一个 listener，用来监听来自 App 的传入 connection。App 可以创建多个 connection，listener 会在 service 端建立相应的 connection 对象。每个 connection 对象都有唯一的 exported object，在 App 端，通过 remote object proxy 发送的消息就是给它的。</p>
<span id="more"></span>

<p>当 App 创建一个到 XPC service 的 connection 时，是 XPC 在管理这个 service 的生命周期，service 的启动与停止都由 XPC runtime 完成，这对 App 来说是透明的。而且如果 service 因为某种原因 crash 了，也会透明地被重启。</p>
<p>App 初始化 XPC connection 的时候，XPC service 并不会启动，直到 App 实际发送的第一条消息到 remote object proxy 时才启动。如果当前没有未结束的响应，系统可能会因为内存压力或者 XPC service 已经闲置了一段时间而停止这个 service。这种情况下，App 持有的 connection 对象任然有效，下次再使用这个 connection 对象的时候，XPC 系统会自动重启对应的 XPC service。</p>
<p>如果 XPC service crash 了，它也会被透明地重启，并且其对应的 connection 也会一直有效。但是如果 XPC service 是在接收消息时 crash 了的话，App 需用重新发送该消息才能接受到对应的响应。这就是为什么要调用  <code>remoteObjectProxyWithErrorHandler</code>  方法来设置错误处理函数了。</p>
<p>这个方法接受一个闭包作为参数，在发生错误的时候被执行。XPC API 保证在错误处理里的闭包或者是消息响应里的闭包之中，只有一个会被执行；如果消息消息响应里的闭包被执行了，那么错误处理的就不会被执行，反之亦然。这样就使得资源清理变得容易了。</p>
<h2 id="中断-Interruption-和失效-Invalidation"><a href="#中断-Interruption-和失效-Invalidation" class="headerlink" title="中断 (Interruption) 和失效 (Invalidation)"></a>中断 (Interruption) 和失效 (Invalidation)</h2><p>XPC 的最常见的用法是 App 发消息给它的 XPC service。XPC 允许非常灵活的设置。我们通过下文会了解到，connection 是双向的，它可以是匿名监听者 (anonymous listeners)。如果另一端消失了（因为 crash 或者是正常的进程终止），这时连接将很有可能变得无效。我们可以给 connection 对象设置失效处理函数，如果 XPC runtime 无法重新创建这个 connection，我们的失效处理函数将会被执行。</p>
<p>我们还可以给 connection 设置中断处理程序，会在 connection 被中断的时候会执行，尽管此时 connection 仍然是有效的。</p>
<p>在  <code>NSXPCConnection中</code>  对应的两个属性是：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> interruptionHandler: (() -&gt; <span class="type">Void</span>)<span class="operator">?</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"><span class="keyword">var</span> invalidationHandler: (() -&gt; <span class="type">Void</span>)<span class="operator">?</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="双向连接-Bidirectional-Connections"><a href="#双向连接-Bidirectional-Connections" class="headerlink" title="双向连接 (Bidirectional Connections)"></a>双向连接 (Bidirectional Connections)</h2><p>一个经常被忽略而又有意思的事实是：connection 是双向的。但是只能通过 App 创建到 service 的初始连接。service 不能主动创建到 App 的连接。一旦连接已经建好了，两端都可以发起请求。</p>
<p>正如 service 端给 connection 对象设置了  <code>exportedObject</code> ，App 端也可以这么做。这样可以让 service 端通过   <code>remoteObjectProxy</code>  来和 App 的 <code>exported object</code> 进行通信了。值得注意是，XPC service 由系统管理其生命周期，如果没有未完成的请求，可能会被停止掉。</p>
<h2 id="服务查找-Service-Lookup"><a href="#服务查找-Service-Lookup" class="headerlink" title="服务查找 (Service Lookup)"></a>服务查找 (Service Lookup)</h2><p>当我们连接到 XPC service 的时候，我们需要找到连接的另一端。对于使用私有 XPC service 的 App，XPC 会在 App 的 bundle 范围内通过名字查找。还有其他的方法来连接到 XPC，让我们来看看所有的可能性。</p>
<h3 id="XPC-Service"><a href="#XPC-Service" class="headerlink" title="XPC Service"></a>XPC Service</h3><p>假如 App 使用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSXPCConnection</span>(serviceName: <span class="string">&quot;io.objc.myapp.myservice&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>XPC 会在 App 自己的命名空间 (namespace) 查找名为  <code>io.objc.myapp.myservice</code>  的service，这样的 service 仅对当前 App 有效，其他 App 无法连接。XPC service bundle 要么是位于 App 的 bundle 里，要么是在该 App 使用的 Framework 的 bundle 里。</p>
<h3 id="Mach-Service"><a href="#Mach-Service" class="headerlink" title="Mach Service"></a>Mach Service</h3><p>另一个选择是使用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSXPCConnection</span>(machServiceName: <span class="string">&quot;io.objc.mymachservice&quot;</span>, options: <span class="type">NSXPCConnectionOptions</span>(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>

<p>这会在当前用户的登录会话 (login session) 中查找名为  <code>io.objc.mymachservice</code>  的service。 我们可以在  <code>/Library/LaunchAgents</code>  或  <code>~/Library/LaunchAgents</code>  目录下安装 launch agent，这些 launch agent 也以与 App 里的 XPC service 几乎相同的方式来提供 service。由于 launch agent 会在 per-login session 中启动的，在同一个登录会话中运行的多个 App 可以和同一个 launch agent 进行通信。</p>
<p>这种方法很有用，例如 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvbWFjL2RvY3VtZW50YXRpb24vQ29jb2EvQ29uY2VwdHVhbC9TdGF0dXNCYXIvU3RhdHVzQmFyLmh0bWwjLy9hcHBsZV9yZWYvZG9jL3VpZC8xMDAwMDA3M2k=">状态栏 (Status Bar)<i class="fa fa-external-link-alt"></i></span>  中的 menu extra 程序（即右上角只有菜单项的 App）需要和 UI App 进行通信的时候。普通 App 和 menu extra 程序都可以和同一个 launch agent 进行通信并交互数据。当你需要让两个以上的进程需要相互通信，XPC 可以是一个非常优雅的方案。</p>
<p>假设我们要写一个天气类的 App，我们可以把天气数据的抓取和解析做成 launch agent 方式的 XPC service。我们可以分别创建 menu extra 程序，普通 App，以及通知中心的 Widget 来显示同样的天气数据。它们都可以通过  <code>NSXPCConnection</code>  和同一个 launch agent 进行通信。</p>
<p>与 XPC service 相同，launch agent 的生命周期也可以完全由 XPC 掌控：按需启动，闲置或者系统内存不足的时候停止。</p>
<h3 id="匿名监听者-Anonymous-Listeners-和端点-Endpoints"><a href="#匿名监听者-Anonymous-Listeners-和端点-Endpoints" class="headerlink" title="匿名监听者 (Anonymous Listeners) 和端点 (Endpoints)"></a>匿名监听者 (Anonymous Listeners) 和端点 (Endpoints)</h3><p>XPC 有通过 connection 来传递被称为  <code>listener endpoints</code>  的能力。这个概念一开始会让人非常费解，但是它可以带来更大的灵活性。</p>
<p>比如说我们有两个 App，我们希望它们能够过 XPC 来互相通信，每个 App 都不知道其他 App 的存在，但它们都知道相同的一个（共享）launch agent。</p>
<p>这两个 App 可以先连接到 launch agent。App A 创建一个被称为  <strong>匿名监听者 (anonymous listener)</strong>  的对象，并通过 XPC 发送一个 <strong>端点 (endpoint)</strong> ，并由匿名监听者创建的对象给 launch agent。App B 可以通过 XPC 在同样的 launch agent 中拿到这个 endpoint。这时，App B 就可以直接连接到这个匿名监听者，即 App A。</p>
<p>在 App A 创建一个 anonymous listener：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> listener <span class="operator">=</span> <span class="type">NSXPCListener</span>.anonymousListener()</span><br></pre></td></tr></table></figure>

<p>类似于 XPC service 创建普通的 listener。然后从这个 listener 创建一个 endpoint：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> endpoint <span class="operator">=</span> listener.endpoint</span><br></pre></td></tr></table></figure>

<p>这个 endpoint 可以通过 XPC 来传递（实现了  <code>NSSecureCoding</code>  协议 ）。一旦 App B 获取到这个 endpoint，它可以创建到 App A 的 listener 的一个 connection：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> connection <span class="operator">=</span> <span class="type">NSXPCConnection</span>(listenerEndpoint: endpoint)</span><br></pre></td></tr></table></figure>

<h3 id="Privileged-Mach-Service"><a href="#Privileged-Mach-Service" class="headerlink" title="Privileged Mach Service"></a>Privileged Mach Service</h3><p>最后一个选择是使用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSXPCConnection</span>(machServiceName: <span class="string">&quot;io.objc.mymachservice&quot;</span>, options: .<span class="type">Privileged</span>)</span><br></pre></td></tr></table></figure>

<p>这种方式和 launch agent 非常类似，不同的是创建了到 launch daemon 的 connection。launch agent 进程是 per user 的，它们以用户的身份运行在用户的登录会话 (login session) 中。守护进程 (Daemon) 则是 per machine 的，即使当前多个用户登录，一个 XPC daemon 也只有一个实例运行。</p>
<p>如果要运行 daemon 的话，有很多安全相关的问题需要考虑。虽然以 root 权限运行 daemon 是可能的，但是最好是不要这么这么做。我们可能更希望它以一些独特的用户身份来运行。具体可以参考  <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvbWFjL3RlY2hub3Rlcy90bjIwODMvX2luZGV4Lmh0bWw=">TN2083 - Designing Secure Helpers and Daemons<i class="fa fa-external-link-alt"></i></span> 。大多数情况，我们并不需要 root 权限。</p>
<h2 id="NSXPC-架构"><a href="#NSXPC-架构" class="headerlink" title="NSXPC 架构"></a>NSXPC 架构</h2><p><img src="/my_pictures/20211103/1.png"></p>
<h2 id="NSXPC连接过程"><a href="#NSXPC连接过程" class="headerlink" title="NSXPC连接过程"></a>NSXPC连接过程</h2><p><img src="/my_pictures/20211103/2.png"></p>
]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>设计守护进程和服务</title>
    <url>/2021/12/17/20211217-%E8%AE%BE%E8%AE%A1%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%92%8C%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="后台进程类型"><a href="#后台进程类型" class="headerlink" title="后台进程类型"></a>后台进程类型</h2><p>在 macOS 中有四种类型的后台进程。不同之处在下表中进行了总结，并在下面的小节中进行了详细描述。要选择适当类型的后台进程，请考虑以下事项：</p>
<ul>
<li>它是针对当前登录的用户还是针对所有用户执行某些操作。</li>
<li>它是由单个应用程序使用还是由多个应用程序使用。</li>
<li>它是否需要显示用户界面或启动GUI应用程序。</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>由 launchd 管理？</th>
<th>在哪种环境下运行</th>
<th>可以显示 UI 吗</th>
</tr>
</thead>
<tbody><tr>
<td>Login item</td>
<td>否</td>
<td>用户</td>
<td>是</td>
</tr>
<tr>
<td>XPC service</td>
<td>是</td>
<td>用户</td>
<td>否（除非以非常有限的方式使用IOSurface）</td>
</tr>
<tr>
<td>Launch Daemon</td>
<td>是</td>
<td>系统</td>
<td>否</td>
</tr>
<tr>
<td>Launch Agent</td>
<td>是</td>
<td>用户</td>
<td>不建议</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="Login-items"><a href="#Login-items" class="headerlink" title="Login items"></a>Login items</h2><p>登录项在用户登录时启动，并继续运行，直到用户注销或手动退出。它们的主要用途是允许用户自动打开常用的应用程序，但也可以由应用程序开发人员使用。例如，登录项可用于额外显示菜单或注册全局热键。</p>
<p>例如，许多待办事项应用程序使用登录项来侦听全局热键，并提供允许用户输入新任务的最小 UI。登录项还通常用于显示用户界面项，例如浮动时钟或计时器，或者用于在菜单栏中显示图标。</p>
<p>另一个示例是带有作为登录启动项的助手应用程序的日历应用程序。助手应用程序在后台运行，并在适当的时候启动主GUI应用程序，以提醒用户即将到来的事件。</p>
<p>login items 有两种添加方式：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2RvY3VtZW50YXRpb24vc2VydmljZW1hbmFnZW1lbnQ=">Service Management<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2RvY3VtZW50YXRpb24vY29yZXNlcnZpY2VzL2xhdW5jaF9zZXJ2aWNlcw==">Launch Services<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>使用 Service Management 安装的登录项目在系统首选项中不可见，只能由安装它们的应用程序删除。</p>
<p>使用共享文件列表安装的登录项目在系统首选项中可见；用户可以直接控制它们。如果您使用此API，则用户可以禁用您的登录项，因此在禁用登录项的情况下，与其通信的任何其他应用程序都应该具有合理的后备行为。</p>
<h3 id="使用-Service-Management-添加登录项"><a href="#使用-Service-Management-添加登录项" class="headerlink" title="使用 Service Management 添加登录项"></a>使用 Service Management 添加登录项</h3><p>应用程序可以包含一个助手应用程序作为完整的应用程序包，存储在 <code>Contents/Library/LoginItems</code> 目录下的主应用程序包中。在帮助器应用程序捆绑包的 <code>Info.plist</code> 文件中设置 <code>LSUIElement</code> 或 <code>LSBackround Only</code> 键。</p>
<p>使用 <code>SMLoginItemSetEnabled</code> 函数（在OSXv10.6.6和更高版本中提供）启用助手应用程序。它有两个参数，一个是包含助手应用程序的捆绑包标识符的 <code>CFStringRef</code> ，另一个是指定所需状态的布尔值。传递 <code>true</code> 可立即启动帮助器应用程序，并指示每次用户登录时都应启动该应用程序。传递 <code>false</code> 以终止帮助器应用程序，并指示在用户登录时不应再启动该应用程序。如果请求的更改已生效，则此函数返回 <code>TRUE</code> ；否则返回 <code>FALSE</code> 。此函数可用于管理任意数量的助手应用程序。</p>
<h3 id="使用-Launch-Services-添加登录项"><a href="#使用-Launch-Services-添加登录项" class="headerlink" title="使用 Launch Services 添加登录项"></a>使用 Launch Services 添加登录项</h3><p>此方法在OSXv10.5及更高版本中可用。有关具体详细信息，请参阅 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2RvY3VtZW50YXRpb24vY29yZXNlcnZpY2VzL2xhdW5jaF9zZXJ2aWNlcw==">Launch Services Reference<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="XPC-Services"><a href="#XPC-Services" class="headerlink" title="XPC Services"></a>XPC Services</h2><p>XPC 服务由 Launchd 管理，并向单个应用程序提供服务。它们通常用于将应用程序划分为更小的部分。这可用于通过限制进程崩溃时的影响来提高可靠性，并通过限制进程受损时的影响来提高安全性。</p>
<p>对于传统的单可执行应用程序，如果应用程序的任何部分崩溃，整个应用程序都会终止。通过将应用程序重组为主进程和服务，服务崩溃的影响明显较小。用户可以继续工作；崩溃的服务将重新启动。例如，电子邮件应用程序可以使用 XPC 服务来处理与邮件服务器的通信。即使服务崩溃，暂时中断了与服务器的通信，应用程序的剩余部分仍可用。</p>
<p>沙箱允许指定程序在正常操作期间预期要做的事情。操作系统会强制执行该事件列表，从而限制攻击者可能造成的破坏。例如，文本编辑器可能需要编辑磁盘上已由用户打开的文件，但它可能不需要打开其他位置的任意文件或通过网络进行通信。</p>
<p>您可以将沙箱与 XPC 服务相结合，通过将复杂的应用程序、工具或守护进程拆分成具有定义良好的功能的较小部分来提供权限分离。由于降低了每个单独部分的权限，任何缺陷都不太容易被攻击者利用：没有一个部分以用户的全部功能运行。例如，组织和编辑照片的应用程序通常不需要网络访问。然而，如果它还允许用户将照片上传到照片共享网站，则可以将该功能实现为具有网络访问和对文件系统的中介访问(或无访问)的 XPC 服务。</p>
<h2 id="Launch-Daemons"><a href="#Launch-Daemons" class="headerlink" title="Launch Daemons"></a>Launch Daemons</h2><p>守护程序由 <code>launchd</code> 在系统上下文中代表操作系统进行管理，这意味着它们不知道登录到系统的用户。守护进程不能直接启动与用户进程的联系；它只能响应用户进程发出的请求。因为它们不了解用户，所以守护程序也无法访问 window server，因此无法发布可视界面或启动 GUI 应用程序。守护进程严格意义上是响应低级别请求的后台进程。</p>
<p>大多数守护进程在系统的系统上下文中运行，也即是说，它们在系统的最低级别运行，并使其服务对所有用户会话可用。即使没有用户登录到系统，此级别的守护进程也会继续运行，因此守护进程程序应该不会直接了解用户。相反，守护进程必须等待用户程序与其联系并发出请求。作为该请求的一部分，用户程序通常告诉守护进程如何返回任何结果。</p>
<h2 id="Launch-Agents"><a href="#Launch-Agents" class="headerlink" title="Launch Agents"></a>Launch Agents</h2><p>代理由 <code>launchd</code> 管理，但代表当前登录的用户(即，在用户上下文中)运行。代理可以与同一用户会话中的其他进程通信，也可以与系统上下文中的系统范围后台进程通信。它们可以显示可视界面，但不推荐这样做。</p>
<p>如果您的代码同时提供特定于用户和独立于用户的服务，则可能需要同时创建守护进程和代理。您的守护进程将在系统上下文中运行，并提供独立于用户的服务，而代理的实例将在每个用户会话中运行。代理将与守护进程协调，为每个用户提供服务。</p>
]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>长截图功能所遇到的问题以及解决方式</title>
    <url>/2022/07/04/20220704-%E9%95%BF%E6%88%AA%E5%9B%BE%E5%8A%9F%E8%83%BD%E6%89%80%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="截图清晰度"><a href="#截图清晰度" class="headerlink" title="截图清晰度"></a>截图清晰度</h2><h3 id="截图处理"><a href="#截图处理" class="headerlink" title="截图处理"></a>截图处理</h3><p>由于笔记截图需要缩放以适应预览视图，所以截图时会出现不清晰的问题。故我们需要用笔记截图的原数据进行渲染绘制。</p>
<p>我们将预览视图分为四大块儿进行处理，分别为，header，note，footer，user info，因为 header 和 footer 只有在设置主题的情况下才可能存在，所以需要将 header，footer 和 user info 分别处理。如下图：</p>
<img src="/my_pictures/20220704/1.png" style="zoom: 33%;" />

<span id="more"></span>

<p>预览视图分区示意</p>
<p>我们将分别截取 header，footer，user info。note 的截图直接使用 <code>pdfDataAndForcePDFAttachments(toRender: Bool)</code> 生成的 <code>image</code> 数据即可，这样可以保持图片的最高清晰度。</p>
<p>我们对 note 截图进行放大两倍绘制，这样就能非常高清。视网膜屏幕截图的像素宽高默认为图片 size 的两倍。我们这里没有使用 <code>lockFocus()</code> 和 <code>unlockFocus()</code> 方法，是因为这个方法的绘制与当前显示器有关，如果显示器设备不是视网膜屏那么绘制出来的图像则并不清晰。所以我们调用 <code>NSBitmapImageRep</code> 手动创建图像的 <code>bitmap</code> 数据，然后使用 <code>NSGraphicsContext</code> 相关方法进行最终图片的 <code>bitmap</code> 数据生成。</p>
<p>对 header，footer 和 user info 三块儿的截图我们需要将其等比放大到与 note 截图等宽大小，相当于这三块儿内容也进行了放大两倍处理，这样最终效果就会非常清晰。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 对 View 进行截图</span></span><br><span class="line"><span class="comment">/// - Parameter scale: 缩放比例</span></span><br><span class="line"><span class="comment">/// - Returns: 截图</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">screenShot</span>(<span class="params">scale</span>: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">1</span>) -&gt; <span class="type">NSImage</span>? &#123;</span><br><span class="line">  <span class="comment">// scale 为 0 无意义</span></span><br><span class="line">  <span class="keyword">guard</span> scale <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">  <span class="keyword">let</span> targetSize <span class="operator">=</span> <span class="type">NSSize</span>(width: bounds.width <span class="operator">*</span> scale, height: bounds.height <span class="operator">*</span> scale)</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> bitmapRep <span class="operator">=</span> <span class="type">NSBitmapImageRep</span>(bitmapDataPlanes: <span class="literal">nil</span>,</span><br><span class="line">                                         pixelsWide: <span class="type">Int</span>(targetSize.width),</span><br><span class="line">                                         pixelsHigh: <span class="type">Int</span>(targetSize.height),</span><br><span class="line">                                         bitsPerSample: <span class="number">8</span>,</span><br><span class="line">                                         samplesPerPixel: <span class="number">4</span>,</span><br><span class="line">                                         hasAlpha: <span class="literal">true</span>,</span><br><span class="line">                                         isPlanar: <span class="literal">false</span>,</span><br><span class="line">                                         colorSpaceName: .calibratedRGB,</span><br><span class="line">                                         bytesPerRow: <span class="number">0</span>,</span><br><span class="line">                                         bitsPerPixel: <span class="number">0</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">  <span class="type">NSGraphicsContext</span>.saveGraphicsState()</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> graphicsContext <span class="operator">=</span> <span class="type">NSGraphicsContext</span>(bitmapImageRep: bitmapRep) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">  <span class="type">NSGraphicsContext</span>.current <span class="operator">=</span> graphicsContext</span><br><span class="line">  graphicsContext.cgContext.scaleBy(x: scale, y: scale)</span><br><span class="line">  <span class="keyword">self</span>.displayIgnoringOpacity(bounds, in: graphicsContext)</span><br><span class="line">  <span class="type">NSGraphicsContext</span>.restoreGraphicsState()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> result <span class="operator">=</span> <span class="type">NSImage</span>(size: bitmapRep.size)</span><br><span class="line">  result.addRepresentation(bitmapRep)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主题处理"><a href="#主题处理" class="headerlink" title="主题处理"></a>主题处理</h3><p>当我们设置主题时，最终效果会有一个背景色的添加。此时我们需要对 note 截图 image 数据进行处理，为其添加相应的背景色，代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 为图像添加背景色</span></span><br><span class="line"><span class="comment">/// - Parameters:</span></span><br><span class="line"><span class="comment">///   - color: 背景色</span></span><br><span class="line"><span class="comment">///   - img: 图像</span></span><br><span class="line"><span class="comment">///   - size: 图像最终大小</span></span><br><span class="line"><span class="keyword">convenience</span> <span class="keyword">init</span>(<span class="params">color</span>: <span class="type">NSColor</span>, <span class="params">img</span>: <span class="type">NSImage</span>, <span class="params">size</span>: <span class="type">NSSize</span>) &#123;</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> bitmapRep <span class="operator">=</span> <span class="type">NSBitmapImageRep</span>(bitmapDataPlanes: <span class="literal">nil</span>,</span><br><span class="line">                                         pixelsWide: <span class="type">Int</span>(size.width),</span><br><span class="line">                                         pixelsHigh: <span class="type">Int</span>(size.height),</span><br><span class="line">                                         bitsPerSample: <span class="number">8</span>,</span><br><span class="line">                                         samplesPerPixel: <span class="number">4</span>,</span><br><span class="line">                                         hasAlpha: <span class="literal">true</span>,</span><br><span class="line">                                         isPlanar: <span class="literal">false</span>,</span><br><span class="line">                                         colorSpaceName: .calibratedRGB,</span><br><span class="line">                                         bytesPerRow: <span class="number">0</span>,</span><br><span class="line">                                         bitsPerPixel: <span class="number">0</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(size: size)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">NSGraphicsContext</span>.saveGraphicsState()</span><br><span class="line">  <span class="type">NSGraphicsContext</span>.current <span class="operator">=</span> <span class="type">NSGraphicsContext</span>(bitmapImageRep: bitmapRep)</span><br><span class="line">  </span><br><span class="line">  color.drawSwatch(in: <span class="type">NSRect</span>(origin: .zero, size: size))</span><br><span class="line">  img.draw(in: <span class="type">NSRect</span>(origin: .zero, size: size), from: .zero, operation: .sourceOver, fraction: <span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="type">NSGraphicsContext</span>.restoreGraphicsState()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">self</span>.<span class="keyword">init</span>(size: size)</span><br><span class="line">  <span class="keyword">self</span>.addRepresentation(bitmapRep)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="水印处理"><a href="#水印处理" class="headerlink" title="水印处理"></a>水印处理</h3><p>当我们设置了水印时，我们先将水印进行截图。然后绘制到最终的效果图上，绘制的 <code>operation</code> 参数一定要是 <code>.sourceOver</code> 类型，如果用 <code>.copy</code> 将会覆盖住最终截图，就好像水印背景并非透明一般。</p>
<p>最终代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 长截图</span></span><br><span class="line"><span class="comment">/// - Returns: 长截图 bitmap 数据</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">screenshot</span>() -&gt; <span class="type">NSBitmapImageRep</span>? &#123;</span><br><span class="line">  <span class="comment">// 主题背景色，默认白色</span></span><br><span class="line">  <span class="keyword">var</span> color <span class="operator">=</span> <span class="type">NSColor</span>.white</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> bgImage <span class="operator">=</span> theme<span class="operator">?</span>.bgImage &#123;</span><br><span class="line">    color <span class="operator">=</span> <span class="type">NSColor</span>(patternImage: bgImage)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 笔记截图</span></span><br><span class="line">  <span class="keyword">let</span> noteSize <span class="operator">=</span> <span class="type">NSSize</span>(width: noteScreenshot.size.width <span class="operator">*</span> <span class="number">2.0</span>, height: noteScreenshot.size.height <span class="operator">*</span> <span class="number">2.0</span>)</span><br><span class="line">  <span class="keyword">let</span> noteImage <span class="operator">=</span> <span class="type">NSImage</span>(color: color,</span><br><span class="line">                          img: noteScreenshot,</span><br><span class="line">                          size: noteSize)</span><br><span class="line">  <span class="comment">// 等比缩放</span></span><br><span class="line">  <span class="keyword">let</span> scale <span class="operator">=</span> noteSize.width <span class="operator">/</span> bounds.width</span><br><span class="line">  <span class="comment">// 主题头部截图</span></span><br><span class="line">  <span class="keyword">var</span> headerImage: <span class="type">NSImage</span>?</span><br><span class="line">  <span class="keyword">if</span> headerHeight <span class="operator">&gt;</span> <span class="number">0</span>, <span class="keyword">let</span> image <span class="operator">=</span> headerView.screenShot(scale: scale) &#123;</span><br><span class="line">    headerImage <span class="operator">=</span> <span class="type">NSImage</span>(color: color, img: image, size: image.size)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 主题页脚截图</span></span><br><span class="line">  <span class="keyword">var</span> footerImage: <span class="type">NSImage</span>?</span><br><span class="line">  <span class="keyword">if</span> footerHeight <span class="operator">&gt;</span> <span class="number">0</span>, <span class="keyword">let</span> image <span class="operator">=</span> footerView.screenShot(scale: scale) &#123;</span><br><span class="line">    footerImage <span class="operator">=</span> <span class="type">NSImage</span>(color: color, img: image, size: image.size)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 用户信息组件截图</span></span><br><span class="line">  <span class="keyword">var</span> userInfoImage: <span class="type">NSImage</span>?</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> image <span class="operator">=</span> userInfoShowView.screenShot(scale: scale) &#123;</span><br><span class="line">    userInfoImage <span class="operator">=</span> <span class="type">NSImage</span>(color: color, img: image, size: image.size)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 水印截图，水印无需添加背景色</span></span><br><span class="line">  <span class="keyword">let</span> watermarkImage <span class="operator">=</span> watermarkView<span class="operator">?</span>.screenShot(scale: scale)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 截图的最终宽度</span></span><br><span class="line">  <span class="keyword">let</span> width <span class="operator">=</span> noteImage.size.width</span><br><span class="line">  <span class="keyword">let</span> headerHeight <span class="operator">=</span> headerImage<span class="operator">?</span>.size.height <span class="operator">??</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> footerHeight <span class="operator">=</span> footerImage<span class="operator">?</span>.size.height <span class="operator">??</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> userInfoHeight <span class="operator">=</span> userInfoImage<span class="operator">?</span>.size.height <span class="operator">??</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> noteHeight <span class="operator">=</span> noteImage.size.height</span><br><span class="line">  <span class="comment">// 截图最终高度</span></span><br><span class="line">  <span class="keyword">let</span> height <span class="operator">=</span> headerHeight <span class="operator">+</span> noteHeight <span class="operator">+</span> footerHeight <span class="operator">+</span> userInfoHeight</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> targetSize <span class="operator">=</span> <span class="type">NSSize</span>(width: width, height: height)</span><br><span class="line">  <span class="comment">// 图像绘制</span></span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> bitmapRep <span class="operator">=</span> <span class="type">NSBitmapImageRep</span>(bitmapDataPlanes: <span class="literal">nil</span>,</span><br><span class="line">                                         pixelsWide: <span class="type">Int</span>(targetSize.width),</span><br><span class="line">                                         pixelsHigh: <span class="type">Int</span>(targetSize.height),</span><br><span class="line">                                         bitsPerSample: <span class="number">8</span>,</span><br><span class="line">                                         samplesPerPixel: <span class="number">4</span>,</span><br><span class="line">                                         hasAlpha: <span class="literal">true</span>,</span><br><span class="line">                                         isPlanar: <span class="literal">false</span>,</span><br><span class="line">                                         colorSpaceName: .calibratedRGB,</span><br><span class="line">                                         bytesPerRow: <span class="number">0</span>,</span><br><span class="line">                                         bitsPerPixel: <span class="number">0</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">  <span class="type">NSGraphicsContext</span>.saveGraphicsState()</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> context <span class="operator">=</span> <span class="type">NSGraphicsContext</span>(bitmapImageRep: bitmapRep) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">  <span class="type">NSGraphicsContext</span>.current <span class="operator">=</span> context</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> userInfoImage <span class="operator">=</span> userInfoImage &#123;</span><br><span class="line">    <span class="keyword">let</span> userInfoRect <span class="operator">=</span> <span class="type">NSRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: width, height: userInfoHeight)</span><br><span class="line">    userInfoImage.draw(in: userInfoRect, from: .zero, operation: .copy, fraction: <span class="number">1.0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> footerImage <span class="operator">=</span> footerImage &#123;</span><br><span class="line">    <span class="keyword">let</span> footerRect <span class="operator">=</span> <span class="type">NSRect</span>(x: <span class="number">0</span>, y: userInfoHeight, width: width, height: footerHeight)</span><br><span class="line">    footerImage.draw(in: footerRect, from: .zero, operation: .copy, fraction: <span class="number">1.0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> noteRect <span class="operator">=</span> <span class="type">NSRect</span>(x: <span class="number">0</span>, y: userInfoHeight <span class="operator">+</span> footerHeight, width: width, height: noteHeight)</span><br><span class="line">  noteImage.draw(in: noteRect, from: .zero, operation: .copy, fraction: <span class="number">1.0</span>)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> headerImage <span class="operator">=</span> headerImage &#123;</span><br><span class="line">    <span class="keyword">let</span> headerRect <span class="operator">=</span> <span class="type">NSRect</span>(x: <span class="number">0</span>, y: userInfoHeight <span class="operator">+</span> noteHeight <span class="operator">+</span> footerHeight, width: width, height: headerHeight)</span><br><span class="line">    headerImage.draw(in: headerRect, from: .zero, operation: .copy, fraction: <span class="number">1.0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> watermarkImage <span class="operator">=</span> watermarkImage &#123;</span><br><span class="line">    <span class="keyword">let</span> watermarkRect <span class="operator">=</span> <span class="type">NSRect</span>(origin: .zero, size: targetSize)</span><br><span class="line">    watermarkImage.draw(in: watermarkRect, from: .zero, operation: .sourceOver, fraction: <span class="number">1.0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="type">NSGraphicsContext</span>.restoreGraphicsState()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> bitmapRep</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="矩形水印旋转后的间距计算"><a href="#矩形水印旋转后的间距计算" class="headerlink" title="矩形水印旋转后的间距计算"></a>矩形水印旋转后的间距计算</h2><p>设计师所给的水印旋转效果如下图：</p>
<p><img src="/my_pictures/20220704/2.png"></p>
<p>由于圆形无论怎么旋转，间距是不会变的，所以我们这里可以忽略对圆形水印的间距重计算。矩形旋转之后，对矩形四个顶点做一个外切矩形，外切矩形的宽高是有相应的变化，所以我们需要重新计算矩形的间距。</p>
<p>假设我们以矩形的对角线交点为圆心，画一个外切圆，矩形无论怎么绕着中心点旋转，四个顶点一定在这个外切圆上，并且对角线长度即为这个外切圆的直径（d），从而我们可得外切圆的半径（r）。圆的中心我们作为平面直角坐标系的中心点（0,0），那么我们可以知道矩形四个顶点的坐标。由四个顶点的坐标我们可以算出 d 和 r。根据相应的余弦定理和圆上坐标公式可得旋转后图形的顶点坐标，从而可以计算出旋转之后矩形。然后我们就计算出相应的间距即可。几何坐标表示如下：</p>
<p><img src="/my_pictures/20220704/3.png"></p>
<p>图中 ABCD 灰色区域是起始位置，A’B’C’D’ 是逆时针旋转 15° 之后的我们展示水印的位置，灰色的圆为以对角线交点 E 为圆心，对角线长为直径的圆，红色的 FGHI 为旋转 15° 后的外切矩形，也即需要我们计算出宽高的矩形。</p>
<p>首先我们可得 ABCD 四个点的坐标，我们利用 D(xd, yd)，B(xb, yb) 两点间距离公式可计算出圆的直径 d，进而可得圆的半径 r。两点间距离公式如下：</p>
<p>我们的最终目标是求出 B‘ 的 y 坐标和 C’ 的 x 坐标，y * 2 即为红色矩形的高，x * 2 即为红色矩形的宽。</p>
<p>因为 B’ 和 C‘ 都在外切圆上，所以利用外切圆的坐标公式即可求出两点坐标，圆上点的坐标公式如下：</p>
<p>圆心 E 的坐标(x0,y0)、半径为r、角度为 angle。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x1 = x0 + r * cos(angle * PI / 180)</span><br><span class="line">y1 = y0 + r * sin(angle * PI / 180)</span><br></pre></td></tr></table></figure>

<p>由公式可知，要想算出 B’ 和 C‘ 坐标，我们需要知道角度 angle。角度的起始位置（0°）为 EJ，所以我们需要计算的角度为 ∠B’EJ（以下称为 α） 和 ∠JEC‘（以下称为 β）。</p>
<h3 id="α-的角度计算"><a href="#α-的角度计算" class="headerlink" title="α 的角度计算"></a>α 的角度计算</h3><p>通过图我们可知，α 的大小为等腰三角形 △BEC 两腰的夹角 ∠BEC（以下称为 γ） 的一半再加上 15°。也即 ∠B‘EB + ∠BEJ。两腰的夹角我们可以通过余弦定理算出。余弦定理公式如下：</p>
<p><img src="/my_pictures/20220704/4.png"></p>
<p><img src="/my_pictures/20220704/5.png"></p>
<p>假设等腰三角形的角为 γ 此时我们可以计算出 cos弧度 的值（macOS 中的旋转是以弧度为单位）。然后我们利用弧度与角度换算公式可知：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">弧度与角度换算公式：1° = π / 180</span><br><span class="line">cos弧度 = cos(γ * PI / 180)</span><br></pre></td></tr></table></figure>

<p>故，具体的角度我们可以用反三角函数 acos 算出。计算方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">γ = acos(cos弧度) / (.pi / 180)</span><br></pre></td></tr></table></figure>

<p>旋转角度知道后就可以计算出 B’ 的 y 坐标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y = r * sin((γ / 2 + rotationAngle) * .pi / 180)</span><br></pre></td></tr></table></figure>

<p>所以红色矩形的高为 2 * y。</p>
<h3 id="β-的角度计算"><a href="#β-的角度计算" class="headerlink" title="β 的角度计算"></a>β 的角度计算</h3><p>C‘ 我们可以看成是 J 顺时针旋转一定的角度得到。则 β 为等腰三角形 △BEC 两腰的夹角 ∠BEC 减去 15° 得到。等腰三角形的夹角 γ 我们已算出，所以 C’ 的 x 坐标我们也很容易得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">β = -(γ / 2 - rotationAngle) // 顺时针为负数</span><br><span class="line">x = r * cos(β * .pi / 180)</span><br></pre></td></tr></table></figure>

<p>所以红色矩形的宽为：2 * x</p>
<p>完整计算代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 返回旋转后水印组件外切矩形的大小</span></span><br><span class="line"><span class="comment">/// - Parameters:</span></span><br><span class="line"><span class="comment">///   - watermarkSize: 水印组件大小</span></span><br><span class="line"><span class="comment">///   - rotationAngle: 旋转角度</span></span><br><span class="line"><span class="comment">/// - Returns: 旋转后外切矩形大小</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">getReal</span>(<span class="params">size</span> <span class="params">watermarkSize</span>: <span class="type">CGSize</span>, <span class="params">angle</span> <span class="params">rotationAngle</span>: <span class="type">CGFloat</span>) -&gt; <span class="type">CGSize</span> &#123;</span><br><span class="line">  <span class="comment">// 矩形旋转后行间距偏移量</span></span><br><span class="line">  <span class="keyword">var</span> realSize <span class="operator">=</span> <span class="type">CGSize</span>.zero</span><br><span class="line">  <span class="comment">// 判断是否是矩形</span></span><br><span class="line">  <span class="keyword">if</span> watermarkSize.width <span class="operator">!=</span> watermarkSize.height &#123;</span><br><span class="line">    <span class="comment">// 我们以矩形外切圆的圆心（即矩形对角线的交点）为平面直角坐标系的原点，则圆心的坐标为 (0, 0)</span></span><br><span class="line">    <span class="comment">// 矩形右上角点的坐标（第一象限）</span></span><br><span class="line">    <span class="keyword">let</span> rightTop <span class="operator">=</span> <span class="type">CGPoint</span>(x: watermarkSize.width <span class="operator">/</span> <span class="number">2</span>, y: watermarkSize.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 矩形左下角点的坐标（第三象限）</span></span><br><span class="line">    <span class="keyword">let</span> leftBottom <span class="operator">=</span> <span class="type">CGPoint</span>(x: <span class="operator">-</span>watermarkSize.width <span class="operator">/</span> <span class="number">2</span>, y: <span class="operator">-</span>watermarkSize.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 半径</span></span><br><span class="line">    <span class="comment">// 两点间距离公式 sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2))</span></span><br><span class="line">    <span class="keyword">let</span> r <span class="operator">=</span> sqrt(pow(rightTop.x <span class="operator">-</span> leftBottom.x, <span class="number">2</span>) <span class="operator">+</span> pow(rightTop.y <span class="operator">-</span> leftBottom.y, <span class="number">2</span>)) <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">    <span class="comment">// 余弦定理求等腰三角形两腰的夹角的 cos 值</span></span><br><span class="line">    <span class="comment">// 这里两腰的长为外切圆半径 r，两腰夹角的对边为矩形的高</span></span><br><span class="line">    <span class="comment">// 故 cos 值为：(pow(r, 2) + pow(r, 2) - pow(height, 2)) / (2 * r * r)</span></span><br><span class="line">    <span class="keyword">let</span> cosRadians <span class="operator">=</span> (pow(r, <span class="number">2</span>) <span class="operator">*</span> <span class="number">2</span> <span class="operator">-</span> pow(watermarkSize.height, <span class="number">2</span>)) <span class="operator">/</span> (<span class="number">2</span> <span class="operator">*</span> r <span class="operator">*</span> r)</span><br><span class="line">    <span class="comment">// 反三角函数求出弧度 angle * PI / 180 的值，则进一步可以求出两腰夹角的角度</span></span><br><span class="line">    <span class="keyword">let</span> angle <span class="operator">=</span> acos(cosRadians) <span class="operator">/</span> (.pi <span class="operator">/</span> <span class="number">180</span>)</span><br><span class="line">    <span class="comment">// 圆上任意一点坐标计算公式，（x0， y0）为圆心坐标</span></span><br><span class="line">    <span class="comment">// x1 = x0 + r * cos(angle * PI / 180)</span></span><br><span class="line">    <span class="comment">// y1 = y0 + r * sin(angle * PI / 180)</span></span><br><span class="line">    <span class="comment">// 右上角点在坐标系中的夹角为：两腰夹角 / 2 + 旋转角度</span></span><br><span class="line">    <span class="comment">// 则右上角的点旋转后位于矩形外切圆的 y 坐标如下</span></span><br><span class="line">    <span class="keyword">let</span> rightTopY <span class="operator">=</span> r <span class="operator">*</span> sin((angle <span class="operator">/</span> <span class="number">2</span> <span class="operator">+</span> rotationAngle) <span class="operator">*</span> .pi <span class="operator">/</span> <span class="number">180</span>)</span><br><span class="line">    <span class="comment">// 旋转后四个点组成的新矩形高为：rightTopY * 2</span></span><br><span class="line">    <span class="keyword">let</span> newHeight <span class="operator">=</span> rightTopY <span class="operator">*</span> <span class="number">2</span></span><br><span class="line">    <span class="comment">// 右下角的旋转角度，我们按顺时针旋转来看，则为负数</span></span><br><span class="line">    <span class="keyword">let</span> rightBottomRotateAngle <span class="operator">=</span> <span class="operator">-</span>(angle <span class="operator">/</span> <span class="number">2</span> <span class="operator">-</span> rotationAngle)</span><br><span class="line">    <span class="comment">// 圆上任意一点坐标计算公式计算右下角点的 x 坐标</span></span><br><span class="line">    <span class="keyword">let</span> rightBottomX <span class="operator">=</span> r <span class="operator">*</span> cos(rightBottomRotateAngle <span class="operator">*</span> .pi <span class="operator">/</span> <span class="number">180</span>)</span><br><span class="line">    <span class="comment">// 同理得旋转后的矩形长为 rightBottomX * 2</span></span><br><span class="line">    <span class="keyword">let</span> newWidth <span class="operator">=</span> rightBottomX <span class="operator">*</span> <span class="number">2</span></span><br><span class="line">    realSize <span class="operator">=</span> <span class="type">CGSize</span>(width: newWidth, height: newHeight)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    realSize <span class="operator">=</span> watermarkSize</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> realSize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>如何成为一名优秀的技术经理</title>
    <url>/2023/02/21/20230221-%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E4%BC%98%E7%A7%80%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BB%8F%E7%90%86/</url>
    <content><![CDATA[<p>我们都知道有的程序员能创造 10 倍的价值，那么我们是吗？</p>
<p>根据 20 世纪 60 年代进行的一份研究，对开发人员的各种方面（如代码简单性、程序大小、调试技巧、程序执行等）进行了比较。根据这项研究，普遍的共识是，一个优秀的开发人员和一个差劲的开发人员之间的差异可以达到20 倍之多，而中间值在大多数情况下是 10 倍。</p>
<p>这就是说，假设你已经苦干了多年，吸收了所有可能的技术，最终达到了令人垂涎的 10 倍高级开发人员级别。太棒了，恭喜！你应该得到名望和随之而来的尊重。现在你想攀登下一座山：成为一名优秀的技术经理。想想就觉得很美。</p>
<p>等等，让我们花点时间想想。</p>
<span id="more"></span>

<p><strong>首先：技术经理到底是谁，与传统项目经理的角色有什么区别？</strong></p>
<p>简单地说，技术经理的职责是计划、安排和管理与 <code>IT</code> 相关的项目，例如支持软件工程、应用程序开发、网络安全等的项目，虽然技术经理的主要管理技能与非技术性的基本管理技能基本类似，但强制性的技术专长（当然还有人际交往技能）才是真正的区别于传统管理者的角色。</p>
<p>所以，这意味着你需要对自己诚实，首先要知道是什么驱使着你。是写代码吗？是设计软件吗？或者，是让团队完成工作，帮助团队在最后期限完成工作？解决冲突，管理挑剔的利益相关者？</p>
<p>以上问题的答案应该在很大程度上决定你未来的行动方向。例如，在我的案例中，我以一个热衷于编写代码的开发人员的身份开始工作，在适当的时候，我发现我有管理人员、解决他们的问题以及从他们身上获得最好结果的诀窍。对我来说，成为一名技术经理是一个显而易见的选择。</p>
<p>一旦你确信技术领导的道路对你是正确的，那么你还有一些工作要做。你需要提高自己，培养自己的所有特质，使自己成为一名成功的技术经理。</p>
<p>以下是一些你需要集中注意力的关键特征。</p>
<h3 id="学会授权"><a href="#学会授权" class="headerlink" title="学会授权"></a><strong>学会授权</strong></h3><p>一个好的技术经理的重要特点是有责任心。</p>
<p>作为一个开发人员，解决疑难问题会给你带来乐趣。对于开发人员来说，没有什么比找到解决一个长期悬而未决的问题的最简单的解决方案，并愿意为重构那些非常糟糕、错误的代码而受到赞誉更令人兴奋的了。</p>
<p>但现在作为一名技术经理，规则已经改变了。当你有很多其他的事情要做的时候，你就没有足够的精力来处理这些有趣的问题。你不能错过其他的会议活动，因为它们对你来说是最重要的。同样，通过解决最难解决的问题，你剥夺了其他开发人员发展和发展技能的机会。简言之，你创造了一个瓶颈，从长远来看对任何人都没有帮助。</p>
<p>当然，当你的经验和知识很重要的时候，也会有一些问题，但是在这里你需要扮演一个灯塔的角色，引导船只（RD 开发者）找到海岸。您可以坐下来和开发人员一起检查解决方案，并让他们走上正确的道路，以便他们能够制定自己的解决方案。</p>
<p>这里的关键是信任。你需要信任开发人员，少参与，委派一个活动，这样你就能把注意力集中在最重要的事情上。</p>
<h3 id="同理心"><a href="#同理心" class="headerlink" title="同理心"></a><strong>同理心</strong></h3><p>作为一名开发人员，您可以从纯编程的角度查看任何解决方案。所以这意味着你只需要关注“如何”而不是“为什么”。所以你可以专注于提供高科技的技术解决方案，把业务影响留给“管理层”去解决。</p>
<p>现在你不能这么做，因为你是“管理层”。这意味着您现在必须根据需要考虑业务现实、人的因素、组织文化、约束和财务。对您来说，现在一个可行的解决方案应该是一个在业务方面能够实现其目标的解决方案，并且应该远远不止是一个强大的技术解决方案。</p>
<p>新的技术经理常常犯错误，用技术术语而不是业务术语解释他们的计划。这会挫败业务方，导致缺乏他们的支持。所以作为一名技术经理，你需要做的最重要的事情就是用业务理解的语言重新定义想法。有些方法是可以的。</p>
<ul>
<li>无论你觉得知识多么简陋，都不要妄想它。在开会前，分发一份技术术语和首字母缩略词的简化表格总是一个好主意。</li>
<li>用故事、隐喻、例子和案例研究来吸引听众，用外行的话来说明你的想法。</li>
<li>别胡闹了。尽可能简明扼要地解释这些想法，使之不利于技术。</li>
</ul>
<p>记住这里的关键词是同理心，一种有效领导的关键技能。技术经理应该试图了解他们的业务同事的问题，并作为业务领导者而不是技术专家来陈述他们的案例，以获得有效的参与。</p>
<h3 id="建立你的人际网络并赢得信任"><a href="#建立你的人际网络并赢得信任" class="headerlink" title="建立你的人际网络并赢得信任"></a><strong>建立你的人际网络并赢得信任</strong></h3><p>当你是一个开发者的时候，你可以做一个独狼，做你自己的事情。是的，独立工作是开发人员所期望的品质。但当你成为一名技术经理时，你需要建立你的人际网络并获得信任。</p>
<p>“人际网络”这个词让大多数技术极客感到恐惧。但是，建立一个由志同道合的同事组成的人际网络并不意味着你需要外向，或者拥有杰出的社交技能。相反，建立人际网络的最好方法就是做你自己。在建立关系时，建立信任是必不可少的，而真诚和直截了当是最好的方法之一。</p>
<p>建立信任和建立关系的最简单方法可以是帮助其他团队处理紧急情况。这样你就开始欠他们“人情”，你可以在适当的时候毫不犹豫地问他们。自愿帮助别人发挥他们的主动性，或尽可能多地帮助别人完成他们的工作，这不仅能培养你的专业技能，而且还能在组织内建立你的影响力。这种影响是帮助你进入“完成任务”模式的秘诀。</p>
<p>当你开始在公司内部建立人家网络时，你很快就会发现事情发生得更快，因为他们了解你，信任你，你甚至能够完成看似无法完成的任务，而这些任务可能是你无法控制的。</p>
<h3 id="最后，找时间编码"><a href="#最后，找时间编码" class="headerlink" title="最后，找时间编码"></a><strong>最后，找时间编码</strong></h3><p>这个角色被称为技术经理是有原因的。你首先应该是一名工程师，有很强的软件工程背景和实践经验。如果你不花时间在代码上，你最终会成为一个“象牙塔架构师”，正如 <code>Scott Ambler</code> 在他关于“敏捷建模”的文章中恰当地定义的那样。</p>
<p>“象牙塔建筑通常由建筑师或建筑团队开发，与项目团队的日常开发活动相对独立。强大的建筑大师开始开发一个或多个模型来描述您团队中的仆从将要构建的架构，这是建筑师最清楚的。象牙塔建筑往往是美丽的东西，通常有很多精美的图表和美妙的视觉宣言，表明它们是你的救赎”。</p>
<p>这些技术经理既不会参加技术讨论，也不会在不了解其对实施或维护的实际影响的情况下领导讨论。这种反模式有灾难性的副作用，比如破坏与开发人员的信任，降低团队士气，增加新特性的开发时间，以及增加软件系统的复杂性。</p>
<p>因此，即使你成为了一名经理，你也应该始终保持你的技能足够敏锐，能够胜任并适应在编码和设计原则方面的领导和交谈。参与代码不仅有助于获得尊重，而且有助于使您的知识与当前的问题、可能的解决方案以及代码库的健康状况保持同步。</p>
<p>找到编写代码的时间的关键是确定活动的优先级。这也意味着要对你的时间花在哪里做出艰难的选择。但是一旦你在你的日历上划掉了专门的时间，你就可以放心，你的生活永远不会过时。生活就是学习。你学得越多，收获越多。</p>
<p>正如圣雄甘地所说的那样。</p>
<p>“活得像明天就要死一样。学习吧，就好像你要永远活着一样。”</p>
<ul>
<li>原文作者 : <span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzOi8vbGV2ZWx1cC5naXRjb25uZWN0ZWQuY29tL0Byc3JhamFuMT9zb3VyY2U9cG9zdF9wYWdlLS0tLS1iYzc5YWM0MTgzOTItLS0tLS0tLS0tLS0tLS0tLS0tLS0t">Ravi Shankar Rajan<i class="fa fa-external-link-alt"></i></span></li>
<li>原文链接 : <span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzOi8vbGV2ZWx1cC5naXRjb25uZWN0ZWQuY29tL2hvdy10by1iZS1hLXN1Y2Nlc3NmdWwtdGVjaC1tYW5hZ2VyLWJjNzlhYzQxODM5Mg==">How to be a Successful Tech Manager<i class="fa fa-external-link-alt"></i></span></li>
<li>译者 : <span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzOi8vZ2l0aHViLmNvbS9kZW5nc2hpd2Vp">邓士伟<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<blockquote>
<p>关于作者：<br>Ravi Rajan是印度孟买的全球IT项目经理。他还是一个狂热的博客作家，俳句诗歌作家，考古学爱好者，历史狂热者。在 <span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzOi8vaW4ubGlua2VkaW4uY29tL2luL3JhdmlzaGFua2FycmFqYW4=">LinkedIn<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzOi8vbWVkaXVtLmNvbS9AcnNyYWphbjE=">Medium<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly93d3cudHdpdHRlci5jb20vcnNyYWphbjE=">Twitter<i class="fa fa-external-link-alt"></i></span> 上与 Ravi 联系。</p>
</blockquote>
]]></content>
      <categories>
        <category>文章翻译</category>
      </categories>
      <tags>
        <tag>管理</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信简介</title>
    <url>/2022/01/24/20220124-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>在许多方面，苹果的故事都是一些有趣的历史偶然事件将技术融合在一起，创造出比以前更好的东西：OS X 是 MacOS 与 NeXTSTEP 的结合。OC 是 Smalltalk 类面向对象编程与 C 的结合。iCloud 则是苹果移动服务与云平台的结合。</p>
<p>虽然苹果技术栈的许多方面都是如此，但是不得不说苹果技术中的进程通讯走的是“反人类”的道路。</p>
<p>由于不是根据每个节点上最优原则进行设计，苹果的进程间通信解决方案更显得混乱扎堆。结果是，大量重叠，不兼容的 IPC 技术在各个抽象层随处可见。（除了 GCD 还有剪贴板）</p>
<ul>
<li>Mach Ports</li>
<li>Distributed Notifications</li>
<li>Distributed Objects</li>
<li>AppleEvents &amp; AppleScript</li>
<li>Pasteboard</li>
<li>XPC</li>
</ul>
<p>从低级内核抽象到高级，面向对象的 API，它们都有各自特殊的表现以及安全特性。但是基础层面来看，它们都是从不同上下文段传递或者获取数据的机制。</p>
<span id="more"></span>

<h2 id="Distributed-Objects"><a href="#Distributed-Objects" class="headerlink" title="Distributed Objects"></a>Distributed Objects</h2><p>90 年代中 NeXT 全盛时期，分发式对象（DO）是 Cocoa 框架中一个远程消息发送特性。尽管现在已经不再大范围的使用，在现代奇数层上 IPC 无障碍通信仍然并未实现。</p>
<p>使用 DO 分发一个对象仅仅是搭建一个 <code>NSConnection</code> 并将其注册为特殊（你分的清楚）的名字：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">Protocol</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">id</span> &lt;Protocol&gt; vendedObject;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSConnection</span> *connection = [[<span class="built_in">NSConnection</span> alloc] init];</span><br><span class="line">[connection setRootObject:vendedObject];</span><br><span class="line">[connection registerName:<span class="string">@&quot;server&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>另外一个应用将会也建立同样名字的并注册过的链接，然后立即获取一个原子代理当做原始对象。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">id</span> proxy = [<span class="built_in">NSConnection</span> rootProxyForConnectionWithRegisteredName:<span class="string">@&quot;server&quot;</span> host:<span class="literal">nil</span>];</span><br><span class="line">[proxy setProtocolForProxy:<span class="class"><span class="keyword">@protocol</span>(<span class="title">Protocol</span>)];</span></span><br></pre></td></tr></table></figure>

<p>只要分发对象代理收到消息了，一个通过 <code>NSConnection</code> 连接远程调用（RPC）将会根据发送对象进行对应的计算并且返回结果给代理。【注：原理是一个 OS 管理的共享的 <code>NSPortNameServer</code> 实例对这个带着名字的连接进行管控。】</p>
<p>分发式对象简单，透明，健壮。简直就是 Cocoa 中的标杆。</p>
<p>实际上，分布式对象不能像局部对象那样使用，那就是因为任何发送给代理的消息都可能抛出异常。不想其他语言，OC 没有异常处理控制流程。所以对任何东西都进行 <code>@try/@catch</code> 也算是 Cocoa 大会很凄凉的补救了。</p>
<p>DO 还有一个原因致其使用不便。在试图通过连接 “marshal values” 时，对象和原语的差距尤为明显。<br>此外，连接是完全加密的，和下方通信信道扩展性的缺乏致使其在大多数的使用中通信被迫中断。</p>
<p>下方是左列分布式对象用来指定其属性代理行为和方法参数的注解：</p>
<ul>
<li><strong>in</strong>：输入参数，后续不再引用</li>
<li><strong>out</strong>：参数被引用作为返回值</li>
<li><strong>inout</strong>：输入参数，引用作为返回值</li>
<li><strong>const</strong>：常量参数</li>
<li><strong>oneway</strong>：无障碍结果返回</li>
<li><strong>bycopy</strong>：返回对象的拷贝</li>
<li><strong>byref</strong>：返回对象的代理</li>
</ul>
<h2 id="XPC-通信技术"><a href="#XPC-通信技术" class="headerlink" title="XPC 通信技术"></a>XPC 通信技术</h2><p>XPC 是 SDK 中最先进的进程间通信技术。它的体系结构目标是避免长时间运行的流程，适应有限的资源，并尽可能延迟初始化。将 XPC 集成到应用程序的动机不是要做原本不可能做的事情，而是要为进程间通信提供更好的特权分离和故障隔离。<br>它是 NSTask 的替代品，甚至不仅仅是替代品。</p>
<p>XPC 负责进程间通信和服务生命周期管理。从注册服务、运行服务到与其他服务通信，所有事情都由 launchd 处理。XPC 服务可以按需启动，或者在崩溃时重新启动，或者在空闲时终止。因此，服务应该设计为完全无状态，以便允许在任何执行点突然终止。</p>
<p>作为 iOS 采用并移植到 OS X 的新安全模型的一部分，默认情况下，XPC 服务在最严格的环境中运行：没有文件系统访问权限，没有网络访问权限，也没有 root 权限提升。任何功能都必须通过一组权利将其列入白名单。</p>
<p><em>权限问题是一大坑点😤</em></p>
<p>可以通过 <code>libxpc C API</code> 或 <code>NSXPCConnection Objective-C API</code> 访问 XPC。</p>
<p>XPC 服务要么驻留在应用程序包中，要么使用 <code>launchd</code> 命令让其在后台运行。</p>
<p>开启后台进程有多种方式：</p>
<ul>
<li>Login Items</li>
<li>XPC Service</li>
<li>Launch Agent</li>
<li>Launch Daemons</li>
</ul>
]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2023/02/23/20230223-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>如下，输入一个数组和一个目标变量：</p>
<p>input: [1, 3, 1, 3, 2, 2, 5, -1]</p>
<p>input: 4</p>
<p>要求找到此数组中所有两数之和等于目标变量的元素集合并返回，并且结果中不能有重复项。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>遍历数组，将当前元素以及其与目标变量的差值存放入字典中，如果字典中已存在，则将其放入结果集中。遍历完成之后，利用<code>Set </code>集合去重，最后返回。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">twoSum</span>(<span class="keyword">_</span> <span class="params">array</span>: [<span class="type">Int</span>], <span class="keyword">_</span> <span class="params">target</span>: <span class="type">Int</span>) -&gt; [[<span class="type">Int</span>]] &#123;</span><br><span class="line">  <span class="keyword">var</span> dict <span class="operator">=</span> [<span class="type">Int</span>: <span class="type">Int</span>]()</span><br><span class="line">  <span class="keyword">var</span> result <span class="operator">=</span> [[<span class="type">Int</span>]]()</span><br><span class="line">  <span class="keyword">for</span> item <span class="keyword">in</span> array &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> num <span class="operator">=</span> dict[item] &#123;</span><br><span class="line">      result.append([num, item])</span><br><span class="line">    &#125;</span><br><span class="line">    dict[target <span class="operator">-</span> item] <span class="operator">=</span> item</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> resultSet: <span class="type">Set</span>&lt;<span class="type">Int</span>&gt; <span class="operator">=</span> []</span><br><span class="line">  <span class="keyword">for</span> (idx, item) <span class="keyword">in</span> result.enumerated() &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="operator">!</span>resultSet.insert(item[<span class="number">0</span>]).inserted <span class="operator">&amp;&amp;</span> <span class="operator">!</span>resultSet.insert(item[<span class="number">1</span>]).inserted &#123;</span><br><span class="line">      result.remove(at: idx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言重拾【一】编程机制</title>
    <url>/2023/03/02/20230302-C%20%E8%AF%AD%E8%A8%80%E9%87%8D%E6%8B%BE%E3%80%90%E4%B8%80%E3%80%91/</url>
    <content><![CDATA[<h2 id="目标代码文件、可执行文件和库"><a href="#目标代码文件、可执行文件和库" class="headerlink" title="目标代码文件、可执行文件和库"></a>目标代码文件、可执行文件和库</h2><p>C 编程的基本策略是，用程序把源代码文件转换为可执行文件（其中包含可直接运行的机器语言代码）。</p>
<p>典型的 C 实现通过编译和链接两个步骤来完成这一过程。编译器把源代码转换成中间代码，链接器把中间代码和其他代码合并，生成可执行文件。C 使用这种分而治之的方法方便对程序进行模块化，可以独立编译单独的模块，稍后再用链接器合并已编译的模块。通过这种方式，如果只更改某个模块，不必因此重新编译其他模块。另外，链接器还将你编写的程序和预编译的库代码合并。</p>
<p>中间文件有多种形式。我们在这里描述的是最普遍的一种形式，即把源代码转专换为机器语言代码，并把结果放在目标代码文件（或简称目标文件）中（这里假设源代码只有一个文件）。虽然目标文件中包含机器语言代码，但是并不能直接运行该文件。因为目标文件中储存的是编译器翻译的源代码，这还不是一个完整的程序。</p>
<p>目标代码文件缺失启动代码（startup code）。启动代码充当着程序和操作系统之间的接口。例如，可以在 <code>MS Windows</code> 或 <code>Linux</code> 系统下运行 1BM PC 兼容机。这两种情况所使用的硬件相同，所以目标代码相同，但是 <code>Windows</code> 和 <code>Linux</code> 所需的启动代码不同，因为这些系统处理程序的方式不同。</p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;Concrete contains gravel and cement. \n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// concrete.c</span></span><br></pre></td></tr></table></figure>

<p>目标代码还缺少库函数。几乎所有的 C 程序都要使用 C 标准库中的两数。例如，<code>concrete.c</code> 中就使用了 <code>printf()</code> 函数。目标代码文件并不包含该函数的代码，它只包含了使用 <code>printf()</code> 函数的指令。<code>printf()</code> 函数真正的代码储存在另一个被称为库的文件中。库文件中有许多函数的目标代码。</p>
<p>链接器的作用是，把你编写的目标代码、系统的标准启动代码和库代码这 3 部分合并成一个文件，即可执行文件。对于库代码，链接器只会把程序中要用到的库函数代码提取出来。（如下图）</p>
<img src="/my_pictures/20230302/1.png" style="zoom: 50%;" />

<p>简而言之，目标文件和可执行文件都由机器语言指令组成的。然而，目标文件中只包含编译器为你编写的代码翻译的机器语言代码，可执行文件中还包含你编写的程序中使用的库函数和启动代码的机器代码。</p>
<p>在有些系统中，必须分别运行编译程序和链接程序，而在另一些系统中，编译器会自动启动链接器，用户只需给出编译命令即可。</p>
<h2 id="GNU-编译器集合和-LLVM-项目"><a href="#GNU-编译器集合和-LLVM-项目" class="headerlink" title="GNU 编译器集合和 LLVM 项目"></a>GNU 编译器集合和 LLVM 项目</h2><p>GNU 项目始于 1987 年，是一个开发大量免费 UNIX 软件的集合（GNU 的意思是 “GNU’s Not UNIX”,即 GNU 不是 UNIX)。GNU 编译器集合（也被称为GCC，其中包含GCC C编译器）是该项目的产品之一。GCC 在一个指导委员会的带领下，持续不断地开发，它的 C 编译器紧跟 C 标准的改动。GCC 有各种版本以适应不同的硬件平台和操作系统，包括 UNIX、Linux 和 Windows。用 gcc 命令便可调用 GCC C编译器。许多使用 gcc 的系统都用cc 作为gec的别名。</p>
<p>LLVM 项目成为 cc 的另一个替代品。该项目是与编译器相关的开源软件集合，始于伊利诺伊大学的 2000 份研究项目。它的 Clang 编译器处理 C 代码，可以通过 Clang 调用。有多种版本供不同的平台使用，包括 Linux。 2012年，Clang 成为 FreeBSD 的默认 C 编译器。Clang 也对最新的 C 标准支持得很好。</p>
<p>GNU 和 LLVM 都可以使用 -v 选项来显示版本信息，因此各系统都使用 cc 别名来代替 gcc 或 clang 命令。以下组合：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cc -v</span><br></pre></td></tr></table></figure>

<p>显示你所使用的编译器及其版本。</p>
<p>gcc 和 clang 命令都可以根据不同的版本选样运行时选项来调用不同 C 标准。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -std=c99 inform.c </span><br><span class="line">gcc -std=c1x inform.c </span><br><span class="line">gcc -std=c11 inform.c</span><br></pre></td></tr></table></figure>

<p>第 1 行调用 C99 标准，第 2 行调用 GCC 接受 C11 之前的草案标准，第 3 行调用 GCC 接受的 C11 标准版本。Clang 编译器在这一点上用法与 GCC 相同。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>C Primer Plus</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言重拾【二】字符串</title>
    <url>/2023/03/06/20230306-C%20%E8%AF%AD%E8%A8%80%E9%87%8D%E6%8B%BE%E3%80%90%E4%BA%8C%E3%80%91/</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">// 提供strlen()函数的原型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DENSITY 62.4 <span class="comment">// 人体密度（单位：磅/立方英尺）</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">float</span> weight, volume;</span><br><span class="line">  <span class="type">int</span> size, letters;</span><br><span class="line">  <span class="type">char</span> name [<span class="number">40</span>]; <span class="comment">// name 是一个可容纳40个宇符的数组</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hi! What&#x27;s your first name?\n&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s, what&#x27;s your weight in pounds?\n&quot;</span>, name);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;weight);</span><br><span class="line">  size = <span class="keyword">sizeof</span> name;</span><br><span class="line">  letters = <span class="built_in">strlen</span>(name);</span><br><span class="line">  volume = weight / DENSITY;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Well, %s, your volume is %2.2f cubic feet. \n&quot;</span>, name, volume);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Also, your first name has %d letters, \n&quot;</span>, letters);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;and we have %d bytes to store it. \n&quot;</span>, size);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>运行程序，输入结果如下：</p>
<blockquote>
<p>Hi! What’s your first name?<br>Christine<br>Christine, what’s your weight in pounds?<br>154<br>Well, Christine, your volume is 2.47 cubic feet.<br>Also, your first name has 9 letters, and we have 40 bytes to store it.</p>
</blockquote>
<p>该程序包含以 下新特性。</p>
<ul>
<li>﻿用数组（array）储存宇符串（character string）。在该程序中，用户输入的名被储存在数组中，该数组占用内存中 40 个连续的字节，每个字节储存一个字符值。</li>
<li>﻿使用名 <code>%s</code> 转换说明来处理字符串的输入和输出。注意，在 <code>scanf()</code> 中，name 没有 <code>&amp;</code> 前缀，而 <code>weight</code><br> 有（稍后解释，<code>&amp;weight</code> 和 <code>name</code> 都是地址）。</li>
<li>﻿用 C 预处理器把字符常量 <code>DENSITY</code> 定义为 62.4。</li>
<li>﻿用 C 函数 <code>strlen()</code> 获取字符串的长度。</li>
</ul>
<h2 id="char-类型数组和-null-字符"><a href="#char-类型数组和-null-字符" class="headerlink" title="char 类型数组和 null 字符"></a>char 类型数组和 null 字符</h2><p>C 语言没有专门用于储存字符串的变量类型，字符串都被储存在 <code>char</code> 类型的数组中。<strong>数组由连续的存储单元组成</strong>，字符串中的宇符被储存在相邻的存储单元中，每个单元储存一个字符，如下图：</p>
<img src="/my_pictures/20230306/1.png" alt="1" style="zoom: 67%;" />

<p>注意上图中数组末尾位置的字符 <code>\0</code>。这是空字符（null character），C 语言用它标记字符串的结束。</p>
<p>空字符不是数字 0，它是非打印字符，其 ASCII 码值是（或等价于）0。C 中的字符串一定以空字符结束，这意味着数组的容量必须至少比待存储字符串中的字符数多 1。因此，程序清单中有 40 个存储单元的字符串，只能储存 39 个字符，剩下一个字节留给空字符。</p>
<p>那么，什么是数组？可以把数组看作是一行连续的多个存储单元。用更正式的说法是，数组是同类型数据元素的有序序列。程序清单通过以下声明创建了一个包含 40 个存储单元（或元素）的数组，每个单元储存一个 <code>char</code> 类型的值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> name [<span class="number">40</span>];</span><br></pre></td></tr></table></figure>

<p><code>name</code> 后面的方括号表明这是一个数组，方括号中的 40 表明该数组中的元素数量。char 表明每个元素的类型，见下图。</p>
<img src="/my_pictures/20230306/2.png" alt="2" style="zoom:50%;" />

<p>字符串看上去比较复杂！必须先创建一个数组，把字符串中的字符逐个放入数组，还要记得在末尾加上一个 <code>\0</code>。还好，计算机可以自己处理这些细节。</p>
<h2 id="字符串和字符"><a href="#字符串和字符" class="headerlink" title="字符串和字符"></a>字符串和字符</h2><p>字符串常量 <code>&quot;x&quot;</code> 和字符常量 <code>&#39;x&#39;</code> 不同。区别之一在于，<code>&#39;x&#39;</code> 是基本类型（char），而 <code>&quot;x&quot;</code> 是派生类型（char数组）；区别之二是 <code>&quot;x&quot;</code> 实际上由两个字符组成：<code>&#39;x&#39;</code> 和空字符 <code>\0</code>，见下图：</p>
<img src="/my_pictures/20230306/3.png" alt="3" style="zoom: 67%;" />

<h2 id="strlen-和-sizeof"><a href="#strlen-和-sizeof" class="headerlink" title="strlen() 和 sizeof"></a>strlen() 和 sizeof</h2><p><code>sizeof</code> 运算符报告，<code>name</code> 数组有 40 个存储单元。但是，只有前 11 个单元用来储存 <code>serendipity</code>，所以 <code>strlen()</code> 得出的结果是 11。 <code>name</code> 数组的第 12个单元储存空字符，<code>strlen()</code> 并未将其计入。下图演示了这个概念。</p>
<img src="/my_pictures/20230306/4.png" alt="4" style="zoom: 67%;" />

<p>对于 PRAISE，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PRAISE <span class="string">&quot;You are an extraordinary being.&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>用 <code>strlen()</code> 得出的也是字符串中的字符数（包括空格和标点符号）。然而，<code>sizeof</code> 运算符给出的数更大，因为它把字符串末尾不可见的空字符也计算在内。该程序并末明确告诉计算机要给字符串预留多少空间，所以它必须计算双引号内的字符数。</p>
<p>另外，还要注意一点：上一章的 <code>sizeof</code> 使用了圆括号，但本例没有。圆括号的使用时机否取决于运算对象是类型还是特定量？运算对象是类型时，圆括号必不可少，但是对于特定量，可有可无。也就是说，对于类型，应写成 <code>sizeof(char)</code> 或 <code>sizeof (float)</code>；对于特定量，可写成 <code>sizeof name</code> 或 <code>sizeof 6.28</code>。尽管如此，还是建议所有情况 下都使用圆括号，如 <code>sizeof(6.28)</code>。</p>
<h2 id="常量和-C-预处理器"><a href="#常量和-C-预处理器" class="headerlink" title="常量和 C 预处理器"></a>常量和 C 预处理器</h2><h3 id="define"><a href="#define" class="headerlink" title="#define"></a>#define</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TAXRATE 0.015</span></span><br></pre></td></tr></table></figure>

<p>编译程序时，程序中所有的 <code>TAXRATE</code> 都会被替换成 0.015。 这一过程被称为编译时替换（compile-timesubstitution）。在运行程序时，程序中所有的替换均己完成（见下图）。通常，这样定义的常量也称为<code>明示常量(manifest constant)</code>。</p>
<p>请注意格式，首先是 <code>#define</code>，接着是符号常量名（TAXRATE），然后是符号常量的值（0.015）（注意，其中并没有 <code>=</code> 符号）。所以，其通用格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NANE value</span></span><br></pre></td></tr></table></figure>

<p>实际应用时，用选定的符号常量名和合适的值来替换 <code>NAME</code> 和 <code>value</code>。注意，末尾不用加分号，因为这是一种由预处理器处理的替换机制。为什么 <code>TAXRATE</code> 要用大写？用大写表示符号常量是 C 语言一贯的传统。这样，在程序中看到全大写的名称就立刻明白这是一个符号常量，而非变量。大写常量只是为了提高程序的可读性，即使全用小写来表示符号常量，程序也能照常运行。尽管如此，初学者还是应该养成大写常量的好习惯。</p>
<p>另外，还有一个不常用的命名约定，即在名称前带 <code>c_</code> 或 <code>k_</code> 前缀来表示常量（如，<code>c_level</code> 或 <code>k_line</code>）。</p>
<p>符号常量的命名规则与变量相同。可以使用大小写字母、数字和下划线宇符，首字符不能为数字。</p>
<img src="/my_pictures/20230306/5.png" alt="5" style="zoom: 50%;" />

<h3 id="const-限定符"><a href="#const-限定符" class="headerlink" title="const 限定符"></a>const 限定符</h3><p>C90 标准新增了 <code>const</code> 关键字，用于限定一个变量为只读。其声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MONTHS = <span class="number">12</span>; <span class="comment">// MONTHIS 在程序中不可更政，值为 12</span></span><br></pre></td></tr></table></figure>

<p>这使得 <code>MONTHS</code> 成为一个只读值。也就是说，可以在计算中使用 <code>MONTHS</code>，可以打印 <code>MONTHS</code>，但是不能更改 <code>MONTHS</code> 的值。<code>const</code> 用起来比 <code>#define</code> 更灵活。（详细内容将在接下来的博客中推出。）</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>C Primer Plus</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言重拾【三】新的 _Bool 类型</title>
    <url>/2023/03/07/20230307-C%20%E8%AF%AD%E8%A8%80%E9%87%8D%E6%8B%BE%E3%80%90%E4%B8%89%E3%80%91/</url>
    <content><![CDATA[<p>在 C 语言中，一直用 <code>int</code> 类型的变量表示 <code>真/假</code> 值。C99 专门针对这种类型的变量新增了 <code>_Bool</code> 类型。该类型是以英国数学家 George Boole 的名字命名的，他开发了用代数表示逻辑和解决逻辑问题。在编程中，表示真或假的变量被称为布尔变量（Boolean variable），所以日 <code>_Bool</code> 是 C 语言中布尔变量的类型名。<code>_Bool</code> 类型的变量只能储存 <code>1（真）</code>或 <code>0（假）</code>。如果把其他非零数值赋给 <code>_Bool</code> 类型的变量，该变量会被设置为 <code>1</code>。这反映了 C 把所有的<strong>非零值都视为真</strong>。</p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// boolean.c 一一 使用 _Bool 类型的变量 variable</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">long</span> num;</span><br><span class="line">  <span class="type">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">  <span class="type">_Bool</span> input_is_good;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;Please enter an integer to be summed &quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot; (q to quit): &quot;</span>);</span><br><span class="line">  input_is_good = (<span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;num) == <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (input_is_good) &#123;</span><br><span class="line">    sum = sum + num;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;Please enter next integer (q to quit): &quot;</span>);</span><br><span class="line">    input_is_good = (<span class="built_in">scanf</span> (<span class="string">&quot;%ld&quot;</span>, &amp;num) == <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;Those integers sum to %ld. \n&quot;</span>, sum);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意程序中把比较的结果赋值给 <code>_Bool</code> 类型的变量 <code>input_is_good</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">input_is_good = (<span class="built_in">scanf</span> (<span class="string">&quot;%ld&quot;</span>, &amp;num) == <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>这样做没问题，因为 <code>==</code> 运算符返回的值不是 1 就是 0。顺带一提，从优先级方面考虑的话，并不需要用圆括号把 <code>scanf(&quot;%ld&quot;, &amp;num) == 1</code> 括起来。但是，这样做可以提高代码可读性。还要注意，如何为变量命名才能让 <code>while</code> 循环的测试简单易懂：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (input_is_good)</span><br></pre></td></tr></table></figure>

<p>C99 提供了 <code>stdbool.h</code> 头文件，该头文件让 <code>bool</code> 成为 <code>_Bool</code> 的别名，而且还把 <code>true</code> 和 <code>false</code> 分别定义为 1 和 0 的符号常量。包含该头文件后，写出的代码可以与 C++ 兼容，因为 C++ 把 <code>bool</code>、<code>true</code> 和 <code>false</code> 定义为关键字。</p>
<p>如果系统不支持 <code>_Bool</code> 类型，导致无法运行该程序，可以把 <code>_Bool</code> 替换成 <code>int</code> 即可。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>C Primer Plus</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言重拾【四】ctype.h 系列的字符函数</title>
    <url>/2023/03/08/20230308-C%20%E8%AF%AD%E8%A8%80%E9%87%8D%E6%8B%BE%E3%80%90%E5%9B%9B%E3%80%91/</url>
    <content><![CDATA[<p>C 有一系列专门处理字符的函数，<code>ctype.h</code> 头文件包含了这些函数的原型。这些函数接受一个字符作为参数，如果该字符属于某特殊的类别，就返回一个非零值（真）；否则，返回口（假）。例如，如果 <code>isalpha()</code> 函数的参数是一个字母，则返回一个非零值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cypher2.c -- 替换输入的字母，非字母字符保持不变</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span> <span class="comment">// 包含isalpha（）的函数原型</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line">  <span class="keyword">while</span> ((ch = getchar()) != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isalpha</span>(ch))    <span class="comment">// 如果是一个宇字符，</span></span><br><span class="line">      <span class="built_in">putchar</span>(ch + <span class="number">1</span>);  <span class="comment">// 显示该字符的下一个字符</span></span><br><span class="line">    <span class="keyword">else</span>                <span class="comment">// 否则，</span></span><br><span class="line">      <span class="built_in">putchar</span>(ch);      <span class="comment">// 原样显示</span></span><br><span class="line">  &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(ch);        <span class="comment">// 显示换行符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>下面是该程序的一个输出示例，注意大小写字母都被替换了，除了空格和标点符号：</p>
<blockquote>
<p>Look! It’s a programmer!</p>
<p>Mppl! Ju’t b qsphsbnnfs!</p>
</blockquote>
<p>下列两表列出了 <code>ctype.h</code> 头文件中的一些函数。有些函数涉及本地化，指的是为适应特定区域的使用习惯修改或扩展 C 基本用法的工具（例如，许多国家在书写小数点时，用逗号代替点号，于是特殊的本地化可以指定 C 编译器使用逗号以相同的方式输出浮点数，这样 123.45 可以显示为 123,45)。注意，字符映射函数不会修改原始的参数，这些函数只会返回己修改的值。也就是说，下面的语句不改变 <code>ch</code> 的值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tolower</span>(ch);	<span class="comment">// 不影响 ch 的值</span></span><br></pre></td></tr></table></figure>

<p>这样做才会改变 <code>ch</code> 的值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ch = <span class="built_in">tolower</span>(ch);	<span class="comment">//把 ch 转换成小写字母</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>函数名</th>
<th>如果是下列参数时，返回值为真</th>
</tr>
</thead>
<tbody><tr>
<td>isalnum()</td>
<td>字母数字（字母或数字）</td>
</tr>
<tr>
<td>isalpha()</td>
<td>字母</td>
</tr>
<tr>
<td>isblank()</td>
<td>标准空白字符（空格、水平制表符或换行符）或任何其他本地化指定为空白的字符</td>
</tr>
<tr>
<td>iscntrl()</td>
<td>控制字符，如 Ctrl+B</td>
</tr>
<tr>
<td>isdigit()</td>
<td>数字</td>
</tr>
<tr>
<td>isgraph()</td>
<td>除空格之外的任意可打印字符</td>
</tr>
<tr>
<td>islower()</td>
<td>小写字母</td>
</tr>
<tr>
<td>isprint()</td>
<td>可打印字符</td>
</tr>
<tr>
<td>ispunct()</td>
<td>标点符号（除空格或字母数字字符以外的任何可打印字符）</td>
</tr>
<tr>
<td>isspace()</td>
<td>空白字符（空格、换行符、换页符、回车符、垂直制表符、水平制表符或其他本地化定义的字符）</td>
</tr>
<tr>
<td>isupper()</td>
<td>大写字母</td>
</tr>
<tr>
<td>isxdigit()</td>
<td>十六进制数字符</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>函数名</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>tolower()</td>
<td>如果参数是大写字符，该函数返回小写字符；否则，返回原始参数</td>
</tr>
<tr>
<td>toupper()</td>
<td>如果参数是小写字符，该函数返回大写字符；否则，返回原始参数</td>
</tr>
</tbody></table>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>C Primer Plus</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言重拾【五】指针</title>
    <url>/2023/03/09/20230309-C%20%E8%AF%AD%E8%A8%80%E9%87%8D%E6%8B%BE%E3%80%90%E4%BA%94%E3%80%91/</url>
    <content><![CDATA[<h2 id="指针简介"><a href="#指针简介" class="headerlink" title="指针简介"></a>指针简介</h2><p>指针？什么是指针？从根本上看，指针（pointer）是一个值为内存地址的变量（或数据对象）。正如<code>char</code>类型变量的值是字符，<code>int</code>类型变量的值是整数，指针变量的值是地址。在 C 语言中，指针有许多用法。本章将介绍如何把指针作为函数参数使用，以及为何要这样用。</p>
<p>假设一个指针变量名是<code>ptr</code>，可以编写如下语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ptr = &amp;pooh; <span class="comment">// 把 pooh 的地址赋给 ptr</span></span><br></pre></td></tr></table></figure>

<p>对于这条语句，我们说<code>ptr</code>“指向”<code>pooh</code>。<code>ptr</code>和<code>&amp;pooh</code>的区别是<code>ptr</code>是变量，而<code>&amp;pooh</code>是常量。或者，<code>ptr</code>是可修改的左值，而<code>&amp;pooh</code>是右值。还可以把<code>ptr</code>指向别处：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ptr = &amp;bah; <span class="comment">// 把 ptr 指向 bah，而不是 pooh</span></span><br></pre></td></tr></table></figure>

<p>现在<code>ptr</code>的值是<code>bah</code>的地址。</p>
<p>要创建指针变量，先要声明指针变量的类型。假设想把<code>ptr</code>声明为储存<code>int</code>类型变量地址的指针，就要使用下面介绍的新运算符。</p>
<span id="more"></span>

<h3 id="间接运算符："><a href="#间接运算符：" class="headerlink" title="间接运算符：*"></a>间接运算符：*</h3><p>假设已知<code>ptr</code>指向<code>bah</code>，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ptr = &amp;bah;</span><br></pre></td></tr></table></figure>

<p>然后使用间接运算符<code>*</code>（indirection operator）找出储存在<code>bah</code>中的值，该运算符有时也称为解引用运算符（dereferencing operator）。不要把间接运算符和二元乘法运算符（*）混淆，虽然它们使用的符号相同，但语法功能不同。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">val = *ptr; <span class="comment">// 找出 ptr 指向的值</span></span><br></pre></td></tr></table></figure>

<p>语句<code>ptr = &amp;bah;</code>和<code>val = *ptr;</code>放在一起相当于下面的语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">val = bah;</span><br></pre></td></tr></table></figure>

<p>由此可见，使用地址和间接运算符可以间接完成上面这条语句的功能，这也是“间接运算符”名称的由来。</p>
<blockquote>
<p>小结：与指针相关的运算符<br>地址运算符：<code>&amp;</code><br>一般注解：<br>后跟一个变量名时，<code>&amp;</code>给出该变量的地址。<br>示例：<br><code>&amp;nurse</code>表示变量<code>nurse</code>的地址。<br>地址运算符：<code>*</code><br>一般注解：<br>后跟一个指针名或地址时，<code>*</code>给出储存在指针指向地址上的值。<br>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nurse　=　<span class="number">22</span>;</span><br><span class="line">ptr = &amp;nurse; <span class="comment">// 指向 nurse 的指针</span></span><br><span class="line">val = *ptr;　 <span class="comment">// 把 ptr 指向的地址上的值赋给 val</span></span><br></pre></td></tr></table></figure>

<p>执行以上 3 条语句的最终结果是把 22 赋给<code>val</code>。</p>
</blockquote>
<h3 id="声明指针"><a href="#声明指针" class="headerlink" title="声明指针"></a>声明指针</h3><p>相信读者已经很熟悉如何声明int类型和其他基本类型的变量，那么如何声明指针变量？你也许认为是这样声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pointer ptr; <span class="comment">// 不能这样声明指针</span></span><br></pre></td></tr></table></figure>

<p>为什么不能这样声明？因为声明指针变量时必须指定指针所指向变量的类型，因为不同的变量类型占用不同的存储空间，一些指针操作要求知道操作对象的大小。另外，程序必须知道储存在指定地址上的数据类型。<code>long</code>和<code>float</code>可能占用相同的存储空间，但是它们储存数字却大相径庭。下面是一些指针的声明示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> * pi;　　 <span class="comment">// pi 是指向 int 类型变量的指针</span></span><br><span class="line"><span class="type">char</span> * pc;　　　　<span class="comment">// pc 是指向 char 类型变量的指针</span></span><br><span class="line"><span class="type">float</span> * pf, * pg; <span class="comment">// pf、pg 都是指向 float 类型变量的指针</span></span><br></pre></td></tr></table></figure>

<p>类型说明符表明了指针所指向对象的类型，星号（*）表明声明的变量是一个指针。<code>int * pi;</code>声明的意思是<code>pi</code>是一个指针，<code>*pi</code>是<code>int</code>类型（见图9.5）。</p>
<img src="/my_pictures/20230309/1.png" style="zoom: 33%;" />

<p><code>*</code>和指针名之间的空格可有可无。通常，程序员在声明时使用空格，在解引用变量时省略空格。<br><code>pc</code>指向的值<code>（*pc）</code>是<code>char</code>类型。<code>pc</code>本身是什么类型？我们描述它的类型是 “指向<code>char</code>类型的指针”。<code>pc</code>的值是一个地址，在大部分系统内部，该地址由一个无符号整数表示。但是，不要把指针认为是整数类型。一些处理整数的操作不能用来处理指针，反之亦然。例如，可以把两个整数相乘，但是不能把两个指针相乘。所以，指针实际上是一个新类型，不是整数类型。因此，如前所述，ANSI C 专门为指针提供了<code>%p</code>格式的转换说明。</p>
<h3 id="使用指针在函数间通信"><a href="#使用指针在函数间通信" class="headerlink" title="使用指针在函数间通信"></a>使用指针在函数间通信</h3><p>我们才刚刚接触指针，指针的世界丰富多彩。本节着重介绍如何使用指针解决函数间的通信问题。请看程序清单 9.15，该程序在<code>interchange()</code>函数中使用了指针参数。稍后我们将对该程序做详细分析。</p>
<p><strong>程序清单 9.15 swap3.c 程序</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* swap3.c -- 使用指针解决交换函数的问题 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>　<span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">interchange</span><span class="params">(<span class="type">int</span> * u, <span class="type">int</span> * v)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">5</span>,　y = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Originally x = %d and y = %d.\n&quot;</span>, x, y);</span><br><span class="line">  interchange(&amp;x, &amp;y);　 <span class="comment">// 把地址发送给函数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Now x = %d　and　y = %d.\n&quot;</span>, x, y);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interchange</span><span class="params">(<span class="type">int</span> * u, <span class="type">int</span> * v)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> temp;</span><br><span class="line">  temp = *u;　　<span class="comment">// temp 获得 u 所指向对象的值</span></span><br><span class="line">  *u = *v;</span><br><span class="line">  *v = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序是否能正常运行？下面是程序的输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Originally　x　=　<span class="number">5</span>　and　y　=　<span class="number">10.</span></span><br><span class="line">Now　x　=　<span class="number">10</span>　and　y　=　<span class="number">5.</span></span><br></pre></td></tr></table></figure>

<p>没问题，一切正常。接下来，我们分析程序清单 9.15 的运行情况。首先看函数调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">interchange(&amp;x, &amp;y);</span><br></pre></td></tr></table></figure>

<p>该函数传递的不是<code>x</code>和<code>y</code>的值，而是它们的地址。这意味着出现在<code>interchange()</code>原型和定义中的形式参数<code>u</code>和<code>v</code>将把地址作为它们的值。因此，应把它们声明为指针。由于<code>x</code>和<code>y</code>是整数，所以<code>u</code>和<code>v</code>是指向整数的指针，其声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">interchange</span> <span class="params">(<span class="type">int</span> * u, <span class="type">int</span> * v)</span></span><br></pre></td></tr></table></figure>

<p>接下来，在函数体中声明了一个交换值时必需的临时变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> temp;</span><br></pre></td></tr></table></figure>

<p>通过下面的语句把x的值储存在<code>temp</code>中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">temp = *u;</span><br></pre></td></tr></table></figure>

<p>记住，<code>u</code>的值是<code>&amp;x</code>，所以<code>u</code>指向<code>x</code>。这意味着用<code>*u</code>即可表示<code>x</code>的值，这正是我们需要的。不要写成这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">temp = u; <span class="comment">/* 不要这样做 */</span></span><br></pre></td></tr></table></figure>

<p>因为这条语句赋给<code>temp</code>的是<code>x</code>的地址（<code>u</code>的值就是<code>x</code>的地址），而不是<code>x</code>的值。函数要交换的是<code>x</code>和<code>y</code>的值，而不是它们的地址。</p>
<p>与此类似，把y的值赋给x，要使用下面的语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*u = *v;</span><br></pre></td></tr></table></figure>

<p>这条语句相当于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = y;</span><br></pre></td></tr></table></figure>

<p>我们总结一下该程序示例做了什么。我们需要一个函数交换<code>x</code>和<code>y</code>的值。把<code>x</code>和<code>y</code>的地址传递给函数，我们让<code>interchange()</code>访问这两个函数。使用指针和<code>*</code>运算符，该函数可以访问储存在这些位置的值并改变它们。</p>
<p>可以省略 ANSI C 风格的函数原型中的形参名，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">interchange</span><span class="params">(<span class="type">int</span> *, <span class="type">int</span> *)</span>;</span><br></pre></td></tr></table></figure>

<p>一般而言，可以把变量相关的两类信息传递给函数。如果这种形式的函数调用，那么传递的是<code>x</code>的值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">function1(x);</span><br></pre></td></tr></table></figure>

<p>如果下面形式的函数调用，那么传递的是<code>x</code>的地址：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">function2(&amp;x);</span><br></pre></td></tr></table></figure>

<p>第 1 种形式要求函数定义中的形式参数必须是一个与<code>x</code>的类型相同的变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">function1</span><span class="params">(<span class="type">int</span> num)</span></span><br></pre></td></tr></table></figure>

<p>第 2 种形式要求函数定义中的形式参数必须是一个指向正确类型的指针：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">function2</span><span class="params">(<span class="type">int</span> * ptr)</span></span><br></pre></td></tr></table></figure>

<p>如果要计算或处理值，那么使用第 1 种形式的函数调用；如果要在被调函数中改变主调函数的变量，则使用第 2 种形式的函数调用。我们用过的<code>scanf()</code>函数就是这样。当程序要把一个值读入变量时（如本例中的<code>num</code>），调用的是<code>scanf(&quot;%d&quot;, &amp;num)</code>。<code>scanf()</code>读取一个值，然后把该值储存到指定的地址上。</p>
<p>对本例而言，指针让<code>interchange()</code>函数通过自己的局部变量改变<code>main()</code>中变量的值。</p>
<p>熟悉 Pascal 和 Modula-2 的读者应该看出第 1 种形式和 Pascal 的值参数相同，第 2 种形式和 Pascal 的变量参数类似。C++ 程序员可能认为，既然 C 和 C++ 都使用指针变量，那么 C 应该也有引用变量。让他们失望了，C 没有引用变量。对 BASIC 程序员而言，可能很难理解整个程序。如果觉得本节的内容晦涩难懂，请多做一些相关的编程练习，你会发现指针非常简单实用（见图9.6）。</p>
<img src="/my_pictures/20230309/2.png" style="zoom: 33%;" />

<blockquote>
<p><strong>变量：名称、地址和值</strong></p>
<p>通过前面的讨论发现，变量的名称、地址和变量的值之间关系密切。我们来进一步分析。<br>编写程序时，可以认为变量有两个属性：名称和值（还有其他性质，如类型，暂不讨论）。计算机编译和加载程序后，认为变量也有两个属性：地址和值。地址就是变量在计算机内部的名称。</p>
<p>在许多语言中，地址都归计算机管，对程序员隐藏。然而在 C 中，可以通过<code>&amp;</code>运算符访问地址，通过<code>*</code>运算符获得地址上的值。例如，<code>&amp;barn</code>表示变量<code>barn</code>的地址，使用函数名即可获得变量的数值。例如，<code>printf(&quot;%d\n&quot;, barn)</code>打印<code>barn</code>的值，使用<code>*</code>运算符即可获得储存在地址上的值。如果<code>pbarn= &amp;barn;</code>，那么<code>*pbarn</code>表示的是储存在<code>&amp;barn</code>地址上的值。</p>
<p>简而言之，普通变量把值作为基本量，把地址作为通过<code>&amp;</code>运算符获得的派生量，而指针变量把地址作为基本量，把值作为通过<code>*</code>运算符获得的派生量。</p>
<p>虽然打印地址可以满足读者好奇心，但是这并不是<code>&amp;</code>运算符的主要用途。更重要的是使用<code>&amp;</code>、<code>*</code>和指针可以操纵地址和地址上的内容，如 swap3.c 程序（程序清单9.15）所示。</p>
</blockquote>
<h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><p>指针提供一种以符号形式使用地址的方法。因为计算机的硬件指令非常依赖地址，指针在某种程度上把程序员想要传达的指令以更接近机器的方式表达。因此，使用指针的程序更有效率。尤其是，指针能有效地处理数组。数组表示法其实是在变相地使用指针。</p>
<p>我们举一个变相使用指针的例子：数组名是数组首元素的地址。也就是说，如果<code>flizny</code>是一个数组，下面的语句成立：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">flizny == &amp;flizny[<span class="number">0</span>]; <span class="comment">// 数组名是该数组首元素的地址</span></span><br></pre></td></tr></table></figure>

<p><code>flizny</code>和<code>&amp;flizny[0]</code>都表示数组首元素的内存地址（<code>&amp;</code>是地址运算符）。两者都是常量，在程序的运行过程中，不会改变。但是，可以把它们赋值给指针变量，然后可以修改指针变量的值，如程序清单 10.8 所示。注意指针加上一个数时，它的值发生了什么变化（转换说明<code>%p</code>通常以十六进制显示指针的值）。</p>
<p><strong>程序清单 10.8 pnt_add.c 程序</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pnt_add.c -- 指针地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>　<span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>　SIZE　4</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">short</span> dates[SIZE];</span><br><span class="line">  <span class="type">short</span> * pti;</span><br><span class="line">  <span class="type">short</span> index;</span><br><span class="line">  <span class="type">double</span> bills[SIZE];</span><br><span class="line">  <span class="type">double</span> * ptf;</span><br><span class="line">  pti = dates;　<span class="comment">// 把数组地址赋给指针</span></span><br><span class="line">  ptf = bills;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%23s　%15s\n&quot;</span>,　<span class="string">&quot;short&quot;</span>,　<span class="string">&quot;double&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (index　=　<span class="number">0</span>;　index　&lt;　SIZE;　index++)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pointers　+　%d:　%10p　%10p\n&quot;</span>, index, pti + index, ptf + index);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是该例的输出示例：</p>
<table>
<thead>
<tr>
<th></th>
<th>short</th>
<th>double</th>
</tr>
</thead>
<tbody><tr>
<td>pointers　+　0:</td>
<td>0x7fff5fbff8dc</td>
<td>0x7fff5fbff8a0</td>
</tr>
<tr>
<td>pointers　+　1:</td>
<td>0x7fff5fbff8de</td>
<td>0x7fff5fbff8a8</td>
</tr>
<tr>
<td>pointers　+　2:</td>
<td>0x7fff5fbff8e0</td>
<td>0x7fff5fbff8b0</td>
</tr>
<tr>
<td>pointers　+　3:</td>
<td>0x7fff5fbff8e2</td>
<td>0x7fff5fbff8b8</td>
</tr>
</tbody></table>
<p>第 2 行打印的是两个数组开始的地址，下一行打印的是指针加 1 后的地址，以此类推。注意，地址是十六进制的，因此<code>dd</code>比<code>dc</code>大1，<code>a1</code>比<code>a0</code>大 1。但是，显示的地址是怎么回事？</p>
<blockquote>
<p>0x7fff5fbff8dc + 1 是否是 0x7fff5fbff8de?<br>0x7fff5fbff8a0 + 1 是否是 0x7fff5fbff8a8?</p>
</blockquote>
<p>我们的系统中，地址按字节编址，<code>short</code>类型占用 2 字节，<code>double</code>类型占用 8 字节。在 C 中，指针加 1 指的是增加一个存储单元。对数组而言，这意味着把加 1 后的地址是下一个元素的地址，而不是下一个字节的地址（见图10.3）。这是为什么必须声明指针所指向对象类型的原因之一。只知道地址不够，因为计算机要知道储存对象需要多少字节（即使指针指向的是标量变量，也要知道变量的类型，否则<code>*pt</code>就无法正确地取回地址上的值）。</p>
<img src="/my_pictures/20230309/3.png" style="zoom: 20%;" />

<p>现在可以更清楚地定义指向<code>int</code>的指针、指向<code>float</code>的指针，以及指向其他数据对象的指针。</p>
<ul>
<li>指针的值是它所指向对象的地址。地址的表示方式依赖于计算机内部的硬件。许多计算机（包括 PC 和 Macintosh）都是按字节编址，意思是内存中的每个字节都按顺序编号。这里，一个较大对象的地址（如<code>double</code>类型的变量）通常是该对象第一个字节的地址。</li>
<li>在指针前面使用<code>*</code>运算符可以得到该指针所指向对象的值。</li>
<li>指针加 1，指针的值递增它所指向类型的大小（以字节为单位）。</li>
</ul>
<p>下面的等式体现了 C 语言的灵活性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dates + <span class="number">2</span> == &amp;date[<span class="number">2</span>]　　　 <span class="comment">// 相同的地址</span></span><br><span class="line">*(dates + <span class="number">2</span>) == dates[<span class="number">2</span>]　 <span class="comment">// 相同的值</span></span><br></pre></td></tr></table></figure>

<p>以上关系表明了数组和指针的关系十分密切，可以使用指针标识数组的元素和获得元素的值。从本质上看，同一个对象有两种表示法。实际上，C 语言标准在描述数组表示法时确实借助了指针。也就是说，定义<code>ar[n]</code>的意思是<code>*(ar + n)</code>。可以认为<code>*(ar + n)</code>的意思是“到内存的<code>ar</code>位置，然后移动<code>n</code>个单元，检索储存在那里的值”。</p>
<h2 id="函数、数组和指针"><a href="#函数、数组和指针" class="headerlink" title="函数、数组和指针"></a>函数、数组和指针</h2><h3 id="声明数组形参"><a href="#声明数组形参" class="headerlink" title="声明数组形参"></a>声明数组形参</h3><p>因为数组名是该数组首元素的地址，作为实际参数的数组名要求形式参数是一个与之匹配的指针。只有在这种情况下，C 才会把<code>int ar[]</code>和<code>int * ar</code>解释成一样。也就是说，<code>ar</code>是指向<code>int</code>的指针。由于函数原型可以省略参数名，所以下面 4 种原型都是等价的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *ar, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> ar[], <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> [],　<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>但是，在函数定义中不能省略参数名。下面两种形式的函数定义等价：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *ar, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 其他代码已省略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> ar[], <span class="type">int</span> n)</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 其他代码已省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用以上提到的任意一种函数原型和函数定义。</p>
<p>程序清单 10.10 演示了一个程序，使用<code>sum()</code>函数。该程序打印原始数组的大小和表示该数组的函数形参的大小。</p>
<p><strong>程序清单 10.10 sum_arr1.c 程序</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sum_arr1.c -- 数组元素之和</span></span><br><span class="line"><span class="comment">// 如果编译器不支持 %zd，用 %u 或 %lu 替换它</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 10</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> ar[],　<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> marbles[SIZE] = &#123; <span class="number">20</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">39</span>, <span class="number">4</span>, <span class="number">16</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">31</span>, <span class="number">20</span> &#125;;</span><br><span class="line">  <span class="type">long</span> answer;</span><br><span class="line">  answer = sum(marbles, SIZE);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The total number of marbles is %ld.\n&quot;</span>, answer);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The size of marbles is %zd bytes.\n&quot;</span>,</span><br><span class="line">         <span class="keyword">sizeof</span> marbles);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> ar[], <span class="type">int</span> n)</span>  <span class="comment">// 这个数组的大小是？</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  	total += ar[i];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The size of ar is %zd bytes.\n&quot;</span>, <span class="keyword">sizeof</span> ar);</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序的输出如下：</p>
<blockquote>
<p>The size of ar is 8 bytes.<br>The total number of marbles is 190.<br>The size of marbles is 40 bytes.</p>
</blockquote>
<p>注意，<code>marbles</code>的大小是 40 字节。这没问题，因为<code>marbles</code>内含 10 个<code>int</code>类型的值，每个值占 4 字节，所以整个<code>marbles</code>的大小是 40 字节。但是，<code>ar</code>才 8 字节。这是因为<code>ar</code>并不是数组本身，它是一个指向<code>marbles</code>数组首元素的指针。我们的系统中用 8 字节储存地址，所以指针变量的大小是 8 字节（其他系统中地址的大小可能不是8字节）。简而言之，在程序清单 10.10 中，<code>marbles</code>是一个数组，<code>ar</code>是一个指向<code>marbles</code>数组首元素的指针，利用 C 中数组和指针的特殊关系，可以用数组表示法来表示指针<code>ar</code>。</p>
<h3 id="使用指针形参"><a href="#使用指针形参" class="headerlink" title="使用指针形参"></a>使用指针形参</h3><p>上面的<code>sum()</code>函数传递了一个<code>n</code>参数来表示数组的长度，我们还有另外一种方式可以实现，那就是利用两个指针来做遍历，也即是使用指针形参。</p>
<p><strong>程序清单 10.11 sum_arr2.c 程序</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* sum_arr2.c -- 数组元素之和 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 10</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sump</span><span class="params">(<span class="type">int</span> * start, <span class="type">int</span> * end)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> marbles[SIZE] = &#123; <span class="number">20</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">39</span>, <span class="number">4</span>, <span class="number">16</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">31</span>, <span class="number">20</span> &#125;;</span><br><span class="line">  <span class="type">long</span> answer;</span><br><span class="line">  answer = sump(marbles, marbles + SIZE);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The total number of marbles is %ld.\n&quot;</span>, answer);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 使用指针算法 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sump</span><span class="params">(<span class="type">int</span> * start, <span class="type">int</span> * end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (start &lt; end)</span><br><span class="line">  &#123;</span><br><span class="line">    total += *start;  <span class="comment">// 把数组元素的值加起来</span></span><br><span class="line">    start++; <span class="comment">// 让指针指向下一个元素</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指针变量的基本操作"><a href="#指针变量的基本操作" class="headerlink" title="指针变量的基本操作"></a>指针变量的基本操作</h3><p><strong>程序清单 10.13 ptr_ops.c 程序</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ptr_ops.c -- 指针操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> urn[<span class="number">5</span>] = &#123; <span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span> &#125;;</span><br><span class="line">  <span class="type">int</span> * ptr1, *ptr2, *ptr3;</span><br><span class="line">  ptr1 = urn; <span class="comment">// 把一个地址赋给指针</span></span><br><span class="line">  ptr2 = &amp;urn[<span class="number">2</span>];  <span class="comment">// 把一个地址赋给指针</span></span><br><span class="line">  <span class="comment">// 解引用指针，以及获得指针的地址</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pointer value, dereferenced pointer, pointer address:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ptr1 = %p, *ptr1 =%d, &amp;ptr1 = %p\n&quot;</span>, ptr1, *ptr1, &amp;ptr1);</span><br><span class="line">  <span class="comment">// 指针加法</span></span><br><span class="line">  ptr3 = ptr1 + <span class="number">4</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nadding an int to a pointer:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ptr1 + 4 = %p, *(ptr1 + 4) = %d\n&quot;</span>, ptr1 + <span class="number">4</span>, *(ptr1 + <span class="number">4</span>));</span><br><span class="line">  ptr1++; <span class="comment">// 递增指针</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nvalues after ptr1++:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ptr1 = %p, *ptr1 =%d, &amp;ptr1 = %p\n&quot;</span>, ptr1, *ptr1, &amp;ptr1);</span><br><span class="line">  ptr2--; <span class="comment">// 递减指针</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nvalues after --ptr2:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ptr2 = %p, *ptr2 = %d, &amp;ptr2 = %p\n&quot;</span>, ptr2, *ptr2, &amp;ptr2);</span><br><span class="line">  --ptr1; <span class="comment">// 恢复为初始值</span></span><br><span class="line">  ++ptr2; <span class="comment">// 恢复为初始值</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nPointers reset to original values:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ptr1 = %p, ptr2 = %p\n&quot;</span>, ptr1, ptr2);</span><br><span class="line">  <span class="comment">// 一个指针减去另一个指针</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nsubtracting one pointer from another:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ptr2 = %p, ptr1 = %p, ptr2 - ptr1 = %td\n&quot;</span>, ptr2, ptr1, ptr2 - ptr1);</span><br><span class="line">  <span class="comment">// 一个指针减去一个整数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nsubtracting an int from a pointer:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ptr3 = %p, ptr3 - 2 = %p\n&quot;</span>, ptr3, ptr3 - <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是我们的系统运行该程序后的输出：</p>
<blockquote>
<p>pointer value, dereferenced pointer, pointer address:<br>ptr1 &#x3D; 0x7fff5fbff8d0, *ptr1 &#x3D;100, &amp;ptr1 &#x3D; 0x7fff5fbff8c8</p>
<p>adding an int to a pointer:<br>ptr1 + 4 &#x3D; 0x7fff5fbff8e0, *(ptr1 + 4) &#x3D; 500</p>
<p>values after ptr1++:<br>ptr1 &#x3D; 0x7fff5fbff8d4, *ptr1 &#x3D;200, &amp;ptr1 &#x3D; 0x7fff5fbff8c8</p>
<p>values after –ptr2:<br>ptr2 &#x3D; 0x7fff5fbff8d4, *ptr2 &#x3D; 200, &amp;ptr2 &#x3D; 0x7fff5fbff8c0</p>
<p>Pointers reset to original values:<br>ptr1 &#x3D; 0x7fff5fbff8d0, ptr2 &#x3D; 0x7fff5fbff8d8</p>
<p>subtracting one pointer from another:<br>ptr2 &#x3D; 0x7fff5fbff8d8, ptr1 &#x3D; 0x7fff5fbff8d0, ptr2 - ptr1 &#x3D; 2</p>
<p>subtracting an int from a pointer:<br>ptr3 &#x3D; 0x7fff5fbff8e0, ptr3 - 2 &#x3D; 0x7fff5fbff8d8</p>
</blockquote>
<h4 id="赋值："><a href="#赋值：" class="headerlink" title="赋值："></a>赋值：</h4><p>可以把地址赋给指针。例如，用数组名、带地址运算符（<code>&amp;</code>）的变量名、另一个指针进行赋值。在该例中，把<code>urn</code>数组的首地址赋给了<code>ptr1</code>，该地址的编号恰好是<code>0x7fff5fbff8d0</code>。变量<code>ptr2</code>获得数组<code>urn</code>的第 3 个元素（<code>urn[2]</code>）的地址。注意，地址应该和指针类型兼容。也就是说，不能把<code>double</code>类型的地址赋给指向<code>int</code>的指针，至少要避免不明智的类型转换。C99&#x2F;C11 已经强制不允许这样做。</p>
<h4 id="解引用："><a href="#解引用：" class="headerlink" title="解引用："></a>解引用：</h4><p><code>*</code>运算符给出指针指向地址上储存的值。因此，<code>*ptr1</code>的初值是 100，该值储存在编号为<code>0x7fff5fbff8d0</code>的地址上。</p>
<h4 id="取址："><a href="#取址：" class="headerlink" title="取址："></a>取址：</h4><p>和所有变量一样，指针变量也有自己的地址和值。对指针而言，<code>&amp;</code>运算符给出指针本身的地址。本例中，<code>ptr1</code>储存在内存编号为<code>0x7fff5fbff8c8</code>的地址上，该存储单元储存的内容是<code>0x7fff5fbff8d0</code>，即<code>urn</code>的地址。因此<code>&amp;ptr1</code>是指向<code>ptr1</code>的指针，而<code>ptr1</code>是指向<code>utn[0]</code>的指针。</p>
<h4 id="指针与整数相加："><a href="#指针与整数相加：" class="headerlink" title="指针与整数相加："></a>指针与整数相加：</h4><p>可以使用<code>+</code>运算符把指针与整数相加，或整数与指针相加。无论哪种情况，整数都会和指针所指向类型的大小（以字节为单位）相乘，然后把结果与初始地址相加。因此<code>ptr1 + 4</code>与<code>&amp;urn[4]</code>等价。如果相加的结果超出了初始指针指向的数组范围，计算结果则是未定义的。除非正好超过数组末尾第一个位置，C 保证该指针有效。</p>
<h4 id="递增指针："><a href="#递增指针：" class="headerlink" title="递增指针："></a>递增指针：</h4><p>递增指向数组元素的指针可以让该指针移动至数组的下一个元素。因此，<code>ptr1++</code>相当于把<code>ptr1</code>的值加上 4（我们的系统中<code>int</code>为 4 字节），<code>ptr1</code>指向<code>urn[1]</code>（见图10.4，该图中使用了简化的地址）。现在<code>ptr1</code>的值是<code>0x7fff5fbff8d4</code>（数组的下一个元素的地址），<code>*ptr</code>的值为 200（即<code>urn[1]</code>的值）。注意，<code>ptr1</code>本身的地址仍是<code>0x7fff5fbff8c8</code>。毕竟，变量不会因为值发生变化就移动位置。</p>
<h4 id="指针减去一个整数："><a href="#指针减去一个整数：" class="headerlink" title="指针减去一个整数："></a>指针减去一个整数：</h4><p>可以使用<code>-</code>运算符从一个指针中减去一个整数。指针必须是第 1 个运算对象，整数是第 2 个运算对象。该整数将乘以指针指向类型的大小（以字节为单位），然后用初始地址减去乘积。所以<code>ptr3 - 2</code>与<code>&amp;urn[2]</code>等价，因为<code>ptr3</code>指向的是<code>&amp;arn[4]</code>。如果相减的结果超出了初始指针所指向数组的范围，计算结果则是未定义的。除非正好超过数组末尾第一个位置， C 保证该指针有效。</p>
<h4 id="递减指针："><a href="#递减指针：" class="headerlink" title="递减指针："></a>递减指针：</h4><p>当然，除了递增指针还可以递减指针。在本例中，递减<code>ptr3</code>使其指向数组的第 2 个元素而不是第 3 个元素。前缀或后缀的递增和递减运算符都可以使用。注意，在重置<code>ptr1</code>和<code>ptr2</code>前，它们都指向相同的元素<code>urn[1]</code>。</p>
<h4 id="指针求差："><a href="#指针求差：" class="headerlink" title="指针求差："></a>指针求差：</h4><p>可以计算两个指针的差值。通常，求差的两个指针分别指向同一个数组的不同元素，通过计算求出两元素之间的距离。差值的单位与数组类型的单位相同。例如，程序清单 10.13 的输出中，<code>ptr2 - ptr1</code>得 2，意思是这两个指针所指向的两个元素相隔两个<code>int</code>，而不是 2 字节。只要两个指针都指向相同的数组（或者其中一个指针指向数组后面的第 1 个地址），C 都能保证相减运算有效。如果指向两个不同数组的指针进行求差运算可能会得出一个值，或者导致运行时错误。</p>
<h4 id="比较："><a href="#比较：" class="headerlink" title="比较："></a>比较：</h4><p>使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象。</p>
<h3 id="解引用未初始化的指针"><a href="#解引用未初始化的指针" class="headerlink" title="解引用未初始化的指针"></a>解引用未初始化的指针</h3><p>说到注意事项，一定要牢记一点：千万不要解引用未初始化的指针。例如，考虑下面的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> * pt;	 <span class="comment">// 未初始化的指针</span></span><br><span class="line">*pt = <span class="number">5</span>;　　<span class="comment">// 严重的错误</span></span><br></pre></td></tr></table></figure>

<p>为何不行？第 2 行的意思是把5储存在pt指向的位置。但是pt未被初始化，其值是一个随机值，所以不知道 5 将储存在何处。这可能不会出什么错，也可能会擦写数据或代码，或者导致程序崩溃。切记：创建一个指针时，系统只分配了储存指针本身的内存，并未分配储存数据的内存。因此，在使用指针之前，必须先用已分配的地址初始化它。例如，可以用一个现有变量的地址初始化该指针（使用带指针形参的函数时，就属于这种情况）。或者还可以使用第 12 章将介绍的<code>malloc()</code>函数先分配内存。无论如何，使用指针时一定要注意，不要解引用未初始化的指针！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> * pd;　<span class="comment">// 未初始化的指针</span></span><br><span class="line">*pd = <span class="number">2.4</span>;　　<span class="comment">// 不要这样做</span></span><br></pre></td></tr></table></figure>

<p>假设</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> urn[<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> * ptr1, * ptr2;</span><br></pre></td></tr></table></figure>

<p>下面是一些有效和无效的语句：</p>
<table>
<thead>
<tr>
<th>有效语句</th>
<th>无效语句</th>
</tr>
</thead>
<tbody><tr>
<td>ptr1++;</td>
<td>urn++;</td>
</tr>
<tr>
<td>ptr2 &#x3D; ptr1 + 2;</td>
<td>ptr2 &#x3D; ptr2 + ptr1;</td>
</tr>
<tr>
<td>ptr2 &#x3D; urn + 1;</td>
<td>ptr2 &#x3D; urn * ptr1;</td>
</tr>
</tbody></table>
<h2 id="指针常量与常量指针"><a href="#指针常量与常量指针" class="headerlink" title="指针常量与常量指针"></a>指针常量与常量指针</h2><p>C 语言中的指针是非常基础也是非常复杂难懂的概念，其中配合<code>const</code>使用更会让初学者一头雾水，接下来我们就来看看 C 语言中的常量指针和指针常量。</p>
<h3 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h3><p>指针指向的对象是常量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * pt = &amp;a;</span><br></pre></td></tr></table></figure>

<p>因为<code>const</code>修饰的是<code>int</code>，所以<code>pt</code>所指向的内存地址所对应的值是常量不可修改。故，如下写法编译器会报错：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*pt = <span class="number">10</span>; <span class="comment">// Read-only variable is not assignable</span></span><br></pre></td></tr></table></figure>

<p>虽然<code>pt</code>指向的内容是不可变的，但是指针本身并没有被<code>const</code>修饰，所以指针本身是可变的，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">pt = &amp;b;</span><br></pre></td></tr></table></figure>

<h3 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h3><p>指针本身是一个常量，所以指针的指向不允许被修改。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="type">const</span> pr = &amp;a;</span><br></pre></td></tr></table></figure>

<p>因为<code>const</code>修饰的是指针<code>pr</code>，所以指针所指向的地址是不可以被修改的，如下代码编译器会报错：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pr = &amp;b; <span class="comment">// Cannot assign to variable &#x27;pr&#x27; with const-qualified type &#x27;int *const&#x27;</span></span><br></pre></td></tr></table></figure>

<p>但是变量<code>a</code>并不是常量，所以其值可以被修改，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*pr = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<h3 id="其他写法"><a href="#其他写法" class="headerlink" title="其他写法"></a>其他写法</h3><p>如下均表示常量指针，意义相同：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> * p;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> * p;</span><br></pre></td></tr></table></figure>

<p>如下两行代码均表示的是常量指针 p 指向一个 int 常量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> * <span class="type">const</span> p;</span><br></pre></td></tr></table></figure>

<h2 id="指针和多维数组"><a href="#指针和多维数组" class="headerlink" title="指针和多维数组"></a>指针和多维数组</h2><p>指针和多维数组有什么关系？为什么要了解它们的关系？处理多维数组的函数要用到指针，所以在使用这种函数之前，先要更深入地学习指针。至于第 1 个问题，我们通过几个示例来回答。为简化讨论，我们使用较小的数组。假设有下面的声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> zippo[<span class="number">4</span>][<span class="number">2</span>]; <span class="comment">/* 内含 int 数组的数组 */</span></span><br></pre></td></tr></table></figure>

<p>然后数组名<code>zippo</code>是该数组首元素的地址。在本例中，<code>zippo</code>的首元素是一个内含两个<code>int</code>值的数组，所以<code>zippo</code>是这个内含两个<code>int</code>值的数组的地址。下面，我们从指针的属性进一步分析。</p>
<p>因为<code>zippo</code>是数组首元素的地址，所以<code>zippo</code>的值和<code>&amp;zippo[0]</code>的值相同。而<code>zippo[0]</code>本身是一个内含两个整数的数组，所以<code>zippo[0]</code>的值和它首元素（一个整数）的地址（即<code>&amp;zippo[0][0]</code>的值）相同。简而言之，<code>zippo[0]</code>是一个占用一个<code>int</code>大小对象的地址，而<code>zippo</code>是一个占用两个<code>int</code>大小对象的地址。由于这个整数和内含两个整数的数组都开始于同一个地址，所以<code>zippo</code>和<code>zippo[0]</code>的值相同。</p>
<p>给指针或地址加 1，其值会增加对应类型大小的数值。在这方面，<code>zippo</code>和<code>zippo[0]</code>不同，因为<code>zippo</code>指向的对象占用了两个<code>int</code>大小，而<code>zippo[0]</code>指向的对象只占用一个<code>int</code>大小。因此，<code>zippo + 1</code>和<code>zippo[0] + 1</code>的值不同。</p>
<p>解引用一个指针（在指针前使用<code>*</code>运算符）或在数组名后使用带下标的<code>[]</code>运算符，得到引用对象代表的值。因为<code>zippo[0]</code>是该数组首元素（<code>zippo[0][0]</code>）的地址，所以<code>*(zippo[0])</code>表示储存在<code>zippo[0][0]</code>上的值（即一个<code>int</code>类型的值）。与此类似，<code>*zippo</code>代表该数组首元素（<code>zippo[0]</code>）的值，但是<code>zippo[0]</code>本身是一个<code>int</code>类型值的地址。该值的地址是<code>&amp;zippo[0][0]</code>，所以<code>*zippo</code>就是<code>&amp;zippo[0][0]</code>。对两个表达式应用解引用运算符表明，<code>**zippo</code>与<code>*&amp;zippo[0][0]</code>等价，这相当于<code>zippo[0][0]</code>，即一个<code>int</code>类型的值。简而言之，<code>zippo</code>是地址的地址，必须解引用两次才能获得原始值。地址的地址或指针的指针是就是双重间接（double indirection）的例子。</p>
<p>显然，增加数组维数会增加指针的复杂度。现在，大部分初学者都开始意识到指针为什么是 C 语言中最难的部分。认真思考上述内容，看看是否能用所学的知识解释程序清单 10.15 中的程序。该程序显示了一些地址值和数组的内容。</p>
<p><strong>程序清单 10.15 zippo1.c 程序</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* zippo1.c -- zippo的相关信息 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> zippo[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123; <span class="number">2</span>, <span class="number">4</span> &#125;, &#123; <span class="number">6</span>, <span class="number">8</span> &#125;, &#123; <span class="number">1</span>, <span class="number">3</span> &#125;, &#123; <span class="number">5</span>, <span class="number">7</span> &#125; &#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;zippo             = %p, zippo + 1    = %p\n&quot;</span>,zippo, zippo + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;zippo[0]          = %p, zippo[0] + 1 = %p\n&quot;</span>,zippo[<span class="number">0</span>], zippo[<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;*zippo            = %p, *zippo + 1   = %p\n&quot;</span>,*zippo, *zippo + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;zippo[0][0]       = %d\n&quot;</span>, zippo[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;*zippo[0]         = %d\n&quot;</span>, *zippo[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;**zippo           = %d\n&quot;</span>, **zippo);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;zippo[2][1]       = %d\n&quot;</span>, zippo[<span class="number">2</span>][<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;*(*(zippo+2) + 1) = %d\n&quot;</span>, *(*(zippo + <span class="number">2</span>) + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是我们的系统运行该程序后的输出：</p>
<img src="/my_pictures/20230309/4.png" style="zoom: 70%;" />

<p>要特别注意，与<code>zippo[2][1]</code>等价的指针表示法是<code>*(*(zippo+2) + 1)</code>。看上去比较复杂，应最好能理解。下面列出了理解该表达式的思路：</p>
<img src="/my_pictures/20230309/5.png" style="zoom: 50%;" />

<p>下图以另一种视图演示了数组地址、数组内容和指针之间的关系。</p>
<img src="/my_pictures/20230309/6.png" style="zoom: 45%;" />

<h3 id="指向多维数组的指针"><a href="#指向多维数组的指针" class="headerlink" title="指向多维数组的指针"></a>指向多维数组的指针</h3><p>如何声明一个指针变量<code>pz</code>指向一个二维数组（如，<code>zippo</code>）？在编写处理类似<code>zippo</code>这样的二维数组时会用到这样的指针。把指针声明为指向<code>int</code>的类型还不够。因为指向<code>int</code>只能与<code>zippo[0]</code>的类型匹配，说明该指针指向一个<code>int</code>类型的值。但是<code>zippo</code>是它首元素的地址，该元素是一个内含两个<code>int</code>类型值的一维数组。因此，<code>pz</code>必须指向一个内含两个<code>int</code>类型值的数组，而不是指向一个<code>int</code>类型值，其声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (* pz)[<span class="number">2</span>];　　<span class="comment">// pz指向一个内含两个 int 类型值的数组</span></span><br></pre></td></tr></table></figure>

<p>以上代码把<code>pz</code>声明为指向一个数组的指针，该数组内含两个<code>int</code>类型值。为什么要在声明中使用圆括号？因为<code>[]</code>的优先级高于<code>*</code>。考虑下面的声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> * pax[<span class="number">2</span>];　　 <span class="comment">// pax 是一个内含两个指针元素的数组，每个元素都指向 int 的指针</span></span><br></pre></td></tr></table></figure>

<p>由于<code>[]</code>优先级高，先与<code>pax</code>结合，所以<code>pax</code>成为一个内含两个元素的数组。然后<code>*</code>表示<code>pax</code>数组内含两个指针。最后，<code>int</code>表示<code>pax</code>数组中的指针都指向<code>int</code>类型的值。因此，这行代码声明了两个指向<code>int</code>的指针。而前面有圆括号的版本，<code>*</code>先与<code>pz</code>结合，因此声明的是一个指向数组（内含两个<code>int</code>类型的值）的指针。程序清单 10.16 演示了如何使用指向二维数组的指针。</p>
<p><strong>程序清单10.16 zippo2.c程序</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* zippo2.c -- 通过指针获取zippo的信息 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> zippo[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123; <span class="number">2</span>, <span class="number">4</span> &#125;, &#123; <span class="number">6</span>, <span class="number">8</span> &#125;, &#123; <span class="number">1</span>, <span class="number">3</span> &#125;, &#123; <span class="number">5</span>, <span class="number">7</span> &#125; &#125;;</span><br><span class="line">  <span class="type">int</span>(*pz)[<span class="number">2</span>];</span><br><span class="line">  pz = zippo;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pz       = %p, pz + 1    = %p\n&quot;</span>,  pz, pz + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pz[0]    = %p, pz[0] + 1 = %p\n&quot;</span>,  pz[<span class="number">0</span>], pz[<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;*pz      = %p, *pz + 1   = %p\n&quot;</span>,  *pz, *pz + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pz[0][0] = %d\n&quot;</span>, pz[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;*pz[0]   = %d\n&quot;</span>, *pz[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;**pz     = %d\n&quot;</span>, **pz);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pz[2][1] = %d\n&quot;</span>, pz[<span class="number">2</span>][<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;*(*(pz+2) + 1) = %d\n&quot;</span>, *(*(pz + <span class="number">2</span>) + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是该程序的输出：</p>
<img src="/my_pictures/20230309/7.png" style="zoom: 70%;" />

<p>如前所述，虽然<code>pz</code>是一个指针，不是数组名，但是也可以使用 <code>pz[2][1]</code>这样的写法。可以用数组表示法或指针表示法来表示一个数组元素，既可以使用数组名，也可以使用指针名：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">zippo[m][n] == *(*(zippo + m) + n)</span><br><span class="line">pz[m][n] == *(*(pz + m) + n)</span><br></pre></td></tr></table></figure>

<h3 id="多维数组的声明"><a href="#多维数组的声明" class="headerlink" title="多维数组的声明"></a>多维数组的声明</h3><p>如果要编写处理二维数组的函数，首先要能正确地理解指针才能写出声明函数的形参。在函数体中，通常使用数组表示法进行相关操作。可以这样声明函数的形参：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">somefunction</span><span class="params">(<span class="type">int</span> (* pt)[<span class="number">4</span>])</span>;</span><br></pre></td></tr></table></figure>

<p>另外，如果当且仅当<code>pt</code>是一个函数的形式参数时，可以这样声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">somefunction</span><span class="params">(<span class="type">int</span> pt[][<span class="number">4</span>])</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，第 1 个方括号是空的。空的方括号表明<code>pt</code>是一个指针。</p>
</blockquote>
<p>注意，下面的声明不正确：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum2</span><span class="params">(<span class="type">int</span> ar[][], <span class="type">int</span> rows)</span>; <span class="comment">// 错误的声明</span></span><br></pre></td></tr></table></figure>

<p>前面介绍过，编译器会把数组表示法转换成指针表示法。例如，编译器会把<code>ar[1]</code>转换成<code>ar+1</code>。编译器对<code>ar+1</code>求值，要知道<code>ar</code>所指向的对象大小。下面的声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum2</span><span class="params">(<span class="type">int</span> ar[][<span class="number">4</span>], <span class="type">int</span> rows)</span>;　　<span class="comment">// 有效声明</span></span><br></pre></td></tr></table></figure>

<p>表示<code>ar</code>指向一个内含 4 个<code>int</code>类型值的数组（在我们的系统中，<code>ar</code>指向的对象占 16 字节），所以<code>ar+1</code>的意思是“该地址加上 16 字节”。如果第 2 对方括号是空的，编译器就不知道该怎样处理。</p>
<p>也可以在第 1 对方括号中写上大小，如下所示，但是编译器会忽略该值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum2</span><span class="params">(<span class="type">int</span> ar[<span class="number">3</span>][<span class="number">4</span>], <span class="type">int</span> rows)</span>; <span class="comment">// 有效声明，但是3将被忽略</span></span><br></pre></td></tr></table></figure>

<h3 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h3><p>C99 新增了变长数组（variable-length array，VLA），允许使用变量表示数组的维度。如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>　quarters　=　<span class="number">4</span>;</span><br><span class="line"><span class="type">int</span>　regions　=　<span class="number">5</span>;</span><br><span class="line"><span class="type">double</span> sales[regions][quarters];　　<span class="comment">// 一个变长数组（VLA）</span></span><br></pre></td></tr></table></figure>

<p>前面提到过，变长数组有一些限制。变长数组必须是自动存储类别，这意味着无论在函数中声明还是作为函数形参声明，都不能使用<code>static</code>或<code>extern</code>存储类别说明符（在之后章节介绍）。而且，不能在声明中初始化它们。最终，C11 把变长数组作为一个可选特性，而不是必须强制实现的特性。</p>
<blockquote>
<p><strong>注意 变长数组不能改变大小</strong></p>
<p>长数组中的“变”不是指可以修改已创建数组的大小。一旦创建了变长数组，它的大小则保持不变。这里的“变”指的是：在创建数组时，可以使用变量指定数组的维度。</p>
</blockquote>
<p>由于变长数组是 C 语言的新特性，目前完全支持这一特性的编译器不多。下面我们来看一个简单的例子：如何编写一个函数，计算<code>int</code>的二维数组所有元素之和。<br>首先，要声明一个带二维变长数组参数的函数，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum2d</span><span class="params">(<span class="type">int</span> rows, <span class="type">int</span> cols, <span class="type">int</span> ar[rows][cols])</span>; <span class="comment">// ar 是一个变长数组（VLA）</span></span><br></pre></td></tr></table></figure>

<p>注意前两个形参（<code>rows</code>和<code>cols</code>）用作第 3 个形参二维数组<code>ar</code>的两个维度。因为<code>ar</code>的声明要使用<code>rows</code>和<code>cols</code>，所以在形参列表中必须在声明<code>ar</code>之前先声明这两个形参。因此，下面的原型是错误的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum2d</span><span class="params">(<span class="type">int</span> ar[rows][cols], <span class="type">int</span> rows, <span class="type">int</span> cols)</span>; <span class="comment">// 无效的顺序</span></span><br></pre></td></tr></table></figure>

<p>C99&#x2F;C11 标准规定，可以省略原型中的形参名，但是在这种情况下，必须用星号来代替省略的维度：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum2d</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span> ar[*][*])</span>; <span class="comment">// ar 是一个变长数组（VLA），省略了维度形参名</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>const 和数组大小</strong></p>
<p>是否可以在声明数组时使用<code>const</code>变量？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span>　<span class="type">int</span>　SZ　=　<span class="number">80</span>;</span><br><span class="line">...</span><br><span class="line"><span class="type">double</span> ar[SZ]; <span class="comment">// 是否允许？</span></span><br></pre></td></tr></table></figure>

<p>C90 标准不允许（也可能允许）。数组的大小必须是给定的整型常量表达式，可以是整型常量组合，如 20、<code>sizeof</code>表达式或其他不是<code>const</code>的内容。由于 C 实现可以扩大整型常量表达式的范围，所以可能会允许使用<code>const</code>，但是这种代码可能无法移植。<br>C99&#x2F;C11 标准允许在声明变长数组时使用<code>const</code>变量。所以该数组的定义必须是声明在块中的自动存储类别数组。</p>
</blockquote>
<p>变长数组还允许动态内存分配，这说明可以在程序运行时指定数组的大小。普通 C 数组都是静态内存分配，即在编译时确定数组的大小。由于数组大小是常量，所以编译器在编译时就知道了。之后章节将详细介绍动态内存分配。</p>
<h3 id="复合字面量"><a href="#复合字面量" class="headerlink" title="复合字面量"></a>复合字面量</h3><p>假设给带<code>int</code>类型形参的函数传递一个值，要传递<code>int</code>类型的变量，但是也可以传递<code>int</code>类型常量，如 5。在 C99 标准以前，对于带数组形参的函数，情况不同，可以传递数组，但是没有等价的数组常量。C99 新增了复合字面量（compound literal）。字面量是除符号常量外的常量。例如，5 是<code>int</code>类型字面量， 81.3 是<code>double</code>类型的字面量，<code>&#39;Y&#39;</code>是<code>char</code>类型的字面量，<code>&quot;elephant&quot;</code>是字符串字面量。发布 C99 标准的委员会认为，如果有代表数组和结构内容的复合字面量，在编程时会更方便。</p>
<p>对于数组，复合字面量类似数组初始化列表，前面是用括号括起来的类型名。例如，下面是一个普通的数组声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> diva[<span class="number">2</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>下面的复合字面量创建了一个和<code>diva</code>数组相同的匿名数组，也有两个<code>int</code>类型的值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(<span class="type">int</span> [<span class="number">2</span>])&#123;<span class="number">10</span>, <span class="number">20</span>&#125;　　　<span class="comment">// 复合字面量</span></span><br></pre></td></tr></table></figure>

<p>注意，去掉声明中的数组名，留下的<code>int [2]</code>即是复合字面量的类型名。<br>初始化有数组名的数组时可以省略数组大小，复合字面量也可以省略大小，编译器会自动计算数组当前的元素个数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(<span class="type">int</span> [])&#123;<span class="number">50</span>, <span class="number">20</span>, <span class="number">90</span>&#125; <span class="comment">// 内含 3 个元素的复合字面量</span></span><br></pre></td></tr></table></figure>

<p>因为复合字面量是匿名的，所以不能先创建然后再使用它，必须在创建的同时使用它。使用指针记录地址就是一种用法。也就是说，可以这样用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> * pt1;</span><br><span class="line">pt1 = (<span class="type">int</span> [<span class="number">2</span>]) &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，该复合字面量的字面常量与上面创建的<code>diva</code>数组的字面常量完全相同。与有数组名的数组类似，复合字面量的类型名也代表首元素的地址，所以可以把它赋给指向<code>int</code>的指针。然后便可使用这个指针。例如，本例中<code>*pt1</code>是 10，<code>pt1[1]</code>是 20。<br>还可以把复合字面量作为实际参数传递给带有匹配形式参数的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>　<span class="title function_">sum</span><span class="params">(<span class="type">const</span>　<span class="type">int</span>　ar[],　<span class="type">int</span>　n)</span>;</span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> total3;</span><br><span class="line">total3 = sum((<span class="type">int</span> [])&#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>&#125;, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>这里，第 1 个实参是内含 6 个<code>int</code>类型值的数组，和数组名类似，这同时也是该数组首元素的地址。这种用法的好处是，把信息传入函数前不必先创建数组，这是复合字面量的典型用法。</p>
<p>可以把这种用法应用于二维数组或多维数组。例如，下面的代码演示了如何创建二维int数组并储存其地址：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*pt2)[<span class="number">4</span>];　　 <span class="comment">// 声明一个指向二维数组的指针，该数组内含 2 个数组元素，</span></span><br><span class="line">									<span class="comment">// 每个元素是内含 4 个 int 类型值的数组</span></span><br><span class="line">pt2　=　(<span class="type">int</span>　[<span class="number">2</span>][<span class="number">4</span>])　&#123;　&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">-9</span>&#125;,　&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">-8</span>&#125;　&#125;;</span><br></pre></td></tr></table></figure>

<p>如上所示，该复合字面量的类型是<code>int [2][4]</code>，即一个 2×4 的<code>int</code>数组。</p>
<p>程序清单 10.19 把上述例子放进一个完整的程序中。</p>
<p><strong>程序清单 10.19 flc.c 程序</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// flc.c -- 有趣的常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLS 4</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum2d</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ar[][COLS], <span class="type">int</span> rows)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ar[], <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> total1, total2, total3;</span><br><span class="line">  <span class="type">int</span> * pt1;</span><br><span class="line">  <span class="type">int</span>(*pt2)[COLS];</span><br><span class="line">  pt1 = (<span class="type">int</span>[<span class="number">2</span>]) &#123; <span class="number">10</span>, <span class="number">20</span> &#125;;</span><br><span class="line">  pt2 = (<span class="type">int</span>[<span class="number">2</span>][COLS]) &#123; &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">-9</span>&#125;, &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">-8</span> &#125; &#125;;</span><br><span class="line">  total1 = sum(pt1, <span class="number">2</span>);</span><br><span class="line">  total2 = sum2d(pt2, <span class="number">2</span>);</span><br><span class="line">  total3 = sum((<span class="type">int</span> [])&#123; <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span> &#125;, <span class="number">6</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;total1 = %d\n&quot;</span>, total1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;total2 = %d\n&quot;</span>, total2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;total3 = %d\n&quot;</span>, total3);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ar [], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  total += ar[i];</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum2d</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ar [][COLS], <span class="type">int</span> rows)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (r = <span class="number">0</span>; r &lt; rows; r++)</span><br><span class="line">  <span class="keyword">for</span> (c = <span class="number">0</span>; c &lt; COLS; c++)</span><br><span class="line">  tot += ar[r][c];</span><br><span class="line">  <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记住，复合字面量是提供只临时需要的值的一种手段。复合字面量具有块作用域（以后章节将介绍相关内容），这意味着一旦离开定义复合字面量的块，程序将无法保证该字面量是否存在。也就是说，复合字面量的定义在最内层的花括号中。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数组是一组数据类型相同的元素。数组元素按顺序储存在内存中，通过整数下标（或索引）可以访问各元素。在 C 中，数组首元素的下标是 0，所以对于内含<code>n</code>个元素的数组，其最后一个元素的下标是<code>n-1</code>。作为程序员，要确保使用有效的数组下标，因为编译器和运行的程序都不会检查下标的有效性。<br>声明一个简单的一维数组形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type name [ size ];</span><br></pre></td></tr></table></figure>

<p>这里，<code>type</code>是数组中每个元素的数据类型，<code>name</code>是数组名，<code>size</code>是数组元素的个数。对于传统的 C 数组，要求<code>size</code>是整型常量表达式。但是 C99&#x2F;C11 允许使用整型非常量表达式。这种情况下的数组被称为变长数组。</p>
<p>C 把数组名解释为该数组首元素的地址。换言之，数组名与指向该数组首元素的指针等价。概括地说，数组和指针的关系十分密切。如果<code>ar</code>是一个数组，那么表达式<code>ar[i]</code>和<code>*(ar+i)</code>等价。</p>
<p>对于 C 语言而言，不能把整个数组作为参数传递给函数，但是可以传递数组的地址。然后函数可以使用传入的地址操控原始数组。如果函数没有修改原始数组的意图，应在声明函数的形式参数时使用关键字<code>const</code>。在被调函数中可以使用数组表示法或指针表示法，无论用哪种表示法，实际上使用的都是指针变量。</p>
<p>指针加上一个整数或递增指针，指针的值以所指向对象的大小为单位改变。也就是说，如果<code>pd</code>指向一个数组的 8 字节<code>double</code>类型值，那么<code>pd</code>加 1 意味着其值加 8，以便它指向该数组的下一个元素。</p>
<p>二维数组即是数组的数组。例如，下面声明了一个二维数组：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> sales[<span class="number">5</span>][<span class="number">12</span>];</span><br></pre></td></tr></table></figure>

<p>该数组名为<code>sales</code>，有 5 个元素（一维数组），每个元素都是一个内含 12 个<code>double</code>类型值的数组。第 1 个一维数组是<code>sales[0]</code>，第 2 个一维数组是<code>sales[1]</code>，以此类推，每个元素都是内含 12 个<code>double</code>类型值的数组。使用第 2 个下标可以访问这些一维数组中的特定元素。例如，<code>sales[2][5]</code>是<code>slaes[2]</code>的第 6 个元素，而<code>sales[2]</code>是<code>sales</code>的第 3 个元素。</p>
<p>C 语言传递多维数组的传统方法是把数组名（即数组的地址）传递给类型匹配的指针形参。声明这样的指针形参要指定所有的数组维度，除了第 1 个维度。传递的第 1 个维度通常作为第 2 个参数。例如，为了处理前面声明的<code>sales</code>数组，函数原型和函数调用如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>　<span class="title function_">display</span><span class="params">(<span class="type">double</span>　ar[][<span class="number">12</span>],　<span class="type">int</span>　rows)</span>;</span><br><span class="line">...</span><br><span class="line">display(sales, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>变长数组提供第 2 种语法，把数组维度作为参数传递。在这种情况下，对应函数原型和函数调用如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>　<span class="title function_">display</span><span class="params">(<span class="type">int</span>　rows,　<span class="type">int</span>　cols,　<span class="type">double</span>　ar[rows][cols])</span>;</span><br><span class="line">...</span><br><span class="line">display(<span class="number">5</span>, <span class="number">12</span>, sales);</span><br></pre></td></tr></table></figure>

<p>虽然上述讨论中使用的是<code>int</code>类型的数组和<code>double</code>类型的数组，其他类型的数组也是如此。然而，字符串有一些特殊的规则，这是由于其末尾的空字符所致。有了这个空字符，不用传递数组的大小，函数通过检测字符串的末尾也知道在何处停止。我们将在以后章节中详细介绍。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>C Primer Plus</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>代理 Xcode SPM</title>
    <url>/2023/03/17/20230317-%E4%BB%A3%E7%90%86%20Xcode%20SPM/</url>
    <content><![CDATA[<p>由于网络问题，我们在使用 Xcode SPM 管理项目依赖库的时候，<code>clone</code>依赖库那速度真的是拉的一泻千里💩。所以我们需要将 SPM 下载依赖库的过程交给我们的代理去处理。首先你需要一个科学上网工具，无论是客户端还是路由器刷机，此文章的例子都是基于本人网络环境 <code>Surge</code>，其他的代理方式需自行研究。</p>
<span id="more"></span>

<h2 id="设置终端代理"><a href="#设置终端代理" class="headerlink" title="设置终端代理"></a>设置终端代理</h2><p><code>Surge</code>中按快捷键 <code>⌘ + c</code>复制终端代理命令，并终端中执行命令（<code>ClashX</code>客户端类似）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> https_proxy=http://127.0.0.1:6152;<span class="built_in">export</span> http_proxy=http://127.0.0.1:6152;<span class="built_in">export</span> all_proxy=socks5://127.0.0.1:6153</span><br></pre></td></tr></table></figure>

<h2 id="执行命令拉取依赖"><a href="#执行命令拉取依赖" class="headerlink" title="执行命令拉取依赖"></a>执行命令拉取依赖</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcodebuild -resolvePackageDependencies -scmProvider system</span><br><span class="line"><span class="comment"># 或者输入 project</span></span><br><span class="line">xcodebuild -resolvePackageDependencies -scmProvider system -project YOURPROJECT.xcodeproj</span><br><span class="line"><span class="comment"># 如果是 workspace 输入 -list</span></span><br><span class="line">xcodebuild -resolvePackageDependencies -scmProvider system -list -workspace YOURPROJECT.xcworkspace</span><br></pre></td></tr></table></figure>

<p>等命令执行完毕之后我们打开工程，此时可以看到依赖库已经拉取完毕，直接执行 <code>build</code>或<code>run</code>。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>科学上网</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Homebrew 管理 Ruby</title>
    <url>/2023/03/27/20230327-%E4%BD%BF%E7%94%A8%20Homebrew%20%E7%AE%A1%E7%90%86%20Ruby/</url>
    <content><![CDATA[<p>macOS 上的 Ruby 环境管理我相信是大多数软件开发都会遇到的一个问题，如果我们需要同时管理多个 Ruby 版本的话，有 <code>rbenv</code> 和 <code>rvm</code> 的方式，具体的操作网上已有大量的文章供我们学习，本文不再做赘述。今天我们来看一下如何使用 <code>Homebrew</code> 来管理我们的 Ruby。</p>
<p>什么情况下我们可以使用 <code>Homebrew</code> 来管理我们的 Ruby 环境？</p>
<ul>
<li>你只是学习一下 Ruby 语言</li>
<li>你只是想编译一个项目（例如我们使用 cocoapods 来管理我们的项目）</li>
</ul>
<p>在使用之前，首先我们需要知道用 <code>Homebrew</code> 来管理 Ruby 有什么缺点。</p>
<ul>
<li>当你升级其他 <code>Homebrew</code> 包时，Homebrew 可能会将 Ruby 更新到新版本</li>
<li>你不能非常轻松的在多个 Ruby 版本之间频繁切换</li>
</ul>
<p>如果你的需求不满足上述描述的话，特别是需要经常切换 Ruby 版本，那么 <code>Homebrew</code> 的方式就不是太适合。</p>
<span id="more"></span>

<h2 id="macOS-系统的-Ruby"><a href="#macOS-系统的-Ruby" class="headerlink" title="macOS 系统的 Ruby"></a>macOS 系统的 Ruby</h2><p>macOS 预装了“系统Ruby”。macOS Monterey 包含 Ruby 2.6.8，这不是最新版本。使用 macOS 系统 Ruby 不是一个好主意（参见：<span class="exturl" data-url="aHR0cHM6Ly9tYWMuaW5zdGFsbC5ndWlkZS9mYXEvZG8tbm90LXVzZS1tYWMtc3lzdGVtLXJ1YnkvaW5kZXguaHRtbA==">Do Not Use the MacOS System Ruby<i class="fa fa-external-link-alt"></i></span>）。系统 Ruby 的 <code>which ruby</code> 和 <code>ruby -v</code> 如下所示：</p>
<p><img src="/my_pictures/20230327/1.png"></p>
<p>我们保留系统 Ruby，使用 <code>Homebrew</code> 来安装最新版 Ruby。</p>
<h2 id="安装-Homebrew"><a href="#安装-Homebrew" class="headerlink" title="安装 Homebrew"></a>安装 Homebrew</h2><p>如果你还没安装 <code>Homebrew</code> 的话，请先安装 <span class="exturl" data-url="aHR0cHM6Ly9icmV3LnNoLw==">Homebrew<i class="fa fa-external-link-alt"></i></span>。</p>
<h2 id="安装-Ruby"><a href="#安装-Ruby" class="headerlink" title="安装 Ruby"></a>安装 Ruby</h2><h3 id="安装最新版的-Ruby"><a href="#安装最新版的-Ruby" class="headerlink" title="安装最新版的 Ruby"></a>安装最新版的 Ruby</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew install ruby</span><br></pre></td></tr></table></figure>

<h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><p>安装完成后，此时我们输入 <code>which ruby</code> 命令发现使用的还是系统 Ruby，因为我们还需要配置一下 <code>$PATH</code> 环境变量。这里使用 <code>zsh</code> 来举例。</p>
<p>我们执行如下命令来编辑我们的 <code>.zshrc</code> 文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ open -e ~/.zshrc</span><br></pre></td></tr></table></figure>

<p>如果安装过 <code>vs code</code> 的话，我们可以使用如下命令来编辑：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ code ~/.zshrc</span><br></pre></td></tr></table></figure>

<p>在 Intel 芯片的电脑上我们在 <code>zshrc</code> 文件末尾加上如下的配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -d <span class="string">&quot;/usr/local/opt/ruby/bin&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">export</span> PATH=/usr/local/opt/ruby/bin:<span class="variable">$PATH</span></span><br><span class="line">  <span class="built_in">export</span> PATH=`gem environment gemdir`/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>在 Apple 芯片的电脑上我们添加下列配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -d <span class="string">&quot;/opt/homebrew/opt/ruby/bin&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">export</span> PATH=/opt/homebrew/opt/ruby/bin:<span class="variable">$PATH</span></span><br><span class="line">  <span class="built_in">export</span> PATH=`gem environment gemdir`/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>这会将 Homebrew 安装的 Ruby 设置为比系统 Ruby 有更高的优先级，并添加用于 Ruby gem 的目录。</p>
<p>接下来重新打开终端，以便识别对 <code>.zshrc</code> 的更改。</p>
<h3 id="锁定-Ruby-更新"><a href="#锁定-Ruby-更新" class="headerlink" title="锁定 Ruby 更新"></a>锁定 Ruby 更新</h3><p>当您升级其他 Homebrew 包时，Homebrew 可能会将 Ruby 更新到新版本。如果你不想让 Homebrew 的 Ruby 版本被新版本取代，你可以使用 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew pin ruby</span><br></pre></td></tr></table></figure>

<p>来阻止对 Ruby 的更新。</p>
<h3 id="确认-Ruby-的安装"><a href="#确认-Ruby-的安装" class="headerlink" title="确认 Ruby 的安装"></a>确认 Ruby 的安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 若输出类似于如下 ruby 配置，则 ruby 环境切换成功</span></span><br><span class="line"><span class="comment"># /opt/homebrew/lib/ruby/gems/3.0.0/bin:/opt/homebrew/opt/ruby/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin</span></span><br></pre></td></tr></table></figure>

<p>在 Apple 芯片上, 你将看到 <code>/opt/homebrew/</code>， 在 Intel 芯片上, 你将看到 <code>/usr/local/</code>。</p>
<p>你可以使用 <code>brew list</code> 命令查看安装了哪些版本的 ruby</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew list</span><br><span class="line">==&gt; Formulae</span><br><span class="line">ca-certificates  libyaml  openssl@1.1  readline  ruby</span><br></pre></td></tr></table></figure>

<p>你也可以使用 <code>brew deps --tree --installed</code> 命令查看为 ruby 安装了哪些依赖。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew deps --tree --installed</span><br><span class="line">ca-certificates</span><br><span class="line"></span><br><span class="line">libyaml</span><br><span class="line"></span><br><span class="line">openssl@1.1</span><br><span class="line"></span><br><span class="line">readline</span><br><span class="line"></span><br><span class="line">ruby</span><br><span class="line">├── libyaml</span><br><span class="line">├── openssl@1.1</span><br><span class="line">│   └── ca-certificates</span><br><span class="line">└── readline</span><br></pre></td></tr></table></figure>

<p>执行命令 <code>ruby -v</code> 验证是否安装了最新版的 Ruby。</p>
<p><img src="/my_pictures/20230327/2.png"></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9tYWMuaW5zdGFsbC5ndWlkZS9ydWJ5LzEzLmh0bWw=">Install Ruby 3.1 · macOS<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言重拾【六】字符串和字符串函数</title>
    <url>/2023/03/28/20230328-C%20%E8%AF%AD%E8%A8%80%E9%87%8D%E6%8B%BE%E3%80%90%E5%85%AD%E3%80%91/</url>
    <content><![CDATA[<p>之前的文章介绍过，字符串是以空字符（\0）结尾的<code>char</code>类型数组。常用的输出字符串的方式有两种 <code>printf()</code>和<code>puts()</code>，他们不同之处在于，<code>printf()</code>是格式化输出字符串，而<code>puts()</code>只显示字符串。</p>
<h2 id="在程序中定义字符串"><a href="#在程序中定义字符串" class="headerlink" title="在程序中定义字符串"></a>在程序中定义字符串</h2><p>用双引号括起来的内容称为<strong>字符串字面量</strong>，也叫<strong>字符串常量</strong>。字符串常量属于<strong>静态存储类别</strong>，这说明如果在函数中使用字符串常量，该字符串只会被存储一次，在整个程序的生命期内存在，即使函数被调用多次。用双引号括起来的内容被视为指向该字符串存储位置的指针。这类似于把数组名作为指向该数组位置的指针。如果确实如此，下面的程序会输出什么？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s, %p, %c\n&quot;</span>, <span class="string">&quot;we&quot;</span>, <span class="string">&quot;are&quot;</span>, *<span class="string">&quot;space farers&quot;</span>);  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">we, 0x100003fa7, s</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="字符串数组与指针"><a href="#字符串数组与指针" class="headerlink" title="字符串数组与指针"></a>字符串数组与指针</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> ar1[] = <span class="string">&quot;Something is pointing at me.&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>数组形式和指针形式有何不同？以上面的声明为例，数组形式（<code>ar1[]</code>）在计算机的内存中分配为一个内含 29 个元素的数组（每个元素对应一个字符，还加上一个末尾的空字符 <code>&#39;\0&#39;</code>），每个元素被初始化为字符串字面量对应的字符。</p>
<blockquote>
<p>通常，字符串都作为可执行文件的一部分储存在数据段中。当把程序载入内存时，也载入了程序中的字符串。字符串储存在静态存储区（static memory）中。但是，程序在开始运行时才会为该数组分配内存。此时，才将字符串拷贝到数组中（接下来的章节将详细讲解）。注意，此时字符串有两个副本。一个是在静态内存中的字符串字面量，另一个是储存在 <code>ar1</code> 数组中的字符串。</p>
</blockquote>
<p>此后，编译器便把数组名 <code>ar1</code> 识别为该数组首元素地址（<code>&amp;ar1[0]</code>）的别名。这里关键要理解，在数组形式中，<code>ar1</code> 是地址常量。不能更改 <code>ar1</code>，如果改变了 <code>ar1</code>，则意味着改变了数组的存储位置（即地址）。可以进行类似 <code>ar1+1</code> 这样的操作，标识数组的下一个元素。但是不允许进行 <code>++ar1</code> 这样的操作。递增运算符只能用于变量名前（或概括地说，只能用于可修改的左值），不能用于常量。</p>
<p>指针形式（<code>*pt1</code>）也使得编译器为字符串在静态存储区预留 29 个元素的空间。另外，一旦开始执行程序，它会为指针变量 <code>pt1</code> 留出一个储存位置，并把字符串的地址储存在指针变量中。该变量最初指向该字符串的首字符，但是它的值可以改变。因此，可以使用递增运算符。例如，<code>++pt1</code> 将指向第 2 个字符（<code>o</code>）。</p>
<p>字符串字面量被视为 <code>const</code> 数据。由于 <code>pt1</code> 指向这个 <code>const</code> 数据，所以应该把 <code>pt1</code> 声明为指向 <code>const</code> 数据的指针。这意味着不能用 <code>pt1</code> 改变它所指向的数据，但是仍然可以改变 <code>pt1</code> 的值（即，<code>pt1</code> 指向的位置）。如果把一个字符串字面量拷贝给一个数组，就可以随意改变数据，除非把数组声明为 <code>const</code>。</p>
<p>总之，初始化数组把静态存储区的字符串拷贝到数组中，而初始化指针只把字符串的地址拷贝给指针。程序清单11.3演示了这一点。</p>
<p><strong>程序清单 11.3 addresses.c 程序</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// addresses.c -- 字符串的地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG <span class="string">&quot;I&#x27;m special&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> ar[] = MSG;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *pt = MSG;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;address of \&quot;I&#x27;m special\&quot;: %p \n&quot;</span>, <span class="string">&quot;I&#x27;m special&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;                address ar: %p\n&quot;</span>, ar);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;                address pt: %p\n&quot;</span>, pt);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;            address of MSG: %p\n&quot;</span>, MSG);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;address of \&quot;I&#x27;m special\&quot;: %p \n&quot;</span>, <span class="string">&quot;I&#x27;m special&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是在我们的系统中运行该程序后的输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">address of <span class="string">&quot;I&#x27;m special&quot;</span>:  <span class="number">0x100000f10</span></span><br><span class="line">              address ar:  <span class="number">0x7fff5fbff858</span></span><br><span class="line">              address pt:  <span class="number">0x100000f10</span></span><br><span class="line">          address of MSG:  <span class="number">0x100000f10</span></span><br><span class="line">address of <span class="string">&quot;I&#x27;m special&quot;</span>:  <span class="number">0x100000f10</span></span><br></pre></td></tr></table></figure>

<p>该程序的输出说明了什么？</p>
<ol>
<li><code>pt</code> 和 <code>MSG</code> 的地址相同，而 <code>ar</code> 的地址不同，这与我们前面讨论的内容一致。</li>
<li>虽然字符串字面量 <code>&quot;I&#39;m special&quot;</code> 在程序的两个 <code>printf()</code> 函数中出现了两次，但是编译器只使用了一个存储位置，而且与 <code>MSG</code> 的地址相同。编译器可以把多次使用的相同字面量储存在一处或多处。另一个编译器可能在不同的位置储存 3 个 <code>&quot;I&#39;m special&quot;</code>。</li>
<li>静态数据使用的内存与 <code>ar</code> 使用的动态内存不同。不仅值不同，特定编译器甚至使用不同的位数表示两种内存。</li>
</ol>
<h2 id="指针初始化字符串"><a href="#指针初始化字符串" class="headerlink" title="指针初始化字符串"></a>指针初始化字符串</h2><p>我们来看一下未使用 <code>const</code> 限定符的指针初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> * word = <span class="string">&quot;frame&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>是否能使用该指针修改这个字符串？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">word[<span class="number">1</span>] = <span class="string">&#x27;l&#x27;</span>; <span class="comment">// 是否允许？</span></span><br></pre></td></tr></table></figure>

<p>编译器可能允许这样做，但是对当前的 C 标准而言，这样的行为是未定义的。例如，这样的语句可能导致内存访问错误。原因前面提到过，编译器可以使用内存中的一个副本来表示所有完全相同的字符串字面量。例如，下面的语句都引用字符串 <code>&quot;Klingon&quot;</code> 的一个内存位置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> * p1 = <span class="string">&quot;Klingon&quot;</span>;</span><br><span class="line">p1[<span class="number">0</span>] = <span class="string">&#x27;F&#x27;</span>; <span class="comment">// ok?</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Klingon&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;: Beware the %ss!\n&quot;</span>, <span class="string">&quot;Klingon&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>也就是说，编译器可以用相同的地址替换每个 <code>&quot;Klingon&quot;</code> 实例。如果编译器使用这种单次副本表示法，并允许 <code>p1[0]</code> 修改 <code>&#39;F&#39;</code>，那将影响所有使用该字符串的代码。所以以上语句打印字符串字面量 <code>&quot;Klingon&quot;</code> 时实际上显示的是 <code>&quot;Flingon&quot;</code>：</p>
<blockquote>
<p>Flingon: Beware the Flingons!</p>
</blockquote>
<p>实际上在过去，一些编译器由于这方面的原因，其行为难以捉摸，而另一些编译器则导致程序异常中断。因此，建议在把指针初始化为字符串字面量时使用 <code>const</code> 限定符：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> * pl = <span class="string">&quot;Klingon&quot;</span>;　 <span class="comment">// 推荐用法</span></span><br></pre></td></tr></table></figure>

<p>然而，把非 <code>const</code> 数组初始化为字符串字面量却不会导致类似的问题。因为数组获得的是原始字符串的副本。</p>
<p>总之，如果不修改字符串，不要用指针指向字符串字面量。</p>
<h2 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a>字符串数组</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>　SLEN　40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>　LIM　5</span></span><br><span class="line">  </span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *mytalents[LIM] = &#123;</span><br><span class="line">  <span class="string">&quot;Adding　numbers　swiftly&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Multiplying　accurately&quot;</span>,　<span class="string">&quot;Stashing　data&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Following　instructions　to　the　letter&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Understanding　the　C　language&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> yourtalents[LIM][SLEN]　=　&#123;</span><br><span class="line">  <span class="string">&quot;Walking　in　a　straight　line&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Sleeping&quot;</span>,　<span class="string">&quot;Watching　television&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Mailing　letters&quot;</span>,　<span class="string">&quot;Reading　email&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从某些方面来看，<code>mytalents</code> 和 <code>yourtalents</code> 非常相似。两者都代表 5 个字符串。使用一个下标时都分别表示一个字符串，如 <code>mytalents[0]</code> 和 <code>yourtalents[0]</code> 使用两个下标时都分别表示一个字符，例如 <code>mytalents[1][2]</code> 表示 <code>mytalents</code> 数组中第 2 个指针所指向的字符串的第 3 个字符 <code>&#39;l&#39;</code>， <code>yourtalents[1][2]</code> 表示<code>youttalentes</code> 数组的第 2 个字符串的第 3 个字符 <code>&#39;e&#39;</code>。而且，两者的初始化方式也相同。</p>
<p>但是，它们也有区别。<code>mytalents</code> 数组是一个内含 5 个指针的数组，在我们的系统中共占用 40 字节。而 <code>yourtalents</code> 是一个内含 5 个数组的数组，每个数组内含 40 个 <code>char</code> 类型的值，共占用 200 字节。所以，虽然 <code>mytalents[0]</code> 和 <code>yourtalents[0]</code> 都分别表示一个字符串，但 <code>mytalents</code> 和 <code>yourtalents</code> 的类型并不相同。<code>mytalents</code> 中的指针指向初始化时所用的字符串字面量的位置，这些字符串字面量被储存在静态内存中；而 <code>yourtalents</code> 中的数组则储存着字符串字面量的副本，所以每个字符串都被储存了两次。此外，为字符串数组分配内存的使用率较低。<code>yourtalents</code> 中的每个元素的大小必须相同，而且必须是能储存最长字符串的大小。</p>
<p>我们可以把 <code>yourtalents</code> 想象成矩形二维数组，每行的长度都是 40 字节；把 <code>mytalents</code> 想象成不规则的数组，每行的长度不同。图 11.2 演示了这两种数组的情况（<strong>实际上，<code>mytalents</code> 数组的指针元素所指向的字符串不必储存在连续的内存中</strong>，图中所示只是为了强调两种数组的不同）。</p>
<img src="/my_pictures/20230328/1.png" style="zoom: 33%;" />

<p>综上所述，<strong>如果要用数组表示一系列待显示的字符串，请使用指针数组</strong>，因为它比二维字符数组的效率高。但是，指针数组也有自身的缺点。<code>mytalents</code> 中的指针指向的字符串字面量不能更改；而 <code>yourtalentsde</code> 中的内容可以更改。所以，<strong>如果要改变字符串或为字符串输入预留空间，不要使用指向字符串字面量的指针。</strong></p>
<h2 id="空字符与空指针"><a href="#空字符与空指针" class="headerlink" title="空字符与空指针"></a>空字符与空指针</h2><p>从概念上看，两者完全不同。空字符（或 <code>&#39;\0&#39;</code>）是用于标记 C 字符串末尾的字符，其对应字符编码是 0。由于其他字符的编码不可能是 0，所以不可能是字符串的一部分。</p>
<p>空指针（或 <code>NULL</code>）有一个值，该值不会与任何数据的有效地址对应。通常，函数使用它返回一个有效地址表示某些特殊情况发生，例如遇到文件结尾或未能按预期执行。</p>
<p>空字符是整数类型，而空指针是指针类型。两者有时容易混淆的原因是：它们都可以用数值 0 来表示。但是，从概念上看，两者是不同类型的 0。另外，<strong>空字符是一个字符，占 1 字节；而空指针是一个地址，通常占 4 字节</strong>。</p>
<h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><p>ANSI C 库有 20 多个用于处理字符串的函数，下面总结了一些常用的函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> * <span class="keyword">restrict</span> s1, <span class="type">const</span> <span class="type">char</span> * <span class="keyword">restrict</span> s2)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数把 <code>s2</code> 指向的字符串（包括空字符）拷贝至 <code>s1</code> 指向的位置，返回值是 s1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> * <span class="keyword">restrict</span> s1, <span class="type">const</span> <span class="type">char</span> * <span class="keyword">restrict</span> s2, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数把 <code>s2</code> 指向的字符串拷贝至 <code>s1</code> 指向的位置，拷贝的字符数不超过 <code>n</code>，其返回值是 <code>s1</code>。该函数不会拷贝空字符后面的字符，如果源字符串的字符少于 <code>n</code> 个，目标字符串就以拷贝的空字符结尾；如果源字符串有 <code>n</code> 个或超过 <code>n</code> 个字符，就不拷贝空字符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> * <span class="keyword">restrict</span> s1, <span class="type">const</span> <span class="type">char</span> * <span class="keyword">restrict</span> s2)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数把 <code>s2</code> 指向的字符串拷贝至 <code>s1</code> 指向的字符串末尾。<code>s2</code> 字符串的第 1 个字符将覆盖 <code>s1</code> 字符串末尾的空字符。该函数返回 <code>s1</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strncat</span><span class="params">(<span class="type">char</span> * <span class="keyword">restrict</span> s1, <span class="type">const</span> <span class="type">char</span> * <span class="keyword">restrict</span> s2, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数把 <code>s2</code> 字符串中的 <code>n</code> 个字符拷贝至 <code>s1</code> 字符串末尾。<code>s2</code> 字符串的第 1 个字符将覆盖 <code>s1</code> 字符串末尾的空字符。不会拷贝 <code>s2</code> 字符串中空字符和其后的字符，并在拷贝字符的末尾添加一个空字符。该函数返回 <code>s1</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * s1, <span class="type">const</span> <span class="type">char</span> * s2)</span>;</span><br></pre></td></tr></table></figure>

<p>如果 <code>s1</code> 字符串在机器排序序列中位于 <code>s2</code> 字符串的后面，该函数返回一个正数；如果两个字符串相等，则返回 0；如果 <code>s1</code> 字符串在机器排序序列中位于s2字符串的前面，则返回一个负数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * s1, <span class="type">const</span> <span class="type">char</span> * s2, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数的作用和 <code>strcmp()</code> 类似，不同的是，该函数在比较 <code>n</code> 个字符后或遇到第 1 个空字符时停止比较。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * s, <span class="type">int</span> c)</span>;</span><br></pre></td></tr></table></figure>

<p>如果 <code>s</code> 字符串中包含 <code>c</code> 字符，该函数返回指向 <code>s</code> 字符串首位置的指针（末尾的空字符也是字符串的一部分，所以在查找范围内）；如果在字符串 <code>s</code> 中未找到 <code>c</code> 字符，该函数则返回空指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strpbrk</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * s1, <span class="type">const</span> <span class="type">char</span> * s2)</span>;</span><br></pre></td></tr></table></figure>

<p>如果 <code>s1</code> 字符中包含 <code>s2</code> 字符串中的任意字符，该函数返回指向 <code>s1</code> 字符串首位置的指针；如果在 <code>s1</code> 字符串中未找到任何 <code>s2</code> 字符串中的字符，则返回空字符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strrchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * s, <span class="type">int</span> c)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数返回 <code>s</code> 字符串中 <code>c</code> 字符的最后一次出现的位置（末尾的空字符也是字符串的一部分，所以在查找范围内）。如果未找到 <code>c</code> 字符，则返回空指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * s1, <span class="type">const</span> <span class="type">char</span> * s2)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数返回指向 <code>s1</code> 字符串中 <code>s2</code> 字符串出现的首位置。如果在 <code>s1</code> 中没有找到 <code>s2</code>，则返回空指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * s)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数返回 <code>s</code> 字符串中的字符数，不包括末尾的空字符。</p>
<p>请注意，那些使用 <code>const</code> 关键字的函数原型表明，函数不会更改字符串。例如，下面的函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> * <span class="keyword">restrict</span> s1, <span class="type">const</span> <span class="type">char</span> * <span class="keyword">restrict</span> s2)</span>;</span><br></pre></td></tr></table></figure>

<p>表明不能更改 <code>s2</code> 指向的字符串，至少不能在 <code>strcpy()</code> 函数中更改。但是可以更改 <code>s1</code> 指向的字符串。这样做很合理，因为 <code>s1</code> 是目标字符串，要改变，而 <code>s2</code> 是源字符串，不能更改。</p>
<p>关键字 <code>restrict</code> 将在接下来的章节中介绍，该关键字限制了函数参数的用法。例如，不能把字符串拷贝给本身。</p>
<h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><p>许多程序都要处理文本数据。一个程序可能要求用户输入姓名、公司列表、地址、一种蕨类植物的学名、音乐剧的演员等。毕竟，我们用言语与现实世界互动，使用文本的例子不计其数。C 程序通过字符串的方式来处理它们。</p>
<p>字符串，无论是由字符数组、指针还是字符串常量标识，都储存为包含字符编码的一系列字节，并以空字符串结尾。C 提供库函数处理字符串，查找字符串并分析它们。尤其要牢记，应该使用 <code>strcmp()</code> 来代替关系运算符，当比较字符串时，应该使用 <code>strcpy()</code> 或 <code>strncpy()</code> 代替赋值运算符把字符串赋给字符数组。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C 字符串是一系列 <code>char</code> 类型的字符，以空字符（<code>&#39;\0&#39;</code>）结尾。字符串可以储存在字符数组中。字符串还可以用字符串常量来表示，里面都是字符，括在双引号中（空字符除外）。编译器提供空字符。因此，<code>&quot;joy&quot;</code> 被储存为 4 个字符 <code>j、o、y 和 \0</code>。<code>strlen()</code> 函数可以统计字符串的长度，空字符不计算在内。</p>
<p>字符串常量也叫作字符串——字面量，可用于初始化字符数组。为了容纳末尾的空字符，数组大小应该至少比容纳的数组长度多 1。也可以用字符串常量初始化指向 <code>char</code> 的指针。</p>
<p>函数使用指向字符串首字符的指针来表示待处理的字符串。通常，对应的实际参数是数组名、指针变量或用双引号括起来的字符串。无论是哪种情况，传递的都是首字符的地址。一般而言，没必要传递字符串的长度，因为函数可以通过末尾的空字符确定字符串的结束。</p>
<p><code>fgets()</code> 函数获取一行输入，<code>puts()</code> 和 <code>fputs()</code> 函数显示一行输出。它们都是 <code>stdio.h</code> 头文件中的函数，用于代替已被弃用的 <code>gets()</code>。</p>
<p>C 库中有多个字符串处理函数。在 ANSI C 中，这些函数都声明在 <code>string.h</code> 文件中。C 库中还有许多字符处理函数，声明在 <code>ctype.h</code> 文件中。</p>
<p>给 <code>main()</code> 函数提供两个合适的形式参数，可以让程序访问命令行参数。第 1 个参数通常是 <code>int</code> 类型的 <code>argc</code>，其值是命令行的单词数量。第 2 个参数通常是一个指向数组的指针 <code>argv</code>，数组内含指向 <code>char</code> 的指针。每个指向 <code>char</code> 的指针都指向一个命令行参数字符串，<code>argv[0]</code> 指向命令名称，<code>argv[1]</code>指向第 1 个命令行参数，以此类推。</p>
<p><code>atoi()</code>、<code>atol()</code> 和 <code>atof()</code> 函数把字符串形式的数字分别转换成 <code>int</code>、<code>long</code> 和 <code>double</code> 类型的数字。<code>strtol()</code>、<code>strtoul()</code> 和<code>strtod()</code> 函数把字符串形式的数字分别转换成 <code>long</code>、<code>unsigned long</code> 和 <code>double</code> 类型的数字。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>C Primer Plus</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>ProvisionQL 简介</title>
    <url>/2023/03/30/20230330-ProvisionQL%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>ProvisionQL 是一款支持快速预览 <code>ipa</code> 和 <code>provision</code> 等文件信息的插件。它能以美观整洁的页面快速预览大量信息，包括设备 UUID、证书、授权等等。</p>
<p>截图示例如下：</p>
<img src="/my_pictures/20230330/1.png" style="zoom: 33%;" />

<p>此插件支持的文件类型有：</p>
<ul>
<li><code>.ipa</code> - iOS 的打包应用</li>
<li><code>.xcarchive</code> - Xcode archive</li>
<li><code>.appex</code> - iOS&#x2F;OSX 应用扩展</li>
<li><code>.mobileprovision</code> - iOS provisioning profile</li>
<li><code>.provisionprofile</code> - OSX provisioning profile</li>
</ul>
<span id="more"></span>

<h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><p>在 macOS 上我们可以通过 <code>Homebrew</code> 的方式安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew install --cask provisionql</span><br></pre></td></tr></table></figure>

<p>安装之后我们就可以在文件上通过按空格键快速查看文件信息。</p>
<h2 id="插件冲突修复"><a href="#插件冲突修复" class="headerlink" title="插件冲突修复"></a>插件冲突修复</h2><p>安装之后我们会发现，如果我们在 <code>.mobileprovision</code> 类型的文件上按空格并未启用 <code>ProvisionQL</code> 的快速预览功能，这是因为 Xcode 现在有了自己的 Mobile Provision Quick Look 插件。因为它是应用程序提供的，<strong>它将覆盖用户安装的插件</strong>，包括 ProvisionQL。不过 ProvisionQL 仍然适用于 IPA 和 <code>xcarchive</code>，但如果你更喜欢它也适用于<code>.mobileprovision</code>，只需在此处删除 Xcode 的 QL 插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/Library/QuickLook/DVTProvisioningProfileQuicklookGenerator.qlgenerator</span><br></pre></td></tr></table></figure>

<p>删除之后最好运行一下如下命令，此命令会强制重新加载生成器列表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ qlmanage -r</span><br></pre></td></tr></table></figure>

<p>现在我们就可以愉快的使用 <code>ProvisionQL</code>。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VhbGVrc2FuZHJvdi9Qcm92aXNpb25RTA==">ProvisionQL - Quick Look for ipa &amp; provision<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9pb3NleGFtcGxlLmNvbS9xdWljay1sb29rLXBsdWdpbi1mb3ItYXBwcy1hbmQtcHJvdmlzaW9uaW5nLXByb2ZpbGUtZmlsZXMv">Quick Look plugin for apps and provisioning profile files<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>编译 objc4-866.9 源码</title>
    <url>/2023/04/08/20230408-%E7%BC%96%E8%AF%91ojbc4%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h2 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h2><ul>
<li>macOS Ventura 13.3</li>
<li>Xcode 14.3</li>
<li>Apple M2 Pro</li>
</ul>
<p>如果环境大体相同可用我已整理好的工程：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JlZ3VsdXNsZW93L2J1aWxkT2JqYzRTb3VyY2VDb2Rl">objc4-866.9 源码编译<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>

<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p>建议到 <span class="exturl" data-url="aHR0cHM6Ly9vcGVuc291cmNlLmFwcGxlLmNvbS9yZWxlYXNlcy8=">Apple Open Source<i class="fa fa-external-link-alt"></i></span> 下载对应版本的包，此处指列出本机环境所需要的包</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlLW9zcy1kaXN0cmlidXRpb25zL29iamM0L2FyY2hpdmUvb2JqYzQtODY2LjkudGFyLmd6">objc4-866.9<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlLW9zcy1kaXN0cmlidXRpb25zL2R5bGQvYXJjaGl2ZS9keWxkLTEwNDIuMS50YXIuZ3o=">dyld-1042.1<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlLW9zcy1kaXN0cmlidXRpb25zL0xpYmMvYXJjaGl2ZS9MaWJjLTE1MzQuODEuMS50YXIuZ3o=">Libc-1534.81.1<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlLW9zcy1kaXN0cmlidXRpb25zL0xpYmMvYXJjaGl2ZS9yZWZzL3RhZ3MvTGliYy04MjUuNDAuMS56aXA=">Libc-825.40.1<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlLW9zcy1kaXN0cmlidXRpb25zL2xpYmNsb3N1cmUvYXJjaGl2ZS9saWJjbG9zdXJlLTg0LnRhci5neg==">libclosure-84<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlLW9zcy1kaXN0cmlidXRpb25zL2xpYmRpc3BhdGNoL2FyY2hpdmUvbGliZGlzcGF0Y2gtMTQxMi50YXIuZ3o=">libdispatch-1412<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlLW9zcy1kaXN0cmlidXRpb25zL2xpYnBsYXRmb3JtL2FyY2hpdmUvbGlicGxhdGZvcm0tMjg4LnRhci5neg==">libplatform-288<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlLW9zcy1kaXN0cmlidXRpb25zL2xpYnB0aHJlYWQvYXJjaGl2ZS9saWJwdGhyZWFkLTUxNC50YXIuZ3o=">libpthread-514<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlLW9zcy1kaXN0cmlidXRpb25zL3hudS9hcmNoaXZlL3hudS04NzkyLjgxLjIudGFyLmd6">xnu-8792.81.2<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="工程修改"><a href="#工程修改" class="headerlink" title="工程修改"></a>工程修改</h2><p>我们在 <code>objc4</code> 工程目录下新建一个 <code>include</code> 文件夹，用来存放修复编译问题的头文件。</p>
<h3 id="修改脚本"><a href="#修改脚本" class="headerlink" title="修改脚本"></a>修改脚本</h3><p>修改 <code>objc target</code> 的 <code>Run Script (markgc)</code> 脚本，将 <code>macosx.internal</code> 改成 <code>macosx</code>：</p>
<img src="/my_pictures/2023040801/1.png" style="zoom:40%;" />

<h3 id="修改Base-SDK"><a href="#修改Base-SDK" class="headerlink" title="修改Base SDK"></a>修改<code>Base SDK</code></h3><p>在 <code>Project</code> -&gt; <code>build setting</code> -&gt; <code>Base SDK</code>，选择 <code>macOS</code>：</p>
<img src="/my_pictures/2023040801/2.png" style="zoom:40%;" />

<h3 id="修改编译目标"><a href="#修改编译目标" class="headerlink" title="修改编译目标"></a>修改编译目标</h3><img src="/my_pictures/2023040801/3.png" style="zoom:50%;" />

<h3 id="设置-Header-Search-Paths"><a href="#设置-Header-Search-Paths" class="headerlink" title="设置 Header Search Paths"></a>设置 <code>Header Search Paths</code></h3><p>将我们刚才创建的 <code>include</code> 文件夹路径添加到 <code>Header Search Paths</code> 中</p>
<img src="/my_pictures/2023040801/4.png" style="zoom:38%;" />

<h3 id="编译-objc-并修复错误"><a href="#编译-objc-并修复错误" class="headerlink" title="编译 objc 并修复错误"></a>编译 <code>objc</code> 并修复错误</h3><p>有关错误修复可查看这两篇文章，需要修复的错误有点多，这里不再罗列，只添加这两篇文章中没有的问题修复。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDY4NTM5ODAzMzE4MzUzOTI4">iOS objc4-838编译流程，可在macOS Monterey运行<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MTEwOTc1OTIyNTA4OTM5MzAx">objc4-841.13可调试&#x2F;编译源码更新(for M1)<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="‘sandbox-private-h’-file-not-found"><a href="#‘sandbox-private-h’-file-not-found" class="headerlink" title="‘sandbox&#x2F;private.h’ file not found"></a>‘sandbox&#x2F;private.h’ file not found</h3><p>错误如图，直接注释掉 <code>#include &lt;sandbox/private.h&gt;</code> 即可。</p>
<img src="/my_pictures/2023040801/7.png" style="zoom:40%;" />

<h3 id="Use-of-undeclared-identifier-‘SANDBOX-FILTER-PATH’"><a href="#Use-of-undeclared-identifier-‘SANDBOX-FILTER-PATH’" class="headerlink" title="Use of undeclared identifier ‘SANDBOX_FILTER_PATH’"></a>Use of undeclared identifier ‘SANDBOX_FILTER_PATH’</h3><p>注释掉 <code>#include &lt;sandbox/private.h&gt;</code> 再编译会遇到如下错误：</p>
<img src="/my_pictures/2023040801/8.png" style="zoom:40%;" />

<p>解决方式同样是直接注释掉相关代码，如下图：</p>
<img src="/my_pictures/2023040801/9.png" style="zoom:50%;" />

<p>或者注释掉这个方法体也可。</p>
<h2 id="创建调试-target"><a href="#创建调试-target" class="headerlink" title="创建调试 target"></a>创建调试 <code>target</code></h2><p>进行完上面的错误修复后，我们就可以创建一个用于调试的 <code>target</code>。如下图，我们创建一个 macOS 的命令行 <code>target</code>。</p>
<img src="/my_pictures/2023040801/5.png" style="zoom:40%;" />

<h3 id="添加依赖和动态库"><a href="#添加依赖和动态库" class="headerlink" title="添加依赖和动态库"></a>添加依赖和动态库</h3><img src="/my_pictures/2023040801/10.png" style="zoom:40%;" />

<h3 id="修复断点不走问题"><a href="#修复断点不走问题" class="headerlink" title="修复断点不走问题"></a>修复断点不走问题</h3><h4 id="设置-Enable-Hardened-Runtime-为-NO"><a href="#设置-Enable-Hardened-Runtime-为-NO" class="headerlink" title="设置 Enable Hardened Runtime 为 NO"></a>设置 <code>Enable Hardened Runtime</code> 为 NO</h4><img src="/my_pictures/2023040801/11.png" style="zoom:45%;" />

<h4 id="在-Build-Phases-的-Compile-Sources-中，将-main-m-拖到最前面"><a href="#在-Build-Phases-的-Compile-Sources-中，将-main-m-拖到最前面" class="headerlink" title="在 Build Phases 的 Compile Sources 中，将 main.m 拖到最前面"></a>在 <code>Build Phases</code> 的 <code>Compile Sources</code> 中，将 <code>main.m </code>拖到最前面</h4><img src="/my_pictures/2023040801/12.png" style="zoom:50%;" />

<h2 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h2><ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9vcGVuc291cmNlLmFwcGxlLmNvbS8=">Open Source at Apple<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDY4NTM5ODAzMzE4MzUzOTI4">iOS objc4-838编译流程，可在macOS Monterey运行<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MTEwOTc1OTIyNTA4OTM5MzAx">objc4-841.13可调试&#x2F;编译源码更新(for M1)<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>编译 Swift 5.8 源码</title>
    <url>/2023/04/08/20230408-%E7%BC%96%E8%AF%91Swift%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h2 id="编译准备"><a href="#编译准备" class="headerlink" title="编译准备"></a>编译准备</h2><p>首先保证硬盘空间足够，本人一套流程下来文件夹有将近 60GB 大小。接下来是相关环境的安装，因为我的环境都是最新的，所以基本安装的都是最新版的包，如果你的环境不是新版的话，请找对应版本包安装。本人环境说明：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>芯片</td>
<td>Apple M2 Pro</td>
</tr>
<tr>
<td>macOS</td>
<td>Ventura 13.3</td>
</tr>
<tr>
<td>Python</td>
<td>3.11.2</td>
</tr>
<tr>
<td>CMake</td>
<td>3.26.3</td>
</tr>
<tr>
<td>ninja</td>
<td>1.11.1</td>
</tr>
<tr>
<td>sccache</td>
<td>0.4.1</td>
</tr>
<tr>
<td>Xcode</td>
<td>14.3</td>
</tr>
</tbody></table>
<p>我们可以通过 <code>homebrew</code> 统一安装环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew install cmake ninja sccache</span><br></pre></td></tr></table></figure>

<p>此文只介绍 Xcode 调试环境，如果想用 VS Code 调试的话，需要用 Ninja 编译，Ninja 的编译请移步官方文档。</p>
<span id="more"></span>

<h2 id="项目拉取"><a href="#项目拉取" class="headerlink" title="项目拉取"></a>项目拉取</h2><p>首先我们在文稿中新建一个文件夹，然后 <code>cd</code> 到我们的目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> ~/Documents/swift-project</span><br><span class="line">$ <span class="built_in">cd</span> ~/Documents/swift-project</span><br></pre></td></tr></table></figure>

<p>然后找到你的 <code>Xcode</code> 所支持的 Swift 版本，因为本人的 Xcode 为 14.3 版本，所以直接下载 <code>Swift 5.8 Release</code>。查找 Xcode 对应的 Swift 的版本有两种方式：</p>
<ol>
<li><p>去官网，查看 Xcode 的 Release Notes，在 Overview 中会有介绍。例如：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2RvY3VtZW50YXRpb24veGNvZGUtcmVsZWFzZS1ub3Rlcy94Y29kZS0xNF8zLXJlbGVhc2Utbm90ZXM=">Xcode 14.3 Release Notes<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>终端运行命令查看 <code>xcrun swift -version</code>。</p>
<p>本地环境输出如下：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">swift-driver version: 1.75.2 Apple Swift version 5.8 (swiftlang-5.8.0.124.2 clang-1403.0.22.11.100)</span><br><span class="line">Target: arm64-apple-macosx13.0</span><br></pre></td></tr></table></figure></li>
</ol>
<p>我们在刚才新建的目录中执行如下命令拉取对应的 Swift 源码，并 <code>cd</code> 到源码目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> --branch swift-5.8-RELEASE git@github.com:apple/swift.git</span><br><span class="line">$ <span class="built_in">cd</span> swift</span><br></pre></td></tr></table></figure>

<p>拉取源码后还须拉取依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ utils/update-checkout --tag swift-5.8-RELEASE --<span class="built_in">clone</span></span><br></pre></td></tr></table></figure>

<p>顺便说一句，上述操作最好全程科学上网。</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>一切准备完毕后我们将开始第一步编译，这里我们需要用到官方的脚本，在 <code>utils</code> 目录下的 <code>build-script</code> 脚本，以下是本人所使用的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ utils/build-script \</span><br><span class="line">--release-debuginfo --debug-swift-stdlib \</span><br><span class="line">--xcode --skip-ios --skip-watchos --skip-tvos \</span><br><span class="line">--skip-early-swiftsyntax --swift-darwin-supported-archs=<span class="string">&quot;<span class="subst">$(uname -m)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>编译命令的参数最好做一些简单了解，不要盲目复制粘贴，这里只展示苹果 M 系列芯片的 <code>arm64</code> 架构编译命令，如果你是 <code>Intel</code> 环境请自行查阅官方文档。或执行 <code>utils/build-script --help</code> 命令查阅。</p>
</blockquote>
<p>我们来简单的介绍一下这里众多的参数：</p>
<ul>
<li><p><code>--release-debuginfo</code> 编译出带有 <code>RelWithDebInfo</code> 环境变量的工程，类似于 <code>Debug</code> 和 <code>Release</code> 模式，<code>RelWithDebInfo</code> 会优化一部分，但同时保留调试信息。</p>
</li>
<li><p><code>--debug-swift-stdlib</code> 编译带有调试信息的 <code>Swift标准库</code>，如果想调试 <code>Swift编译器</code>，可以使用 <code>--debug-swift</code>。</p>
</li>
<li><p><code>--xcode</code> 使用 <code>CMake</code> 的 Xcode 生成器，编译完成后会生成一个 <code>Swift.xcodeproj</code> 工程。</p>
</li>
<li><p><code>--skip-ios --skip-watchos --skip-tvos</code> 跳过相应平台，这里只编译 <code>macOS</code> 平台。</p>
</li>
<li><p><code>--swift-darwin-supported-archs=&quot;$(uname -m)&quot;</code> 编译相关架构，<code>$(uname -m)</code> 命令用于获取机器架构环境，例如本机获取的结果为 <code>arm64</code>。</p>
</li>
</ul>
<blockquote>
<p> <code>--skip-early-swiftsyntax</code> 这个命令我们留到后面错误修复的时候再说，这里先留个悬念。</p>
</blockquote>
<p>接下来我们回车执行命令，这里需要等待一段时间，编译时间长短与机器性能有关。编译结束之后，我们会在目录 <code>~/Documents/swift-project</code> 下得到一个 <code>build</code> 文件夹，里面就是我们 <code>build</code> 的产物。</p>
<p><code>Xcode-RelWithDebInfoAssert+stdlib-DebugAssert</code>。目录结构如下图：</p>
<img src="/my_pictures/20230408/1.png" style="zoom: 40%;" />

<p>至此第一阶段编译完成，离成功又近了一步，接下来我们进入 Xcode 编译阶段。</p>
<h2 id="源码调试"><a href="#源码调试" class="headerlink" title="源码调试"></a>源码调试</h2><p>进入目录 <code>swift-macosx-arm64</code> 双击打开 Xcode 工程，此时会有自动创建 <code>schemes</code> 的提示，如下图，我们选择自动创建。</p>
<img src="/my_pictures/20230408/2.png" style="zoom:50%;" />

<h3 id="创建自定义-target-用于调试"><a href="#创建自定义-target-用于调试" class="headerlink" title="创建自定义 target 用于调试"></a>创建自定义 target 用于调试</h3><p>在 <code>Swift.xcodeproj</code> 工程里面，我们点击 <code>TARGETS</code> 下面的 <code>+</code> 新建一个调试的 <code>target</code>，我们选择 macOS 的命令行模式。如下图：</p>
<img src="/my_pictures/20230408/3.png" style="zoom:40%;" />

<p><code>Product Name</code> 取个自定义名字就行。接下来为我们的 <code>target</code> 引入依赖，如下图：</p>
<img src="/my_pictures/20230408/4.png" style="zoom:50%;" />

<p>接下来我们需要在设置中关闭 <code>Hardened Runtime</code> 选项，如下图：</p>
<img src="/my_pictures/20230408/5.png" style="zoom:50%;" />

<p>如果想了解更多关于 <code>Hardened Runtime</code> 的介绍，请查看官方文档：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2RvY3VtZW50YXRpb24vc2VjdXJpdHkvaGFyZGVuZWRfcnVudGltZQ==">Hardened Runtime<i class="fa fa-external-link-alt"></i></span>。</p>
<p>我们还须将 <code>target scheme</code> 的 <code>Build Configuration</code> 修改为 <code>ReWithDebInfo</code>。</p>
<img src="/my_pictures/20230408/7.png" style="zoom:40%;" />

<p>最后我们在自定义 <code>target</code> 文件夹下的 <code>main.swift</code> 文件中添加相应的代码，并在 <code>HeapObject.cpp</code> 中设置断点就可以开始愉快的调试了。如下图：</p>
<img src="/my_pictures/20230408/6.png" style="zoom:50%;" />

<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>在编译源码的过程中，本人遇到了几个问题，列在这里用以记录，也方便他人。</p>
<h3 id="执行脚本阶段，最开始我执行的脚本并没有添加-skip-early-swiftsyntax-这两个参数，脚本执行不通过，报错如下："><a href="#执行脚本阶段，最开始我执行的脚本并没有添加-skip-early-swiftsyntax-这两个参数，脚本执行不通过，报错如下：" class="headerlink" title="执行脚本阶段，最开始我执行的脚本并没有添加 --skip-early-swiftsyntax 这两个参数，脚本执行不通过，报错如下："></a>执行脚本阶段，最开始我执行的脚本并没有添加 <code>--skip-early-swiftsyntax</code> 这两个参数，脚本执行不通过，报错如下：</h3><blockquote>
<p>CMake Error in lib&#x2F;ASTGen&#x2F;CMakeLists.txt:<br>  Imported target “SwiftSyntax::SwiftBasicFormat” includes non-existent path</p>
<pre><code>&quot;/Users/jiafengwu/Documents/github/buildSwiftSource/build/Xcode-RelWithDebInfoAssert+stdlib-DebugAssert/earlyswiftsyntax-macosx-arm64/lib/swift/host&quot;
</code></pre>
<p>  in its INTERFACE_INCLUDE_DIRECTORIES.  Possible reasons include:</p>
<ul>
<li><p>The path was deleted, renamed, or moved to another location.</p>
</li>
<li><p>An install or uninstall procedure did not complete successfully.</p>
</li>
<li><p>The installation package was faulty and references files it does not<br>provide.</p>
</li>
</ul>
<p>CMake Error in lib&#x2F;ASTGen&#x2F;CMakeLists.txt:<br>  Imported target “SwiftSyntax::SwiftBasicFormat” includes non-existent path</p>
<pre><code>&quot;/Users/jiafengwu/Documents/github/buildSwiftSource/build/Xcode-RelWithDebInfoAssert+stdlib-DebugAssert/earlyswiftsyntax-macosx-arm64/lib/swift/host&quot;
</code></pre>
<p>  in its INTERFACE_INCLUDE_DIRECTORIES.  Possible reasons include:</p>
<ul>
<li><p>The path was deleted, renamed, or moved to another location.</p>
</li>
<li><p>An install or uninstall procedure did not complete successfully.</p>
</li>
<li><p>The installation package was faulty and references files it does not<br>provide.</p>
</li>
</ul>
<p>CMake Error in lib&#x2F;ASTGen&#x2F;CMakeLists.txt:<br>  Imported target “SwiftSyntax::SwiftBasicFormat” includes non-existent path</p>
<pre><code>&quot;/Users/jiafengwu/Documents/github/buildSwiftSource/build/Xcode-RelWithDebInfoAssert+stdlib-DebugAssert/earlyswiftsyntax-macosx-arm64/lib/swift/host&quot;
</code></pre>
<p>  in its INTERFACE_INCLUDE_DIRECTORIES.  Possible reasons include:</p>
<ul>
<li><p>The path was deleted, renamed, or moved to another location.</p>
</li>
<li><p>An install or uninstall procedure did not complete successfully.</p>
</li>
<li><p>The installation package was faulty and references files it does not<br>provide.</p>
</li>
</ul>
<p>CMake Error in lib&#x2F;ASTGen&#x2F;CMakeLists.txt:<br>  Imported target “SwiftSyntax::SwiftBasicFormat” includes non-existent path</p>
<pre><code>&quot;/Users/jiafengwu/Documents/github/buildSwiftSource/build/Xcode-RelWithDebInfoAssert+stdlib-DebugAssert/earlyswiftsyntax-macosx-arm64/lib/swift/host&quot;
</code></pre>
<p>  in its INTERFACE_INCLUDE_DIRECTORIES.  Possible reasons include:</p>
<ul>
<li><p>The path was deleted, renamed, or moved to another location.</p>
</li>
<li><p>An install or uninstall procedure did not complete successfully.</p>
</li>
<li><p>The installation package was faulty and references files it does not<br>provide.</p>
</li>
</ul>
<p>CMake Error in lib&#x2F;Parse&#x2F;CMakeLists.txt:<br>  Imported target “SwiftSyntax::SwiftBasicFormat” includes non-existent path</p>
<pre><code>&quot;/Users/jiafengwu/Documents/github/buildSwiftSource/build/Xcode-RelWithDebInfoAssert+stdlib-DebugAssert/earlyswiftsyntax-macosx-arm64/lib/swift/host&quot;
</code></pre>
<p>  in its INTERFACE_INCLUDE_DIRECTORIES.  Possible reasons include:</p>
<ul>
<li><p>The path was deleted, renamed, or moved to another location.</p>
</li>
<li><p>An install or uninstall procedure did not complete successfully.</p>
</li>
<li><p>The installation package was faulty and references files it does not<br>provide.</p>
</li>
</ul>
<p>CMake Error in lib&#x2F;Parse&#x2F;CMakeLists.txt:<br>  Imported target “SwiftSyntax::SwiftBasicFormat” includes non-existent path</p>
<pre><code>&quot;/Users/jiafengwu/Documents/github/buildSwiftSource/build/Xcode-RelWithDebInfoAssert+stdlib-DebugAssert/earlyswiftsyntax-macosx-arm64/lib/swift/host&quot;
</code></pre>
<p>  in its INTERFACE_INCLUDE_DIRECTORIES.  Possible reasons include:</p>
<ul>
<li><p>The path was deleted, renamed, or moved to another location.</p>
</li>
<li><p>An install or uninstall procedure did not complete successfully.</p>
</li>
<li><p>The installation package was faulty and references files it does not<br>provide.</p>
</li>
</ul>
<p>CMake Error in lib&#x2F;Parse&#x2F;CMakeLists.txt:<br>  Imported target “SwiftSyntax::SwiftBasicFormat” includes non-existent path</p>
<pre><code>&quot;/Users/jiafengwu/Documents/github/buildSwiftSource/build/Xcode-RelWithDebInfoAssert+stdlib-DebugAssert/earlyswiftsyntax-macosx-arm64/lib/swift/host&quot;
</code></pre>
<p>  in its INTERFACE_INCLUDE_DIRECTORIES.  Possible reasons include:</p>
<ul>
<li><p>The path was deleted, renamed, or moved to another location.</p>
</li>
<li><p>An install or uninstall procedure did not complete successfully.</p>
</li>
<li><p>The installation package was faulty and references files it does not<br>provide.</p>
</li>
</ul>
<p>CMake Error in lib&#x2F;Parse&#x2F;CMakeLists.txt:<br>  Imported target “SwiftSyntax::SwiftBasicFormat” includes non-existent path</p>
<pre><code>&quot;/Users/jiafengwu/Documents/github/buildSwiftSource/build/Xcode-RelWithDebInfoAssert+stdlib-DebugAssert/earlyswiftsyntax-macosx-arm64/lib/swift/host&quot;
</code></pre>
<p>  in its INTERFACE_INCLUDE_DIRECTORIES.  Possible reasons include:</p>
<ul>
<li><p>The path was deleted, renamed, or moved to another location.</p>
</li>
<li><p>An install or uninstall procedure did not complete successfully.</p>
</li>
<li><p>The installation package was faulty and references files it does not<br>provide.</p>
</li>
</ul>
</blockquote>
<p>从上面的报错可看出，出错的原因是在编译 <code>earlyswiftsyntax</code> 的时候。要修复此问题，我们只需添加参数 <code>--skip-early-swiftsyntax</code> 即可，让其在执行编译命令的时候跳过 <code>earlyswiftsyntax</code> 的构建。因为这并不影响我们最终的源码调试。</p>
<h3 id="Xcode-编译阶段，第一次执行编译的时候出现了如下的错误："><a href="#Xcode-编译阶段，第一次执行编译的时候出现了如下的错误：" class="headerlink" title="Xcode 编译阶段，第一次执行编译的时候出现了如下的错误："></a>Xcode 编译阶段，第一次执行编译的时候出现了如下的错误：</h3><img src="/my_pictures/20230408/8.png" style="zoom: 33%;" />

<p>这是由于在执行 <code>utils/build-script --xcode</code> 的时候 <code>cxxshim</code> 试图创建模块目录导致。我们只需要将 <code>swift/stdlib/public/Cxx/cxxshim/CMakeLists.txt</code> 此文件中的如下命令删除即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">list(APPEND outputs <span class="variable">$&#123;module_dir&#125;</span>)</span><br><span class="line"><span class="keyword">if</span>(SWIFT_BUILD_STATIC_STDLIB)</span><br><span class="line">  list(APPEND outputs <span class="variable">$&#123;module_dir_static&#125;</span>)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>

<p>然后清空 <code>build</code> 目录，重新执行 <code>utils/build-script</code> 进行构建即可。</p>
<h3 id="接下来一切完成后，继续-Xcode-编译又会出现如下错误"><a href="#接下来一切完成后，继续-Xcode-编译又会出现如下错误" class="headerlink" title="接下来一切完成后，继续 Xcode 编译又会出现如下错误:"></a>接下来一切完成后，继续 Xcode 编译又会出现如下错误:</h3><img src="/my_pictures/20230408/9.png" style="zoom:40%;" />

<p>看报错是 <code>llvm-macosx-arm64</code> 中的 <code>Debug</code> 目录下没有相应的文件。首先我们查看 <code>swift-compatibility-symbols</code> 这个 <code>target</code> 将其 <code>Build Configuration</code> 修改为 <code>ReWithDebInfo</code> 。然后我们在执行编译即可。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0L2Jsb2Ivc3dpZnQtNS44LVJFTEVBU0UvZG9jcy9Ib3dUb0d1aWRlcy9HZXR0aW5nU3RhcnRlZC5tZA==">How to Set Up an Edit-Build-Test-Debug Loop<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0L2lzc3Vlcy82MjAxNw==">Bootstrapping broken for Ninja builds on Apple silicon Macs (arm64) <i class="fa fa-external-link-alt"></i></span></li>
<li><a href="https://forums.swift.org/t/problems-with-build-script-building-compiler-with-xcode/53477/7">Problems with <code>build-script</code> building compiler with <code>–xcode</code></a></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0L3B1bGwvNjE3MzY=">Fix multiple commands produce ${SWIFTLIB_DIR}&#x2F;${arch_subdir}<i class="fa fa-external-link-alt"></i></span></li>
<li><a href="https://github.com/apple/swift/issues/62645">CMake error when running <code>build-script</code> with <code>--xcode</code> </a></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MTAxODcyODg1MDM1MTcxODc3">Swift源码编译调试(M1&#x2F;Xcode)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDY0MDc3ODM2NzU1MTQwNjQ1">超实用～使用Xcode编译Swift源码<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 使用 fastlane 打包</title>
    <url>/2023/04/10/20230410-iOS%E4%BD%BF%E7%94%A8fastlane%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<p>在一款 App 从开发到上架都会经历 <code>编译 -&gt; 打包 -&gt; 签名 -&gt; 推送 App Store Connect -&gt; 提审 -&gt; 上架</code> 的过程。其中编译打包这种重复且繁琐的工作公司内都会有一个 CI 平台去负责，我们今天就来了解一下 CI 的编译打包流程是怎样的。</p>
<span id="more"></span>

<h2 id="fastlane-简介"><a href="#fastlane-简介" class="headerlink" title="fastlane 简介"></a>fastlane 简介</h2><p>fastlane 是自动为 iOS 和 Android 应用程序进行测试版部署和发布的最简单方式。它会为你处理所有繁琐的任务，如生成屏幕截图、处理代码签名和发布应用程序。</p>
<p>下面是一个简单的编译发布的例子：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">lane <span class="symbol">:beta</span> <span class="keyword">do</span></span><br><span class="line">  increment_build_number</span><br><span class="line">  build_app</span><br><span class="line">  upload_to_testflight</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">lane <span class="symbol">:release</span> <span class="keyword">do</span></span><br><span class="line">  capture_screenshots</span><br><span class="line">  build_app</span><br><span class="line">  upload_to_app_store       <span class="comment"># 将屏幕截图和二进制文件上传到 iTunes</span></span><br><span class="line">  slack                     <span class="comment"># 让你的队友知道新版本上线了</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>上面的代码定义了两个不同的打包流程，如果你想在 App Store 发布你的应用，你只需要执行如下操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ fastlane release</span><br></pre></td></tr></table></figure>

<!-- more -->

<h2 id="使用-fastlane-执行打包流程"><a href="#使用-fastlane-执行打包流程" class="headerlink" title="使用 fastlane 执行打包流程"></a>使用 fastlane 执行打包流程</h2><h3 id="Ruby-安装环境"><a href="#Ruby-安装环境" class="headerlink" title="Ruby 安装环境"></a>Ruby 安装环境</h3><p>首先我们需要安装一套开发用的 Ruby 环境，macOS 中不推荐直接使用系统的 Ruby。我们可以用多种方式来管理我们的 Ruby 环境，例如 <code>rvm</code>，<code>rebnv</code>，<code>homebrew</code>。由于本人是通过 <code>homebrew</code> 安装的 Ruby 环境，所以本篇只介绍 <code>homebrew</code> 的管理方式，其他方式请自行查阅资料。</p>
<p>对于使用 <code>homebrew</code> 安装 Ruby 可以看我之前的这片文章，这里有详细的说明：<a href="https://regulusleow.github.io/2023/03/27/20230327-%E4%BD%BF%E7%94%A8%20Homebrew%20%E7%AE%A1%E7%90%86%20Ruby/">使用 Homebrew 管理 Ruby</a></p>
<h3 id="fastlane-的安装"><a href="#fastlane-的安装" class="headerlink" title="fastlane 的安装"></a>fastlane 的安装</h3><p>Ruby 环境设置完毕后我们就可以开始安装 <code>fastlane</code>，同样使用 <code>homebrew</code> 的方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew install fastlane</span><br></pre></td></tr></table></figure>

<h3 id="fastlane-的配置"><a href="#fastlane-的配置" class="headerlink" title="fastlane 的配置"></a>fastlane 的配置</h3><p><code>fastlane</code> 安装完成后我们 <code>cd</code> 到我们的工程目录，执行如下命令进行初始化：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ fastlane init</span><br></pre></td></tr></table></figure>

<p>在此期间，<code>fastlane</code> 将自动检测项目，并询问任何丢失的信息。例如：开发者账号，密码等。</p>
<p>安装完成之后，在我们的工程中会生成一个 <code>fastlane</code> 文件夹，里面有两个重要的文件：<code>Appfile</code> 和 <code>Fastfile</code>。</p>
<p><code>Appfile</code> 记录了一些开发账号信息，例如：<code>Apple ID</code>、<code>Bundle Identifier</code>等。</p>
<p><code>Fastfile</code> 则是你打包流程的具体实现，一个简单的例子如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">lane <span class="symbol">:my_lane</span> <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># Whatever actions you like go in here.</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这时我们在终端中，<code>cd</code> 到我们的工程，然后执行 <code>fastlane my_lane</code> 即会执行我们定义的打包流程。你可以定义很多个 <code>lane</code> 用于执行不同的流程。</p>
<h3 id="fastlane-相关功能简介"><a href="#fastlane-相关功能简介" class="headerlink" title="fastlane 相关功能简介"></a>fastlane 相关功能简介</h3><h4 id="非常有用的-block"><a href="#非常有用的-block" class="headerlink" title="非常有用的 block"></a>非常有用的 block</h4><p><code>fastlane</code> 还提供了两个非常有用的 <code>block</code>：<code>before_all</code> 和 <code>after_all</code>。</p>
<p><code>before_all</code> 此块将在运行 <code>lane</code> 流程之前执行。它支持与 <code>lane</code> 相同的操作。在这个 <code>block</code> 中我们就可以执行一些打包之前需要进行的操作，比如执行 <code>cocoapods</code>。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">before_all <span class="keyword">do</span> |<span class="params">lane</span>|</span><br><span class="line">  cocoapods</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><code>after_all</code> 故名思义，就是在执行完打包流程之后进行的操作，例如我们可以在这里发送通知，执行打包完成后的脚本等，如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">after_all <span class="keyword">do</span> |<span class="params">lane</span>|</span><br><span class="line">  say(<span class="string">&quot;Successfully finished deployment (<span class="subst">#&#123;lane&#125;</span>)!&quot;</span>)</span><br><span class="line">  slack(</span><br><span class="line">    <span class="symbol">message:</span> <span class="string">&quot;Successfully submitted new App Update&quot;</span></span><br><span class="line">  )</span><br><span class="line">  sh(<span class="string">&quot;./send_screenshots_to_team.sh&quot;</span>) <span class="comment"># Example</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><code>fastlane</code> 中的错误处理由 <code>error block</code> 处理，当任何块(<code>before_all</code>、<code>lane</code> 本身或 <code>after_all</code>)中发生错误时将执行该 <code>block</code>。我们可以使用 <code>error_info</code> 属性获取有关错误的更多信息。：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">error <span class="keyword">do</span> |<span class="params">lane, exception</span>|</span><br><span class="line">  slack(</span><br><span class="line">    <span class="symbol">message:</span> <span class="string">&quot;Something went wrong with the deployment.&quot;</span>,</span><br><span class="line">    <span class="symbol">success:</span> <span class="literal">false</span>,</span><br><span class="line">    <span class="symbol">payload:</span> &#123; <span class="string">&quot;Error Info&quot;</span> =&gt; exception.error_info.to_s &#125; </span><br><span class="line">  )</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h4 id="导入其他-Fastfile-文件"><a href="#导入其他-Fastfile-文件" class="headerlink" title="导入其他 Fastfile 文件"></a>导入其他 Fastfile 文件</h4><p>如果我们的 <code>Fastfile</code> 比较复杂我们可以拆分成多个文件然后进行 <code>import </code> 操作，就像我们开发时候的头文件导入一般。 对于 <code>import</code> 功能 <code>fastlane</code> 提供了两种方式。</p>
<h5 id="import"><a href="#import" class="headerlink" title="import"></a>import</h5><p>导入本地文件路径</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">import <span class="string">&quot;../GeneralFastfile&quot;</span></span><br><span class="line"></span><br><span class="line">override_lane <span class="symbol">:from_general</span> <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h5 id="import-from-git"><a href="#import-from-git" class="headerlink" title="import_from_git"></a>import_from_git</h5><p>从另一个 git 资源库导入，我们可以使用该资源库为所有项目创建一个带有默认 <code>Fastfile</code> 的 git 资源库：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">import_from_git(<span class="symbol">url:</span> <span class="string">&#x27;https://github.com/fastlane/fastlane&#x27;</span>)</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">import_from_git(<span class="symbol">url:</span> <span class="string">&#x27;git@github.com:MyAwesomeRepo/MyAwesomeFastlaneStandardSetup.git&#x27;</span>,</span><br><span class="line">               <span class="symbol">path:</span> <span class="string">&#x27;fastlane/Fastfile&#x27;</span>)</span><br><span class="line"></span><br><span class="line">lane <span class="symbol">:new_main_lane</span> <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这还将自动的从 <code>repo</code> 中导入所有的 <code>action</code>。</p>
<blockquote>
<p>如果你需要覆盖现有的 <code>lane</code> 声明，可以使用 <code>override_lane</code> 关键字</p>
</blockquote>
<p>想更多的了解 <code>Fastfile</code> 请参阅文档: <span class="exturl" data-url="aHR0cDovL2RvY3MuZmFzdGxhbmUudG9vbHMvYWR2YW5jZWQvRmFzdGZpbGUvI2Zhc3RmaWxl">Fastfile<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="使用环境变量"><a href="#使用环境变量" class="headerlink" title="使用环境变量"></a>使用环境变量</h4><p>如果我们的打包环境比较复杂，比如需要适应多个账户打包需求，此时我们可以定义环境变量来管理相关信息。我们可以在与 <code>Fastfile</code> 相同的目录中创建 <code>.env</code> 或 <code>.env.default</code> 文件，然后定义环境变量。使用 <code>dotenv</code> 加载环境变量。下面是一个例子：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">WORKSPACE=YourApp.xcworkspace</span><br><span class="line">HOCKEYAPP<span class="built_in">_</span>API<span class="built_in">_</span>TOKEN=your-hockey-api-token</span><br></pre></td></tr></table></figure>

<p>在 <code>Fastfile</code> 中我们就可以使用如下方式获取相关环境变量：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">bundle_identifier = <span class="variable constant_">ENV</span>[<span class="string">&#x27;APP_IDENTIFIER&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>更多详细的讲解请看官方文档：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmZhc3RsYW5lLnRvb2xzL2FkdmFuY2VkL290aGVyLyNlbnZpcm9ubWVudC12YXJpYWJsZXM=">Environment Variables<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="众多的-actions"><a href="#众多的-actions" class="headerlink" title="众多的 actions"></a>众多的 actions</h4><p><code>fastlane</code> 最终要的功能就是提供了众多的 <code>actions</code> 供我们使用，最常用的有：<code>gym (build_app)</code>，<code>cocoapods</code>，<code>match</code>，<code>upload_to_testflight</code>，<code>upload_to_testflight</code>等。这里不再做过多的讲解，官方文档已经说的非常清楚，详情请查阅 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmZhc3RsYW5lLnRvb2xzL2FjdGlvbnMv">fastlane actions<i class="fa fa-external-link-alt"></i></span>。</p>
<p>最后附上一个完整的流程示例：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">&#x27;./xcode_build_settings&#x27;</span></span><br><span class="line"></span><br><span class="line">default_platform(<span class="symbol">:ios</span>)</span><br><span class="line"></span><br><span class="line">platform <span class="symbol">:ios</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">  bundle_identifier = <span class="variable constant_">ENV</span>[<span class="string">&#x27;APP_IDENTIFIER&#x27;</span>]</span><br><span class="line">  scheme = <span class="variable constant_">ENV</span>[<span class="string">&#x27;SCHEME&#x27;</span>]</span><br><span class="line">  xcworkspace = <span class="variable constant_">ENV</span>[<span class="string">&#x27;XCWORKSPACE&#x27;</span>]</span><br><span class="line">  xcodeproj = <span class="variable constant_">ENV</span>[<span class="string">&#x27;XCODEPROJ&#x27;</span>]</span><br><span class="line">  apple_id = <span class="variable constant_">ENV</span>[<span class="string">&#x27;APPLE_ID&#x27;</span>]</span><br><span class="line">  adhoc_output_path = <span class="string">&quot;./fastlane/adhoc&quot;</span></span><br><span class="line">  product_output_path = <span class="string">&quot;./fastlane/release&quot;</span></span><br><span class="line">  <span class="comment"># branch_name = &quot;xxxxx&quot;</span></span><br><span class="line"></span><br><span class="line">  desc <span class="string">&quot;Push a new beta build to TestFlight&quot;</span></span><br><span class="line"></span><br><span class="line">  api_key = app_store_connect_api_key(</span><br><span class="line">    <span class="symbol">key_id:</span> <span class="string">&quot;xxxx&quot;</span>,</span><br><span class="line">    <span class="symbol">issuer_id:</span> <span class="string">&quot;xxx-xxx-xxx&quot;</span>,</span><br><span class="line">    <span class="symbol">key_filepath:</span> <span class="string">&#x27;./fastlane/AuthKey_xxxx.p8&#x27;</span>,</span><br><span class="line">    <span class="symbol">duration:</span> <span class="number">1200</span>,</span><br><span class="line">    <span class="symbol">in_house:</span> <span class="literal">false</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  before_all <span class="keyword">do</span> |<span class="params">lane</span>|</span><br><span class="line">    <span class="title class_">BuildSettings</span>.configTarget</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  lane <span class="symbol">:beta</span> <span class="keyword">do</span></span><br><span class="line">    increment_build_number(<span class="symbol">xcodeproj:</span> xcodeproj)</span><br><span class="line">    match(</span><br><span class="line">      <span class="symbol">api_key:</span> api_key,</span><br><span class="line">      <span class="symbol">app_identifier:</span> bundle_identifier,</span><br><span class="line">      <span class="symbol">type:</span> <span class="string">&quot;adhoc&quot;</span></span><br><span class="line">      <span class="comment"># git_branch: branch_name</span></span><br><span class="line">    )</span><br><span class="line">    cocoapods(</span><br><span class="line">      <span class="symbol">repo_update:</span> <span class="literal">true</span>,</span><br><span class="line">      <span class="symbol">clean_install:</span> <span class="literal">true</span>,</span><br><span class="line">      <span class="symbol">use_bundle_exec:</span> <span class="literal">false</span>,</span><br><span class="line">      <span class="symbol">podfile:</span> <span class="string">&quot;./Podfile&quot;</span></span><br><span class="line">    )</span><br><span class="line">    build_app(</span><br><span class="line">      <span class="symbol">clean:</span> <span class="literal">true</span>,</span><br><span class="line">      <span class="symbol">output_directory:</span> adhoc_output_path,</span><br><span class="line">      <span class="symbol">output_name:</span> <span class="string">&quot;xxxx&quot;</span>,</span><br><span class="line">      <span class="symbol">workspace:</span> xcworkspace, </span><br><span class="line">      <span class="symbol">scheme:</span> scheme,</span><br><span class="line">      <span class="symbol">xcargs:</span> <span class="string">&quot;-allowProvisioningUpdates&quot;</span>,</span><br><span class="line">      <span class="symbol">export_options:</span> &#123;</span><br><span class="line">        <span class="symbol">manifest:</span> &#123;</span><br><span class="line">          <span class="symbol">appURL:</span> <span class="string">&quot;https://server.local/apps/xxx.ipa&quot;</span>,</span><br><span class="line">          <span class="symbol">displayImageURL:</span> <span class="string">&quot;https://server.local/apps/xxx.png&quot;</span>,</span><br><span class="line">          <span class="symbol">fullSizeImageURL:</span> <span class="string">&quot;https://server.local/apps/xxx.png&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="symbol">thinning:</span> <span class="string">&quot;&lt;none&gt;&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    verify_build(</span><br><span class="line">      <span class="symbol">provisioning_type:</span> <span class="string">&quot;distribution&quot;</span>,</span><br><span class="line">      <span class="symbol">bundle_identifier:</span> bundle_identifier</span><br><span class="line">    )</span><br><span class="line">    upload_to_testflight(</span><br><span class="line">      <span class="symbol">api_key:</span> api_key,</span><br><span class="line">      <span class="symbol">app_identifier:</span> bundle_identifier,</span><br><span class="line">      <span class="symbol">ipa:</span> <span class="string">&quot;./fastlane/release/xxxx.ipa&quot;</span></span><br><span class="line">    )</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  lane <span class="symbol">:product</span> <span class="keyword">do</span></span><br><span class="line">    increment_build_number(<span class="symbol">xcodeproj:</span> xcodeproj)</span><br><span class="line">    match(</span><br><span class="line">      <span class="symbol">api_key:</span> api_key,</span><br><span class="line">      <span class="symbol">app_identifier:</span> bundle_identifier,</span><br><span class="line">      <span class="symbol">type:</span> <span class="string">&quot;appstore&quot;</span></span><br><span class="line">      <span class="comment"># git_branch: branch_name</span></span><br><span class="line">    )</span><br><span class="line">    build_app(</span><br><span class="line">      <span class="symbol">clean:</span> <span class="literal">true</span>,</span><br><span class="line">      <span class="symbol">output_directory:</span> product_output_path,</span><br><span class="line">      <span class="symbol">output_name:</span> <span class="string">&quot;xxxx&quot;</span>,</span><br><span class="line">      <span class="symbol">workspace:</span> xcworkspace, </span><br><span class="line">      <span class="symbol">scheme:</span> scheme,</span><br><span class="line">      <span class="symbol">xcargs:</span> <span class="string">&quot;-allowProvisioningUpdates&quot;</span></span><br><span class="line">    )</span><br><span class="line">    verify_build(</span><br><span class="line">      <span class="symbol">provisioning_type:</span> <span class="string">&quot;distribution&quot;</span>,</span><br><span class="line">      <span class="symbol">bundle_identifier:</span> bundle_identifier</span><br><span class="line">    )</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  error <span class="keyword">do</span> |<span class="params">lane, exception</span>|</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CI</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>fastlane</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言重拾【七】存储类别、链接和内存管理</title>
    <url>/2023/04/11/20230411-C%20%E8%AF%AD%E8%A8%80%E9%87%8D%E6%8B%BE%E3%80%90%E4%B8%83%E3%80%91/</url>
    <content><![CDATA[<p>C 语言能让程序员恰到好处的控制程序，这是它的优势之一。程序员通过 C 的内存管理系统指定变量的作用域和生命周期，实现对程序的控制。合理使用内存存储数据是设计程序的一个要点。</p>
<h2 id="存储类别"><a href="#存储类别" class="headerlink" title="存储类别"></a>存储类别</h2><p>C 提供了多种不同的模型或存储类别在内存中存储数据。要理解这些存储类别，我们先来了解一些概念和术语。</p>
<p>程序中的大部分数据都是存储在内存中。从硬件方面来看，被存储的每个值都占用一定的物理内存，C 语言把这样的一块内存称为 <strong>对象（objc）</strong>。这里所指的对象和我们面向对象编程所说的对象是不同的，要注意<strong>（面向对象中的对象指的是类对象）</strong>。这里所说的对象实际指的是一块可以存储数据的内存。对象可以存储一个或多个值。一个对象可能并未存储实际的值，但是它在存储适当的值时一定具有相应的大小 。</p>
<span id="more"></span>

<p>从软件方面来看，程序需要一种方法访问对象。这可以通过声明变量来完成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> entity = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>该声明创建了一个 <code>entity</code> <strong>标识符</strong>。标识符是一个名称，可以用来指定特定对象的内容。变量名不是指定对象的唯一途径。考虑下面两个声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *pt = &amp;entity;</span><br><span class="line"><span class="type">int</span> ranks[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p><code>pt</code> 是一个指针，并不是一个标识符。<code>ranks</code> 的声明创建了一个可容纳 10 个 <code>int</code> 类型元素的对象，该数组的每个元素也是一个对象。</p>
<p>可以用 <strong>存储期</strong> 描述对象，所谓存储期是指对象在内存中保留了多长时间。标识符用于访问对象，可以用 <strong>作用域</strong> 和 <strong>链接</strong> 描述标识符，标识符的 <strong>作用域</strong> 和 <strong>链接</strong> 表明了程序的哪些部分可以使用它。不同的存储类别具有不同的 <strong>存储期</strong>、<strong>作用域</strong>和<strong>链接</strong>。</p>
<p>通俗一点的描述就是，存储期可以理解为一个对象的声明周期，也即是内存的创建到销毁。链接可以理解为访问控制，是对于文件来说。作用域是对于变量来说的访问控制。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>一个 C 变量的作用域可以是 <strong>块作用域</strong>、<strong>函数作用域</strong>、<strong>函数原型作用域</strong>或<strong>文件作用域</strong>。块作用域其实就是两个大括号之间的作用域。举个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">blocky</span><span class="params">(<span class="type">double</span> cleo)</span> &#123;</span><br><span class="line">  <span class="type">double</span> patrick = <span class="number">0.0</span>;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="type">double</span> q = cleo * i; <span class="comment">// q 的作用域开始</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    patrick *= q;</span><br><span class="line">  &#125; <span class="comment">// q 的作用域结束</span></span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">  <span class="keyword">return</span> patrick;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数作用域仅用于 <code>goto</code> 语句的标签。</p>
<p>函数原型作用域用于函数原型中的形参名，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mighty</span><span class="params">(<span class="type">int</span> mouse, <span class="type">double</span> large)</span>;</span><br></pre></td></tr></table></figure>

<p>其范围是从形参定义处到原型声明结束。这意味着，编译起在处理函数原型中的形参时只关心它的类型，而形参名（如果有的话）通常无关紧要。而且，即使有形参名，也不必与函数定义中的形参名相匹配。只有在变长数组中，形参名才有用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">use_a_VLA</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, ar[n][m])</span>;</span><br></pre></td></tr></table></figure>

<p>方括号中必须使用在函数原型中已声明的名称。</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>C 语言具有 3 中链接属性：外部链接、内部链接或无链接。具有块作用域、函数作用域或函数原型作用域的变量都是无链接变量。具有文件作用域的变量可以是外部链接或内部链接。外部链接变量可以在多文件程序中使用，内部链接变量只能在一个翻译单元中使用。</p>
<blockquote>
<p>正式和非正式术语</p>
<p>C 标准用“内部链接的文件作用域”描述仅限于一个翻译单元（即一个源代码文件和它所包含的头文件）的作用域，用“外部链接的文件作用域”描述可延伸至其他翻译单元的作用域。但是，对程序员而言这些术语太长了。一些程序员把“内部链接的文件作用域”简称为“文件作用域”，把“外部链接的文件作用域”简称为“全局作用域”或“程序作用域”。</p>
</blockquote>
<p>如何知道文件作用域变量是内部链接还是外部链接？可以查看外部定义中是否使用了存储类别说明符 <code>static</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> giants = <span class="number">5</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> dodgers = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>该文件和同一程序的其他文件都可以使用变量 <code>giants</code>。而变量 <code>dodgers</code> 属文件私有，该文件中的任意函数都可使用它。</p>
<h3 id="存储期"><a href="#存储期" class="headerlink" title="存储期"></a>存储期</h3><p>作用域和链接描述了标识符的可见性。存储期描述了通过这些标识符访问的对象的生存期。C 对象有4种存储期：静态存储期、线程存储期、自动存储期、动态分配存储期。</p>
<p>如果对象具有静态存储期，那么它在程序的执行期间一直存在。文件作用域变量具有静态存储期。注意，对于文件作用域变量，关键字 static表明了其链接属性，而非存储期。以 <code>static</code> 声明的文件作用域变量具有内部链接。但是无论是内部链接还是外部链接，所有的文件作用域变量都具有静态存储期。</p>
<p>线程存储期用于并发程序设计，程序执行可被分为多个线程。具有线程存储期的对象，从被声明时到线程结束一直存在。以关键字 <code>_Thread_local</code> 声明一个对象时，每个线程都获得该变量的私有备份。</p>
<p>块作用域的变量通常都具有自动存储期。当程序进入定义这些变量的块时，为这些变量分配内存；当退出这个块时，释放刚才为变量分配的内存。这种做法相当于把自动变量占用的内存视为一个可重复使用的工作区或暂存区。例如，一个函数调用结束后，其变量占用的内存可用于储存下一个被调用函数的变量。</p>
<p><strong>变长数组稍有不同，它们的存储期从声明处到块的末尾，而不是从块的开始处到块的末尾。</strong></p>
<p>块作用域变量也能具有静态存储期。为了创建这样的变量，要把变量声明在块中，且在声明前面加上关键字 <code>static</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">more</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">  <span class="type">int</span> index;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> ct = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，变量 <code>ct</code> 储存在静态内存中，它从程序被载入到程序结束期间都存在。但是，它的作用域定义在 <code>more()</code> 函数块中。只有在执行该函数时，程序才能使用 <code>ct</code> 访问它所指定的对象（但是，该函数可以给其他函数提供该存储区的地址以便间接访问该对象，例如通过指针形参或返回值）。</p>
<table>
<thead>
<tr>
<th>存储类别</th>
<th>存储期</th>
<th>作用域</th>
<th>链接</th>
<th>声明方式</th>
</tr>
</thead>
<tbody><tr>
<td>自动</td>
<td>自动</td>
<td>块</td>
<td>无</td>
<td>块内</td>
</tr>
<tr>
<td>寄存器</td>
<td>自动</td>
<td>块</td>
<td>无</td>
<td>块内，使用关键字 register</td>
</tr>
<tr>
<td>静态外部链接</td>
<td>静态</td>
<td>文件</td>
<td>外部</td>
<td>所有函数外</td>
</tr>
<tr>
<td>静态内部链接</td>
<td>静态</td>
<td>文件</td>
<td>内部</td>
<td>所有函数外，使用关键字 static</td>
</tr>
<tr>
<td>静态无链接</td>
<td>静态</td>
<td>块</td>
<td>无</td>
<td>块内，使用关键字 static</td>
</tr>
</tbody></table>
<h3 id="寄存器变量"><a href="#寄存器变量" class="headerlink" title="寄存器变量"></a>寄存器变量</h3><p>变量通常储存在计算机内存中。如果幸运的话，寄存器变量储存在CPU的寄存器中，或者概括地说，储存在最快的可用内存中。与普通变量相比，访问和处理这些变量的速度更快。由于寄存器变量储存在寄存器而非内存中，所以无法获取寄存器变量的地址。绝大多数方面，寄存器变量和自动变量都一样。也就是说，它们都是块作用域、无链接和自动存储期。使用存储类别说明符 <code>register</code> 便可声明寄存器变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">int</span> quick;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们刚才说“如果幸运的话”，是因为声明变量为 <code>register</code> 类别与直接命令相比更像是一种请求。编译器必须根据寄存器或最快可用内存的数量衡量你的请求，或者直接忽略你的请求，所以可能不会如你所愿。在这种情况下，寄存器变量就变成普通的自动变量。即使是这样，仍然不能对该变量使用地址运算符。<br>在函数头中使用关键字 <code>register</code>，便可请求形参是寄存器变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">macho</span><span class="params">(<span class="keyword">register</span> <span class="type">int</span> n)</span></span><br></pre></td></tr></table></figure>

<p>可声明为 <code>register</code> 的数据类型有限。例如，处理器中的寄存器可能没有足够大的空间来存储 <code>double</code> 类型的值。</p>
<h3 id="存储类别说明符"><a href="#存储类别说明符" class="headerlink" title="存储类别说明符"></a>存储类别说明符</h3><p>读者可能已经注意到了，关键字 <code>static</code> 和 <code>extern</code> 的含义取决于上下文。C 语言有 6 个关键字作为存储类别说明符：<code>auto</code>、<code>register</code>、<code>static</code>、<code>extern</code>、<code>_Thread_local</code> 和 <code>typedef</code>。<code>typedef</code> 关键字与任何内存存储无关，把它归于此类有一些语法上的原因。尤其是，在绝大多数情况下，不能在声明中使用多个存储类别说明符，所以这意味着不能使用多个存储类别说明符作为 <code>typedef</code> 的一部分。唯一例外的是 <code>_Thread_local</code>，它可以和 <code>static</code> 或 <code>extern</code> 一起使用。</p>
<p><code>auto</code> 说明符表明变量是自动存储期，只能用于块作用域的变量声明中。由于在块中声明的变量本身就具有自动存储期，所以使用 <code>auto</code> 主要是为了明确表达要使用与外部变量同名的局部变量的意图。</p>
<p><code>register</code> 说明符也只用于块作用域的变量，它把变量归为寄存器存储类别，请求最快速度访问该变量。同时，还保护了该变量的地址不被获取。</p>
<p>用 <code>static</code> 说明符创建的对象具有静态存储期，载入程序时创建对象，当程序结束时对象消失。如果 <code>static</code> 用于文件作用域声明，作用域受限于该文件。如果 <code>static</code> 用于块作用域声明，作用域则受限于该块。因此，只要程序在运行对象就存在并保留其值，但是只有在执行块内的代码时，才能通过标识符访问。块作用域的静态变量无链接。文件作用域的静态变量具有内部链接。</p>
<p><code>extern</code> 说明符表明声明的变量定义在别处。如果包含 <code>extern</code> 的声明具有文件作用域，则引用的变量必须具有外部链接。如果包含 <code>extern</code> 的声明具有块作用域，则引用的变量可能具有外部链接或内部链接，这接取决于该变量的定义式声明。</p>
<blockquote>
<p><strong>小结：存储类别</strong></p>
<p>自动变量具有块作用域、无链接、自动存储期。它们是局部变量，属于其定义所在块（通常指函数）私有。寄存器变量的属性和自动变量相同，但是编译器会使用更快的内存或寄存器储存它们。不能获取寄存器变量的地址。</p>
<p>具有静态存储期的变量可以具有外部链接、内部链接或无链接。在同一个文件所有函数的外部声明的变量是外部变量，具有文件作用域、外部链接和静态存储期。如果在这种声明前面加上关键字 <code>static</code>，那么其声明的变量具有文件作用域、内部链接和静态存储期。如果在函数中用 <code>static</code> 声明一个变量，则该变量具有块作用域、无链接、静态存储期。</p>
<p>具有自动存储期的变量，程序在进入该变量的声明所在块时才为其分配内存，在退出该块时释放之前分配的内存。如果未初始化，自动变量中是垃圾值。程序在编译时为具有静态存储期的变量分配内存，并在程序的运行过程中一直保留这块内存。如果未初始化，这样的变量会被设置为 0。</p>
<p>具有块作用域的变量是局部的，属于包含该声明的块私有。具有文件作用域的变量对文件（或翻译单元）中位于其声明后面的所有函数可见。具有外部链接的文件作用域变量，可用于该程序的其他翻译单元。具有内部链接的文件作用域变量，只能用于其声明所在的文件内。</p>
</blockquote>
<h2 id="分配内存：malloc-和-free"><a href="#分配内存：malloc-和-free" class="headerlink" title="分配内存：malloc() 和 free()"></a>分配内存：<code>malloc()</code> 和 <code>free()</code></h2><p>首先，回顾一下内存分配。所有程序都必须预留足够的内存来储存程序使用的数据。这些内存中有些是自动分配的。例如，以下声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> x;</span><br><span class="line"><span class="type">char</span> place[] = <span class="string">&quot;Dancing Oxen Creek&quot;</span></span><br></pre></td></tr></table></figure>

<p>为一个 <code>float</code> 类型的值和一个字符串预留了足够的内存，或者可以显式指定分配一定数量的内存：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> plates[<span class="number">100</span>];</span><br></pre></td></tr></table></figure>

<p>该声明预留了 100 个内存位置，每个位置都用于储存int类型的值。声明还为内存提供了一个标识符。因此，可以使用 <code>x</code> 或 <code>place</code> 识别数据。回忆一下，静态数据在程序载入内存时分配，而自动数据在程序执行块时分配，并在程序离开该块时销毁。</p>
<p>C 能做的不止这些。可以在程序运行时分配更多的内存。主要的工具是 <code>malloc()</code> 函数，该函数接受一个参数：所需的内存字节数。<code>malloc()</code> 函数会找到合适的空闲内存块，这样的内存是匿名的。也就是说， <code>malloc()</code> 分配内存，但是不会为其赋名。然而，它确实返回动态分配内存块的首字节地址。因此，可以把该地址赋给一个指针变量，并使用指针访问这块内存。因为 <code>char</code> 表示 1 字节，<code>malloc()</code> 的返回类型通常被定义为指向char的指针。然而，从 ANSI C 标准开始，C 使用一个新的类型：指向 <code>void</code> 的指针。该类型相当于一个“通用指针”。<code>malloc()</code> 函数可用于返回指向数组的指针、指向结构的指针等，所以通常该函数的返回值会被强制转换为匹配的类型。在 ANSI C 中，应该坚持使用强制类型转换，提高代码的可读性。然而，把指向 <code>void</code> 的指针赋给任意类型的指针完全不用考虑类型匹配的问题。如果 <code>malloc()</code> 分配内存失败，将返回空指针。</p>
<p>我们试着用 <code>malloc()</code> 创建一个数组。除了用 <code>malloc()</code> 在程序运行时请求一块内存，还需要一个指针记录这块内存的位置。例如，考虑下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> *pt;</span><br><span class="line">ptd = (<span class="type">double</span> *)<span class="built_in">malloc</span>(<span class="number">30</span> * <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br></pre></td></tr></table></figure>

<p>以上代码为 30 个 <code>double</code> 类型的值请求内存空间，并设置 <code>ptd</code> 指向该位置。注意，指针 <code>ptd</code> 被声明为指向一个 <code>double</code> 类型，而不是指向内含 30 个 <code>double</code> 类型值的块。回忆一下，数组名是该数组首元素的地址。因此，如果让 <code>ptd</code> 指向这个块的首元素，便可像使用数组名一样使用它。也就是说，可以使用表达式 <code>ptd[0]</code> 访问该块的首元素，<code>ptd[1]</code> 访问第 2 个元素，以此类推。根据前面所学的知识，可以使用数组名来表示指针，也可以用指针来表示数组。</p>
<p>现在，我们有 3 种创建数组的方法。</p>
<ul>
<li>声明数组时，用常量表达式表示数组的维度，用数组名访问数组的元素。可以用静态内存或自动内存创建这种数组。</li>
<li>声明变长数组（C99 新增的特性）时，用变量表达式表示数组的维度，用数组名访问数组的元素。具有这种特性的数组只能在自动内存中创建。</li>
<li>声明一个指针，调用 <code>malloc()</code>，将其返回值赋给指针，使用指针访问数组的元素。该指针可以是静态的或自动的。</li>
</ul>
<p>使用第 2 种和第 3 种方法可以创建动态数组（dynamic array）。这种数组和普通数组不同，可以在程序运行时选择数组的大小和分配内存。</p>
<p>通常，<code>malloc()</code> 要与 <code>free()</code> 配套使用。<code>free()</code> 函数的参数是之前 <code>malloc()</code> 返回的地址，该函数释放之前 <code>malloc()</code> 分配的内存。因此，动态分配内存的存储期从调用 <code>malloc()</code> 分配内存到调用 <code>free()</code> 释放内存为止。设想 <code>malloc()</code> 和 <code>free()</code> 管理着一个内存池。每次调用 <code>malloc()</code> 分配内存给程序使用，每次调用 <code>free()</code> 把内存归还内存池中，这样便可重复使用这些内存。<code>free()</code> 的参数应该是一个指针，指向由 <code>malloc()</code> 分配的一块内存。不能用 <code>free()</code> 释放通过其他方式（如，声明一个数组）分配的内存。<code>malloc()</code> 和 <code>free()</code> 的原型都在 <code>stdlib.h</code> 头文件中。</p>
<h3 id="calloc-函数"><a href="#calloc-函数" class="headerlink" title="calloc() 函数"></a><code>calloc()</code> 函数</h3><p>分配内存还可以使用 <code>calloc()</code>，典型的用法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> *newmem;</span><br><span class="line">newmem = (<span class="type">long</span> *)<span class="built_in">calloc</span>(<span class="number">100</span>, <span class="keyword">sizeof</span>(<span class="type">long</span>));</span><br></pre></td></tr></table></figure>

<p>和 <code>malloc()</code> 类似，在 ANSI 之前，<code>calloc()</code> 也返回指向 <code>char</code> 的指针；在 ANSI 之后，返回指向 <code>void</code> 的指针。如果要储存不同的类型，应使用强制类型转换运算符。<code>calloc()</code> 函数接受两个无符号整数作为参数（ANSI 规定是 <code>size_t</code> 类型）。第 1 个参数是所需的存储单元数量，第 2 个参数是存储单元的大小（以字节为单位）。在该例中，<code>long</code> 为 4 字节，所以，前面的代码创建了 100 个 4 字节的存储单元，总共 400 字节。</p>
<p>用 <code>sizeof(long)</code> 而不是 4，提高了代码的可移植性。这样，在其他 <code>long</code> 不是 4 字节的系统中也能正常工作。</p>
<p><code>calloc()</code> 函数还有一个特性：它把块中的所有位都设置为 0（注意，在某些硬件系统中，不是把所有位都设置为 0 来表示浮点值 0）</p>
<p><code>free()</code> 函数也可用于释放 <code>calloc()</code> 分配的内存。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>内存用于存储程序中的数据，由存储期、作用域和链接表征。存储期可以是静态的、自动的或动态分配的。如果是静态存储期，在程序开始执行时分配内存，并在程序运行时都存在。如果是自动存储期，在程序进入变量定义所在块时分配变量的内存，在程序离开块时释放内存。如果是动态分配存储期，在调用 <code>malloc()</code>（或相关函数）时分配内存，在调用 <code>free()</code> 函数时释放内存。</p>
<p>作用域决定程序的哪些部分可以访问某数据。定义在所有函数之外的变量具有文件作用域，对位于该变量声明之后的所有函数可见。定义在块或作为函数形参内的变量具有块作用域，只对该块以及它包含的嵌套块可见。</p>
<p>链接描述定义在程序某翻译单元中的变量可被链接的程度。具有块作用域的变量是局部变量，无链接。具有文件作用域的变量可以是内部链接或外部链接。内部链接意味着只有其定义所在的文件才能使用该变量。外部链接意味着其他文件使用也可以使用该变量。</p>
<p>下面是 C 的 5 种存储类别（不包括线程的概念）。</p>
<ul>
<li><strong>自动</strong>——在块中不带存储类别说明符或带 <code>auto</code> 存储类别说明符声明的变量（或作为函数头中的形参）属于自动存储类别，具有自动存储期、块作用域、无链接。如果未初始化自动变量，它的值是未定义的。</li>
<li><strong>寄存器</strong>——在块中带 <code>register</code> 存储类别说明符声明的变量（或作为函数头中的形参）属于寄存器存储类别，具有自动存储期、块作用域、无链接，且无法获取其地址。把一个变量声明为寄存器变量即请求编译器将其储存到访问速度最快的区域。如果未初始化寄存器变量，它的值是未定义的。</li>
<li><strong>静态、无链接</strong>——在块中带 <code>static</code> 存储类别说明符声明的变量属于“静态、无链接”存储类别，具有静态存储期、块作用域、无链接。只在编译时被初始化一次。如果未显式初始化，它的字节都被设置为 0。</li>
<li><strong>静态、外部链接</strong>——在所有函数外部且没有使用 <code>static</code> 存储类别说明符声明的变量属于“静态、外部链接”存储类别，具有静态存储期、文件作用域、外部链接。只能在编译器被初始化一次。如果未显式初始化，它的字节都被设置为 0。</li>
<li><strong>静态、内部链接</strong>——在所有函数外部且使用了 <code>static</code> 存储类别说明符声明的变量属于“静态、内部链接”存储类别，具有静态存储期、文件作用域、内部链接。只能在编译器被初始化一次。如果未显式初始化，它的字节都被设置为 0。</li>
</ul>
<p>动态分配的内存由 <code>malloc()</code>（或相关）函数分配，该函数返回一个指向指定字节数内存块的指针。这块内存被 <code>free()</code> 函数释放后便可重复使用，<code>free()</code> 函数以该内存块的地址作为参数。</p>
<p>类型限定符 <code>const</code>、<code>volatile</code>、<code>restrict</code> 和 <code>_Atomic</code>。<code>const</code> 限定符限定数据在程序运行时不能改变。对指针使用 <code>const</code> 时，可限定指针本身不能改变或指针指向的数据不能改变，这取决于 <code>const</code> 在指针声明中的位置。<code>volatile</code> 限定符表明，限定的数据除了被当前程序修改外还可以被其他进程修改。该限定符的目的是警告编译器不要进行假定的优化。<code>restrict</code> 限定符也是为了方便编译器设置优化方案。<code>restrict</code> 限定的指针是访问它所指向数据的唯一途径。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>C Primer Plus</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 Git 进行高效的版本控制</title>
    <url>/2023/04/20/20230420-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Git%20%E8%BF%9B%E8%A1%8C%E9%AB%98%E6%95%88%E7%9A%84%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>Git 是一款分布式版本控制系统，于 2005 年由 Linus Torvalds 创造并开源发布。Git 的设计初衷是为了更好地管理 Linux 内核代码，它的分布式特性使得多人协作开发和大型项目的版本控制变得更加高效和可靠。现在，Git 已经成为了开源社区和软件开发领域中最受欢迎的版本控制工具之一。</p>
<span id="more"></span>

<h2 id="Git-的基本概念包括："><a href="#Git-的基本概念包括：" class="headerlink" title="Git 的基本概念包括："></a>Git 的基本概念包括：</h2><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p>版本控制是指对文件或代码的修改历史进行记录和管理，以便于多人协作开发和版本回溯。Git 通过记录每次提交的快照来实现版本控制，并提供了一系列的命令和工具来管理版本库。</p>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>分支是指从一个代码库中派生出来的独立代码线。在 Git 中，每个分支都是一个独立的代码库，可以在分支上进行修改和提交，而不影响主线代码的开发。分支在多人协作和复杂项目的版本控制中起到了重要作用。</p>
<h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><p>提交是指将代码库中的修改保存到版本库中的操作。每次提交都会创建一个新的版本快照，并记录下该次提交的作者、时间、提交信息等相关信息。</p>
<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p>远程仓库是指存放在网络上的代码库，通常由多人协作开发的团队使用。Git 通过远程仓库来实现分布式版本控制，可以将代码库复制到本地进行修改和提交，然后将修改推送到远程仓库中。</p>
<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>合并是指将两个不同的代码库中的修改合并到一个新的代码库中的操作。在多人协作开发中，当两个人在同一个文件的同一个位置做了修改时，就会产生冲突。Git 提供了合并功能来解决冲突，可以将两个不同的修改合并到一个新的代码库中。</p>
<h3 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h3><p>补丁是指在不修改原有代码的情况下，通过对代码库进行修改来实现功能的操作。在 Git 中，补丁通常由 <code>diff</code> 命令生成，可以通过 <code>patch</code> 命令来应用补丁。</p>
<p>Git 的这些基本概念是 Git 理解和使用的基础，掌握这些概念有助于更好地理解 Git 的命令和工作原理。</p>
<!-- more -->

<h2 id="Git-基本命令"><a href="#Git-基本命令" class="headerlink" title="Git 基本命令"></a>Git 基本命令</h2><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><p><code>git init</code>是一个初始化 Git 仓库的命令。在执行该命令后，Git 会在当前目录下创建一个新的 <code>.git</code> 目录，这个目录包含了 Git 仓库所需要的所有元数据，比如说分支(branch)、提交(commit)、远程仓库(remote)等。</p>
<p>常用参数:</p>
<ul>
<li><code>--bare</code>: 初始化一个裸仓库，即不包含工作目录。</li>
<li><code>--template=&lt;template_directory&gt;</code>: 使用指定目录作为模板来初始化仓库。</li>
</ul>
<p>举例说明:</p>
<ol>
<li>在当前目录下创建一个新的Git仓库，可以使用以下命令：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>初始化一个裸仓库：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init --bare</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用指定目录作为模板来初始化仓库：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init --template=&lt;template_directory&gt;</span><br></pre></td></tr></table></figure>

<h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p><code>git add</code> 命令将更改的文件添加到 Git 仓库的暂存区，使这些更改准备好被记录在一个新的提交中。</p>
<p>常用参数包括：</p>
<ul>
<li><code>-u</code> 或 <code>--update</code>：将已跟踪的文件的更改添加到暂存区，同时不包括新文件和被删除的文件</li>
<li><code>-A</code> 或 <code>--all</code>：将所有更改，包括新文件、被删除的文件和已跟踪的文件的更改添加到暂存区</li>
<li><code>&lt;pathspec&gt;</code>：指定要添加的文件路径，可以使用通配符匹配多个文件</li>
</ul>
<p>例如，我们新建了一个名为 <code>example.txt</code> 的文件，我们可以使用以下命令将该文件添加到暂存区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add example.txt</span><br></pre></td></tr></table></figure>

<p>如果我们想要将所有更改的文件都添加到暂存区，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add -A</span><br></pre></td></tr></table></figure>

<p>如果我们只想要将已跟踪的文件的更改添加到暂存区，同时不包括新文件和被删除的文件，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add -u</span><br></pre></td></tr></table></figure>

<h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p><code>git commit</code> 命令用于将已暂存的更改保存为一个新的提交对象。它是 Git 中最基本的命令之一，经常用于提交代码和记录版本变更历史。以下是该命令的一些常用参数：</p>
<ul>
<li><code>-m</code>：使用一行消息来描述本次提交，例如 <code>git commit -m &quot;fix bug in login page&quot;</code>。</li>
<li><code>-a</code>：跳过 <code>git add</code> 步骤直接提交已经被追踪的文件更改，不包括未被追踪的文件，例如 <code>git commit -a -m &quot;update readme file&quot;</code>。</li>
<li><code>-am</code>：上述两个参数的合并形式，可以同时提交已经被追踪的文件更改并附带一行消息，例如 <code>git commit -am &quot;update readme file&quot;</code>。</li>
<li><code>--amend</code>：修改上一个提交，通常用于修改提交消息或添加遗漏的文件，例如 <code>git commit --amend -m &quot;update readme file&quot;</code>。</li>
</ul>
<p>示例：</p>
<ol>
<li><p>提交所有暂存的更改并附带一行消息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;add new feature&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>跳过 <code>git add</code> 步骤，提交已经被追踪的文件更改并附带一行消息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -a -m <span class="string">&quot;fix bug&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改上一个提交的提交消息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit --amend -m <span class="string">&quot;fix typo&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p><code>git status</code> 命令用于查看当前工作区状态和暂存区状态，可以帮助开发者确定下一步操作。命令格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status [-s|--short] [--branch] [--porcelain] [--long] [--untracked-files[=&lt;mode&gt;]] [--ignore-submodules[=&lt;when&gt;]] [--ignored] [&lt;pathspec&gt;...]</span><br></pre></td></tr></table></figure>

<p>常用参数包括：</p>
<ul>
<li><code>-s|--short</code>：使用短格式输出。</li>
<li><code>--branch</code>：在输出中包括分支信息。</li>
<li><code>--porcelain</code>：使用机器可读格式输出。</li>
<li><code>--long</code>：使用详细格式输出。</li>
<li><code>--untracked-files[=&lt;mode&gt;]</code>：包括未跟踪的文件。<code>mode</code> 可选参数包括 <code>no</code>、<code>normal</code> 和 <code>all</code>。</li>
<li><code>--ignore-submodules[=&lt;when&gt;]</code>：是否忽略子模块状态。<code>when</code> 可选参数包括 <code>none</code>、<code>untracked</code>、<code>dirty</code> 和 <code>all</code>。</li>
<li><code>--ignored</code>：包括被忽略的文件。</li>
<li><code>&lt;pathspec&gt;...</code>：指定要显示状态的文件。</li>
</ul>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前工作区和暂存区状态</span></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前工作区和暂存区状态，使用短格式输出</span></span><br><span class="line">$ git status -s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前工作区和暂存区状态，包括分支信息</span></span><br><span class="line">$ git status --branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前工作区和暂存区状态，使用机器可读格式输出</span></span><br><span class="line">$ git status --porcelain</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前工作区和暂存区状态，使用详细格式输出</span></span><br><span class="line">$ git status --long</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有未跟踪的文件</span></span><br><span class="line">$ git status --untracked-files=all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略子模块状态</span></span><br><span class="line">$ git status --ignore-submodules=dirty</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定文件的状态</span></span><br><span class="line">$ git status README.md</span><br></pre></td></tr></table></figure>

<p><code>git status</code> 命令的输出结果通常包括：</p>
<ul>
<li>当前所在的分支</li>
<li>已修改但未添加至暂存区的文件</li>
<li>已添加至暂存区但未提交的文件</li>
<li>上游分支与本地分支之间的差异</li>
<li>各个分支之间的差异</li>
<li>存在冲突的文件</li>
<li>忽略的文件</li>
</ul>
<p>根据输出结果，可以进行相应的操作，如添加、提交、撤销等。</p>
<h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p><code>git diff</code>命令可以用于比较工作目录和暂存区域的差异，或者比较已提交的版本和暂存区域的差异。下面介绍几种常用的用法及其参数：</p>
<ol>
<li><p>比较工作目录和暂存区域的差异</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff</span><br></pre></td></tr></table></figure>

<p>运行这个命令会显示工作目录和暂存区域的差异。如果没有任何参数，<code>git diff</code>会显示所有已修改但未添加到暂存区域的文件的差异。</p>
<p>举个例子，假设我们修改了<code>file.txt</code>文件并保存了修改，但是还没有使用<code>git add</code>将修改添加到暂存区域。此时，如果运行<code>git diff</code>命令，会显示出<code>file.txt</code>文件的差异。</p>
</li>
<li><p>比较暂存区域和已提交的版本的差异</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff --staged</span><br></pre></td></tr></table></figure>

<p>这个命令会显示暂存区域和已提交的版本的差异。如果没有任何参数，<code>git diff</code>会显示所有已修改但未添加到暂存区域的文件的差异。</p>
<p>举个例子，假设我们修改了<code>file.txt</code>文件并使用<code>git add</code>将修改添加到暂存区域，但是还没有使用<code>git commit</code>将修改提交到版本库。此时，如果运行<code>git diff --staged</code>命令，会显示出<code>file.txt</code>文件的差异。</p>
</li>
<li><p>比较两个已提交的版本之间的差异</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff &lt;commit1&gt; &lt;commit2&gt;</span><br></pre></td></tr></table></figure>

<p>这个命令会显示两个已提交的版本之间的差异。<code>&lt;commit1&gt;</code>和<code>&lt;commit2&gt;</code>可以是版本号、分支名或标签名等。</p>
<p>举个例子，假设我们想要比较<code>v1.0</code>标签和<code>v2.0</code>标签之间的差异，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff v1.0 v2.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示文件的修改历史记录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<p>这个命令会显示指定文件的修改历史记录。</p>
<p>举个例子，假设我们想要查看<code>file.txt</code>文件的修改历史记录，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> file.txt</span><br></pre></td></tr></table></figure></li>
</ol>
<p>以上就是<code>git diff</code>命令的常用用法及其参数的介绍，可以帮助我们更好地了解工作目录、暂存区域和版本库之间的差异，以及文件的修改历史记录。</p>
<h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><p><code>git log</code> 用于查看 Git 仓库中的提交记录。可以使用该命令查看当前分支的提交记录，也可以查看某个分支或某个特定提交的提交记录。默认情况下，<code>git log</code> 会按照时间顺序列出所有提交记录。</p>
<p>常用的参数包括：</p>
<ul>
<li><code>-n</code> 或 <code>--max-count=&lt;n&gt;</code>：限制显示的提交记录数量。</li>
<li><code>--since</code> 和 <code>--until</code>：按时间过滤提交记录。</li>
<li><code>--author</code>：按作者过滤提交记录。</li>
<li><code>--grep</code>：按提交说明过滤提交记录。</li>
</ul>
<p>以下是一些使用示例：</p>
<ol>
<li><p>显示当前分支的所有提交记录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>显示指定分支的所有提交记录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示某个文件的提交记录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> &lt;file-name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>限制显示最近的 n 条提交记录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -n &lt;n&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示某个时间段内的提交记录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --since=&lt;date1&gt; --<span class="keyword">until</span>=&lt;date2&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示某个作者的提交记录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --author=&lt;author-name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>按提交说明搜索提交记录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --grep=&lt;commit-message&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><code>git log</code> 常用于查看项目的提交历史和了解每个提交所做的更改。通过对提交记录的分析，可以更好地理解项目的发展过程，并且可以帮助开发人员更有效地进行合并和回滚操作。</p>
<h2 id="Git-分支操作命令"><a href="#Git-分支操作命令" class="headerlink" title="Git 分支操作命令"></a>Git 分支操作命令</h2><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p>git branch 命令用于列出、创建、重命名或删除分支。下面详细介绍其常用参数和示例：</p>
<p>常用参数：</p>
<ul>
<li><code>-a</code>：列出所有本地和远程分支。</li>
<li><code>-d</code> 或 <code>--delete</code>：删除指定的分支。</li>
<li><code>-D</code>：强制删除指定的分支。</li>
<li><code>-m</code> 或 <code>--move</code>：重命名指定的分支。</li>
<li><code>-M</code>：强制重命名指定的分支。</li>
</ul>
<p>示例：</p>
<ol>
<li>列出本地分支</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  master</span><br><span class="line">* dev</span><br><span class="line">  feature</span><br></pre></td></tr></table></figure>

<p>上述命令表示列出当前所在仓库的所有本地分支，<code>*</code> 符号代表当前所在分支。</p>
<ol start="2">
<li>创建分支</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch feature</span><br></pre></td></tr></table></figure>

<p>上述命令表示创建一个名为 <code>feature</code> 的分支。</p>
<ol start="3">
<li>切换分支</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout feature</span><br></pre></td></tr></table></figure>

<p>上述命令表示切换到名为 <code>feature</code> 的分支。</p>
<ol start="4">
<li>删除分支</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -d feature</span><br></pre></td></tr></table></figure>

<p>上述命令表示删除名为 <code>feature</code> 的分支，如果该分支还有未合并的提交，删除操作将失败。如果一定要删除该分支，可以使用 <code>-D</code> 参数，它会强制删除分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -D feature</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>重命名分支</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -m feature new-feature</span><br></pre></td></tr></table></figure>

<p>上述命令表示将名为 <code>feature</code> 的分支重命名为 <code>new-feature</code>。</p>
<ol start="6">
<li>列出所有分支</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -a</span><br></pre></td></tr></table></figure>

<p>上述命令表示列出当前所在仓库的所有本地和远程分支。</p>
<h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><p><code>git checkout</code> 命令用于切换分支或还原工作目录中的文件。它的常用参数包括：</p>
<ul>
<li><code>-b &lt;new_branch&gt;</code>: 创建并切换到新分支。</li>
<li><code>-f</code> 或 <code>--force</code>: 强制切换分支或还原文件，可能会丢失未保存的更改。</li>
<li><code>-p</code>: 交互式地选择要丢弃的更改。</li>
<li><code>&lt;commit&gt;</code>: 切换到指定的提交，创建一个分离头指针。</li>
</ul>
<p>以下是一些示例：</p>
<ol>
<li><p>切换分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">&#x27;dev&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建并切换到新分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b feature-branch</span><br><span class="line">Switched to a new branch <span class="string">&#x27;feature-branch&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>还原单个文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout file.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>还原整个目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout .</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换到特定提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout 1a2b3c4d</span><br><span class="line">Note: checking out <span class="string">&#x27;1a2b3c4d&#x27;</span>.</span><br><span class="line"></span><br><span class="line">You are <span class="keyword">in</span> <span class="string">&#x27;detached HEAD&#x27;</span> state. You can look around, make experimental</span><br><span class="line">changes and commit them, and you can discard any commits you make <span class="keyword">in</span> this</span><br><span class="line">state without impacting any branches by performing another checkout.</span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may</span><br><span class="line"><span class="keyword">do</span> so (now or later) by using -b with the checkout <span class="built_in">command</span> again. Example:</span><br><span class="line"></span><br><span class="line">  git checkout -b new_branch_name</span><br><span class="line"></span><br><span class="line">HEAD is now at 1a2b3c4d... Initial commit</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p><code>git merge</code> 命令用于将一个分支的更改合并到当前分支中。它有以下常用参数：</p>
<ul>
<li><code>-m</code>：指定合并时使用的提交信息。如果省略该参数，Git 将自动使用默认信息。</li>
<li><code>--no-ff</code>：创建一个新的合并提交，而不是使用快进模式合并分支。这将保留分支历史信息，并防止将更改直接合并到主线分支。</li>
<li><code>--abort</code>：取消合并操作，恢复到合并之前的状态。</li>
<li><code>--continue</code>：在解决合并冲突后继续进行合并操作。</li>
</ul>
<p>下面是一个示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个新分支</span></span><br><span class="line">$ git checkout -b my-branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 my-branch 上进行更改并提交</span></span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">&quot;Added new feature to my-branch&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到主分支并进行合并</span></span><br><span class="line">$ git checkout main</span><br><span class="line">$ git merge my-branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果发生合并冲突，则需要解决冲突后再进行合并</span></span><br><span class="line">$ git status</span><br><span class="line">$ git diff</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">&quot;Resolved merge conflict&quot;</span></span><br><span class="line">$ git merge --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们首先创建了一个名为 <code>my-branch</code> 的新分支，并在该分支上进行了一些更改和提交。然后我们切换到主分支，并使用 <code>git merge</code> 命令将 <code>my-branch</code> 分支合并到主分支中。如果发生合并冲突，我们需要解决冲突并继续合并操作。最后，我们完成了合并并提交了一个新的合并提交。</p>
<h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p><code>git rebase</code> 是 Git 中一个非常强大的命令，它可以在合并分支的时候，将多个提交整合成一次提交，从而保持分支的整洁性。</p>
<p>具体来说，<code>git rebase</code> 的作用是将当前分支上的提交复制到另一个分支上，这个过程中，Git 会先将当前分支的提交暂存起来，然后切换到目标分支，将暂存的提交依次应用到目标分支上，并产生新的提交，最后再切换回原来的分支。</p>
<p>常用参数包括：</p>
<ul>
<li><code>-i</code>：交互式 rebase，可以手动调整提交的顺序、合并提交等操作。</li>
<li><code>-p</code>：保留 commit 中的时间戳、作者等信息。</li>
<li><code>-s/--strategy</code>：选择 rebase 的策略，常用的策略有 <code>merge</code>（默认）、<code>ours</code>、<code>theirs</code> 等。</li>
</ul>
<p>举个例子，假设我们有一个分支 <code>feature-branch</code>，它基于 <code>master</code> 分支并已经存在多个提交。现在我们需要将 <code>master</code> 分支的更改合并到 <code>feature-branch</code>，可以通过以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout feature-branch</span><br><span class="line">$ git rebase master</span><br></pre></td></tr></table></figure>

<p>这样，Git 会将 <code>feature-branch</code> 分支上的所有提交复制到 <code>master</code> 分支上，并在 <code>master</code> 分支上产生一次新的提交，保持分支的整洁性。在这个过程中，如果出现冲突，需要手动解决冲突并使用 <code>git add</code> 命令来标记解决冲突后的文件，然后使用 <code>git rebase --continue</code> 命令来继续 rebase 过程。</p>
<h2 id="Git-远程仓库命令"><a href="#Git-远程仓库命令" class="headerlink" title="Git 远程仓库命令"></a>Git 远程仓库命令</h2><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p><code>git clone</code> 命令用于从远程 Git 存储库克隆项目到本地机器上。它会复制整个存储库，包括所有分支和版本历史记录。这使得它成为在新机器上开始工作或与他人共享项目的理想选择。</p>
<p>该命令的基本语法如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> &lt;url&gt;</span><br></pre></td></tr></table></figure>

<p>其中，<code>url</code> 是要克隆的 Git 存储库的 URL 地址。还可以通过添加其他选项来定制克隆过程：</p>
<ul>
<li><code>-b</code> 或 <code>--branch</code>：指定要克隆的分支，默认为 <code>master</code>。</li>
<li><code>-depth</code>：仅克隆指定深度的历史记录，以减少下载时间和磁盘空间的使用量。</li>
<li><code>--recursive</code>：在克隆时也初始化和更新任何子模块。</li>
</ul>
<p>以下是一些常见的用法和例子：</p>
<ol>
<li>克隆名为 <code>my-project</code> 的存储库：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/my-username/my-project.git</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>克隆名为 <code>my-project</code> 的存储库中的 <code>development</code> 分支：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> --branch development https://github.com/my-username/my-project.git</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>仅克隆存储库的最近 5 次提交：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> --depth 5 https://github.com/my-username/my-project.git</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>克隆一个包含子模块的存储库：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> --recursive https://github.com/my-username/my-project.git</span><br></pre></td></tr></table></figure>

<h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p>git push是用于将本地代码推送到远程代码库的命令。它的一般语法为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<p>其中<code>&lt;remote&gt;</code>是要推送到的远程代码库的名称，<code>&lt;branch&gt;</code>是要推送的本地分支名称。如果省略<code>&lt;branch&gt;</code>，则会将当前本地分支推送到远程代码库的同名分支。</p>
<p>常用参数：</p>
<ul>
<li><code>-u</code>：将本地分支与远程分支关联，这样以后就可以使用<code>git push</code>命令推送代码了。</li>
<li><code>--force</code>：强制推送本地代码到远程分支，即使远程分支的代码比本地代码更新。</li>
</ul>
<p>示例：</p>
<ol>
<li><p>将本地分支<code>main</code>推送到远程代码库<code>origin</code>的<code>main</code>分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin main</span><br></pre></td></tr></table></figure>
</li>
<li><p>将本地分支<code>feature</code>推送到远程代码库<code>origin</code>的<code>dev</code>分支，并将本地分支与远程分支关联：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push -u origin feature:dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>强制将本地分支<code>main</code>推送到远程代码库<code>origin</code>的<code>main</code>分支，即使远程分支的代码比本地代码更新：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push --force origin main</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p><code>git pull</code>命令用于从远程仓库中获取最新的代码并合并到本地分支中，实现代码同步。它实际上是<code>git fetch</code>和<code>git merge</code>两个命令的组合。</p>
<p>常用参数：</p>
<ul>
<li><code>-r</code>或<code>--rebase</code>：使用<code>git pull --rebase</code>可以将本地的修改放到最新的远程提交后面，以避免由于本地修改引起的合并冲突。</li>
</ul>
<p>举例说明：</p>
<p>假设你的本地分支与远程分支存在差异，并且你想要获取远程分支的最新代码并将其合并到本地分支中，可以执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull origin master</span><br></pre></td></tr></table></figure>

<p>这会从远程仓库中获取master分支的最新代码并将其合并到当前的本地分支。如果本地分支和远程分支之间有冲突，则需要解决冲突后再次提交。如果你想使用rebase方式进行合并，可以使用<code>git pull --rebase origin master</code>命令。</p>
<h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p><code>git fetch</code> 命令用于从远程仓库中下载最新的代码到本地仓库，但是不会自动将代码合并到当前分支中。它会将远程仓库的代码更新到本地仓库的“远程跟踪分支”中。可以使用 <code>git merge</code> 或者 <code>git rebase</code> 将这些更新合并到本地分支中。</p>
<p>常用的参数包括：</p>
<ul>
<li><code>&lt;remote&gt;</code>：指定要获取代码的远程仓库，默认为 <code>origin</code>。</li>
<li><code>&lt;branch&gt;</code>：指定要获取的分支名。默认为当前所在分支。</li>
</ul>
<p>举例来说，要从远程仓库 <code>origin</code> 的 <code>main</code> 分支中获取最新代码，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git fetch origin main</span><br></pre></td></tr></table></figure>

<p>这将会将最新的 <code>main</code> 分支代码更新到本地仓库中的 <code>origin/main</code> 远程跟踪分支中，但是不会将代码合并到当前分支中。如果需要将这些更新合并到当前分支中，可以使用 <code>git merge</code> 或 <code>git rebase</code> 命令。</p>
<h2 id="Git-高级命令"><a href="#Git-高级命令" class="headerlink" title="Git 高级命令"></a>Git 高级命令</h2><h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><p><code>git stash</code>命令可用于将未提交的更改保存到一个临时区域（称为“stash”），以便稍后恢复。这在需要快速更改分支或修复错误时非常有用。</p>
<p>常用的参数和选项包括：</p>
<ul>
<li><code>git stash save [&lt;message&gt;]</code>：将未提交的更改存储到一个新的stash，并可选地为存储添加描述信息。</li>
<li><code>git stash list</code>：列出当前存储的stash。</li>
<li><code>git stash apply [&lt;stash&gt;]</code>：将最新的stash应用到当前分支。如果指定了一个stash，将应用指定的stash。</li>
<li><code>git stash drop [&lt;stash&gt;]</code>：从列表中删除指定的stash。如果没有指定，则删除最新的stash。</li>
<li><code>git stash pop [&lt;stash&gt;]</code>：将最新的stash应用到当前分支，并从列表中删除它。如果指定了一个stash，将应用指定的stash并将其从列表中删除。</li>
<li><code>git stash branch &lt;branchname&gt; [&lt;stash&gt;]</code>：从指定的stash创建一个新分支，并将其应用到该分支。如果没有指定，则使用最新的stash。</li>
</ul>
<p>以下是一个使用<code>git stash</code>命令的示例：</p>
<ol>
<li><p>修改文件并添加到暂存区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add .</span><br></pre></td></tr></table></figure>
</li>
<li><p>对文件进行修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim file.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>对文件进行另一些修改，但还没有提交</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim file.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在您需要切换分支，但不能提交尚未完成的工作。 使用git stash将更改保存在暂存区。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash save <span class="string">&quot;my work in progress&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>您可以通过git stash list查看保存的stash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: On master: my work <span class="keyword">in</span> progress</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在可以切换到其他分支，进行其他工作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout other-branch</span><br></pre></td></tr></table></figure>
</li>
<li><p>回到之前的分支，并应用之前保存的stash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git stash apply</span><br></pre></td></tr></table></figure>
</li>
<li><p>或者，您可以创建一个新分支并将stash应用到该分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash branch new-branch</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h3><p><code>git cherry-pick</code> 命令用于将指定的提交应用于当前分支，它可以将单个或多个提交从其他分支或当前分支的不同位置应用到当前分支。它可以用来复制特定的提交或解决特定的问题。</p>
<p>该命令的基本语法为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick &lt;commit-hash&gt;</span><br></pre></td></tr></table></figure>

<p>其中 <code>&lt;commit-hash&gt;</code> 是要应用的提交的哈希值。可以使用 <code>git log</code> 命令来查找要应用的提交的哈希值。另外，可以一次选择多个提交来应用。</p>
<p><code>git cherry-pick</code> 命令还支持以下常用参数：</p>
<ul>
<li><code>-e</code> 或 <code>--edit</code>：打开编辑器以编辑提交信息；</li>
<li><code>-n</code> 或 <code>--no-commit</code>：将更改应用到工作目录和暂存区，但不自动提交；</li>
<li><code>-x</code>：在提交信息中包含从哪个提交进行的 Cherry-pick 信息；</li>
<li><code>-s</code> 或 <code>--signoff</code>：在提交信息末尾添加 Signed-off-by 行。</li>
</ul>
<p>下面是一个使用 <code>git cherry-pick</code> 命令的示例：</p>
<ol>
<li><p>假设我们有一个名为 <code>feature-branch</code> 的分支，我们要将该分支上的一个提交应用到 <code>main</code> 分支上。首先，我们需要切换到 <code>main</code> 分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout main</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，我们可以使用 <code>git log</code> 命令来查找要应用的提交的哈希值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> feature-branch</span><br></pre></td></tr></table></figure>
</li>
<li><p>找到要应用的提交的哈希值后，我们可以使用 <code>git cherry-pick</code> 命令将其应用到当前分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick &lt;commit-hash&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果该提交没有冲突，则会自动应用。如果有冲突，则需要手动解决冲突并使用 <code>git add</code> 命令将更改标记为已解决。然后，可以使用 <code>git cherry-pick --continue</code> 命令继续应用提交。如果想放弃 cherry-pick，则可以使用 <code>git cherry-pick --abort</code> 命令。</p>
</li>
</ol>
<h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p><code>git reset</code> 命令可以将 HEAD 指针指向指定的提交记录，并把这个提交记录之后的提交记录从暂存区和工作区中移除。它可以用来撤销已提交的更改，恢复之前的版本。常用参数如下：</p>
<ul>
<li><code>--soft</code>：将 HEAD 指针移动到指定的提交记录，但是不会修改暂存区和工作区，这意味着你可以重新提交这些更改。</li>
<li><code>--mixed</code>：这是默认选项，将 HEAD 指针移动到指定的提交记录，并将暂存区恢复为该提交的状态，但不修改工作区，这意味着你需要再次使用 <code>git add</code> 命令将需要提交的更改加入暂存区。</li>
<li><code>--hard</code>：将 HEAD 指针移动到指定的提交记录，并将暂存区和工作区都恢复为该提交的状态。这意味着之前的更改将被完全删除，慎用该选项。</li>
</ul>
<p>常见用法包括：</p>
<ul>
<li>恢复到之前某个提交版本，例如 <code>git reset HEAD~1</code> 表示回到上一个提交版本。</li>
<li>撤销之前的提交，例如 <code>git reset HEAD~1 --soft</code> 表示将 HEAD 指针指向上一个提交版本，但是保留之前提交的更改，可以重新修改并再次提交。</li>
</ul>
<p>注意，<code>git reset</code> 命令改变了 Git 的提交历史记录，因此如果已经推送到远程仓库，需要慎重使用该命令，否则可能导致协作中的其他人产生困惑。</p>
<h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><p><code>git revert</code>命令用于撤销一个或多个提交，它会生成一个新的提交，该提交将逆转先前的提交更改。</p>
<p>常用的参数包括：</p>
<ul>
<li><code>-n, --no-commit</code>: 撤销提交时不自动生成新的提交。</li>
<li><code>-m parent-num</code>: 用于撤销一个合并提交，指定合并提交中要撤销的父提交的序号。</li>
</ul>
<p>例如，假设我们有一个提交历史记录如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">* 1f024d6 (HEAD -&gt; main) add file3.txt</span><br><span class="line">* 6c66a89 add file2.txt</span><br><span class="line">* 8f75d27 add file1.txt</span><br></pre></td></tr></table></figure>

<p>如果我们想要撤销 <code>add file2.txt</code> 这个提交，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git revert 6c66a89</span><br></pre></td></tr></table></figure>

<p>Git会自动生成一个新的提交，将之前 <code>add file2.txt</code> 提交中的更改逆转。这将导致提交历史记录如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">* a438432 (HEAD -&gt; main) Revert <span class="string">&quot;add file2.txt&quot;</span></span><br><span class="line">* 1f024d6 add file3.txt</span><br><span class="line">* 6c66a89 add file2.txt</span><br><span class="line">* 8f75d27 add file1.txt</span><br></pre></td></tr></table></figure>

<p>注意，使用 <code>git revert</code> 不会从代码库中删除任何东西，只是生成一个新的提交来撤销之前的更改。如果要完全删除某个提交及其更改，可以使用 <code>git reset</code> 或 <code>git rebase</code> 命令。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了 Git 常用的基础命令及其用法，并给出了相应的示例。</p>
<p>Git初始化</p>
<ul>
<li><code>git init</code> 初始化一个 Git 仓库</li>
</ul>
<p>Git管理文件</p>
<ul>
<li><code>git add [file]</code> 将文件添加到 Git 索引中</li>
<li><code>git commit -m &quot;message&quot;</code> 提交索引中的文件并添加提交消息</li>
</ul>
<p>Git状态查询</p>
<ul>
<li><code>git status</code> 显示 Git 仓库的当前状态</li>
<li><code>git diff</code> 显示未暂存文件与上次提交版本的差异</li>
<li><code>git log</code> 显示提交日志</li>
</ul>
<p>Git分支管理</p>
<ul>
<li><code>git branch</code> 显示本地分支列表</li>
<li><code>git checkout [branch]</code> 切换到目标分支</li>
<li><code>git merge [branch]</code> 合并指定分支到当前分支</li>
<li><code>git rebase [branch]</code> 将当前分支变基到目标分支</li>
</ul>
<p>Git远程仓库管理</p>
<ul>
<li><code>git clone [url]</code> 从远程仓库克隆代码到本地</li>
<li><code>git push [remote] [branch]</code> 将本地分支推送到远程仓库</li>
<li><code>git pull [remote] [branch]</code> 从远程仓库拉取最新代码到本地</li>
<li><code>git fetch [remote]</code> 从远程仓库获取最新代码</li>
</ul>
<p>Git其他命令</p>
<ul>
<li><code>git stash</code> 暂存当前工作进度</li>
<li><code>git cherry-pick [commit]</code> 从指定提交中提取更改并应用于当前分支</li>
<li><code>git reset [commit]</code> 撤销到指定的提交</li>
<li><code>git revert [commit]</code> 撤销指定的提交</li>
</ul>
<p>推荐最佳实践</p>
<ul>
<li>使用分支进行开发，不要直接在 <code>master</code> 分支上进行开发。</li>
<li>提交信息要详细，不要简单地写 “修改” 或 “更新” 等不具体的描述。</li>
<li>定期将本地分支与远程分支同步，避免出现代码冲突。</li>
<li>使用 Git 工作流程管理开发流程，如 Git Flow 等。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL2VuL3Yy">Pro Git book<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9kb2M=">Git official documentation<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>版本管理</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub 使用命令行同步 fork 仓库</title>
    <url>/2023/05/02/20230502-github%E4%BB%93%E5%BA%93%E5%86%8D%E6%AC%A1fork/</url>
    <content><![CDATA[<p>在 GitHub 上，我们可以使用 Fork 操作将其他用户的仓库复制到自己的账户下。但如果原始仓库更新了，我们可能需要将其再次 fork 到自己的账户下，以保持代码与原始仓库同步。下面将介绍如何使用 Git 命令行进行 GitHub 仓库再次 fork 的操作。</p>
<span id="more"></span>

<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><ol>
<li><p>在 GitHub 上找到你之前 fork 的一个仓库，并且该原始仓库已经有更新。</p>
</li>
<li><p>打开 Git 命令行，使用 <code>cd</code> 命令进入你想要存储该仓库的本地目录中。</p>
</li>
<li><p>在命令行中输入以下命令，将你的 fork 仓库克隆到本地。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> &lt;你的 fork 仓库的地址&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入本地仓库的目录中，使用 <code>git remote -v</code> 命令查看远程仓库的地址，确认你当前的远程仓库是你 fork 的仓库。</p>
</li>
<li><p>为原始仓库添加一个远程地址。输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote add upstream &lt;原始仓库的地址&gt;</span><br></pre></td></tr></table></figure>

<p>其中 <code>&lt;原始仓库的地址&gt;</code> 是你想要再次 fork 的仓库的地址。如果不知道原始仓库的地址，可以在该仓库页面中点击 “Clone or download” 按钮，复制仓库地址。</p>
</li>
<li><p>使用 <code>git remote -v</code> 命令确认添加的远程地址是否生效。如果添加成功会有如下输出，当然我们使用 <code>cat .git/config</code> 命令也能查看相关配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">origin	&lt;你的 fork 仓库的地址&gt; (fetch)</span><br><span class="line">origin	&lt;你的 fork 仓库的地址&gt; (push)</span><br><span class="line">upstream	&lt;原始仓库的地址&gt; (fetch)</span><br><span class="line">upstream	&lt;原始仓库的地址&gt; (push)</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新本地仓库代码，将原始仓库的更新合并到你的 fork 仓库中。输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git fetch upstream</span><br><span class="line">$ git merge upstream/master</span><br></pre></td></tr></table></figure>

<p>这样，你的本地仓库就会被更新到原始仓库的最新版本。</p>
</li>
<li><p>最后，执行 <code>git push</code> 命令，将合并的代码推送到远端。</p>
</li>
</ol>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>还有一个更加简便快捷的命令，如下（下述命令执行前请先根据<em><strong>方法一</strong></em>设置好 <code>upstream</code>）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git fetch upstream &amp;&amp; git reset --hard upstream/master &amp;&amp; git push -f</span><br></pre></td></tr></table></figure>

<p>这种方法只适用于不用保存自己版本的情况。<em><strong>当执行上述命令时，你一定要知道你在做什么。</strong></em>接下来，我们来解释一下这段命令的含义。</p>
<p>这行命令做了以下三个操作：</p>
<ol>
<li><p><code>git fetch upstream</code>: 这个命令从远程仓库 <code>upstream</code> 中拉取最新的代码到本地的 <code>upstream/master</code> 分支中。这样可以让你的本地仓库知道有哪些新的提交。</p>
</li>
<li><p><code>git reset --hard upstream/master</code>: 这个命令将你当前的分支（通常是 <code>master</code> 分支）回滚到 <code>upstream/master</code> 分支指向的提交。这意味着本地分支将与原始仓库的最新代码完全一致，并且会放弃本地所有的提交。因此，在执行这个命令之前，请确保你已经备份了本地的修改。</p>
</li>
<li><p><code>git push -f</code>: 这个命令将你的本地分支强制推送到远程仓库。由于你在本地分支进行了回滚操作，因此你需要强制推送以覆盖远程仓库的历史记录。这个命令应该谨慎使用，因为它会破坏其他人的提交记录。因此，如果你的本地分支和远程仓库不一致，最好先使用 <code>git pull</code> 尝试合并代码。</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 Git 命令行进行 GitHub 仓库再次 fork 的操作可以让我们更好地管理代码，并保持代码与原始仓库的同步。掌握 Git 命令行的基本用法可以让我们更加高效地进行开发工作。</p>
]]></content>
      <categories>
        <category>版本管理</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS 安装 manpages-zh</title>
    <url>/2023/05/18/20230518-%E5%AE%89%E8%A3%85%E4%B8%AD%E6%96%87man%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>在 macOS 上，<code>man</code> 命令用于查看系统中安装的程序的帮助文档。然而，默认情况下，这些帮助文档都是英文的，对于不熟悉英文的用户来说可能会有些困难。幸运的是，我们可以安装 <code>manpages-zh</code> 来获取中文帮助文档。</p>
<span id="more"></span>

<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>在安装之前，我们需要先安装一些依赖项，依赖项有三个：cmake，python3，opencc，在 macOS 上我们使用 <code>brew</code> 安装这些依赖。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew install cmake</span><br><span class="line">$ brew install python</span><br><span class="line">$ brew install opencc</span><br></pre></td></tr></table></figure>

<h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><ol>
<li><p><code>clone</code> 项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:man-pages-zh/manpages-zh.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看最新的 tag</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git describe --tags --abbrev=0</span><br><span class="line"><span class="comment"># 或者执行 git tag -l 查看 tag 列表</span></span><br><span class="line"><span class="comment"># 写这篇博客时，最近的 tag 是 v1.6.4.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>切换到最新的 tag</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout tags/v1.6.4.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> manpages-zh</span><br><span class="line">$ <span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build/</span><br><span class="line">$ cmake ..</span><br><span class="line">$ make</span><br><span class="line">$ <span class="built_in">sudo</span> make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装完成后，我们会在 /usr/local/share/man 目录下看到两个目录 zh_CN zh_TW</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加 <code>zh_CN</code> 到配置文件，本人环境为 <code>zsh</code>，我是将环境添加到 <code>.zshrc</code> 中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MANPATH=/usr/local/share/man/zh_CN:$MANPATH; export MANPATH</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启终端尝试 <code>man</code> 命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ man <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<img src="/my_pictures/20230518/1.png" style="zoom:45%;" /></li>
</ol>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>安装 <code>manpages-zh</code> 后，我们可以方便地查看中文帮助文档，这对于不熟悉英文的用户来说是非常有用的。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21hbi1wYWdlcy16aC9tYW5wYWdlcy16aA==">manpages-zh<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Z5a2VjLmdpdGh1Yi5pby8yMDE1LzEwLzI2L21hbnBhZ2VzLXpoLU1hYy1PUy1JbnN0YWxsYXRpb24uaHRtbA==">Manpages Zh Mac Os Installation<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>终端命令</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言重拾【八】结构和其他数据形式</title>
    <url>/2023/06/20/20230620-C%20%E8%AF%AD%E8%A8%80%E9%87%8D%E6%8B%BE%E3%80%90%E5%85%AB%E3%80%91/</url>
    <content><![CDATA[<p>在 C 语言中，结构体是一种非常重要的数据类型。它可以将不同的数据类型组合成一个整体，方便程序员进行操作。比如，我们可以定义一个结构体来表示一个人的信息，包括姓名、年龄、性别等等。使用结构体可以使得程序更加清晰易懂，提高代码的可读性和可维护性。</p>
<span id="more"></span>

<p>结构声明（structure declaration）描述了一个结构的组织布局。声明类似下面这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> title[MAXTITL];</span><br><span class="line">  <span class="type">char</span> author[MAXAUTL];</span><br><span class="line">  <span class="type">float</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该声明描述了一个由两个字符数组和一个 <code>float</code> 类型变量组成的结构。该声明并未创建实际的数据对象，只描述了该对象由什么组成。我们来分析一些细节。首先是关键字 <code>struct</code>，它表明跟在其后的是一个结构，后面是一个可选的标记（该例中是 <code>book</code>），稍后程序中可以使用该标记引用该结构。所以，我们在后面的程序中可以这样声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>;</span></span><br></pre></td></tr></table></figure>

<p>这把 <code>library</code> 声明为一个使用 <code>book</code> 结构布局的结构变量。</p>
<p>结构有两层含义。一层含义是“结构布局”，刚才已经讨论过了。结构布局告诉编译器如何表示数据，但是它并未让编译器为数据分配空间。下一步是创建一个结构变量，即是结构的另一层含义。程序中创建结构变量的一行是:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>;</span></span><br></pre></td></tr></table></figure>

<p>编译器执行这行代码便创建了一个结构变量 <code>library</code>。编译器使用book模板为该变量分配空间：一个内含 <code>MAXTITL</code> 个元素的 <code>char</code> 数组、一个内含 <code>MAXAUTL</code> 个元素的 <code>char</code> 数组和一个 <code>float</code> 类型的变量。这些存储空间都与一个名称 <code>library</code> 结合在一起。</p>
<p><img src="/my_pictures/20230620/1.png" alt="一个结构的内存分配"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>;</span></span><br></pre></td></tr></table></figure>

<p>是以下声明的简化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> title[MAXTITL];</span><br><span class="line">  <span class="type">char</span> author[AXAUTL];</span><br><span class="line">  <span class="type">float</span> value;</span><br><span class="line">&#125; library;　 <span class="comment">/* 声明的右右花括号后跟变量名*/</span></span><br></pre></td></tr></table></figure>

<p>换言之，声明结构的过程和定义结构变量的过程可以组合成一个步骤。如下所示，组合后的结构声明和结构变量定义不需要使用结构标记：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* 无结构标记 */</span></span><br><span class="line">  <span class="type">char</span> title[MAXTITL];</span><br><span class="line">  <span class="type">char</span> author[MAXAUTL];</span><br><span class="line">  <span class="type">float</span> value;</span><br><span class="line">&#125; library;</span><br></pre></td></tr></table></figure>

<p>然而，如果打算多次使用结构模板，就要使用带标记的形式；或者，使用本章后面介绍的 <code>typedef</code>。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 中 gitlab 登录密码忘了怎么办？</title>
    <url>/2023/09/09/20230909-Docker%20%E4%B8%AD%20gitlab%20%E7%99%BB%E5%BD%95%E5%AF%86%E7%A0%81%E5%BF%98%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/</url>
    <content><![CDATA[<p>一直自动登录导致忘记 gitlab 的密码，这篇文章我们来通过命令行修改 gitlab 的密码。</p>
<span id="more"></span>

<h2 id="启动并进入-Docker-中的-gitlab"><a href="#启动并进入-Docker-中的-gitlab" class="headerlink" title="启动并进入 Docker 中的 gitlab"></a>启动并进入 Docker 中的 gitlab</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it gitlab-ce /bin/bash</span><br></pre></td></tr></table></figure>

<h2 id="在生产环境运行-GitLab-的-Rails-控制台"><a href="#在生产环境运行-GitLab-的-Rails-控制台" class="headerlink" title="在生产环境运行 GitLab 的 Rails 控制台"></a>在生产环境运行 GitLab 的 Rails 控制台</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gitlab-rails console -e production</span><br></pre></td></tr></table></figure>

<p>执行命令后需要稍微等待，将会进入如下界面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@dbbc74ab8f4f:/# gitlab-rails console -e production</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"> Ruby:         ruby 3.0.6p216 (2023-03-30 revision 23a532679b) [aarch64-linux]</span><br><span class="line"> GitLab:       16.2.1 (3216f7a4aef) FOSS</span><br><span class="line"> GitLab Shell: 14.23.0</span><br><span class="line"> PostgreSQL:   13.11</span><br><span class="line">------------------------------------------------------------[ booted <span class="keyword">in</span> 15.32s ]</span><br><span class="line">Loading production environment (Rails 7.0.6)</span><br><span class="line">irb(main):001:0&gt;</span><br></pre></td></tr></table></figure>

<h2 id="获取所有用户"><a href="#获取所有用户" class="headerlink" title="获取所有用户"></a>获取所有用户</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ user = User.all</span><br></pre></td></tr></table></figure>

<p>执行命令后你会看到 gitlab 中所有用户信息，大致如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ =&gt; [#&lt;User <span class="built_in">id</span>:1 @root&gt;, <span class="comment">#&lt;User id:34 @my_gitlab&gt;]</span></span><br></pre></td></tr></table></figure>

<p>上面输出了一个用户数组，其中有两个用户，一个是 <code>root</code> 一个是 <code>my_gitlab</code></p>
<p>这次我们需要修改的是 <code>my_gitlab</code> 账户的密码，所以我们获取对应的 <code>User</code> 对象。</p>
<h2 id="根据-id-查询用户"><a href="#根据-id-查询用户" class="headerlink" title="根据 id 查询用户"></a>根据 id 查询用户</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ user = User.<span class="built_in">where</span>(<span class="built_in">id</span>:34).first</span><br></pre></td></tr></table></figure>

<p>你会得到如下的输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ =&gt; <span class="comment">#&lt;User id:34 @my_gitlab&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在我们的 user 变量存的就是 <code>my_gitlab</code> 对象。</p>
<h2 id="重置密码"><a href="#重置密码" class="headerlink" title="重置密码"></a>重置密码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ user.password = <span class="string">&#x27;xxxx&#x27;</span></span><br></pre></td></tr></table></figure>

<p>执行上面的命令修改 <code>my_gitlab</code> 的密码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ user.password_confirmation = <span class="string">&#x27;xxxx&#x27;</span></span><br></pre></td></tr></table></figure>

<p>执行上面的命令确认密码。修改完密码后记得调用 <code>save</code> 进行保存。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ user.save</span><br></pre></td></tr></table></figure>

<p>看到输出 <code>true</code> 即修改成功。最后执行 <code>exit</code>。退出设置即可。打开网页，使用刚才修改的密码登录。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 学习之 Activity 生命周期</title>
    <url>/2023/09/19/20230919-Android%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%20Activity/</url>
    <content><![CDATA[<p>当用户浏览、退出和返回到您的应用时，应用中的 <code>Activity</code> 实例会在其生命周期的不同状态间转换。<code>Activity</code> 类会提供许多回调，这些回调会让 Activity 知晓某个状态已经更改：系统正在创建、停止或恢复某个 Activity，或者正在销毁该 Activity 所在的进程。</p>
<span id="more"></span>

<h2 id="Activity-生命周期概念"><a href="#Activity-生命周期概念" class="headerlink" title="Activity 生命周期概念"></a>Activity 生命周期概念</h2><p>为了在 Activity 生命周期的各个阶段之间导航转换，Activity 类提供六个核心回调：<code>onCreate()</code>、<code>onStart()</code>、<code>onResume()</code>、<code>onPause()</code>、<code>onStop()</code> 和 <code>onDestroy()</code>。当 Activity 进入新状态时，系统会调用其中每个回调。</p>
<p>下图是对此范例的直观展现。</p>
<img src="/my_pictures/20230919/1.png" style="zoom:90%;" />

<p>当用户开始离开 Activity 时，系统会调用方法来销毁该 Activity。在某些情况下，此销毁只是部分销毁；Activity 仍然驻留在内存中（例如当用户切换至另一应用时），并且仍然可以返回到前台。如果用户返回到该 Activity，Activity 会从用户离开时的位置继续运行。除了少数例外，应用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vZ3VpZGUvY29tcG9uZW50cy9hY3Rpdml0aWVzL2JhY2tncm91bmQtc3RhcnRzP2hsPXpoLWNu">在后台运行时会受到限制，无法启动 Activity<i class="fa fa-external-link-alt"></i></span>。</p>
<p>系统终止给定进程及其中 Activity 的可能性取决于当时 Activity 的状态。<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vZ3VpZGUvY29tcG9uZW50cy9hY3Rpdml0aWVzL2FjdGl2aXR5LWxpZmVjeWNsZT9obD16aC1jbiNhc2Vt">Activity 状态和从内存中弹出<i class="fa fa-external-link-alt"></i></span> 会更详细地介绍状态与弹出漏洞之间的关系。</p>
<p>根据 Activity 的复杂程度，您可能不需要实现所有生命周期方法。但是，请务必了解每个方法，并实现能够确保应用按用户预期方式运行的方法，这非常重要。</p>
<p>在下一部分中，本文档将详细介绍用于处理状态间转换的回调。</p>
<h2 id="生命周期回调"><a href="#生命周期回调" class="headerlink" title="生命周期回调"></a>生命周期回调</h2><p>本部分介绍 Activity 生命周期中所用回调方法的相关概念及实现信息。</p>
<p>某些操作（例如调用 <code>setContentView()</code>）属于 Activity 生命周期方法本身。不过，用于实现依赖组件操作的代码应放在组件本身内。为此，您必须使依赖组件具有生命周期感知能力。请参阅<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdG9waWMvbGlicmFyaWVzL2FyY2hpdGVjdHVyZS9saWZlY3ljbGU/aGw9emgtY24=">使用生命周期感知型组件处理生命周期<i class="fa fa-external-link-alt"></i></span>，了解如何让您的依赖组件获得生命周期感知能力。</p>
<h3 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate()"></a>onCreate()</h3><p>您必须实现此回调，它会在系统首次创建 Activity 时触发。Activity 会在创建后进入“已创建”状态。在 <code>onCreate()</code> 方法中，您需执行基本应用启动逻辑，该逻辑在 Activity 的整个生命周期中只应发生一次。例如，<code>onCreate()</code> 的实现可能会将数据绑定到列表，将 Activity 与 <code>ViewModel</code> 相关联，并实例化某些类作用域变量。此方法会接收 <code>savedInstanceState</code> 参数，后者是包含 Activity 先前保存状态的 <code>Bundle</code> 对象。如果 Activity 此前未曾存在，<code>Bundle</code> 对象的值为 null。</p>
<p>如果您有一个生命周期感知型组件与您的 Activity 生命周期相关联，该组件将收到 <code>ON_CREATE</code> 事件。系统将调用带有 <code>@OnLifecycleEvent</code> 注释的方法，以使您的生命周期感知型组件可以执行已创建状态所需的任何设置代码。</p>
<p><code>onCreate()</code> 方法的以下示例显示执行 Activity 某些基本设置的一些代码，例如声明界面（在 XML 布局文件中定义）、定义成员变量，以及配置某些界面。在本示例中，系统通过将文件的资源 ID <code>R.layout.main_activity</code> 传递给 <code>setContentView()</code> 来指定 XML 布局文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TextView textView;</span><br><span class="line"></span><br><span class="line"><span class="comment">// some transient state for the activity instance</span></span><br><span class="line">String gameState;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="comment">// call the super class onCreate to complete the creation of activity like</span></span><br><span class="line">    <span class="comment">// the view hierarchy</span></span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recovering the instance state</span></span><br><span class="line">    <span class="keyword">if</span> (savedInstanceState != <span class="literal">null</span>) &#123;</span><br><span class="line">        gameState = savedInstanceState.getString(GAME_STATE_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set the user interface layout for this activity</span></span><br><span class="line">    <span class="comment">// the layout file is defined in the project res/layout/main_activity.xml file</span></span><br><span class="line">    setContentView(R.layout.main_activity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize member TextView so we can manipulate it later</span></span><br><span class="line">    textView = (TextView) findViewById(R.id.text_view);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This callback is called only when there is a saved instance that is previously saved by using</span></span><br><span class="line"><span class="comment">// onSaveInstanceState(). We restore some state in onCreate(), while we can optionally restore</span></span><br><span class="line"><span class="comment">// other state here, possibly usable after onStart() has completed.</span></span><br><span class="line"><span class="comment">// The savedInstanceState Bundle is same as the one used in onCreate().</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    textView.setText(savedInstanceState.getString(TEXT_VIEW_KEY));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// invoked when the activity may be temporarily destroyed, save the instance state here</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSaveInstanceState</span><span class="params">(Bundle outState)</span> &#123;</span><br><span class="line">    outState.putString(GAME_STATE_KEY, gameState);</span><br><span class="line">    outState.putString(TEXT_VIEW_KEY, textView.getText());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call superclass to save any view hierarchy</span></span><br><span class="line">    <span class="built_in">super</span>.onSaveInstanceState(outState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了定义 XML 文件，然后将其传递给 <code>setContentView()</code>，您还可以在 Activity 代码中新建 <code>View</code> 对象，并将新建的 <code>View</code> 插入到 <code>ViewGroup</code> 中，以构建视图层次结构。然后，将根 <code>ViewGroup</code> 传递给 <code>setContentView()</code> 以使用该布局。如需详细了解如何创建界面，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vZ3VpZGUvdG9waWNzL3VpP2hsPXpoLWNu">界面<i class="fa fa-external-link-alt"></i></span>文档。</p>
<p>您的 Activity 并未处于“已创建”状态。<code>onCreate()</code> 方法完成执行后，Activity 进入“已开始”状态，系统会相继调用 <code>onStart()</code> 和 <code>onResume()</code> 方法。下一部分将介绍 <code>onStart()</code> 回调。</p>
<h3 id="onStart"><a href="#onStart" class="headerlink" title="onStart()"></a>onStart()</h3><p>当 Activity 进入“已开始”状态时，系统会调用此回调。<code>onStart()</code> 调用使 Activity 对用户可见，因为应用会为 Activity 进入前台并支持互动做准备。例如，应用通过此方法来初始化维护界面的代码。</p>
<p>当 Activity 进入已开始状态时，与 Activity 生命周期相关联的所有生命周期感知型组件都将收到 <code>ON_START</code> 事件。</p>
<p><code>onStart()</code> 方法会非常快速地完成，并且与“已创建”状态一样，Activity 不会一直处于“已开始”状态。一旦此回调结束，Activity 便会进入“已恢复”状态，系统将调用 <code>onResume()</code> 方法。</p>
<h3 id="onResume"><a href="#onResume" class="headerlink" title="onResume()"></a>onResume()</h3><p>Activity 会在进入“已恢复”状态时来到前台，然后系统调用 <code>onResume()</code> 回调。这是应用与用户互动的状态。应用会一直保持这种状态，直到某些事件发生，让焦点远离应用。此类事件包括接到来电、用户导航到另一个 Activity，或设备屏幕关闭。</p>
<p>当 Activity 进入已恢复状态时，与 Activity 生命周期相关联的所有生命周期感知型组件都将收到 <code>ON_RESUME</code> 事件。这时，生命周期组件可以启用在组件可见且位于前台时需要运行的任何功能，例如启动相机预览。</p>
<p>当发生中断事件时，Activity 进入“已暂停”状态，系统调用 <code>onPause()</code> 回调。</p>
<p>如果 Activity 从“已暂停”状态返回“已恢复”状态，系统将再次调用 <code>onResume()</code> 方法。因此，您应实现 <code>onResume()</code>，以初始化在 <code>onPause()</code> 期间释放的组件，并执行每次 Activity 进入“已恢复”状态时必须完成的任何其他初始化操作。</p>
<p>以下是生命周期感知型组件的示例，该组件在收到 <code>ON_RESUME</code> 事件时访问相机：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CameraComponent</span> <span class="keyword">implements</span> <span class="title class_">LifecycleObserver</span> &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initializeCamera</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (camera == <span class="literal">null</span>) &#123;</span><br><span class="line">            getCamera();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LifecycleObserver</code> 收到 ON_RESUME 事件后，上述代码便会初始化相机。然而，在多窗口模式下，即使处于“已暂停”状态，您的 Activity 也可能完全可见。例如，当用户处于多窗口模式，并点按另一个不包含 Activity 的窗口时，您的 Activity 将进入“已暂停”状态。如果您希望相机仅在应用处于“已恢复”（可见且在前台运行）状态时可用，请在收到上述 ON_RESUME 事件后初始化相机。如果您希望在 Activity 处于“已暂停”状态但可见时（例如在多窗口模式下）保持相机可用，应在收到 ON_START 事件后初始化相机。但请注意，若要让相机在 Activity 处于“已暂停”状态时可用，可能会导致系统在多窗口模式下拒绝其他处于“已恢复”状态的应用访问相机。有时可能有必要让相机在 Activity 处于“已暂停”状态时保持可用，但这样做实际可能会降低整体用户体验。请仔细考虑，生命周期的哪个阶段更适合在多窗口环境下控制共享系统资源。如需详细了解如何支持多窗口模式，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vZ3VpZGUvdG9waWNzL3VpL211bHRpLXdpbmRvdz9obD16aC1jbg==">多窗口支持<i class="fa fa-external-link-alt"></i></span>。</p>
<p>无论您选择在哪个构建事件中执行初始化操作，都请务必使用相应的生命周期事件来释放资源。如果您在收到 ON_START 事件后初始化某些内容，请在收到 ON_STOP 事件后释放或终止相应内容。如果您在收到 ON_RESUME 事件后初始化某些内容，请在收到 ON_PAUSE 事件后将其释放。</p>
<p>请注意，上述代码段将相机初始化代码放置在生命周期感知型组件中。您也可以直接将此代码放入 Activity 生命周期回调（例如 <code>onStart()</code> 和 <code>onStop()</code>），但我们不建议您这样做。通过将此逻辑添加到独立的生命周期感知型组件中，您可以对多个 Activity 重复使用该组件，而无需复制代码。请参阅<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdG9waWMvbGlicmFyaWVzL2FyY2hpdGVjdHVyZS9saWZlY3ljbGU/aGw9emgtY24=">使用生命周期感知型组件处理生命周期<i class="fa fa-external-link-alt"></i></span>，了解如何创建生命周期感知型组件。</p>
<h3 id="onPause"><a href="#onPause" class="headerlink" title="onPause()"></a>onPause()</h3><p>系统将此方法视为用户将要离开您的 Activity 的第一个标志（尽管这并不总是意味着 Activity 会被销毁）；此方法表示 Activity 不再位于前台（尽管在用户处于多窗口模式时 Activity 仍然可见）。使用 <code>onPause()</code> 方法暂停或调整当 <code>Activity</code> 处于“已暂停”状态时不应继续（或应有节制地继续）的操作，以及您希望很快恢复的操作。Activity 进入此状态的原因有很多。例如：</p>
<ul>
<li>如 <code>onResume()</code> 部分所述，某个事件会中断应用执行。这是最常见的情况。</li>
<li>在 Android 7.0（API 级别 24）或更高版本中，有多个应用在多窗口模式下运行。无论何时，都只有一个应用（窗口）可以拥有焦点，因此系统会暂停所有其他应用。</li>
<li>有新的半透明 Activity（例如对话框）处于开启状态。只要 Activity 仍然部分可见但并未处于焦点之中，它便会一直暂停。</li>
</ul>
<p>当 Activity 进入已暂停状态时，与 Activity 生命周期相关联的所有生命周期感知型组件都将收到 <code>ON_PAUSE</code> 事件。这时，生命周期组件可以停止在组件未位于前台时无需运行的任何功能，例如停止相机预览。</p>
<p>您还可以使用 <code>onPause()</code> 方法释放系统资源、传感器（例如 GPS）手柄，或当您的 Activity 暂停且用户不需要它们时仍然可能影响电池续航时间的任何资源。然而，正如上文的 onResume() 部分所述，如果处于多窗口模式，“已暂停”的 Activity 仍完全可见。因此，您应该考虑使用 onStop() 而非 onPause() 来完全释放或调整与界面相关的资源和操作，以便更好地支持多窗口模式。</p>
<p>响应 ON_PAUSE 事件的以下 <code>LifecycleObserver</code> 示例与上述 ON_RESUME 事件示例相对应，会释放在收到 ON_RESUME 事件后初始化的相机：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaCameraComponent</span> <span class="keyword">implements</span> <span class="title class_">LifecycleObserver</span> &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseCamera</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (camera != <span class="literal">null</span>) &#123;</span><br><span class="line">            camera.release();</span><br><span class="line">            camera = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，上述代码段在 LifecycleObserver 收到 ON_PAUSE 事件后放置相机释放代码。如前所述，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdG9waWMvbGlicmFyaWVzL2FyY2hpdGVjdHVyZS9saWZlY3ljbGU/aGw9emgtY24=">使用生命周期感知型组件处理生命周期<i class="fa fa-external-link-alt"></i></span>了解如何创建生命周期感知型组件。</p>
<p><code>onPause()</code> 执行非常简单，而且不一定要有足够的时间来执行保存操作。因此，您<strong>不</strong>应使用 <code>onPause()</code> 来保存应用或用户数据、进行网络调用或执行数据库事务。因为在该方法完成之前，此类工作可能无法完成。相反，您应在 <code>onStop()</code>期间执行高负载的关闭操作。如需详细了解在 <code>onStop()</code> 期间执行的合适操作，请参阅 <code>onStop()</code>。如需详细了解如何保存数据，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vZ3VpZGUvY29tcG9uZW50cy9hY3Rpdml0aWVzL2FjdGl2aXR5LWxpZmVjeWNsZT9obD16aC1jbiNzYXJhcw==">保存和恢复 Activity 状态<i class="fa fa-external-link-alt"></i></span>。</p>
<p><code>onPause()</code> 方法的完成并不意味着 Activity 离开“已暂停”状态。相反，Activity 会保持此状态，直到其恢复或变成对用户完全不可见。如果 Activity 恢复，系统将再次调用 <code>onResume()</code> 回调。如果 Activity 从“已暂停”状态返回“已恢复”状态，系统会让 <code>Activity</code> 实例继续驻留在内存中，并会在系统调用 <code>onResume()</code> 时重新调用该实例。在这种情况下，您无需重新初始化在任何回调方法导致 Activity 进入“已恢复”状态期间创建的组件。如果 Activity 变为完全不可见，系统会调用 <code>onStop()</code>。下一部分将介绍 <code>onStop()</code> 回调。</p>
<h3 id="onStop"><a href="#onStop" class="headerlink" title="onStop()"></a>onStop()</h3><p>如果您的 Activity 不再对用户可见，说明其已进入“已停止”状态，因此系统将调用 <code>onStop()</code> 回调。例如，当新启动的 Activity 覆盖整个屏幕时，可能会发生这种情况。如果 Activity 已结束运行并即将终止，系统还可以调用 <code>onStop()</code>。</p>
<p>当 Activity 进入已停止状态时，与 Activity 生命周期相关联的所有生命周期感知型组件都将收到 <code>ON_STOP</code> 事件。这时，生命周期组件可以停止在组件未显示在屏幕上时无需运行的任何功能。</p>
<p>在 <code>onStop()</code> 方法中，应用应释放或调整在应用对用户不可见时的无用资源。例如，应用可以暂停动画效果，或从精确位置更新切换到粗略位置更新。使用 <code>onStop()</code> 而非 <code>onPause()</code> 可确保与界面相关的工作继续进行，即使用户在多窗口模式下查看您的 Activity 也能如此。</p>
<p>您还应使用 <code>onStop()</code> 执行 CPU 相对密集的关闭操作。例如，如果您无法找到更合适的时机来将信息保存到数据库，可以在 <code>onStop()</code> 期间执行此操作。以下示例展示了 <code>onStop()</code> 的实现，它将草稿笔记内容保存到持久性存储空间中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// call the superclass method first</span></span><br><span class="line">    <span class="built_in">super</span>.onStop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save the note&#x27;s current draft, because the activity is stopping</span></span><br><span class="line">    <span class="comment">// and we want to be sure the current note progress isn&#x27;t lost.</span></span><br><span class="line">    <span class="type">ContentValues</span> <span class="variable">values</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContentValues</span>();</span><br><span class="line">    values.put(NotePad.Notes.COLUMN_NAME_NOTE, getCurrentNoteText());</span><br><span class="line">    values.put(NotePad.Notes.COLUMN_NAME_TITLE, getCurrentNoteTitle());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do this update in background on an AsyncQueryHandler or equivalent</span></span><br><span class="line">    asyncQueryHandler.startUpdate (</span><br><span class="line">            mToken,  <span class="comment">// int token to correlate calls</span></span><br><span class="line">            <span class="literal">null</span>,    <span class="comment">// cookie, not used here</span></span><br><span class="line">            uri,    <span class="comment">// The URI for the note to update.</span></span><br><span class="line">            values,  <span class="comment">// The map of column names and new values to apply to them.</span></span><br><span class="line">            <span class="literal">null</span>,    <span class="comment">// No SELECT criteria are used.</span></span><br><span class="line">            <span class="literal">null</span>     <span class="comment">// No WHERE columns are used.</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，上述代码示例直接使用 SQLite。但您应该改用 Room，这是一个通过 SQLite 提供抽象层的持久性库。如需详细了解使用 Room 的好处，以及如何在应用中实现 Room，请参阅 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdG9waWMvbGlicmFyaWVzL2FyY2hpdGVjdHVyZS9yb29tP2hsPXpoLWNu">Room 持久性库<i class="fa fa-external-link-alt"></i></span>指南。</p>
<p>当您的 Activity 进入“已停止”状态时，<code>Activity</code> 对象会继续驻留在内存中：该对象将维护所有状态和成员信息，但不会附加到窗口管理器。Activity 恢复后，Activity 会重新调用这些信息。您无需重新初始化在任何回调方法导致 Activity 进入“已恢复”状态期间创建的组件。系统还会追踪布局中每个 <code>View</code> 对象的当前状态，如果用户在 <code>EditText</code> 微件中输入文本，系统将保留文本内容，因此您无需保存和恢复文本。</p>
<details class="note info"><summary><p>flat</p>
</summary>
<p><strong>注意</strong>：Activity 停止后，如果系统需要恢复内存，可能会销毁包含该 Activity 的进程。即使系统在 Activity 停止后销毁相应进程，系统仍会保留 <code>Bundle</code>（键值对的 blob）中 <code>View</code> 对象（例如 <code>EditText</code> 微件中的文本）的状态，并在用户返回 Activity 时恢复这些对象。如需详细了解如何恢复用户返回的 Activity，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vZ3VpZGUvY29tcG9uZW50cy9hY3Rpdml0aWVzL2FjdGl2aXR5LWxpZmVjeWNsZT9obD16aC1jbiNzYXJhcw==">保存和恢复 Activity 状态<i class="fa fa-external-link-alt"></i></span>。</p>

</details>

<p>进入“已停止”状态后，Activity 要么返回与用户互动，要么结束运行并消失。如果 Activity 返回，系统将调用 <code>onRestart()</code>。如果 <code>Activity</code> 结束运行，系统将调用 <code>onDestroy()</code>。下一部分将介绍 <code>onDestroy()</code> 回调。</p>
<h3 id="onDestroy"><a href="#onDestroy" class="headerlink" title="onDestroy()"></a>onDestroy()</h3><p>销毁 Activity 之前，系统会先调用 <code>onDestroy()</code>。系统调用此回调的原因如下：</p>
<ol>
<li>Activity 即将结束（由于用户彻底关闭 Activity 或由于系统为 Activity 调用 <code>finish()</code>），或者</li>
<li>由于配置变更（例如设备旋转或多窗口模式），系统暂时销毁 Activity</li>
</ol>
<p>当 Activity 进入已销毁状态时，与 Activity 生命周期相关联的所有生命周期感知型组件都将收到 <code>ON_DESTROY</code> 事件。这时，生命周期组件可以在 Activity 被销毁之前清理所需的任何数据。</p>
<p>您应使用 <code>ViewModel</code> 对象来包含 Activity 的相关视图数据，而不是在您的 Activity 中加入逻辑来确定 Activity 被销毁的原因。如果因配置变更而重新创建 Activity，ViewModel 不必执行任何操作，因为系统将保留 ViewModel 并将其提供给下一个 Activity 实例。如果不重新创建 Activity，ViewModel 将调用 <code>onCleared()</code> 方法，以便在 Activity 被销毁前清除所需的任何数据。</p>
<p>您可以使用 <code>isFinishing()</code> 方法区分这两种情况。</p>
<p>如果 Activity 即将结束，onDestroy() 是 Activity 收到的最后一个生命周期回调。如果由于配置变更而调用 onDestroy()，系统会立即新建 Activity 实例，然后在新配置中为新实例调用 <code>onCreate()</code>。</p>
<p><code>onDestroy()</code> 回调应释放先前的回调（例如 <code>onStop()</code>）尚未释放的所有资源。</p>
<h2 id="UIViewController、Activity生命周期异同"><a href="#UIViewController、Activity生命周期异同" class="headerlink" title="UIViewController、Activity生命周期异同"></a>UIViewController、Activity生命周期异同</h2><p>Activity 生命周期，一共6个回调方法，可以分为3组：</p>
<ul>
<li>onCreate()，页面创建。</li>
<li>onStart()，显示页面，即将获取焦点。</li>
<li>onResume()，已获取焦点，可以和用户交互。</li>
<li>onPause()，页面即将消失，即将失去焦点。</li>
<li>onStop()，页面已消失，失去焦点。</li>
<li>onDestroy()，页面销毁。</li>
</ul>
<p>UIViewController 的生命周期和 Activity 一样，也有 6 个方法，也可以分为三组：</p>
<ul>
<li>viewDidLoad，页面创建</li>
<li>viewWillAppear，显示页面，即将获取焦点。</li>
<li>viewDidAppear，已获取焦点，可以和用户交互。</li>
<li>viewWillDisappear，页面即将消失，即将失去焦点。</li>
<li>viewDidDisappear，页面已消失，失去焦点。</li>
<li>dealloc，页面销毁。</li>
</ul>
<h3 id="UIViewController-和-Activity-生命周期的不同"><a href="#UIViewController-和-Activity-生命周期的不同" class="headerlink" title="UIViewController 和 Activity 生命周期的不同"></a>UIViewController 和 Activity 生命周期的不同</h3><p>如果是 Android，按任务键或者 Home 键，会回调栈顶的 Activity 的生命周期，顺序：onPause() &#x3D;&gt; onStop()。</p>
<p>而 UIViewController 则没有回调，而是回调 AppDelegate，回调 applicationDidEnterBackground，当再点击桌面上App的图标，则是回调 applicationWillEnterForeground。</p>
<p>AppDelegate 类似 Android 中的 Application，App 生命周期中只有一个，是一个单例，applicationDidEnterBackground为App 进入后台，applicationWillEnterForeground为App 进入后台。</p>
<p>这是 2 个平台设计的差异，iOS 的提供了前、后台切换的回调，而 Android 则没有，需要自己去实现。</p>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vZ3VpZGUvY29tcG9uZW50cy9hY3Rpdml0aWVzL2FjdGl2aXR5LWxpZmVjeWNsZT9obD16aC1jbiNzb2FmYQ==">了解 Activity 生命周期<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzNTc0MTk1OTI5MTAy">UIViewController、Activity生命周期异同<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Activity</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript学习之基础类型</title>
    <url>/2023/09/25/20230925-TypeScript%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>JavaScript 程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用<code>string</code>表示文本数据类型。 和 JavaScript 一样，可以使用双引号（<code>&quot;</code>）或单引号（<code>&#39;</code>）表示字符串。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;bob&quot;</span>;</span><br><span class="line">name = <span class="string">&quot;smith&quot;</span>;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>你还可以使用<em>模版字符串</em>，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围，并且以<code>$&#123; expr &#125;</code>这种形式嵌入表达式</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">`Gene`</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">37</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">sentence</span>: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123; name &#125;</span>.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I&#x27;ll be <span class="subst">$&#123; age + <span class="number">1</span> &#125;</span> years old next month.`</span>;</span><br></pre></td></tr></table></figure>

<p>这与下面定义<code>sentence</code>的方式效果相同：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">sentence</span>: <span class="built_in">string</span> = <span class="string">&quot;Hello, my name is &quot;</span> + name + <span class="string">&quot;.\n\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;I&#x27;ll be &quot;</span> + (age + <span class="number">1</span>) + <span class="string">&quot; years old next month.&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>TypeScript 像 JavaScript 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上<code>[]</code>，表示由此类型元素组成的一个数组：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>第二种方式是使用数组泛型，<code>Array&lt;元素类型&gt;</code>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<h2 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h2><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为<code>string</code>和<code>number</code>类型的元组。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Declare a tuple type</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="comment">// Initialize it</span></span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>]; <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// Initialize it incorrectly</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">&#x27;hello&#x27;</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>当访问一个已知索引的元素，会得到正确的类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x[<span class="number">0</span>].<span class="title function_">substr</span>(<span class="number">1</span>)); <span class="comment">// OK</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x[<span class="number">1</span>].<span class="title function_">substr</span>(<span class="number">1</span>)); <span class="comment">// Error, &#x27;number&#x27; does not have &#x27;substr&#x27;</span></span><br></pre></td></tr></table></figure>

<p>当访问一个越界的元素，会使用联合类型替代：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">x[<span class="number">3</span>] = <span class="string">&#x27;world&#x27;</span>; <span class="comment">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x[<span class="number">5</span>].<span class="title function_">toString</span>()); <span class="comment">// OK, &#x27;string&#x27; 和 &#x27;number&#x27; 都有 toString</span></span><br><span class="line"></span><br><span class="line">x[<span class="number">6</span>] = <span class="literal">true</span>; <span class="comment">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure>

<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p><code>enum</code>类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>;</span><br></pre></td></tr></table></figure>

<p>默认情况下，从<code>0</code>开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从<code>1</code>开始编号：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="number">1</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>;</span><br></pre></td></tr></table></figure>

<p>或者，全部都采用手动赋值：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="number">1</span>, <span class="title class_">Green</span> = <span class="number">2</span>, <span class="title class_">Blue</span> = <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>;</span><br></pre></td></tr></table></figure>

<p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="number">1</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">colorName</span>: <span class="built_in">string</span> = <span class="title class_">Color</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colorName);  <span class="comment">// 显示&#x27;Green&#x27;因为上面代码里它的值是2</span></span><br></pre></td></tr></table></figure>

<h2 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h2><p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用<code>any</code>类型来标记这些变量：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure = <span class="string">&quot;maybe a string instead&quot;</span>;</span><br><span class="line">notSure = <span class="literal">false</span>; <span class="comment">// okay, definitely a boolean</span></span><br></pre></td></tr></table></figure>

<p>在对现有代码进行改写的时候，<code>any</code>类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为<code>Object</code>有相似的作用，就像它在其它语言中那样。 但是<code>Object</code>类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure.<span class="title function_">ifItExists</span>(); <span class="comment">// okay, ifItExists might exist at runtime</span></span><br><span class="line">notSure.<span class="title function_">toFixed</span>(); <span class="comment">// okay, toFixed exists (but the compiler doesn&#x27;t check)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">prettySure</span>: <span class="title class_">Object</span> = <span class="number">4</span>;</span><br><span class="line">prettySure.<span class="title function_">toFixed</span>(); <span class="comment">// Error: Property &#x27;toFixed&#x27; doesn&#x27;t exist on type &#x27;Object&#x27;.</span></span><br></pre></td></tr></table></figure>

<p>当你只知道一部分数据的类型时，<code>any</code>类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="literal">true</span>, <span class="string">&quot;free&quot;</span>];</span><br><span class="line"></span><br><span class="line">list[<span class="number">1</span>] = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h2><p>某种程度上来说，<code>void</code>类型像是与<code>any</code>类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">warnUser</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is my warning message&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明一个<code>void</code>类型的变量没有什么大用，因为你只能为它赋予<code>undefined</code>和<code>null</code>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">unusable</span>: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h2><p>TypeScript里，<code>undefined</code>和<code>null</code>两者各自有自己的类型分别叫做<code>undefined</code>和<code>null</code>。 和 <code>void</code>相似，它们的本身的类型用处不是很大：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Not much else we can assign to these variables!</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">u</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">n</span>: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>默认情况下<code>null</code>和<code>undefined</code>是所有类型的子类型。 就是说你可以把 <code>null</code>和<code>undefined</code>赋值给<code>number</code>类型的变量。</p>
<p>然而，当你指定了<code>--strictNullChecks</code>标记，<code>null</code>和<code>undefined</code>只能赋值给<code>void</code>和它们各自。 这能避免<em>很多</em>常见的问题。 也许在某处你想传入一个 <code>string</code>或<code>null</code>或<code>undefined</code>，你可以使用联合类型<code>string | null | undefined</code>。 再次说明，稍后我们会介绍联合类型。</p>
<details class="note info"><summary><p>flat</p>
</summary>
<p>注意：我们鼓励尽可能地使用<code>--strictNullChecks</code>，但在本手册里我们假设这个标记是关闭的。</p>

</details>

<h2 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h2><p><code>never</code>类型表示的是那些永不存在的值的类型。 例如， <code>never</code>类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是<code>never</code>类型，当它们被永不为真的类型保护所约束时。</p>
<p><code>never</code>类型是任何类型的子类型，也可以赋值给任何类型；然而，<em>没有</em>类型是<code>never</code>的子类型或可以赋值给<code>never</code>类型（除了<code>never</code>本身之外）。 即使<code>any</code>也不可以赋值给<code>never</code>。</p>
<p>下面是一些返回<code>never</code>类型的函数：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">error</span>(<span class="params"><span class="attr">message</span>: <span class="built_in">string</span></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推断的返回值类型为never</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fail</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">error</span>(<span class="string">&quot;Something failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">infiniteLoop</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p><code>object</code>表示非原始类型，也就是除<code>number</code>，<code>string</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code>或<code>undefined</code>之外的类型。</p>
<p>使用<code>object</code>类型，就可以更好的表示像<code>Object.create</code>这样的API。例如：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">create</span>(<span class="params"><span class="attr">o</span>: <span class="built_in">object</span> | <span class="literal">null</span></span>): <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">create</span>(&#123; <span class="attr">prop</span>: <span class="number">0</span> &#125;); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">create</span>(<span class="literal">null</span>); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">create</span>(<span class="number">42</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="title function_">create</span>(<span class="string">&quot;string&quot;</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="title function_">create</span>(<span class="literal">false</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="title function_">create</span>(<span class="literal">undefined</span>); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p>
<p>通过<em>类型断言</em>这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。</p>
<p>类型断言有两种形式。 其一是“尖括号”语法：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).<span class="property">length</span>;</span><br></pre></td></tr></table></figure>

<p>另一个为<code>as</code>语法：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">length</span>;</span><br></pre></td></tr></table></figure>

<p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有<code>as</code>语法断言是被允许的。</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript学习之日常类型</title>
    <url>/2024/01/22/20240122-TypeScript%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%B8%B8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是在 JavaScript 中传递数据的主要方式。 TypeScript 允许您指定函数的输入和输出值的类型。</p>
<span id="more"></span>

<h3 id="参数类型注解"><a href="#参数类型注解" class="headerlink" title="参数类型注解"></a>参数类型注解</h3><p>声明函数时，可以在每个参数后面加上类型注解，声明函数接受哪些类型的参数。 参数类型注释在参数名称之后：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Parameter type annotation</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params"><span class="attr">name</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="comment">//                 ^^^^^^^^</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + name.<span class="title function_">toUpperCase</span>() + <span class="string">&quot;!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当参数具有类型注释时，将检查该函数的参数：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params"><span class="attr">name</span>: <span class="built_in">string</span></span>): <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Would be a runtime error if executed!</span></span><br><span class="line"><span class="title function_">greet</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>即使您的参数上没有类型注释，TypeScript 仍会检查您是否传递了正确数量的参数。</p>
</blockquote>
<h3 id="返回类型注解"><a href="#返回类型注解" class="headerlink" title="返回类型注解"></a>返回类型注解</h3><p>您还可以添加返回类型注释。 返回类型注释出现在参数列表之后：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getFavoriteNumber</span>(<span class="params"></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="comment">//                        ^^^^^^^^</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">26</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与变量类型注解非常相似，您通常不需要返回类型注解，因为 TypeScript 会根据其 <code>return</code> 语句推断函数的返回类型。 上面例子中的类型注解并没有改变任何东西。 一些代码库将明确指定返回类型以用于文档目的，以防止意外更改，或仅出于个人喜好。</p>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>匿名函数与函数声明有点不同。 当一个函数出现在 TypeScript 可以确定如何调用它的地方时，该函数的参数会自动被赋予类型。</p>
<p>这是一个例子：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// No type annotations here, but TypeScript can spot the bug</span></span><br><span class="line"><span class="keyword">const</span> names = [<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Eve&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Contextual typing for function</span></span><br><span class="line">names.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">toUppercase</span>());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Contextual typing also applies to arrow functions</span></span><br><span class="line">names.<span class="title function_">forEach</span>(<span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">toUppercase</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>即使参数 <code>s</code> 没有类型注释，TypeScript 还是使用 <code>forEach</code> 函数的类型以及推断的数组类型来确定 <code>s</code> 将具有的类型。</p>
<p>这个过程称为上下文类型，因为函数发生的上下文告知它应该具有什么类型。</p>
<p>与推理规则类似，您不需要明确了解这是如何发生的，但了解它确实发生可以帮助您注意到何时不需要类型注释。 稍后，我们将看到更多关于值出现的上下文如何影响其类型的示例。</p>
<h2 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h2><p>除了基本类型之外，您会遇到的最常见的类型是对象类型。 这指的是任何带有属性的 JavaScript 值，几乎是所有属性！ 要定义对象类型，我们只需列出其属性及其类型。</p>
<p>例如，这是一个接受点状对象的函数：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The parameter&#x27;s type annotation is an object type</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printCoord</span>(<span class="params"><span class="attr">pt</span>: &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="comment">//                      ^^^^^^^^^^^^^^^^^^^^^^^^</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;The coordinate&#x27;s x value is &quot;</span> + pt.<span class="property">x</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;The coordinate&#x27;s y value is &quot;</span> + pt.<span class="property">y</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">printCoord</span>(&#123; <span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">7</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>在这里，我们使用具有两个属性的类型注释参数 - <code>x</code> 和 <code>y</code> - 这两个属性都是 <code>number</code> 类型。 您可以使用 <code>,</code> 或 <code>;</code> 来分隔属性，最后一个分隔符是可选的。</p>
<p>每个属性的类型部分也是可选的。 如果不指定类型，则假定为 <code>any</code>。</p>
<h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>对象类型还可以指定它们的部分或全部属性是可选的。 为此，请在属性名称后添加 <code>?</code>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printName</span>(<span class="params"><span class="attr">obj</span>: &#123; first: <span class="built_in">string</span>; last?: <span class="built_in">string</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Both OK</span></span><br><span class="line"><span class="title function_">printName</span>(&#123; <span class="attr">first</span>: <span class="string">&quot;Bob&quot;</span> &#125;);</span><br><span class="line"><span class="title function_">printName</span>(&#123; <span class="attr">first</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">last</span>: <span class="string">&quot;Alisson&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>在 JavaScript 中，如果您访问一个不存在的属性，您将获得值 <code>undefined</code> 而不是运行时错误。 因此，当您从可选属性中读取数据时，您必须在使用它之前检查 <code>undefined</code>。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printName</span>(<span class="params"><span class="attr">obj</span>: &#123; first: <span class="built_in">string</span>; last?: <span class="built_in">string</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// Error - might crash if &#x27;obj.last&#x27; wasn&#x27;t provided!</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">last</span>.<span class="title function_">toUpperCase</span>());</span><br><span class="line">  <span class="keyword">if</span> (obj.<span class="property">last</span> !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// OK</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">last</span>.<span class="title function_">toUpperCase</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A safe alternative using modern JavaScript syntax:</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">last</span>?.<span class="title function_">toUpperCase</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>TypeScript 的类型系统允许您使用各种运算符从现有类型中构建新类型。 现在我们知道如何编写几种类型，是时候开始以有趣的方式组合它们了。</p>
<h3 id="定义联合类型"><a href="#定义联合类型" class="headerlink" title="定义联合类型"></a>定义联合类型</h3><p>您可能会看到的第一种组合类型的方法是联合类型。 联合类型是由两种或多种其他类型组成的类型，表示可能是这些类型中的任何一种的值。 我们将这些类型中的每一种都称为联合的成员。</p>
<p>让我们编写一个可以对字符串或数字进行操作的函数：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printId</span>(<span class="params"><span class="attr">id</span>: <span class="built_in">number</span> | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Your ID is: &quot;</span> + id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// OK</span></span><br><span class="line"><span class="title function_">printId</span>(<span class="number">101</span>);</span><br><span class="line"><span class="comment">// OK</span></span><br><span class="line"><span class="title function_">printId</span>(<span class="string">&quot;202&quot;</span>);</span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="title function_">printId</span>(&#123; <span class="attr">myID</span>: <span class="number">22342</span> &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="使用联合类型"><a href="#使用联合类型" class="headerlink" title="使用联合类型"></a>使用联合类型</h3><p>提供与联合类型匹配的值很容易 - 只需提供与联合的任何成员匹配的类型即可。 如果你有一个联合类型的值，你如何处理它？</p>
<p>TypeScript 只有在对联合的每个成员都有效的情况下才允许操作。 例如，如果您有联合 <code>string | number</code>，则不能使用仅在 <code>string</code> 上可用的方法：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printId</span>(<span class="params"><span class="attr">id</span>: <span class="built_in">number</span> | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(id.<span class="title function_">toUpperCase</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案是用代码缩小联合，就像在没有类型注释的 JavaScript 中一样。 当 TypeScript 可以根据代码的结构为某个值推断出更具体的类型时，就会发生缩小。</p>
<p>例如，TypeScript 知道只有 <code>string</code> 值才会有 <code>typeof</code> 值 <code>&quot;string&quot;</code>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printId</span>(<span class="params"><span class="attr">id</span>: <span class="built_in">number</span> | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> id === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// In this branch, id is of type &#x27;string&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id.<span class="title function_">toUpperCase</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Here, id is of type &#x27;number&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个例子是使用像 <code>Array.isArray</code> 这样的函数：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">welcomePeople</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">string</span>[] | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(x)) &#123;</span><br><span class="line">    <span class="comment">// Here: &#x27;x&#x27; is &#x27;string[]&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + x.<span class="title function_">join</span>(<span class="string">&quot; and &quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Here: &#x27;x&#x27; is &#x27;string&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Welcome lone traveler &quot;</span> + x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，在 <code>else</code> 分支中，我们不需要做任何特别的事情——如果 <code>x</code> 不是 <code>string[]</code>，那么它一定是 <code>string</code>。</p>
<p>有时你会有一个联合，所有成员都有共同点。 例如，数组和字符串都有一个 <code>slice</code> 方法。 如果联合中的每个成员都有一个共同的属性，则可以使用该属性而不会缩小类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Return type is inferred as number[] | string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getFirstThree</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">number</span>[] | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类型的联合似乎具有这些类型的属性的交集，这可能会令人困惑。 这不是偶然的——联合这个名字来源于类型论。 联合 <code>number | string</code> 是通过取每种类型的值的联合组成的。 请注意，给定两个具有关于每个集合的相应事实的集合，只有这些事实的交集适用于集合本身的并集。 例如，如果我们有一个房间里有戴帽子的高个子，而另一个房间里有戴帽子的说西班牙语的人，在组合这些房间后，我们对每个人的唯一了解就是他们必须戴帽子。</p>
</blockquote>
<h3 id="实现一个-Swift-中的-compactMap-函数"><a href="#实现一个-Swift-中的-compactMap-函数" class="headerlink" title="实现一个 Swift 中的 compactMap 函数"></a>实现一个 Swift 中的 compactMap 函数</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函数 compactMap</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该函数会移除输入数组中的 null 和 undefined 元素，</span></span><br><span class="line"><span class="comment"> * 然后返回新的数组，新数组中的元素类型和输入数组的非空元素类型一致。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array&lt;T | null | undefined&gt;</span>&#125; <span class="variable">array</span> - 输入数组，元素可能为 T，null 或 undefined。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">Array&lt;T&gt;</span>&#125; 结果数组，包含和输入数组的非空元素相同类型的元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@template</span> <span class="variable">T</span> - 输入数组中非空元素的类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> compactMap&lt;T&gt;(<span class="attr">array</span>: <span class="title class_">Array</span>&lt;T | <span class="literal">null</span> | <span class="literal">undefined</span>&gt;): <span class="title class_">Array</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// Filter: 去除 null 和 undefined，保留 T。</span></span><br><span class="line">  <span class="keyword">return</span> array.<span class="title function_">filter</span>((item): item is T =&gt; item != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="literal">null</span>, <span class="number">2</span>, <span class="string">&quot;hello&quot;</span>, <span class="literal">undefined</span>, <span class="literal">true</span>, <span class="literal">false</span>];</span><br><span class="line"><span class="keyword">let</span> compacted = <span class="title function_">compactMap</span>(array);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(compacted); <span class="comment">// 输出: [1, 2, &quot;hello&quot;, true, false]</span></span><br></pre></td></tr></table></figure>

<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>有时你会得到关于 TypeScript 无法知道的值类型的信息。</p>
<p>例如，如果您使用的是 <code>document.getElementById</code>，TypeScript 只知道这将返回某种 <code>HTMLElement</code>，但您可能知道您的页面将始终具有具有给定 ID 的 <code>HTMLCanvasElement</code>。</p>
<p>在这种情况下，您可以使用类型断言来指定更具体的类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myCanvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;main_canvas&quot;</span>) <span class="keyword">as</span> <span class="title class_">HTMLCanvasElement</span>;</span><br></pre></td></tr></table></figure>

<p>与类型注释一样，类型断言被编译器删除，不会影响代码的运行时行为。</p>
<p>您还可以使用尖括号语法（除非代码在 <code>.tsx</code> 文件中），它是等效的：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myCanvas = &lt;<span class="title class_">HTMLCanvasElement</span>&gt;<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;main_canvas&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提醒：因为类型断言在编译时被删除，所以没有与类型断言关联的运行时检查。 如果类型断言错误，则不会产生异常或 <code>null</code>。</p>
</blockquote>
<p>TypeScript 只允许类型断言转换为更具体或更不具体的类型版本。 此规则可防止 “impossible” 强制，例如：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="string">&quot;hello&quot;</span> <span class="keyword">as</span> <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure>

<p>有时，此规则可能过于保守，并且不允许可能有效的更复杂的强制转换。 如果发生这种情况，您可以使用两个断言，首先是 <code>any</code>（或 <code>unknown</code>，我们稍后会介绍），然后是所需的类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">expr</span>: <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">type</span> T = &#123; <span class="attr">a</span>: <span class="number">1</span>; <span class="attr">b</span>: <span class="number">2</span>; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = (expr <span class="keyword">as</span> <span class="built_in">any</span>) <span class="keyword">as</span> T;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript学习之类型缩小</title>
    <url>/2024/01/23/20240123-TypeScript%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB%E5%9E%8B%E7%BC%A9%E5%B0%8F/</url>
    <content><![CDATA[<h2 id="类型缩小"><a href="#类型缩小" class="headerlink" title="类型缩小"></a>类型缩小</h2><p>假设我们有一个名为 <code>padLeft</code> 的函数。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">padLeft</span>(<span class="params"><span class="attr">padding</span>: <span class="built_in">number</span> | <span class="built_in">string</span>, <span class="attr">input</span>: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Not implemented yet!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>padding</code> 是 <code>number</code>，它会将其视为我们想要添加到 <code>input</code> 的空格数。如果 <code>padding</code> 是 <code>string</code>，它应该只是将 <code>padding</code> 前置到 <code>input</code>。让我们尝试实现当 <code>padLeft</code> 为 <code>padding</code> 传递 <code>number</code> 时的逻辑。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">padLeft</span>(<span class="params"><span class="attr">padding</span>: <span class="built_in">number</span> | <span class="built_in">string</span>, <span class="attr">input</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.<span class="title function_">repeat</span>(padding) + input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哦，我们在 <code>padding</code> 上遇到错误。TypeScript 警告我们，将 <code>number | string</code> 添加到 <code>number</code> 可能不会给我们想要的东西，这是正确的。换句话说，我们没有先明确检查 <code>padding</code> 是否是 <code>number</code>，也没有处理它是 <code>string</code> 的情况，所以让我们这样做。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">padLeft</span>(<span class="params"><span class="attr">padding</span>: <span class="built_in">number</span> | <span class="built_in">string</span>, <span class="attr">input</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.<span class="title function_">repeat</span>(padding) + input;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> padding + input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这看起来像是无趣的 JavaScript 代码，那就是重点。除了我们放置的注释之外，这个 TypeScript 代码看起来像 JavaScript。这个想法是 TypeScript 的类型系统旨在使编写典型的 JavaScript 代码尽可能容易，而无需向后兼容以获得类型安全。</p>
<span id="more"></span>

<p>虽然它可能看起来不多，但实际上这里有很多东西。就像 TypeScript 如何使用静态类型分析运行时值一样，它在 JavaScript 的运行时控制流结构（如 <code>if/else</code>、条件三元组、循环、真实性检查等）上进行类型分析，这些都会影响这些类型。</p>
<p>在我们的 <code>if</code> 检查中，TypeScript 看到 <code>typeof padding === &quot;number&quot;</code> 并将其理解为一种称为类型保护的特殊形式的代码。TypeScript 遵循我们的程序可以采用的可能执行路径来分析给定位置的值的最具体的可能类型。它着眼于这些特殊检查（称为类型保护）和赋值，将类型精炼为比声明的更具体的类型的过程称为缩小。在许多编辑器中，我们可以观察这些类型的变化，我们甚至会在示例中这样做。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">padLeft</span>(<span class="params"><span class="attr">padding</span>: <span class="built_in">number</span> | <span class="built_in">string</span>, <span class="attr">input</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.<span class="title function_">repeat</span>(padding) + input;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> padding + input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TypeScript 可以理解几种不同的结构来缩小类型。</p>
<h3 id="typeof-类型保护"><a href="#typeof-类型保护" class="headerlink" title="typeof 类型保护"></a>typeof 类型保护</h3><p>正如我们所见，JavaScript 支持 <code>typeof</code> 运算符，它可以提供关于我们在运行时拥有的值类型的非常基本的信息。TypeScript 期望它返回一组特定的字符串：</p>
<ul>
<li><code>&quot;string&quot;</code></li>
<li><code>&quot;number&quot;</code></li>
<li><code>&quot;bigint&quot;</code></li>
<li><code>&quot;boolean&quot;</code></li>
<li><code>&quot;symbol&quot;</code></li>
<li><code>&quot;undefined&quot;</code></li>
<li><code>&quot;object&quot;</code></li>
<li><code>&quot;function&quot;</code></li>
</ul>
<p>就像我们在 <code>padLeft</code> 中看到的那样，这个运算符经常出现在许多 JavaScript 库中，TypeScript 可以理解它来缩小不同分支中的类型。</p>
<p>在 TypeScript 中，检查 <code>typeof</code> 返回的值是一种类型保护。因为 TypeScript 编码了 <code>typeof</code> 如何对不同的值进行操作，所以它知道它在 JavaScript 中的一些怪癖。例如，请注意在上面的列表中，<code>typeof</code> 不返回字符串 <code>null</code>。查看以下示例：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printAll</span>(<span class="params"><span class="attr">strs</span>: <span class="built_in">string</span> | <span class="built_in">string</span>[] | <span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> s <span class="keyword">of</span> strs) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(strs);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>printAll</code> 函数中，我们尝试检查 <code>strs</code> 是否为对象以查看它是否为数组类型（现在可能是强化数组是 JavaScript 中的对象类型的好时机）。但事实证明，在 JavaScript 中，<code>typeof null</code> 实际上是 <code>&quot;object&quot;</code>！这是历史上不幸的事故之一。</p>
<p>有足够经验的用户可能不会感到惊讶，但并不是每个人都在 JavaScript 中遇到过这种情况；幸运的是，TypeScript 让我们知道 <code>strs</code> 仅缩小到 <code>string[] | null</code> 而不仅仅是 <code>string[]</code>。</p>
<p>这可能是我们称之为 “truthiness” 检查的一个很好的转义。</p>
<h3 id="真实性缩小"><a href="#真实性缩小" class="headerlink" title="真实性缩小"></a>真实性缩小</h3><p>真实性可能不是您在字典中可以找到的词，但您会在 JavaScript 中听到很多东西。</p>
<p>在 JavaScript 中，我们可以在条件、<code>&amp;&amp;</code>、<code>||</code>、<code>if</code> 语句、布尔否定 (<code>!</code>) 等中使用任何表达式。例如，<code>if</code> 语句不希望它们的条件总是具有 <code>boolean</code> 类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getUsersOnlineMessage</span>(<span class="params"><span class="attr">numUsersOnline</span>: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (numUsersOnline) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`There are <span class="subst">$&#123;numUsersOnline&#125;</span> online now!`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Nobody&#x27;s here. :(&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 JavaScript 中，像 <code>if</code> 这样的构造首先将它们的条件 “coerce” 到 <code>boolean</code> 以理解它们，然后根据结果是 <code>true</code> 还是 <code>false</code> 来选择它们的分支。像这样的值</p>
<ul>
<li><code>0</code></li>
<li><code>NaN</code></li>
<li><code>&quot;&quot;</code>（空字符串）</li>
<li><code>0n</code>（<code>bigint</code>版零）</li>
<li><code>null</code></li>
<li><code>undefined</code></li>
</ul>
<p>所有强制为 <code>false</code>，其他值强制为 <code>true</code>。您始终可以通过 <code>Boolean</code> 函数或使用较短的双布尔否定来将值强制为 <code>boolean</code>。（后者的优点是 TypeScript 推断出一个缩小的字面布尔类型 <code>true</code>，而将第一个推断为类型 <code>boolean</code>。）</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// both of these result in &#x27;true&#x27;</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// type: boolean, value: true</span></span><br><span class="line">!!<span class="string">&quot;world&quot;</span>; <span class="comment">// type: true,    value: true</span></span><br></pre></td></tr></table></figure>

<p>利用这种行为相当流行，尤其是在防范 <code>null</code> 或 <code>undefined</code> 之类的值时。例如，让我们尝试将它用于我们的 <code>printAll</code> 函数。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printAll</span>(<span class="params"><span class="attr">strs</span>: <span class="built_in">string</span> | <span class="built_in">string</span>[] | <span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (strs &amp;&amp; <span class="keyword">typeof</span> strs === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> s <span class="keyword">of</span> strs) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(strs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你会注意到我们已经通过检查 <code>strs</code> 是否为真消除了上面的错误。这至少可以防止我们在运行以下代码时出现可怕的错误：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">TypeError: null is not iterable</span><br></pre></td></tr></table></figure>

<p>请记住，尽管对原语进行真实性检查通常容易出错。例如，考虑编写 <code>printAll</code> 的不同尝试</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printAll</span>(<span class="params"><span class="attr">strs</span>: <span class="built_in">string</span> | <span class="built_in">string</span>[] | <span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="comment">// !!!!!!!!!!!!!!!!</span></span><br><span class="line">  <span class="comment">//  DON&#x27;T DO THIS!</span></span><br><span class="line">  <span class="comment">//   KEEP READING</span></span><br><span class="line">  <span class="comment">// !!!!!!!!!!!!!!!!</span></span><br><span class="line">  <span class="keyword">if</span> (strs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> s <span class="keyword">of</span> strs) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(strs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将整个函数体包装在一个真值检查中，但这有一个微妙的缺点：我们可能不再正确处理空字符串大小写。</p>
<p>TypeScript 在这里根本不会伤害我们，但如果您对 JavaScript 不太熟悉，这是值得注意的行为。TypeScript 通常可以帮助您及早发现错误，但如果您选择对值不做任何事情，那么它可以做的事情就只有这么多，而不会过于规范。如果您愿意，您可以确保使用 linter 处理此类情况。</p>
<p>关于真实性缩小的最后一句话是带有 <code>!</code> 的布尔否定从否定分支中过滤掉。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">multiplyAll</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="attr">values</span>: <span class="built_in">number</span>[] | <span class="literal">undefined</span>,</span></span><br><span class="line"><span class="params">  <span class="attr">factor</span>: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>): <span class="built_in">number</span>[] | <span class="literal">undefined</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!values) &#123;</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> values.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x * factor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="相等性缩小"><a href="#相等性缩小" class="headerlink" title="相等性缩小"></a>相等性缩小</h3><p>TypeScript 还使用 <code>switch</code> 语句和 <code>===</code>、<code>!==</code>、<code>==</code> 和 <code>!=</code> 等相等性检查来缩小类型。例如：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">string</span> | <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">string</span> | <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">    <span class="comment">// We can now call any &#x27;string&#x27; method on &#x27;x&#x27; or &#x27;y&#x27;.</span></span><br><span class="line">    x.<span class="title function_">toUpperCase</span>();</span><br><span class="line">    y.<span class="title function_">toLowerCase</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们在上面的示例中检查 <code>x</code> 和 <code>y</code> 是否相等时，TypeScript 知道它们的类型也必须相等。由于 <code>string</code> 是 <code>x</code> 和 <code>y</code> 都可以采用的唯一常见类型，TypeScript 知道 <code>x</code> 和 <code>y</code> 在第一个分支中必须是 <code>string</code>。</p>
<p>检查特定的字面值（而不是变量）也可以。在我们关于真实性缩小的部分中，我们编写了一个容易出错的 <code>printAll</code> 函数，因为它意外地没有正确处理空字符串。相反，我们可以做一个特定的检查来阻止 <code>null</code>，TypeScript 仍然正确地从 <code>strs</code> 的类型中删除 <code>null</code>。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printAll</span>(<span class="params"><span class="attr">strs</span>: <span class="built_in">string</span> | <span class="built_in">string</span>[] | <span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (strs !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> s <span class="keyword">of</span> strs) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(strs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JavaScript 对 <code>==</code> 和 <code>!=</code> 的更宽松的相等性检查也正确地缩小了类型。如果您不熟悉，检查某事 <code>== null</code> 是否实际上不仅检查它是否具体是值 <code>null</code> - 它还检查它是否可能是 <code>undefined</code>。这同样适用于 <code>== undefined</code>：它检查一个值是 <code>null</code> 还是 <code>undefined</code>。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">number</span> | <span class="literal">null</span> | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">multiplyValue</span>(<span class="params"><span class="attr">container</span>: <span class="title class_">Container</span>, <span class="attr">factor</span>: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="comment">// Remove both &#x27;null&#x27; and &#x27;undefined&#x27; from the type.</span></span><br><span class="line">  <span class="keyword">if</span> (container.<span class="property">value</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(container.<span class="property">value</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now we can safely multiply &#x27;container.value&#x27;.</span></span><br><span class="line">    container.<span class="property">value</span> *= factor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="in-运算符缩小"><a href="#in-运算符缩小" class="headerlink" title="in 运算符缩小"></a>in 运算符缩小</h3><p>JavaScript 有一个运算符，用于确定对象是否具有带名称的属性：<code>in</code> 运算符。TypeScript 将这一点视为缩小潜在类型的一种方式。</p>
<p>例如，使用代码：<code>&quot;value&quot; in x</code>。其中 <code>&quot;value&quot;</code> 是字符串字面，<code>x</code> 是联合类型。”true” 分支缩小了 <code>x</code> 具有可选或必需属性 <code>value</code> 的类型，而 “false” 分支缩小了具有可选或缺少属性 <code>value</code> 的类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fish</span> = &#123; <span class="attr">swim</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bird</span> = &#123; <span class="attr">fly</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params"><span class="attr">animal</span>: <span class="title class_">Fish</span> | <span class="title class_">Bird</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;swim&quot;</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">    <span class="keyword">return</span> animal.<span class="title function_">swim</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> animal.<span class="title function_">fly</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重申一下可选属性将存在于类型缩小的两侧，例如人类既可以游泳又可以飞行（使用正确的设备），因此应该出现在 <code>in</code> 检查的两侧：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fish</span> = &#123; <span class="attr">swim</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bird</span> = &#123; <span class="attr">fly</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Human</span> = &#123; <span class="attr">swim</span>?: <span class="function">() =&gt;</span> <span class="built_in">void</span>; <span class="attr">fly</span>?: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params"><span class="attr">animal</span>: <span class="title class_">Fish</span> | <span class="title class_">Bird</span> | <span class="title class_">Human</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;swim&quot;</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">    animal;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    animal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="instanceof-缩小"><a href="#instanceof-缩小" class="headerlink" title="instanceof 缩小"></a>instanceof 缩小</h3><p>JavaScript 有一个运算符用于检查一个值是否是另一个值的 “instance”。更具体地说，在 JavaScript 中，<code>x instanceof Foo</code> 检查 <code>x</code> 的原型链是否包含 <code>Foo.prototype</code>。虽然我们不会在这里深入探讨，并且当我们进入类时您会看到更多内容，但它们对于可以使用 <code>new</code> 构造的大多数值仍然很有用。你可能已经猜到了，<code>instanceof</code> 也是一个类型保护，TypeScript 缩小了由 <code>instanceof</code> 保护的分支。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logValue</span>(<span class="params"><span class="attr">x</span>: <span class="title class_">Date</span> | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="title function_">toUTCString</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="title function_">toUpperCase</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用类型谓词"><a href="#使用类型谓词" class="headerlink" title="使用类型谓词"></a>使用类型谓词</h3><p>到目前为止，我们已经使用现有的 JavaScript 结构来处理类型缩小，但是有时您希望更直接地控制类型在整个代码中的变化方式。</p>
<p>要定义用户定义的类型保护，我们只需要定义一个返回类型为类型谓词的函数：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fish</span> = &#123; <span class="attr">swim</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bird</span> = &#123; <span class="attr">fly</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">getSmallPet</span>(<span class="params"></span>): <span class="title class_">Fish</span> | <span class="title class_">Bird</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isFish</span>(<span class="params"><span class="attr">pet</span>: <span class="title class_">Fish</span> | <span class="title class_">Bird</span></span>): pet is <span class="title class_">Fish</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (pet <span class="keyword">as</span> <span class="title class_">Fish</span>).<span class="property">swim</span> !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>pet is Fish</code> 是本例中的类型谓词。谓词采用 <code>parameterName is Type</code> 的形式，其中 <code>parameterName</code> 必须是当前函数签名中的参数名称。</p>
<p>任何时候使用某个变量调用 <code>isFish</code> 时，如果原始类型兼容，TypeScript 就会将该变量缩小到该特定类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fish</span> = &#123; <span class="attr">swim</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bird</span> = &#123; <span class="attr">fly</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">getSmallPet</span>(<span class="params"></span>): <span class="title class_">Fish</span> | <span class="title class_">Bird</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isFish</span>(<span class="params"><span class="attr">pet</span>: <span class="title class_">Fish</span> | <span class="title class_">Bird</span></span>): pet is <span class="title class_">Fish</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (pet <span class="keyword">as</span> <span class="title class_">Fish</span>).<span class="property">swim</span> !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Both calls to &#x27;swim&#x27; and &#x27;fly&#x27; are now okay.</span></span><br><span class="line"><span class="keyword">let</span> pet = <span class="title function_">getSmallPet</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isFish</span>(pet)) &#123;</span><br><span class="line">  pet.<span class="title function_">swim</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  pet.<span class="title function_">fly</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，TypeScript 不仅知道 <code>if</code> 分支中的 <code>pet</code> 是 <code>Fish</code>；它也知道在<code>else</code>分支中，你没有<code>Fish</code>，所以你必须有<code>Bird</code>。</p>
<p>您可以使用类型保护 <code>isFish</code> 过滤 <code>Fish | Bird</code> 的数组并获得 <code>Fish</code> 的数组：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fish</span> = &#123; <span class="attr">swim</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>; <span class="attr">name</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bird</span> = &#123; <span class="attr">fly</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>; <span class="attr">name</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">getSmallPet</span>(<span class="params"></span>): <span class="title class_">Fish</span> | <span class="title class_">Bird</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isFish</span>(<span class="params"><span class="attr">pet</span>: <span class="title class_">Fish</span> | <span class="title class_">Bird</span></span>): pet is <span class="title class_">Fish</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (pet <span class="keyword">as</span> <span class="title class_">Fish</span>).<span class="property">swim</span> !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">zoo</span>: (<span class="title class_">Fish</span> | <span class="title class_">Bird</span>)[] = [<span class="title function_">getSmallPet</span>(), <span class="title function_">getSmallPet</span>(), <span class="title function_">getSmallPet</span>()];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">underWater1</span>: <span class="title class_">Fish</span>[] = zoo.<span class="title function_">filter</span>(isFish);</span><br><span class="line"><span class="comment">// or, equivalently</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">underWater2</span>: <span class="title class_">Fish</span>[] = zoo.<span class="title function_">filter</span>(isFish) <span class="keyword">as</span> <span class="title class_">Fish</span>[];</span><br><span class="line"></span><br><span class="line"><span class="comment">// The predicate may need repeating for more complex examples</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">underWater3</span>: <span class="title class_">Fish</span>[] = zoo.<span class="title function_">filter</span>((pet): pet is <span class="title class_">Fish</span> =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (pet.<span class="property">name</span> === <span class="string">&quot;sharkey&quot;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">isFish</span>(pet);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>另外，类可以<a href="https://nodejs.cn/typescript/handbook/narrowing/##1cef09dc354d4c04a66f6e38820a8ea3">使用 <code>this is Type</code></a>来缩小他们的类型。</p>
<h3 id="判别联合"><a href="#判别联合" class="headerlink" title="判别联合"></a>判别联合</h3><p>到目前为止，我们看到的大多数示例都集中在使用简单类型（如 <code>string</code>、<code>boolean</code> 和 <code>number</code>）来缩小单个变量的作用域。虽然这很常见，但大多数时候在 JavaScript 中我们将处理稍微复杂的结构。</p>
<p>出于某种动机，假设我们正在尝试对圆形和正方形等形状进行编码。圆记录它们的半径，正方形记录它们的边长。我们将使用一个名为 <code>kind</code> 的字段来判断我们正在处理的形状。这是定义 <code>Shape</code> 的第一次尝试。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;circle&quot;</span> | <span class="string">&quot;square&quot;</span>;</span><br><span class="line">  <span class="attr">radius</span>?: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">sideLength</span>?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，我们使用字符串字面类型的联合：<code>&quot;circle&quot;</code> 和 <code>&quot;square&quot;</code> 来告诉我们应该将形状分别视为圆形还是方形。通过使用 <code>&quot;circle&quot; | &quot;square&quot;</code> 而不是 <code>string</code>，我们可以避免拼写错误的问题。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;circle&quot;</span> | <span class="string">&quot;square&quot;</span>;</span><br><span class="line">  <span class="attr">radius</span>?: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">sideLength</span>?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleShape</span>(<span class="params"><span class="attr">shape</span>: <span class="title class_">Shape</span></span>) &#123;</span><br><span class="line">  <span class="comment">// oops!</span></span><br><span class="line">  <span class="keyword">if</span> (shape.<span class="property">kind</span> === <span class="string">&quot;rect&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以编写一个 <code>getArea</code> 函数，根据它是处理圆形还是正方形来应用正确的逻辑。我们将首先尝试处理圈子。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;circle&quot;</span> | <span class="string">&quot;square&quot;</span>;</span><br><span class="line">  <span class="attr">radius</span>?: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">sideLength</span>?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params"><span class="attr">shape</span>: <span class="title class_">Shape</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * shape.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <a href="https://nodejs.cn/typescript/handbook/narrowing/##c8ae1aa9dc0a4972be0e6d6f1ab46085"><code>strictNullChecks</code></a> 下给我们一个错误 - 这是适当的，因为 <code>radius</code> 可能没有定义。但是如果我们对 <code>kind</code> 属性进行适当的检查呢？</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;circle&quot;</span> | <span class="string">&quot;square&quot;</span>;</span><br><span class="line">  <span class="attr">radius</span>?: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">sideLength</span>?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params"><span class="attr">shape</span>: <span class="title class_">Shape</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (shape.<span class="property">kind</span> === <span class="string">&quot;circle&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * shape.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嗯，TypeScript 还是不知道在这里做什么。我们已经达到了比类型检查器更了解我们的值的地步。我们可以尝试使用非空断言（<code>shape.radius</code> 之后的 <code>!</code>）来表示 <code>radius</code> 肯定存在。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;circle&quot;</span> | <span class="string">&quot;square&quot;</span>;</span><br><span class="line">  <span class="attr">radius</span>?: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">sideLength</span>?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params"><span class="attr">shape</span>: <span class="title class_">Shape</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (shape.<span class="property">kind</span> === <span class="string">&quot;circle&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * shape.<span class="property">radius</span>! ** <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这感觉并不理想。我们不得不用那些非空断言（<code>!</code>）对类型检查器大喊大叫，以说服它定义了 <code>shape.radius</code>，但是如果我们开始移动代码，这些断言很容易出错。此外，在 <a href="https://nodejs.cn/typescript/handbook/narrowing/##c8ae1aa9dc0a4972be0e6d6f1ab46085"><code>strictNullChecks</code></a> 之外，我们无论如何都可以意外访问这些字段中的任何一个（因为在读取它们时假定可选属性始终存在）。我们绝对可以做得更好。</p>
<p>这种 <code>Shape</code> 编码的问题在于，类型检查器无法根据 <code>kind</code> 属性知道是否存在 <code>radius</code> 或 <code>sideLength</code>。我们需要将我们所知道的信息传达给类型检查器。考虑到这一点，让我们再次定义 <code>Shape</code>。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;circle&quot;</span>;</span><br><span class="line">  <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;square&quot;</span>;</span><br><span class="line">  <span class="attr">sideLength</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Shape</span> = <span class="title class_">Circle</span> | <span class="title class_">Square</span>;</span><br></pre></td></tr></table></figure>

<p>在这里，我们已经正确地将 <code>Shape</code> 分成了 <code>kind</code> 属性具有不同值的两种类型，但是 <code>radius</code> 和 <code>sideLength</code> 在它们各自的类型中被声明为必需的属性。</p>
<p>让我们看看当我们尝试访问 <code>Shape</code> 的 <code>radius</code> 时会发生什么。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;circle&quot;</span>;</span><br><span class="line">  <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;square&quot;</span>;</span><br><span class="line">  <span class="attr">sideLength</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Shape</span> = <span class="title class_">Circle</span> | <span class="title class_">Square</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params"><span class="attr">shape</span>: <span class="title class_">Shape</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * shape.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像我们对 <code>Shape</code> 的第一个定义一样，这仍然是一个错误。当 <code>radius</code> 是可选的时，我们得到一个错误（启用 <a href="https://nodejs.cn/typescript/handbook/narrowing/##c8ae1aa9dc0a4972be0e6d6f1ab46085"><code>strictNullChecks</code></a>），因为 TypeScript 无法判断该属性是否存在。现在 <code>Shape</code> 是一个联合，TypeScript 告诉我们 <code>shape</code> 可能是一个 <code>Square</code>，而 <code>Square</code> 上没有定义 <code>radius</code>！两种解释都是正确的，但是无论 <a href="https://nodejs.cn/typescript/handbook/narrowing/##c8ae1aa9dc0a4972be0e6d6f1ab46085"><code>strictNullChecks</code></a> 是如何配置的，只有 <code>Shape</code> 的联合编码会导致错误。</p>
<p>但是，如果我们再次尝试检查 <code>kind</code> 属性会怎样？</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;circle&quot;</span>;</span><br><span class="line">  <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;square&quot;</span>;</span><br><span class="line">  <span class="attr">sideLength</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Shape</span> = <span class="title class_">Circle</span> | <span class="title class_">Square</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params"><span class="attr">shape</span>: <span class="title class_">Shape</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (shape.<span class="property">kind</span> === <span class="string">&quot;circle&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * shape.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这摆脱了错误！当联合中的每个类型都包含具有字面类型的公共属性时，TypeScript 认为这是一个可区分的联合，并且可以缩小联合的成员。</p>
<p>在这种情况下，<code>kind</code> 是该公共属性（这被认为是 <code>Shape</code> 的判别属性）。检查 <code>kind</code> 属性是否为 <code>&quot;circle&quot;</code> 删除了 <code>Shape</code> 中没有 <code>&quot;circle&quot;</code> 类型的 <code>kind</code> 属性的所有类型。这将 <code>shape</code> 缩小到 <code>Circle</code> 类型。</p>
<p>同样的检查也适用于 <code>switch</code> 语句。现在我们可以尝试编写完整的 <code>getArea</code> 而不需要任何讨厌的 <code>!</code> 非空断言。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;circle&quot;</span>;</span><br><span class="line">  <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;square&quot;</span>;</span><br><span class="line">  <span class="attr">sideLength</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Shape</span> = <span class="title class_">Circle</span> | <span class="title class_">Square</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params"><span class="attr">shape</span>: <span class="title class_">Shape</span></span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (shape.<span class="property">kind</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;circle&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * shape.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;square&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> shape.<span class="property">sideLength</span> ** <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里重要的是<code>Shape</code>的编码。向 TypeScript 传达正确的信息 - <code>Circle</code> 和 <code>Square</code> 实际上是具有特定 <code>kind</code> 字段的两种不同类型 - 至关重要。这样做可以让我们编写类型安全的 TypeScript 代码，看起来与我们原本编写的 JavaScript 没有什么不同。从那里，类型系统能够做 “right” 的事情并找出我们 <code>switch</code> 语句的每个分支中的类型。</p>
<blockquote>
<p>顺便说一句，尝试使用上面的示例并删除一些返回关键字。您会看到类型检查有助于避免在 <code>switch</code> 语句中意外遇到不同子句时出现错误。</p>
</blockquote>
<p>判别联合不仅仅用于讨论圆形和正方形。它们非常适合在 JavaScript 中表示任何类型的消息传递方案，例如通过网络发送消息（客户端&#x2F;服务器通信）或在状态管理框架中编码突变。</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript学习之函数</title>
    <url>/2024/02/07/20240207-TypeScript%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是任何应用程序的基本构建块，无论它们是本地函数、从另一个模块导入的函数，还是类中的方法。 它们也是值，就像其他值一样，TypeScript 有很多方法来描述如何调用函数。 让我们学习如何编写描述函数的类型。</p>
<span id="more"></span>

<h3 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h3><p>我们编写了一些通用函数，可以处理任何类型的值。 有时我们想关联两个值，但只能对某个值的子集进行操作。 在这种情况下，我们可以使用约束来限制类型参数可以接受的类型种类。</p>
<p>让我们编写一个返回两个值中较长者的函数。 为此，我们需要一个 <code>length</code> 属性，它是一个数字。 我们通过编写 <code>extends</code> 子句将类型参数限制为该类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> longest&lt;<span class="title class_">Type</span> <span class="keyword">extends</span> &#123; <span class="attr">length</span>: <span class="built_in">number</span> &#125;&gt;(<span class="attr">a</span>: <span class="title class_">Type</span>, <span class="attr">b</span>: <span class="title class_">Type</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a.<span class="property">length</span> &gt;= b.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// longerArray is of type &#x27;number[]&#x27;</span></span><br><span class="line"><span class="keyword">const</span> longerArray = <span class="title function_">longest</span>([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">// longerString is of type &#x27;alice&#x27; | &#x27;bob&#x27;</span></span><br><span class="line"><span class="keyword">const</span> longerString = <span class="title function_">longest</span>(<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;bob&quot;</span>);</span><br><span class="line"><span class="comment">// Error! Numbers don&#x27;t have a &#x27;length&#x27; property</span></span><br><span class="line"><span class="keyword">const</span> notOK = <span class="title function_">longest</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>在这个例子中有一些有趣的事情需要注意。 我们允许 TypeScript 推断 <code>longest</code> 的返回类型。 返回类型推断也适用于泛型函数。</p>
<p>因为我们将 <code>Type</code> 限制为 <code>&#123; length: number &#125;</code>，所以我们可以访问 <code>a</code> 和 <code>b</code> 参数的 <code>.length</code> 属性。 如果没有类型约束，我们将无法访问这些属性，因为这些值可能是没有长度属性的其他类型。</p>
<p><code>longerArray</code> 和 <code>longerString</code> 的类型是根据参数推断出来的。 请记住，泛型就是将两个或多个具有相同类型的值关联起来！</p>
<p>最后，正如我们所愿，对 <code>longest(10, 100)</code> 的调用被拒绝，因为 <code>number</code> 类型没有 <code>.length</code> 属性。</p>
<h3 id="使用约束值"><a href="#使用约束值" class="headerlink" title="使用约束值"></a>使用约束值</h3><p>这是使用通用约束时的一个常见错误：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> minimumLength&lt;<span class="title class_">Type</span> <span class="keyword">extends</span> &#123; <span class="attr">length</span>: <span class="built_in">number</span> &#125;&gt;(</span><br><span class="line">  <span class="attr">obj</span>: <span class="title class_">Type</span>,</span><br><span class="line">  <span class="attr">minimum</span>: <span class="built_in">number</span></span><br><span class="line">): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj.<span class="property">length</span> &gt;= minimum) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">length</span>: minimum &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来这个函数没问题 - <code>Type</code> 被约束为 <code>&#123; length: number &#125;</code>，并且该函数返回 <code>Type</code> 或与该约束匹配的值。 问题是该函数承诺返回与传入相同类型的对象，而不仅仅是与约束匹配的某个对象。 如果这段代码是合法的，你可以编写绝对行不通的代码：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> minimumLength&lt;<span class="title class_">Type</span> <span class="keyword">extends</span> &#123; <span class="attr">length</span>: <span class="built_in">number</span> &#125;&gt;(</span><br><span class="line">  <span class="attr">obj</span>: <span class="title class_">Type</span>,</span><br><span class="line">  <span class="attr">minimum</span>: <span class="built_in">number</span></span><br><span class="line">): <span class="title class_">Type</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#x27;arr&#x27; gets value &#123; length: 6 &#125;</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="title function_">minimumLength</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">6</span>);</span><br><span class="line"><span class="comment">// and crashes here because arrays have</span></span><br><span class="line"><span class="comment">// a &#x27;slice&#x27; method, but not the returned object!</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">slice</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<h3 id="指定类型参数"><a href="#指定类型参数" class="headerlink" title="指定类型参数"></a>指定类型参数</h3><p>TypeScript 通常可以在泛型调用中推断出预期的类型参数，但并非总是如此。 例如，假设您编写了一个函数来组合两个数组：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> combine&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arr1</span>: <span class="title class_">Type</span>[], <span class="attr">arr2</span>: <span class="title class_">Type</span>[]): <span class="title class_">Type</span>[] &#123;</span><br><span class="line">  <span class="keyword">return</span> arr1.<span class="title function_">concat</span>(arr2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常使用不匹配的数组调用此函数会出错：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> combine&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arr1</span>: <span class="title class_">Type</span>[], <span class="attr">arr2</span>: <span class="title class_">Type</span>[]): <span class="title class_">Type</span>[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = <span class="title function_">combine</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="string">&quot;hello&quot;</span>]);</span><br></pre></td></tr></table></figure>

<p>但是，如果您打算这样做，您可以手动指定 <code>Type</code>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> combine&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arr1</span>: <span class="title class_">Type</span>[], <span class="attr">arr2</span>: <span class="title class_">Type</span>[]): <span class="title class_">Type</span>[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = combine&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt;([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="string">&quot;hello&quot;</span>]);</span><br></pre></td></tr></table></figure>

<h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><p>JavaScript 中的函数通常采用可变数量的参数。 例如，<code>number</code> 的 <code>toFixed</code> 方法采用可选的位数计数：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"><span class="attr">n</span>: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n.<span class="title function_">toFixed</span>()); <span class="comment">// 0 arguments</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n.<span class="title function_">toFixed</span>(<span class="number">3</span>)); <span class="comment">// 1 argument</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过使用 <code>?</code> 将参数标记为可选来在 TypeScript 中对此进行建模：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"><span class="attr">x</span>?: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">f</span>(<span class="number">10</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>尽管参数被指定为 <code>number</code> 类型，但 <code>x</code> 参数实际上将具有 <code>number | undefined</code> 类型，因为 JavaScript 中未指定的参数获取值 <code>undefined</code>。</p>
<p>您还可以提供参数默认值：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x = <span class="number">10</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在在 <code>f</code> 的主体中，<code>x</code> 将具有 <code>number</code> 类型，因为任何 <code>undefined</code> 参数都将被 <code>10</code> 替换。 请注意，当参数是可选的时，调用者始终可以传递 <code>undefined</code>，因为这只是模拟 “missing” 参数：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"><span class="attr">x</span>?: <span class="built_in">number</span></span>): <span class="built_in">void</span>;</span><br><span class="line"><span class="comment">// cut</span></span><br><span class="line"><span class="comment">// All OK</span></span><br><span class="line"><span class="title function_">f</span>();</span><br><span class="line"><span class="title function_">f</span>(<span class="number">10</span>);</span><br><span class="line"><span class="title function_">f</span>(<span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure>

<h3 id="回调中的可选参数"><a href="#回调中的可选参数" class="headerlink" title="回调中的可选参数"></a>回调中的可选参数</h3><p>一旦你了解了可选参数和函数类型表达式，在编写调用回调的函数时很容易犯以下错误：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myForEach</span>(<span class="params"><span class="attr">arr</span>: <span class="built_in">any</span>[], <span class="attr">callback</span>: (arg: <span class="built_in">any</span>, index?: <span class="built_in">number</span>) =&gt; <span class="built_in">void</span></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">callback</span>(arr[i], i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>人们在编写 <code>index?</code> 作为可选参数时通常的意图是他们希望这两个调用都是合法的：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">myForEach</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="attr">arr</span>: <span class="built_in">any</span>[],</span></span><br><span class="line"><span class="params">  <span class="attr">callback</span>: (arg: <span class="built_in">any</span>, index?: <span class="built_in">number</span>) =&gt; <span class="built_in">void</span></span></span><br><span class="line"><span class="params"></span>): <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">myForEach</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">a</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(a));</span><br><span class="line"><span class="title function_">myForEach</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">a, i</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(a, i));</span><br></pre></td></tr></table></figure>

<p>这实际上意味着 <code>callback</code> 可能会被一个参数调用。 换句话说，函数定义表明实现可能如下所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myForEach</span>(<span class="params"><span class="attr">arr</span>: <span class="built_in">any</span>[], <span class="attr">callback</span>: (arg: <span class="built_in">any</span>, index?: <span class="built_in">number</span>) =&gt; <span class="built_in">void</span></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// I don&#x27;t feel like providing the index today</span></span><br><span class="line">    <span class="title function_">callback</span>(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反过来，TypeScript 将强制执行此含义并发出实际上不可能的错误：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">myForEach</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="attr">arr</span>: <span class="built_in">any</span>[],</span></span><br><span class="line"><span class="params">  <span class="attr">callback</span>: (arg: <span class="built_in">any</span>, index?: <span class="built_in">number</span>) =&gt; <span class="built_in">void</span></span></span><br><span class="line"><span class="params"></span>): <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">myForEach</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">a, i</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i.<span class="title function_">toFixed</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在 JavaScript 中，如果你调用一个参数多于参数的函数，多余的参数将被忽略。 TypeScript 的行为方式相同。 具有较少参数（相同类型）的函数总是可以代替具有更多参数的函数。</p>
<blockquote>
<p>为回调编写函数类型时，切勿编写可选参数，除非您打算在不传递该参数的情况下调用该函数</p>
</blockquote>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>可以以各种参数计数和类型调用一些 JavaScript 函数。 例如，您可以编写一个函数来生成一个 <code>Date</code>，它采用时间戳（一个参数）或月&#x2F;日&#x2F;年规范（三个参数）。</p>
<p>在 TypeScript 中，我们可以通过编写重载签名来指定一个可以以不同方式调用的函数。 为此，请编写一些函数签名（通常是两个或更多），然后是函数的主体：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeDate</span>(<span class="params"><span class="attr">timestamp</span>: <span class="built_in">number</span></span>): <span class="title class_">Date</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeDate</span>(<span class="params"><span class="attr">m</span>: <span class="built_in">number</span>, <span class="attr">d</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span></span>): <span class="title class_">Date</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeDate</span>(<span class="params"><span class="attr">mOrTimestamp</span>: <span class="built_in">number</span>, <span class="attr">d</span>?: <span class="built_in">number</span>, <span class="attr">y</span>?: <span class="built_in">number</span></span>): <span class="title class_">Date</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (d !== <span class="literal">undefined</span> &amp;&amp; y !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(y, mOrTimestamp, d);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(mOrTimestamp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> d1 = <span class="title function_">makeDate</span>(<span class="number">12345678</span>);</span><br><span class="line"><span class="keyword">const</span> d2 = <span class="title function_">makeDate</span>(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">const</span> d3 = <span class="title function_">makeDate</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们写了两个重载：一个接受一个参数，另一个接受三个参数。 前两个签名称为重载签名。</p>
<p>然后，我们编写了一个具有兼容签名的函数实现。 函数有一个实现签名，但是这个签名不能直接调用。 即使我们在必需的参数之后编写了一个带有两个可选参数的函数，也不能用两个参数调用它！</p>
<h3 id="重载签名和实现签名"><a href="#重载签名和实现签名" class="headerlink" title="重载签名和实现签名"></a>重载签名和实现签名</h3><p>这是一个常见的混淆来源。 很多时候人们会写这样的代码，却不明白为什么会出现错误：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">string</span></span>): <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Expected to be able to call with zero arguments</span></span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure>

<p>同样，用于编写函数体的签名不能是外部的 “seen”。</p>
<blockquote>
<p>从外部看不到实现的签名。 在编写重载函数时，您应该始终在函数实现之上有两个或多个签名。</p>
</blockquote>
<p>实现签名还必须与重载签名兼容。 例如，这些函数有错误，因为实现签名没有以正确的方式匹配重载：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">boolean</span></span>): <span class="built_in">void</span>;</span><br><span class="line"><span class="comment">// Argument type isn&#x27;t right</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">string</span></span>): <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">boolean</span></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="comment">// Return type isn&#x27;t right</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">number</span></span>): <span class="built_in">boolean</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;oops&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写好的重载"><a href="#编写好的重载" class="headerlink" title="编写好的重载"></a>编写好的重载</h3><p>与泛型一样，在使用函数重载时应该遵循一些准则。 遵循这些原则将使您的函数更易于调用、更易于理解和更易于实现。</p>
<p>让我们考虑一个返回字符串或数组长度的函数：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">len</span>(<span class="params"><span class="attr">s</span>: <span class="built_in">string</span></span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">len</span>(<span class="params"><span class="attr">arr</span>: <span class="built_in">any</span>[]</span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">len</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数很好；我们可以用字符串或数组调用它。 但是，我们不能使用可能是字符串或数组的值来调用它，因为 TypeScript 只能将函数调用解析为单个重载：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">len</span>(<span class="params"><span class="attr">s</span>: <span class="built_in">string</span></span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">len</span>(<span class="params"><span class="attr">arr</span>: <span class="built_in">any</span>[]</span>): <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">len</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">len</span>([<span class="number">0</span>]); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">len</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() &gt; <span class="number">0.5</span> ? <span class="string">&quot;hello&quot;</span> : [<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>因为两个重载具有相同的参数计数和相同的返回类型，我们可以改为编写函数的非重载版本：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">len</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">any</span>[] | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这好多了！ 调用者可以使用任何一种值来调用它，作为额外的好处，我们不必找出正确的实现签名。</p>
<blockquote>
<p>尽可能使用联合类型的参数而不是重载</p>
</blockquote>
<h2 id="其他需要了解的类型"><a href="#其他需要了解的类型" class="headerlink" title="其他需要了解的类型"></a>其他需要了解的类型</h2><p>在使用函数类型时，您需要识别一些经常出现的其他类型。 像所有类型一样，您可以在任何地方使用它们，但这些在函数的上下文中尤其相关。</p>
<h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p><code>void</code> 表示不返回值的函数的返回值。 只要函数没有任何 <code>return</code> 语句，或者没有从这些返回语句返回任何显式值，它就是推断类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The inferred return type is void</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">noop</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 JavaScript 中，不返回任何值的函数将隐式返回值 <code>undefined</code>。 但是，<code>void</code> 和 <code>undefined</code> 在 TypeScript 中不是一回事。 本章末尾有更多详细信息。</p>
<blockquote>
<p><code>void</code> 与 <code>undefined</code> 不同。</p>
</blockquote>
<h3 id="object"><a href="#object" class="headerlink" title="object"></a>object</h3><p>特殊类型 <code>object</code> 指的是任何非原始值（<code>string</code>、<code>number</code>、<code>bigint</code>、<code>boolean</code>、<code>symbol</code>、<code>null</code> 或 <code>undefined</code>）。 这与空对象类型 <code>&#123; &#125;</code> 不同，也与全局类型 <code>Object</code> 不同。 您很可能永远不会使用 <code>Object</code>。</p>
<blockquote>
<p><code>object</code> 不是 <code>Object</code>。<strong>总是</strong>使用 <code>object</code>！</p>
</blockquote>
<p>请注意，在 JavaScript 中，函数值是对象：它们有属性，在它们的原型链中有 <code>Object.prototype</code>，是 <code>instanceof Object</code>，你可以在它们上调用 <code>Object.keys</code>，等等。 因此，函数类型在 TypeScript 中被认为是 <code>object</code>。</p>
<h3 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h3><p><code>unknown</code> 类型代表任何值。 这类似于 <code>any</code> 类型，但更安全，因为使用 <code>unknown</code> 值做任何事情都是不合法的：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"><span class="attr">a</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  a.<span class="title function_">b</span>(); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"><span class="attr">a</span>: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">  a.<span class="title function_">b</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这在描述函数类型时很有用，因为您可以描述接受任何值而不在函数体中包含 <code>any</code> 值的函数。</p>
<p>相反，您可以描述一个返回未知类型值的函数：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">someRandomString</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">safeParse</span>(<span class="params"><span class="attr">s</span>: <span class="built_in">string</span></span>): <span class="built_in">unknown</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Need to be careful with &#x27;obj&#x27;!</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">safeParse</span>(someRandomString);</span><br></pre></td></tr></table></figure>

<h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><p>有些函数从不返回值：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fail</span>(<span class="params"><span class="attr">msg</span>: <span class="built_in">string</span></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>never</code> 类型表示从未观察到的值。 在返回类型中，这意味着函数抛出异常或终止程序的执行。</p>
<p>当 TypeScript 确定联合中没有任何内容时，<code>never</code> 也会出现。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// do something else</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    x; <span class="comment">// has type &#x27;never&#x27;!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p>全局类型 <code>Function</code> 描述了 <code>bind</code>、<code>call</code>、<code>apply</code> 等属性，以及 JavaScript 中所有函数值上的其他属性。 它还有一个特殊的属性，即 <code>Function</code> 类型的值总是可以被调用；这些调用返回 <code>any</code>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"><span class="attr">f</span>: <span class="title class_">Function</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">f</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个无类型的函数调用，通常最好避免，因为不安全的 <code>any</code> 返回类型。</p>
<p>如果您需要接受任意函数但不打算调用它，则类型 <code>() =&gt; void</code> 通常更安全。</p>
<h2 id="剩余形参和实参"><a href="#剩余形参和实参" class="headerlink" title="剩余形参和实参"></a>剩余形参和实参</h2><h3 id="剩余形参"><a href="#剩余形参" class="headerlink" title="剩余形参"></a>剩余形参</h3><p>除了使用可选参数或重载来制作可以接受各种固定参数计数的函数之外，我们还可以使用剩余参数定义接受无限数量参数的函数。</p>
<p>剩余参数出现在所有其他参数之后，并使用 <code>...</code> 语法：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params"><span class="attr">n</span>: <span class="built_in">number</span>, ...<span class="attr">m</span>: <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> m.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> n * x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27; gets value [10, 20, 30, 40]</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="title function_">multiply</span>(<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>在 TypeScript 中，这些参数的类型注解隐含地是 <code>any[]</code> 而不是 <code>any</code>，并且任何给定的类型注解都必须是 <code>Array&lt;T&gt;</code> 或 <code>T[]</code> 的形式，或者是元组类型（我们稍后会了解）。</p>
<h3 id="剩余实参"><a href="#剩余实参" class="headerlink" title="剩余实参"></a>剩余实参</h3><p>相反，我们可以使用扩展语法从数组中提供可变数量的参数。 例如，数组的 <code>push</code> 方法接受任意数量的参数：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">arr1.<span class="title function_">push</span>(...arr2);</span><br></pre></td></tr></table></figure>

<p>请注意，通常，TypeScript 并不假定数组是不可变的。 这可能会导致一些令人惊讶的行为：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Inferred type is number[] -- &quot;an array with zero or more numbers&quot;,</span></span><br><span class="line"><span class="comment">// not specifically two numbers</span></span><br><span class="line"><span class="keyword">const</span> args = [<span class="number">8</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> angle = <span class="title class_">Math</span>.<span class="title function_">atan2</span>(...args);</span><br></pre></td></tr></table></figure>

<p>这种情况的最佳解决方案取决于您的代码，但通常 <code>const</code> 上下文是最直接的解决方案：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Inferred as 2-length tuple</span></span><br><span class="line"><span class="keyword">const</span> args = [<span class="number">8</span>, <span class="number">5</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="comment">// OK</span></span><br><span class="line"><span class="keyword">const</span> angle = <span class="title class_">Math</span>.<span class="title function_">atan2</span>(...args);</span><br></pre></td></tr></table></figure>

<p>针对较旧的运行时，使用剩余参数可能需要打开 <a href="https://nodejs.cn/typescript/handbook/functions/##6fcb22e48619498984a44e4109a7161e"><code>downlevelIteration</code></a>。</p>
<h2 id="参数解构"><a href="#参数解构" class="headerlink" title="参数解构"></a>参数解构</h2><p>您可以使用参数解构来方便地将作为参数提供的对象解压缩到函数体中的一个或多个局部变量中。 在 JavaScript 中，它看起来像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">&#123; a, b, c &#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b + c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(&#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">3</span>, <span class="attr">c</span>: <span class="number">9</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>对象的类型注释遵循解构语法：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">&#123; a, b, c &#125;: &#123; a: <span class="built_in">number</span>; b: <span class="built_in">number</span>; c: <span class="built_in">number</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b + c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这看起来有点冗长，但您也可以在此处使用命名类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Same as prior example</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">ABC</span> = &#123; <span class="attr">a</span>: <span class="built_in">number</span>; <span class="attr">b</span>: <span class="built_in">number</span>; <span class="attr">c</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">&#123; a, b, c &#125;: ABC</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b + c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>常用 Android Debug Bridge (ADB) 命令指南</title>
    <url>/2024/05/24/20240524-%E5%B8%B8%E7%94%A8%20Android%20Debug%20Bridge%20(ADB)%20%E5%91%BD%E4%BB%A4%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>Android Debug Bridge (adb) 是一个功能强大的工具，广泛应用于安卓开发、调试和设备管理。本文将为大家介绍一些常用且实用的 adb 命令，帮助你更好地利用这个工具来提高工作效率。</p>
<span id="more"></span>

<h2 id="设备和连接管理"><a href="#设备和连接管理" class="headerlink" title="设备和连接管理"></a>设备和连接管理</h2><h3 id="列出连接的设备"><a href="#列出连接的设备" class="headerlink" title="列出连接的设备"></a>列出连接的设备</h3><p>要查看当前连接的设备，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb devices</span><br></pre></td></tr></table></figure>

<p>这将列出所有当前连接的设备和模拟器实例。</p>
<h3 id="指定设备"><a href="#指定设备" class="headerlink" title="指定设备"></a>指定设备</h3><p>在多设备环境中，可以通过序列号指定目标设备来执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb -s &lt;device_serial&gt; &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure>

<p>例如，安装应用到特定设备：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb -s emulator-5554 install app.apk</span><br></pre></td></tr></table></figure>

<h3 id="重启设备"><a href="#重启设备" class="headerlink" title="重启设备"></a>重启设备</h3><p>重启设备是常见的操作，使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb reboot</span><br></pre></td></tr></table></figure>

<h3 id="重启到引导加载程序"><a href="#重启到引导加载程序" class="headerlink" title="重启到引导加载程序"></a>重启到引导加载程序</h3><p>如果需要进入引导加载程序，可以使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb reboot bootloader</span><br></pre></td></tr></table></figure>

<h3 id="重启到恢复模式"><a href="#重启到恢复模式" class="headerlink" title="重启到恢复模式"></a>重启到恢复模式</h3><p>进入恢复模式的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb reboot recovery</span><br></pre></td></tr></table></figure>

<h2 id="应用管理"><a href="#应用管理" class="headerlink" title="应用管理"></a>应用管理</h2><h3 id="安装应用"><a href="#安装应用" class="headerlink" title="安装应用"></a>安装应用</h3><p>安装 APK 文件到设备：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb install &lt;path_to_apk&gt;</span><br></pre></td></tr></table></figure>

<h3 id="卸载应用"><a href="#卸载应用" class="headerlink" title="卸载应用"></a>卸载应用</h3><p>从设备中卸载指定应用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb uninstall &lt;package_name&gt;</span><br></pre></td></tr></table></figure>

<h3 id="列出已安装的应用"><a href="#列出已安装的应用" class="headerlink" title="列出已安装的应用"></a>列出已安装的应用</h3><p>查看设备上所有已安装的应用包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb shell pm list packages</span><br></pre></td></tr></table></figure>

<h3 id="清除应用数据"><a href="#清除应用数据" class="headerlink" title="清除应用数据"></a>清除应用数据</h3><p>清除应用的所有数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb shell pm clear &lt;package_name&gt;</span><br></pre></td></tr></table></figure>

<h3 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a>启动应用</h3><p>通过 monkey 命令启动应用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb shell monkey -p &lt;package_name&gt; -c android.intent.category.LAUNCHER 1</span><br></pre></td></tr></table></figure>

<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="推送文件到设备"><a href="#推送文件到设备" class="headerlink" title="推送文件到设备"></a>推送文件到设备</h3><p>将文件从本地机器推送到设备：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb push &lt;local_path&gt; &lt;remote_path&gt;</span><br></pre></td></tr></table></figure>

<h3 id="从设备拉取文件"><a href="#从设备拉取文件" class="headerlink" title="从设备拉取文件"></a>从设备拉取文件</h3><p>从设备上拉取文件到本地：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb pull &lt;remote_path&gt; &lt;local_path&gt;</span><br></pre></td></tr></table></figure>

<h2 id="调试和日志"><a href="#调试和日志" class="headerlink" title="调试和日志"></a>调试和日志</h2><h3 id="查看设备日志"><a href="#查看设备日志" class="headerlink" title="查看设备日志"></a>查看设备日志</h3><p>查看设备运行的实时日志：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb logcat</span><br></pre></td></tr></table></figure>

<h3 id="筛选日志"><a href="#筛选日志" class="headerlink" title="筛选日志"></a>筛选日志</h3><p>通过标签和优先级筛选日志输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb logcat -s &lt;tag&gt;:&lt;priority&gt;</span><br></pre></td></tr></table></figure>

<p>例如，筛选 tag 为 MyAppTag 的 debug 日志：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb logcat -s MyAppTag:D</span><br></pre></td></tr></table></figure>

<h3 id="转储系统状态"><a href="#转储系统状态" class="headerlink" title="转储系统状态"></a>转储系统状态</h3><p>获取设备的系统状态信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb shell dumpsys</span><br></pre></td></tr></table></figure>

<h3 id="获取设备信息"><a href="#获取设备信息" class="headerlink" title="获取设备信息"></a>获取设备信息</h3><p>查看设备属性信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb shell getprop</span><br></pre></td></tr></table></figure>

<h3 id="获取特定的应用域名首选项设置"><a href="#获取特定的应用域名首选项设置" class="headerlink" title="获取特定的应用域名首选项设置"></a>获取特定的应用域名首选项设置</h3><p>要查看某个设备上设置的域名首选项应用，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb shell dumpsys package domain-preferred-apps</span><br></pre></td></tr></table></figure>

<p>此命令列出系统中由用户或系统定义的哪些应用程序被设置为首选处理某些网络域名的请求。</p>
<h2 id="模拟用户输入"><a href="#模拟用户输入" class="headerlink" title="模拟用户输入"></a>模拟用户输入</h2><h3 id="模拟按键事件"><a href="#模拟按键事件" class="headerlink" title="模拟按键事件"></a>模拟按键事件</h3><p>模拟按键事件（例如返回键， Home 键等）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb shell input keyevent &lt;keycode&gt;</span><br></pre></td></tr></table></figure>

<h3 id="模拟触摸事件"><a href="#模拟触摸事件" class="headerlink" title="模拟触摸事件"></a>模拟触摸事件</h3><p>模拟屏幕上的触摸动作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb shell input tap &lt;x&gt; &lt;y&gt;</span><br></pre></td></tr></table></figure>

<h3 id="模拟文本输入"><a href="#模拟文本输入" class="headerlink" title="模拟文本输入"></a>模拟文本输入</h3><p>模拟输入文本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb shell input text &lt;string&gt;</span><br></pre></td></tr></table></figure>

<h2 id="网络和端口转发"><a href="#网络和端口转发" class="headerlink" title="网络和端口转发"></a>网络和端口转发</h2><h3 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h3><p>在设备和本地机器之间进行端口转发：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb forward &lt;<span class="built_in">local</span>&gt; &lt;remote&gt;</span><br></pre></td></tr></table></figure>

<p>例如，将本地 6100 端口转发到设备的 7100 端口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb forward tcp:6100 tcp:7100</span><br></pre></td></tr></table></figure>

<h3 id="通过无线连接设备"><a href="#通过无线连接设备" class="headerlink" title="通过无线连接设备"></a>通过无线连接设备</h3><p>通过 Wi-Fi 连接设备，首先将设备设置为 TCP&#x2F;IP 模式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb tcpip 5555</span><br><span class="line">$ adb connect &lt;device_ip&gt;:5555</span><br></pre></td></tr></table></figure>

<h2 id="截图和屏幕录制"><a href="#截图和屏幕录制" class="headerlink" title="截图和屏幕录制"></a>截图和屏幕录制</h2><h3 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h3><p>截取设备屏幕并保存到本地：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb shell screencap /sdcard/screenshot.png</span><br><span class="line">$ adb pull /sdcard/screenshot.png</span><br></pre></td></tr></table></figure>

<h3 id="屏幕录制"><a href="#屏幕录制" class="headerlink" title="屏幕录制"></a>屏幕录制</h3><p>录制设备屏幕并保存到本地：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb shell screenrecord /sdcard/screenrecord.mp4</span><br><span class="line">$ adb pull /sdcard/screenrecord.mp4</span><br></pre></td></tr></table></figure>

<h2 id="特殊场景命令"><a href="#特殊场景命令" class="headerlink" title="特殊场景命令"></a>特殊场景命令</h2><h3 id="启动浏览器打开特定-URL"><a href="#启动浏览器打开特定-URL" class="headerlink" title="启动浏览器打开特定 URL"></a>启动浏览器打开特定 URL</h3><p>若希望直接在设备上启动浏览器并打开特定 URL，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb -s &lt;devices-number&gt; shell am start -a android.intent.action.VIEW \</span><br><span class="line">    -c android.intent.category.BROWSABLE \</span><br><span class="line">    -d <span class="string">&quot;https://xxxxx&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里，<code>&lt;devices-number&gt;</code> 是设备序列号，<code>https://xxxxx</code> 是要打开的 URL。你可以依据实际情况替换这部分内容。</p>
<h3 id="关闭模拟器"><a href="#关闭模拟器" class="headerlink" title="关闭模拟器"></a>关闭模拟器</h3><p>快速关闭指定的模拟器实例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb -s emulator-5554 emu <span class="built_in">kill</span></span><br></pre></td></tr></table></figure>

<p>此命令用于关闭端口号为 emulator-5554 的安卓模拟器。</p>
<h2 id="其他有用的命令"><a href="#其他有用的命令" class="headerlink" title="其他有用的命令"></a>其他有用的命令</h2><h3 id="显示设备信息"><a href="#显示设备信息" class="headerlink" title="显示设备信息"></a>显示设备信息</h3><p>获取设备的电池状态信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb shell dumpsys battery</span><br></pre></td></tr></table></figure>

<h3 id="列出所有系统属性"><a href="#列出所有系统属性" class="headerlink" title="列出所有系统属性"></a>列出所有系统属性</h3><p>查看设备的所有系统属性：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb shell getprop</span><br></pre></td></tr></table></figure>

<p>通过掌握以上这些 adb 命令，你可以更高效地进行安卓应用的开发、调试和设备管理。不论是日常操作还是复杂的调试任务，adb 都能提供极大的帮助。希望本文能为你的安卓开发之旅提供坚实的支持。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>adb</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 fastlane 读取 iOS 证书信息</title>
    <url>/2024/09/23/20240923-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8fastlane%E8%AF%BB%E5%8F%96iOS%E8%AF%81%E4%B9%A6%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p>在 iOS 开发中，证书管理一直是一个重要且复杂的话题。随着 fastlane 的更新，我们处理证书信息的方式也在不断演进。今天，我想分享我在使用 fastlane 读取和加密 iOS 证书信息时的经历，以及如何应对 fastlane 更新带来的变化。</p>
<h2 id="初始方法：直接读取证书文件"><a href="#初始方法：直接读取证书文件" class="headerlink" title="初始方法：直接读取证书文件"></a><strong>初始方法：直接读取证书文件</strong></h2><p>最初，我创建了一个自定义的 fastlane Action 来直接读取 .cer 文件，这里使用的是 OpenSSL 进行解密：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReadSpecificFileAction</span> &lt; <span class="title class_ inherited__">Action</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">self</span>.decrypt_specific_file(<span class="symbol">path:</span> <span class="literal">nil</span>, <span class="symbol">password:</span> <span class="literal">nil</span>, <span class="symbol">hash_algorithm:</span> <span class="string">&quot;MD5&quot;</span>)</span><br><span class="line">    stored_data = <span class="title class_">Base64</span>.decode64(<span class="title class_">File</span>.read(path))</span><br><span class="line">    salt = stored_data[<span class="number">8</span>..<span class="number">15</span>]</span><br><span class="line">    data_to_decrypt = stored_data[<span class="number">16</span>..-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    decipher = <span class="symbol">:</span><span class="symbol">:OpenSSL</span><span class="symbol">:</span><span class="symbol">:Cipher</span>.new(<span class="string">&#x27;AES-256-CBC&#x27;</span>)</span><br><span class="line">    decipher.decrypt</span><br><span class="line">    decipher.pkcs5_keyivgen(password, salt, <span class="number">1</span>, hash_algorithm)</span><br><span class="line"></span><br><span class="line">    decrypted_data = decipher.update(data_to_decrypt) + decipher.final</span><br><span class="line"></span><br><span class="line">    <span class="title class_">File</span>.binwrite(path, decrypted_data)</span><br><span class="line">  <span class="keyword">rescue</span> =&gt; error</span><br><span class="line">    fallback_hash_algorithm = <span class="string">&quot;SHA256&quot;</span></span><br><span class="line">    <span class="keyword">if</span> hash_algorithm != fallback_hash_algorithm</span><br><span class="line">      decrypt_specific_file(<span class="symbol">path:</span> path, <span class="symbol">password:</span> password, <span class="symbol">hash_algorithm:</span> fallback_hash_algorithm)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="variable constant_">UI</span>.error(error.to_s)</span><br><span class="line">      <span class="variable constant_">UI</span>.crash!(<span class="string">&quot;Error decrypting &#x27;<span class="subst">#&#123;path&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这种方法简单直接，但随着 fastlane 的更新，fastlane 应该是修改了加密解密的逻辑，上面的方案已经无法使用，我们需要寻找新的实现方案。</p>
<span id="more"></span>

<h2 id="寻找新的实现方案"><a href="#寻找新的实现方案" class="headerlink" title="寻找新的实现方案"></a>寻找新的实现方案</h2><h3 id="Step-1-查阅-fastlane-match-插件的官方文档"><a href="#Step-1-查阅-fastlane-match-插件的官方文档" class="headerlink" title="Step 1: 查阅 fastlane match 插件的官方文档"></a>Step 1: 查阅 fastlane match 插件的官方文档</h3><p>在阅读 <code>match</code> 文档的过程中我看到一个手动解密的信息，原文如下：</p>
<blockquote>
<h3 id="Manual-Decrypt"><a href="#Manual-Decrypt" class="headerlink" title="Manual Decrypt"></a>Manual Decrypt</h3><p>If you want to manually decrypt or encrypt a file, you can use the companion script <code>match_file</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">match_file encrypt &quot;&lt;fileYouWantToEncryptPath&gt;&quot; [&quot;&lt;encryptedFilePath&gt;&quot;]</span><br><span class="line"></span><br><span class="line">match_file decrypt &quot;&lt;fileYouWantToDecryptPath&gt;&quot; [&quot;&lt;decryptedFilePath&gt;&quot;]</span><br></pre></td></tr></table></figure>

<p>The password will be asked interactively.</p>
<p><em><strong>Note:</strong> You may need to swap double quotes <code>&quot;</code> for single quotes <code>&#39;</code> if your match password contains an exclamation mark <code>!</code>.</em></p>
</blockquote>
<h3 id="Step-2-查看-match-file-命令的源码实现"><a href="#Step-2-查看-match-file-命令的源码实现" class="headerlink" title="Step 2: 查看 match_file 命令的源码实现"></a>Step 2: 查看 match_file 命令的源码实现</h3><p>既然我们知道了这里是使用 <code>match_file</code> 命令进行手动解密的，那么我们可以去 github 看一下他是如何实现的。<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Zhc3RsYW5lL2Zhc3RsYW5lL2Jsb2IvbWFzdGVyL2Jpbi9tYXRjaF9maWxl">match_file<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="title class_">Match::Encryption::MatchFileEncryption</span>.new.send(method_name, <span class="symbol">file_path:</span> input_file, <span class="symbol">password:</span> password, <span class="symbol">output_path:</span> output_file)</span><br><span class="line"><span class="keyword">rescue</span> =&gt; e</span><br><span class="line">  puts(<span class="string">&quot;ERROR <span class="subst">#&#123;method_name&#125;</span>ing. [<span class="subst">#&#123;e&#125;</span>]. Check your password&quot;</span>)</span><br><span class="line">  usage</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这是脚本的核心部分，使用 <code>Match::Encryption::MatchFileEncryption</code> 类来执行加密或解密操作。如果发生错误（例如密码错误），会捕获异常并显示错误信息。</p>
<p>我们来看一下这个方法的参数都是什么：</p>
<h4 id="method-name"><a href="#method-name" class="headerlink" title="method_name"></a>method_name</h4><ul>
<li>这是第一个参数，它决定了要执行的操作。</li>
<li>值可以是 <code>encrypt</code> 或 <code>decrypt</code>。</li>
<li>这个参数使用 send 方法动态调用相应的方法（加密或解密）。</li>
</ul>
<h4 id="file-path-input-file"><a href="#file-path-input-file" class="headerlink" title="file_path: input_file"></a>file_path: input_file</h4><ul>
<li>这是一个命名参数，指定要处理的 iOS 证书文件的路径。</li>
<li><code>input_file</code> 是之前从命令行参数中获取的值。</li>
</ul>
<h4 id="password-password"><a href="#password-password" class="headerlink" title="password: password"></a>password: password</h4><ul>
<li>这个命名参数提供用于加密或解密的密码。</li>
</ul>
<h4 id="output-path-output-file"><a href="#output-path-output-file" class="headerlink" title="output_path: output_file"></a>output_path: output_file</h4><ul>
<li>这个命名参数指定处理后文件的输出路径。</li>
</ul>
<h2 id="新方法：基于-match-file-的实现"><a href="#新方法：基于-match-file-的实现" class="headerlink" title="新方法：基于 match_file 的实现"></a>新方法：基于 match_file 的实现</h2><p>我创建了一个新的 <code>Action</code>，名为 <code>MatchFileEncryptionAction</code>。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MatchFileEncryptionAction</span> &lt; <span class="title class_ inherited__">Action</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">self</span>.run(params)</span><br><span class="line">    method_name = params[<span class="symbol">:method</span>]</span><br><span class="line">    input_file = params[<span class="symbol">:input_file</span>]</span><br><span class="line">    output_file = params[<span class="symbol">:output_file</span>] |<span class="params"></span>| input_file</span><br><span class="line">    password = params[<span class="symbol">:password</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">      <span class="title class_">Match::Encryption::MatchFileEncryption</span>.new.send(method_name, <span class="symbol">file_path:</span> input_file, <span class="symbol">password:</span> password, <span class="symbol">output_path:</span> output_file)</span><br><span class="line">    <span class="keyword">rescue</span> =&gt; e</span><br><span class="line">      <span class="variable constant_">UI</span>.user_error!(<span class="string">&quot;ERROR <span class="subst">#&#123;method_name&#125;</span>ing. [<span class="subst">#&#123;e&#125;</span>]. Check your password&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>可以看到，这个方法只是做了加密解密相关的事情，没有对证书信息进行读取，我将对证书的解析封装到了另一个 <code>ReadCertificateInfoAction</code> 中。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReadCertificateInfoAction</span> &lt; <span class="title class_ inherited__">Action</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">self</span>.run(params)</span><br><span class="line">    cert_path = params[<span class="symbol">:cert_path</span>]</span><br><span class="line"></span><br><span class="line">    <span class="variable constant_">UI</span>.user_error!(<span class="string">&quot;Certificate file not found at path: <span class="subst">#&#123;cert_path&#125;</span>&quot;</span>) <span class="keyword">unless</span> <span class="title class_">File</span>.exist?(cert_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">      cert = <span class="title class_">OpenSSL::X509::Certificate</span>.new(<span class="title class_">File</span>.read(cert_path))</span><br><span class="line"></span><br><span class="line">      subject = parse_subject(cert.subject)</span><br><span class="line"></span><br><span class="line">      info = &#123;</span><br><span class="line">        <span class="symbol">subject:</span> cert.subject.to_s,</span><br><span class="line">        <span class="symbol">issuer:</span> cert.issuer.to_s,</span><br><span class="line">        <span class="symbol">serial:</span> cert.serial.to_s,</span><br><span class="line">        <span class="symbol">not_before:</span> cert.not_before,</span><br><span class="line">        <span class="symbol">not_after:</span> cert.not_after,</span><br><span class="line">        <span class="symbol">public_key:</span> cert.public_key.to_pem,</span><br><span class="line">        <span class="symbol">team_id:</span> extract_team_id(subject),</span><br><span class="line">        <span class="symbol">description:</span> extract_description(subject)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment"># Extract Subject Alternative Names if present</span></span><br><span class="line">      ext = cert.extensions.find &#123; |<span class="params">e</span>| e.oid == <span class="string">&#x27;subjectAltName&#x27;</span> &#125;</span><br><span class="line">      info[<span class="symbol">:subject_alt_names</span>] = ext.value <span class="keyword">if</span> ext</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> info</span><br><span class="line">    <span class="keyword">rescue</span> <span class="title class_">Open</span>SSL::<span class="variable constant_">X509</span><span class="symbol">:</span><span class="symbol">:CertificateError</span> =&gt; e</span><br><span class="line">      <span class="variable constant_">UI</span>.user_error!(<span class="string">&quot;Failed to read certificate: <span class="subst">#&#123;e.message&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">rescue</span> =&gt; e</span><br><span class="line">      <span class="variable constant_">UI</span>.user_error!(<span class="string">&quot;An error occurred: <span class="subst">#&#123;e.message&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">self</span>.parse_subject(subject)</span><br><span class="line">    subject.to_a.each_with_object(&#123;&#125;) <span class="keyword">do</span> |<span class="params">field, hash</span>|</span><br><span class="line">      hash[field[<span class="number">0</span>]] = field[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">self</span>.extract_team_id(subject)</span><br><span class="line">    subject[<span class="string">&#x27;OU&#x27;</span>] |<span class="params"></span>| <span class="string">&quot;Not found&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">self</span>.extract_description(subject)</span><br><span class="line">    cn = subject[<span class="string">&#x27;CN&#x27;</span>] |<span class="params"></span>| <span class="string">&quot;&quot;</span></span><br><span class="line">    o = subject[<span class="string">&#x27;O&#x27;</span>] |<span class="params"></span>| <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;<span class="subst">#&#123;cn&#125;</span><span class="subst">#&#123;o.empty? ? <span class="string">&#x27;&#x27;</span> : <span class="string">&quot; (<span class="subst">#&#123;o&#125;</span>)&quot;</span>&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>至此，我们已经能够在新版 fastlane 中进行对证书的解密和对证书的解析。</p>
<p>最后我们来看一下，iOS 证书里面我解析出了哪些信息</p>
<ul>
<li><code>subject</code>: 证书的主题，通常包含证书持有者的信息。</li>
<li><code>issuer</code>: 证书的颁发者，即签发这个证书的机构（通常是Apple）。</li>
<li><code>serial</code>: 证书的序列号，是一个唯一标识符。</li>
<li><code>not_before</code>: 证书的生效日期，在这个日期之前证书是无效的。</li>
<li><code>not_after</code>: 证书的过期日期，在这个日期之后证书将失效。</li>
<li><code>public_key</code>: 证书中包含的公钥，用于验证与之配对的私钥签名的内容。</li>
<li><code>team_id</code>: 开发者团队ID，这是从证书主题中提取出来的。每个Apple开发者账号都有一个唯一的团队ID。</li>
<li><code>description</code>: 证书的描述信息，也是从证书主题中提取的。</li>
</ul>
]]></content>
      <categories>
        <category>CI</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>fastlane</tag>
      </tags>
  </entry>
  <entry>
    <title>Ruby 魔法：用 Monkey Patching 解决 Fastlane Gym 的清理困境</title>
    <url>/2024/10/01/20241001-Ruby-%E9%AD%94%E6%B3%95%EF%BC%9A%E7%94%A8-Monkey-Patching-%E8%A7%A3%E5%86%B3-Fastlane-Gym-%E7%9A%84%E6%B8%85%E7%90%86%E5%9B%B0%E5%A2%83/</url>
    <content><![CDATA[<p>在 iOS 开发中，自动化构建和打包流程是提高效率的关键。Fastlane 的 Gym 工具为我们提供了强大的自动化能力，但有时也会带来一些令人头疼的问题。今天，我们就来探讨一个我遇到的 Gym 打包问题，并分享一个巧妙的解决方案。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在使用 Fastlane 的 Gym 工具进行批量 iOS 打包时，我们可能会遇到一个棘手的问题。特别是当我们将 Gym 的 <code>clean</code> 参数设置为 <code>true</code> 时，可能会导致构建过程失败。</p>
<p>在执行打包命令时，Gym 会运行类似这样的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /usr/bin/xcrun \</span><br><span class="line">    /opt/homebrew/lib/ruby/gems/3.3.0/gems/fastlane-2.222.0/gym/lib/assets/wrap_xcodebuild/xcbuild-safe.sh \</span><br><span class="line">    -exportArchive \</span><br><span class="line">    -exportOptionsPlist <span class="string">&#x27;/var/folders/64/8v_9fcln0_g76s0ry0j6pwt40000gn/T/gym_config20240929-78449-4vb1zz.plist&#x27;</span> \</span><br><span class="line">    -archivePath build/beta/zestbuy_beta.xcarchive \</span><br><span class="line">    -exportPath <span class="string">&#x27;/var/folders/64/8v_9fcln0_g76s0ry0j6pwt40000gn/T/gym_output20240929-78449-k1ep6q&#x27;</span></span><br></pre></td></tr></table></figure>

<p>问题出现在这里：当 <code>clean</code> 参数设置为 <code>true</code> 时，Gym 会在构建过程中清理临时文件和目录。这可能导致 <code>exportOptionsPlist</code> 指定的文件路径被删除，从而引发 “文件或目录不存在”的错误，最终导致整个打包过程失败。</p>
<p>更具体地说，问题的根源在于：</p>
<ol>
<li>Gym 使用系统的临时目录来存储 exportOptionsPlist 文件。</li>
<li>当 <code>clean</code> 参数为 <code>true</code> 时，这些临时文件可能在需要使用之前就被清理掉了。</li>
<li>Gym 没有提供直接的方法让我们自定义这个文件的存储路径。</li>
</ol>
<p>这个问题特别棘手，因为它只在特定配置下出现（即 <code> clean: true</code>），而这个配置在某些情况下是必要的，比如为了确保每次构建都是从一个干净的状态开始。</p>
<span id="more"></span>

<h2 id="深入分析"><a href="#深入分析" class="headerlink" title="深入分析"></a>深入分析</h2><p>经过对 Gym 源码分析，我们发现问题的根源主要在 Gym 的 <code>PackageCommandGeneratorXcode7</code> 类中的 <code>config_path</code> 方法。这个方法决定了 <code>exportOptionsPlist</code> 文件的生成位置。同时，为了进一步提高可靠性，我们也可以修改 <code>temporary_output_path</code> 方法来控制临时输出目录的位置。</p>
<p>让我们看看这两个方法的原始实现：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">temporary_output_path</span></span><br><span class="line">  <span class="title class_">Gym</span>.cache[<span class="symbol">:temporary_output_path</span>] |<span class="params"></span>|= <span class="title class_">Dir</span>.mktmpdir(<span class="string">&#x27;gym_output&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">config_path</span></span><br><span class="line">  <span class="title class_">Gym</span>.cache[<span class="symbol">:config_path</span>] |<span class="params"></span>|= <span class="string">&quot;<span class="subst">#&#123;<span class="title class_">Tempfile</span>.new(<span class="string">&#x27;gym_config&#x27;</span>).path&#125;</span>.plist&quot;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Gym</span>.cache[<span class="symbol">:config_path</span>]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><code>config_path</code> 方法使用 <code>Tempfile</code> 创建一个临时文件，这就是导致 <code>exportOptionsPlist</code> 文件可能找不到的主要原因。而 <code>temporary_output_path</code> 方法虽然不是直接导致问题的根源，但它使用 <code>Dir.mktmpdir</code> 创建临时目录，也可能在某些情况下引发类似的问题。</p>
<h2 id="Ruby-的-Monkey-Patching-原理"><a href="#Ruby-的-Monkey-Patching-原理" class="headerlink" title="Ruby 的 Monkey Patching 原理"></a>Ruby 的 Monkey Patching 原理</h2><p>在介绍具体解决方案之前，让我们深入了解 Ruby 的 “Monkey Patching” 原理，这是我们解决问题的关键技术。<br>Monkey Patching 是 Ruby 中一个强大而独特的特性，它允许开发者在运行时修改现有类的行为。其核心原理包括：</p>
<ol>
<li><p><strong>开放类（Open Classes）：</strong><br>Ruby 允许在任何时候重新打开并修改已定义的类，包括内置类和第三方库中的类。</p>
</li>
<li><p><strong>方法查找机制：</strong><br>当调用一个对象的方法时，Ruby 会沿着方法查找路径（也称为祖先链）向上搜索，直到找到第一个匹配的方法定义。</p>
</li>
<li><p><strong>方法重定义：</strong><br>当重新定义一个已存在的方法时，Ruby 会更新该类的方法表，使新的定义覆盖旧的。</p>
</li>
<li><p><strong>动态性：</strong><br>由于 Ruby 的动态特性，这些修改是即时生效的，影响所有后续的方法调用。</p>
</li>
</ol>
<h3 id="Monkey-Patching-的工作原理可以概括为以下步骤："><a href="#Monkey-Patching-的工作原理可以概括为以下步骤：" class="headerlink" title="Monkey Patching 的工作原理可以概括为以下步骤："></a>Monkey Patching 的工作原理可以概括为以下步骤：</h3><ol>
<li>重新打开目标类。</li>
<li>定义新的方法或重写现有方法。</li>
<li>Ruby 更新类的方法表。</li>
<li>后续的方法调用将使用新的实现。</li>
</ol>
<p>对于做过 iOS 开发的朋友来说，这是不是听起来有点熟悉？没错，这与 Objective-C 中的方法交换（Method Swizzling）有些相似之处。让我们来比较一下这两种技术：</p>
<h3 id="Monkey-Patching-vs-Method-Swizzling"><a href="#Monkey-Patching-vs-Method-Swizzling" class="headerlink" title="Monkey Patching vs. Method Swizzling"></a>Monkey Patching vs. Method Swizzling</h3><h4 id="相似之处"><a href="#相似之处" class="headerlink" title="相似之处"></a>相似之处</h4><ul>
<li>两者都允许在运行时修改既有行为。</li>
<li>都可以用于扩展或修改现有类的功能。</li>
<li>在调试和添加功能时都非常有用。</li>
</ul>
<h4 id="不同之处："><a href="#不同之处：" class="headerlink" title="不同之处："></a>不同之处：</h4><ul>
<li><p><strong>作用范围</strong>：<br>Ruby 的 Monkey Patching 可以添加新方法、修改现有方法，甚至修改核心类。<br>Objective-C 的方法交换主要用于交换现有方法的实现，不能直接添加新方法。</p>
</li>
<li><p><strong>实现方式</strong>：<br>Ruby 直接在类定义中重新定义方法。<br>Objective-C 使用运行时函数如 method_exchangeImplementations 来交换方法实现。</p>
</li>
<li><p><strong>灵活性</strong>：<br>Ruby 的 Monkey Patching 更加灵活，可以轻松修改任何类的行为。<br>Objective-C 的方法交换相对受限，主要用于修改自己的类或分类中的方法。</p>
</li>
<li><p><strong>使用场景</strong>：<br>Ruby 的 Monkey Patching 常用于扩展库功能、打补丁、调试等。<br>Objective-C 的方法交换常用于 AOP（面向切面编程）、为现有方法添加额外功能等。</p>
</li>
<li><p><strong>风险</strong>：<br>Ruby 的 Monkey Patching 可能导致难以预料的副作用，特别是在修改核心类时。<br>Objective-C 的方法交换风险相对较小，但不当使用仍可能导致意外行为。</p>
</li>
</ul>
<p>在我们的 Fastlane Gym 问题中，选择使用 Ruby 的 Monkey Patching 是因为我们需要修改第三方库的行为，而且不仅要修改现有方法的实现，还要改变其逻辑和返回值。Ruby 的动态特性允许我们在不修改原始源代码的情况下实现这些改变，这正是解决我们问题的理想方法。</p>
<h2 id="解决方案：应用-Monkey-Patching"><a href="#解决方案：应用-Monkey-Patching" class="headerlink" title="解决方案：应用 Monkey Patching"></a>解决方案：应用 Monkey Patching</h2><p>了解了 Monkey Patching 的原理，我们现在可以应用这种技术来解决 Gym 的问题。我们将创建一个 <code>gym_patches.rb</code> 文件，使用 Monkey Patching 方式来修改 <code>PackageCommandGeneratorXcode7</code> 类的关键方法。</p>
<p>以下是 <code>gym_patches.rb</code> 的源码：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># frozen_string_literal: true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;gym&#x27;</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;fileutils&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> <span class="title class_">Gym</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">PackageCommandGeneratorXcode7</span></span><br><span class="line">    <span class="keyword">class</span> &lt;&lt; <span class="variable language_">self</span></span><br><span class="line">      <span class="comment"># 生成配置文件的路径</span></span><br><span class="line">      <span class="comment">#</span></span><br><span class="line">      <span class="comment"># <span class="doctag">@return</span> [String] 配置文件的完整路径</span></span><br><span class="line">      <span class="comment"># <span class="doctag">@note</span> 这个方法会在 fastlane 目录下的 configs 子目录中创建一个新的配置文件</span></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">config_path</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">          <span class="title class_">Gym</span>.cache[<span class="symbol">:config_path</span>] |<span class="params"></span>|= <span class="keyword">begin</span></span><br><span class="line">            config_dir = <span class="title class_">File</span>.join(<span class="title class_">File</span>.dirname(<span class="variable constant_">__FILE__</span>), <span class="string">&#x27;configs&#x27;</span>)</span><br><span class="line">            <span class="title class_">FileUtils</span>.mkdir_p(config_dir)</span><br><span class="line"></span><br><span class="line">            timestamp = <span class="title class_">Time</span>.now.strftime(<span class="string">&#x27;%Y%m%d%H%M%S&#x27;</span>)</span><br><span class="line">            project_name = <span class="title class_">File</span>.basename(<span class="title class_">Dir</span>.pwd)</span><br><span class="line">            filename = <span class="string">&quot;<span class="subst">#&#123;project_name&#125;</span>_gym_config_<span class="subst">#&#123;timestamp&#125;</span>.plist&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="title class_">File</span>.join(config_dir, filename)</span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">rescue</span> <span class="title class_">NoMethodError</span> =&gt; e</span><br><span class="line">          <span class="variable constant_">UI</span>.error <span class="string">&quot;Error accessing Gym.cache: <span class="subst">#&#123;e.message&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 生成临时输出目录的路径</span></span><br><span class="line">      <span class="comment">#</span></span><br><span class="line">      <span class="comment"># <span class="doctag">@return</span> [String] 临时输出目录的完整路径</span></span><br><span class="line">      <span class="comment"># <span class="doctag">@note</span> 这个方法会在项目的 build 目录下创建一个带时间戳的 gym_output 子目录</span></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">temporary_output_path</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">          <span class="title class_">Gym</span>.cache[<span class="symbol">:temporary_output_path</span>] |<span class="params"></span>|= <span class="keyword">begin</span></span><br><span class="line">            output_dir = <span class="title class_">File</span>.join(<span class="title class_">File</span>.dirname(<span class="variable constant_">__FILE__</span>), <span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;build&#x27;</span>, <span class="string">&#x27;gym_output&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="title class_">FileUtils</span>.mkdir_p(output_dir)</span><br><span class="line"></span><br><span class="line">            timestamp = <span class="title class_">Time</span>.now.strftime(<span class="string">&#x27;%Y%m%d%H%M%S&#x27;</span>)</span><br><span class="line">            timestamped_dir = <span class="title class_">File</span>.join(output_dir, timestamp)</span><br><span class="line">            <span class="title class_">FileUtils</span>.mkdir_p(timestamped_dir)</span><br><span class="line"></span><br><span class="line">            timestamped_dir</span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">rescue</span> <span class="title class_">NoMethodError</span> =&gt; e</span><br><span class="line">          <span class="variable constant_">UI</span>.error <span class="string">&quot;Error accessing Gym.cache: <span class="subst">#&#123;e.message&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这段代码重新定义了 <code>PackageCommandGeneratorXcode7</code> 类中的 <code>config_path</code> 和 <code>temporary_output_path</code> 方法。新的实现将文件和目录路径改为项目内的固定位置，而不是使用系统的临时目录。</p>
<p>要使用这个解决方案，只需要在 Fastfile 中添加一行导入即可：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">require_relative <span class="string">&#x27;./gym_patches&#x27;</span></span><br></pre></td></tr></table></figure>

<p>就这么简单！现在运行 Gym 时，它会使用我们指定的路径，而不是 Gym 实现的临时目录。</p>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol>
<li><strong>可靠性提升</strong>：通过使用项目内的固定路径，大大减少了因临时文件丢失导致的构建失败。</li>
<li><strong>更好的可追踪性</strong>：时间戳的添加使得每次构建的输出都能被轻松识别和追踪。</li>
<li><strong>便于调试</strong>：当出现问题时，你可以轻松找到并检查相关的配置文件和输出。</li>
<li><strong>更好的版本控制</strong>：你可以选择将这些文件纳入版本控制，方便团队协作和问题复现。</li>
<li><strong>非侵入式修改</strong>：通过 Monkey Patching，我们修改了 Gym 的行为而无需改动其源代码，保持了原有代码的完整性。</li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>通过运用 Ruby 的 Monkey Patching 技术，我们巧妙地解决了 Fastlane Gym 在打包过程中可能遇到的文件路径问题。这个解决方案不仅修复了当前的问题，还提高了整个打包过程的可靠性和可追踪性。</p>
<p>记住，当你遇到框架限制时，深入研究源码并运用语言特性往往能找到解决方案。希望这个技巧能帮助到遇到类似问题的开发者。如果你有任何问题或改进建议，欢迎在评论区留言讨论。</p>
<p>Happy coding!</p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>CI</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Ruby</tag>
        <tag>Fastlane</tag>
        <tag>Monkey Patching</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法：数组的基本原理</title>
    <url>/2025/02/16/20250216-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%9A%E6%95%B0%E7%BB%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>在讲解数据结构时，数组总是一个大家早期接触的主题。但你可能会发现，不同编程语言中“数组”这一概念的使用方式和 API 有所区别。其实我们可以把「数组」分为两大类：</p>
<h2 id="静态数组"><a href="#静态数组" class="headerlink" title="静态数组"></a>静态数组</h2><p>静态数组在创建时就已经确定了元素的个数以及连续的内存空间。我们可以通过下标索引访问数组中存储的元素，这正是数组最原始的形式，也是其 “随机访问” 能力得以实现的根本原因。</p>
<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>动态数组是在静态数组基础上，为了方便编程引入的一层封装。动态数组在内部依然使用静态数组存储数据，但会自动进行扩容和提供一些常用的增删查改 API，如 ⁠<code>push</code>、⁠<code>insert</code>、⁠<code>remove</code> 等。了解动态数组的底层原理，有助于我们深入理解后续实现其他数据结构（例如队列、栈、哈希表等）的核心思想。</p>
<p>本文将围绕静态数组的基本原理，并用 C 语言代码手把手实现简单版本的动态数组，展示其增删查改操作。</p>
<span id="more"></span>

<h2 id="静态数组的基本使用"><a href="#静态数组的基本使用" class="headerlink" title="静态数组的基本使用"></a>静态数组的基本使用</h2><p>在 C 语言中，我们可以直接通过如下方式定义一个大小为 10 的静态数组：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个大小为 10 的静态数组</span></span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用 memset 函数把数组的值初始化为 0</span></span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用索引赋值</span></span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用索引取值</span></span><br><span class="line">    <span class="type">int</span> a = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中：</p>
<ol>
<li><p>数组 ⁠<code>arr</code> 在内存中占用了连续的 ⁠<code>10 * sizeof(int)</code> 字节空间（通常一个 ⁠<code>int</code> 占 4 字节，总共 40 字节）。</p>
</li>
<li><p>数组名 ⁠<code>arr</code> 就代表这块内存的首地址，因此 ⁠<code>arr[0]</code> 就是起始地址处的数据，而 ⁠<code>arr[1]</code> 则是偏移 4 字节后存储的数据。</p>
</li>
</ol>
<p>这种连续内存的特性保证了数组的“随机访问”，即给定任何下标，都可以在 <code>O(1)</code> 时间内通过首地址和偏移量直接计算目标元素的内存位置。</p>
<h2 id="数组的增删改查"><a href="#数组的增删改查" class="headerlink" title="数组的增删改查"></a>数组的增删改查</h2><p>对于静态数组来说，查改操作比较简单，需要给定下标直接访问数据，时间复杂度均为 <code>O(1)</code>。而增删操作则需要考虑两种情况：</p>
<ul>
<li><p>在数组<strong>末尾</strong>增加或删除元素</p>
</li>
<li><p>在数组<strong>中间</strong>插入或删除元素（这就需要进行数据搬移）</p>
</li>
</ul>
<h3 id="数组的增删改查-1"><a href="#数组的增删改查-1" class="headerlink" title="数组的增删改查"></a>数组的增删改查</h3><p>假设我们有一个大小为 10 的数组，前 4 个位置存储数据，现在直接在末尾追加一个元素：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 数组初始化为 0</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">4</span>;        <span class="comment">// 当前已存储 4 个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对前 4 个位置赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        arr[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在数组末尾追加一个元素 4</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        arr[len] = <span class="number">4</span>;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出数组结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在末尾追加数据时只需一次赋值操作，时间复杂度为 <code>O(1)</code>。</p>
<h3 id="在中间插入元素"><a href="#在中间插入元素" class="headerlink" title="在中间插入元素"></a>在中间插入元素</h3><p>如果要在数组的某个中间位置插入一个新元素，就需要先将后面的元素向后搬移，为新元素腾出空间。例如，在下标 2（第三个位置）插入新数据 666：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 初始化数组</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">4</span>;        <span class="comment">// 当前有 4 个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋初始值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        arr[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pos = <span class="number">2</span>;      <span class="comment">// 插入位置</span></span><br><span class="line">    <span class="type">int</span> newVal = <span class="number">666</span>; <span class="comment">// 要插入的新元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测是否有足够空间</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="comment">// 从最后一个元素开始到插入位置，倒序搬移，避免覆盖</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = len; i &gt; pos; i--) &#123;</span><br><span class="line">            arr[i] = arr[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将新元素放入指定位置</span></span><br><span class="line">        arr[pos] = newVal;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出数组结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要将位置 <code>pos</code> 之后的所有元素依次后移一位，因此时间复杂度为 <code>O(N)</code>。</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>删除元素同样分两种情况：</p>
<ul>
<li><p>删除<strong>末尾</strong>元素时，只需要将数组长度减少一位，时间复杂度为 <code>O(1)</code>。</p>
</li>
<li><p>删除数组中间的元素时，需要将目标元素后面的数据前移一位，时间复杂度为 <code>O(N)</code>。</p>
</li>
</ul>
<h4 id="删除末尾元素示例"><a href="#删除末尾元素示例" class="headerlink" title="删除末尾元素示例"></a>删除末尾元素示例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">5</span>; <span class="comment">// 假设数组中有 5 个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋初始值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        arr[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除末尾元素，简单将 len 减 1（此处用 -1 表示已删除，仅作示例）</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        arr[len - <span class="number">1</span>] = <span class="number">-1</span>;  <span class="comment">// 标记为 -1</span></span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出数组结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除中间元素示例"><a href="#删除中间元素示例" class="headerlink" title="删除中间元素示例"></a>删除中间元素示例</h4><p>例如删除下标 1（第二个元素）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">5</span>; <span class="comment">// 假设数组中有 5 个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋初始值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        arr[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> pos = <span class="number">1</span>; <span class="comment">// 删除位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 pos 后面的元素依次前移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = pos; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后一个位置标记为 -1，代表已删除（仅作示例）</span></span><br><span class="line">    arr[len - <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">    len--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出数组结果（仅输出数组中有效的部分）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组的扩容思想"><a href="#数组的扩容思想" class="headerlink" title="数组的扩容思想"></a>数组的扩容思想</h4><p>静态数组的最大问题在于：在创建数组时就必须确定内存大小，一旦数组满了，无法直接在连续内存后面追加更多数据。我们只能重新开辟一块更大的内存，将原有数据复制到新数组中，然后插入新元素。这就是“扩容”操作，其时间复杂度为 <code>O(N)</code>。</p>
<p>以下示例展示如何扩容一个静态数组：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始数组大小为 10</span></span><br><span class="line">    <span class="type">int</span> initCapacity = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *arr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(initCapacity * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> len = initCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设数组已满，赋值 0 ~ 9</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        arr[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在需要扩容，创建一个大小为 20 的新数组</span></span><br><span class="line">    <span class="type">int</span> newCapacity = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> *newArr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(newCapacity * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把原来数组的数据复制到新数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        newArr[i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放旧数组内存</span></span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在新的大数组中追加新元素，比如新元素为 10</span></span><br><span class="line">    newArr[len] = <span class="number">10</span>;</span><br><span class="line">    len++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出新数组中的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, newArr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(newArr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实际开发中，动态数组的扩容不会在每次添加元素时都发生，而是采用均摊时间复杂度（摊还分析）来评估其操作效率。正因为这种策略，使得在尾部追加元素的均摊时间复杂度依然是 <code>O(1)</code>。</p>
<h2 id="动态数组的代码实现与关键点"><a href="#动态数组的代码实现与关键点" class="headerlink" title="动态数组的代码实现与关键点"></a>动态数组的代码实现与关键点</h2><p>动态数组是在静态数组基础上进行封装，以便更方便地进行增删查改操作。动态数组解决了静态数组大小固定的问题，最主要的改进包括：</p>
<ul>
<li><p><strong>自动扩缩容</strong>：当数组元素个数达到容量上限时，扩容为原来的 2 倍；当元素个数减少到容量的 1&#x2F;4 时，可以缩容为原来的 1&#x2F;2。</p>
</li>
<li><p><strong>索引越界检查</strong>：在插入、查找和修改时分别进行检查，保证操作合法。</p>
</li>
<li><p><strong>防止内存泄漏</strong>：删除元素时清除相关数据，确保不再使用的数据能被正确释放。</p>
</li>
</ul>
<p>下面我们通过一个完整的 C 语言示例来实现一个只存储整数的动态数组，该示例包含了自动扩容和缩容、插入、删除、查找以及修改等功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义动态数组结构，用来存储整数数据</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *data;      <span class="comment">// 指向存放数据的数组</span></span><br><span class="line">    <span class="type">int</span> size;       <span class="comment">// 当前存储的元素个数</span></span><br><span class="line">    <span class="type">int</span> capacity;   <span class="comment">// 底层数组的容量</span></span><br><span class="line">&#125; DynamicArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化动态数组，指定初始容量</span></span><br><span class="line">DynamicArray* <span class="title function_">initDynamicArray</span><span class="params">(<span class="type">int</span> initCapacity)</span> &#123;</span><br><span class="line">    DynamicArray *arr = (DynamicArray*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DynamicArray));</span><br><span class="line">    <span class="keyword">if</span> (initCapacity &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        initCapacity = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arr-&gt;data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(initCapacity * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    arr-&gt;size = <span class="number">0</span>;</span><br><span class="line">    arr-&gt;capacity = initCapacity;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放动态数组内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeDynamicArray</span><span class="params">(DynamicArray *arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr) &#123;</span><br><span class="line">        <span class="built_in">free</span>(arr-&gt;data);</span><br><span class="line">        <span class="built_in">free</span>(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据新容量 newCap 重新分配内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">resize</span><span class="params">(DynamicArray *arr, <span class="type">int</span> newCap)</span> &#123;</span><br><span class="line">    <span class="comment">// 容量至少为 1</span></span><br><span class="line">    <span class="keyword">if</span> (newCap &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        newCap = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> *newData = (<span class="type">int</span>*)<span class="built_in">malloc</span>(newCap * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="comment">// 搬移数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr-&gt;size; i++) &#123;</span><br><span class="line">        newData[i] = arr-&gt;data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放旧数组内存</span></span><br><span class="line">    <span class="built_in">free</span>(arr-&gt;data);</span><br><span class="line">    arr-&gt;data = newData;</span><br><span class="line">    arr-&gt;capacity = newCap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引检查：用于返回已有元素的位置（查找、修改、删除）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">checkElementIndex</span><span class="params">(DynamicArray *arr, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= arr-&gt;size) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;IndexOutOfBoundsException: Index: %d, Size: %d\n&quot;</span>, index, arr-&gt;size);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引检查：用于新增元素时，允许 index == size（插入至末尾）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">checkPositionIndex</span><span class="params">(DynamicArray *arr, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; arr-&gt;size) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;IndexOutOfBoundsException: index: %d, Size: %d\n&quot;</span>, index, arr-&gt;size);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组内部状态（调试函数）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">(DynamicArray *arr)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size = %d, capacity = %d\n&quot;</span>, arr-&gt;size, arr-&gt;capacity);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr-&gt;size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 增 --- //</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在数组末尾追加元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addLast</span><span class="params">(DynamicArray *arr, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (arr-&gt;size == arr-&gt;capacity) &#123;</span><br><span class="line">        resize(arr, arr-&gt;capacity * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    arr-&gt;data[arr-&gt;size] = val;</span><br><span class="line">    arr-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定位置添加元素；允许 index == size（插入空隙）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(DynamicArray *arr, <span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    checkPositionIndex(arr, index);</span><br><span class="line">    <span class="keyword">if</span> (arr-&gt;size == arr-&gt;capacity) &#123;</span><br><span class="line">        resize(arr, arr-&gt;capacity * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 index 后的所有元素向后搬移一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = arr-&gt;size - <span class="number">1</span>; i &gt;= index; i--) &#123;</span><br><span class="line">        arr-&gt;data[i + <span class="number">1</span>] = arr-&gt;data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    arr-&gt;data[index] = val;</span><br><span class="line">    arr-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在数组首部添加元素，直接调用 add(index, val)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addFirst</span><span class="params">(DynamicArray *arr, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    add(arr, <span class="number">0</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 删 --- //</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数组最后一个元素，并返回该值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">removeLast</span><span class="params">(DynamicArray *arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr-&gt;size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;NoSuchElementException: Array is empty\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缩容判断</span></span><br><span class="line">    <span class="keyword">if</span> (arr-&gt;size == arr-&gt;capacity / <span class="number">4</span> &amp;&amp; arr-&gt;capacity &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        resize(arr, arr-&gt;capacity / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> deletedVal = arr-&gt;data[arr-&gt;size - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 清理数据，防止内存泄漏</span></span><br><span class="line">    arr-&gt;data[arr-&gt;size - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    arr-&gt;size--;</span><br><span class="line">    <span class="keyword">return</span> deletedVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定位置的元素并返回该值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">removeAt</span><span class="params">(DynamicArray *arr, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    checkElementIndex(arr, index);</span><br><span class="line">    <span class="comment">// 缩容判断</span></span><br><span class="line">    <span class="keyword">if</span> (arr-&gt;size == arr-&gt;capacity / <span class="number">4</span> &amp;&amp; arr-&gt;capacity &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        resize(arr, arr-&gt;capacity / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> deletedVal = arr-&gt;data[index];</span><br><span class="line">    <span class="comment">// 搬移数据，将 index+1 ... end 向前移动</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = index + <span class="number">1</span>; i &lt; arr-&gt;size; i++) &#123;</span><br><span class="line">        arr-&gt;data[i - <span class="number">1</span>] = arr-&gt;data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    arr-&gt;data[arr-&gt;size - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 清理数据</span></span><br><span class="line">    arr-&gt;size--;</span><br><span class="line">    <span class="keyword">return</span> deletedVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数组首部元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">removeFirst</span><span class="params">(DynamicArray *arr)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> removeAt(arr, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 查 --- //</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定索引处的元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">(DynamicArray *arr, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    checkElementIndex(arr, index);</span><br><span class="line">    <span class="keyword">return</span> arr-&gt;data[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 改 --- //</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改指定索引处的元素，返回原值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">set</span><span class="params">(DynamicArray *arr, <span class="type">int</span> index, <span class="type">int</span> newVal)</span> &#123;</span><br><span class="line">    checkElementIndex(arr, index);</span><br><span class="line">    <span class="type">int</span> oldVal = arr-&gt;data[index];</span><br><span class="line">    arr-&gt;data[index] = newVal;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始容量设为 3</span></span><br><span class="line">    DynamicArray *arr = initDynamicArray(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 5 个元素：1 2 3 4 5</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        addLast(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时数组元素为：[1, 2, 3, 4, 5]</span></span><br><span class="line">    display(arr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除下标 3 的元素（即第四个元素 4）</span></span><br><span class="line">    <span class="type">int</span> deleted = removeAt(arr, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Removed value: %d\n&quot;</span>, deleted);</span><br><span class="line">    <span class="comment">// 数组更新为：[1, 2, 3, 5]</span></span><br><span class="line">    display(arr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在下标 1 的位置插入元素 9</span></span><br><span class="line">    add(arr, <span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="comment">// 数组更新为：[1, 9, 2, 3, 5]</span></span><br><span class="line">    display(arr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在数组首部插入元素 100</span></span><br><span class="line">    addFirst(arr, <span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 更新为：[100, 1, 9, 2, 3, 5]</span></span><br><span class="line">    display(arr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除数组尾部元素</span></span><br><span class="line">    <span class="type">int</span> lastVal = removeLast(arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Removed last value: %d\n&quot;</span>, lastVal);</span><br><span class="line">    <span class="comment">// 数组更新为：[100, 1, 9, 2, 3]</span></span><br><span class="line">    display(arr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查、改示例</span></span><br><span class="line">    <span class="type">int</span> val = get(arr, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Element at index 2: %d\n&quot;</span>, val);</span><br><span class="line">    <span class="built_in">set</span>(arr, <span class="number">2</span>, <span class="number">66</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After setting index 2 to 66:\n&quot;</span>);</span><br><span class="line">    display(arr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    freeDynamicArray(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码说明</strong></p>
<ol>
<li><strong>自动扩缩容</strong></li>
</ol>
<ul>
<li><p>在添加元素时，如果 ⁠<code>size == capacity</code>，调用 ⁠<code>resize</code> 扩容为原来的 2 倍。</p>
</li>
<li><p>删除元素后，如果 ⁠<code>size == capacity / 4（且容量不小于 1）</code>，进行缩容以节约内存。</p>
</li>
</ul>
<ol start="2">
<li><strong>索引越界检查</strong></li>
</ol>
<ul>
<li><p>使用 ⁠<code>checkElementIndex</code> 对已有元素的索引进行检查，确保查找、修改和删除操作在合法范围内。</p>
</li>
<li><p>使用 ⁠<code>checkPositionIndex</code> 检查插入操作时允许 ⁠<code>index == size</code> 的情况，从而支持在末尾插入新元素。</p>
</li>
</ul>
<ol start="3">
<li><strong>防止内存泄漏</strong></li>
</ol>
<ul>
<li>删除元素后，将对应位置的数据置为 <code>0</code>（如果存放的是指针类型，则应调用适当的释放函数），以防止出现悬挂引用的问题。</li>
</ul>
<ol start="4">
<li><strong>其他细节优化</strong></li>
</ol>
<ul>
<li>数据搬移在示例中采用 <code>for</code> 循环实现，这有助于理解底层算法本质；但在生产环境中，可以考虑使用更高效的内存复制函数。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文融合了静态数组与动态数组的相关内容，主要介绍了：</p>
<ul>
<li><p>静态数组的内存连续性和基本增删改查操作，其中在中间插入和删除元素需要搬移数据。</p>
</li>
<li><p>动态数组在静态数组之上封装了自动扩缩容、索引越界检查与内存清理等功能，使我们在实际开发中能够更灵活、更安全地操作数组。</p>
</li>
<li><p>通过 C 语言完整示例展示了动态数组的实现细节，从而帮助大家深入理解其背后的工作原理和设计思路。</p>
</li>
</ul>
<p>希望这篇博客能够帮助你全面理解数组的基本原理及动态数组的实现方法，并为你后续学习队列、栈、哈希表等更复杂的数据结构打下坚实基础！</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：两数相加</title>
    <url>/2025/02/18/20250218-%E7%AE%97%E6%B3%95%EF%BC%9A%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/../my_pictures/20250218/1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
<li>题目数据保证列表表示的数字不含前导零</li>
</ul>
<span id="more"></span>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">addTwoNumbers</span>(<span class="keyword">_</span> <span class="params">l1</span>: <span class="type">ListNode</span>?, <span class="keyword">_</span> <span class="params">l2</span>: <span class="type">ListNode</span>?) -&gt; <span class="type">ListNode</span>? &#123;</span><br><span class="line">  <span class="keyword">if</span> l1 <span class="operator">==</span> <span class="literal">nil</span> <span class="operator">||</span> l2 <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> l1 <span class="operator">??</span> l2</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> cur1 <span class="operator">=</span> l1</span><br><span class="line">  <span class="keyword">var</span> cur2 <span class="operator">=</span> l2</span><br><span class="line">  <span class="keyword">let</span> sum <span class="operator">=</span> cur1<span class="operator">!</span>.val <span class="operator">+</span> cur2<span class="operator">!</span>.val</span><br><span class="line">  <span class="keyword">var</span> carry <span class="operator">=</span> sum <span class="operator">/</span> <span class="number">10</span></span><br><span class="line">  <span class="keyword">let</span> head <span class="operator">=</span> <span class="type">ListNode</span>(sum <span class="operator">%</span> <span class="number">10</span>)</span><br><span class="line">  <span class="keyword">var</span> cur: <span class="type">ListNode</span>? <span class="operator">=</span> head</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> cur1<span class="operator">?</span>.next <span class="operator">!=</span> <span class="literal">nil</span> <span class="operator">||</span> cur2<span class="operator">?</span>.next <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value1 <span class="operator">=</span> cur1<span class="operator">?</span>.next<span class="operator">?</span>.val <span class="operator">??</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> value2 <span class="operator">=</span> cur2<span class="operator">?</span>.next<span class="operator">?</span>.val <span class="operator">??</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> sum <span class="operator">=</span> value1 <span class="operator">+</span> value2  <span class="operator">+</span> carry</span><br><span class="line">    carry <span class="operator">=</span> sum <span class="operator">/</span> <span class="number">10</span></span><br><span class="line">    cur<span class="operator">?</span>.next <span class="operator">=</span> <span class="type">ListNode</span>(sum <span class="operator">%</span> <span class="number">10</span>)</span><br><span class="line">    cur <span class="operator">=</span> cur<span class="operator">?</span>.next</span><br><span class="line">    cur1 <span class="operator">=</span> cur1<span class="operator">?</span>.next</span><br><span class="line">    cur2 <span class="operator">=</span> cur2<span class="operator">?</span>.next</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> carry <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">    cur<span class="operator">?</span>.next <span class="operator">=</span> <span class="type">ListNode</span>(carry)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>两数相加问题的主要思路是，将两个数字表示成逆序链表，每个节点存储一个数字位。步骤如下：</p>
<ol>
<li><p><strong>从头节点开始相加</strong>：由于链表是逆序存储，链表的头节点就是数字的个位，从最低位开始相加。</p>
</li>
<li><p><strong>计算和与进位</strong>：将对应的两个节点的值相加，同时加上上一次运算的进位，得到当前的和。</p>
</li>
</ol>
<ul>
<li><p>令当前位的值为 <code>sum</code> 模 10，即 <code>digit = sum % 10</code></p>
</li>
<li><p>更新进位为 <code>sum</code> 除以 10，即 <code>carry = sum / 10</code></p>
</li>
</ul>
<ol start="3">
<li><p><strong>构造结果链表</strong>：每计算出一位的值，就构造一个新的节点，将其接入结果链表中。</p>
</li>
<li><p><strong>遍历所有节点</strong>：同时遍历两个链表，直到两个链表的所有节点都被处理完毕。如果还有进位，则需要在链表末尾插入一个新节点来表示该进位。</p>
</li>
<li><p><strong>考虑特殊情况</strong>：如果输入链表为空或只存在其中一个链表的情况，也要正确处理。</p>
</li>
</ol>
<h2 id="代码实现详细讲解"><a href="#代码实现详细讲解" class="headerlink" title="代码实现详细讲解"></a>代码实现详细讲解</h2><p>下面详细解释代码中每一部分的功能和实现细节：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> l1 <span class="operator">==</span> <span class="literal">nil</span> <span class="operator">||</span> l2 <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> l1 <span class="operator">??</span> l2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输入判断："><a href="#输入判断：" class="headerlink" title="输入判断："></a>输入判断：</h3><p>如果任意一个链表为空，直接返回非空的那个链表。</p>
<p>其中，<code>⁠l1 ?? l2</code> 表示如果 ⁠<code>l1</code> 非空则返回 ⁠<code>l1</code>，否则返回 ⁠<code>l2</code>。</p>
<hr>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cur1 <span class="operator">=</span> l1</span><br><span class="line"><span class="keyword">var</span> cur2 <span class="operator">=</span> l2</span><br><span class="line"><span class="keyword">let</span> sum <span class="operator">=</span> cur1<span class="operator">!</span>.val <span class="operator">+</span> cur2<span class="operator">!</span>.val</span><br><span class="line"><span class="keyword">var</span> carry <span class="operator">=</span> sum <span class="operator">/</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> head <span class="operator">=</span> <span class="type">ListNode</span>(sum <span class="operator">%</span> <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> cur: <span class="type">ListNode</span>? <span class="operator">=</span> head</span><br></pre></td></tr></table></figure>

<h3 id="变量初始化："><a href="#变量初始化：" class="headerlink" title="变量初始化："></a>变量初始化：</h3><ul>
<li><p><code>cur1</code> 和 ⁠<code>cur2</code> 分别作为遍历 ⁠<code>l1</code> 和 ⁠<code>l2</code> 的指针。</p>
</li>
<li><p>首先对两个链表的头节点（个位）进行相加，计算总和 ⁠<code>sum = cur1!.val + cur2!.val</code>。</p>
</li>
<li><p>根据 ⁠<code>sum</code> 计算进位 ⁠<code>carry = sum / 10</code>。</p>
</li>
<li><p>新建结果链表的头节点，节点的值为 ⁠<code>sum % 10</code>（当前位的结果）。</p>
</li>
<li><p>定义一个 ⁠<code>cur</code> 指针指向当前处理的结果链表尾部，方便后续的节点追加。</p>
</li>
</ul>
<hr>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> cur1<span class="operator">?</span>.next <span class="operator">!=</span> <span class="literal">nil</span> <span class="operator">||</span> cur2<span class="operator">?</span>.next <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> value1 <span class="operator">=</span> cur1<span class="operator">?</span>.next<span class="operator">?</span>.val <span class="operator">??</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> value2 <span class="operator">=</span> cur2<span class="operator">?</span>.next<span class="operator">?</span>.val <span class="operator">??</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> sum <span class="operator">=</span> value1 <span class="operator">+</span> value2  <span class="operator">+</span> carry</span><br><span class="line">  carry <span class="operator">=</span> sum <span class="operator">/</span> <span class="number">10</span></span><br><span class="line">  cur<span class="operator">?</span>.next <span class="operator">=</span> <span class="type">ListNode</span>(sum <span class="operator">%</span> <span class="number">10</span>)</span><br><span class="line">  cur <span class="operator">=</span> cur<span class="operator">?</span>.next</span><br><span class="line">  cur1 <span class="operator">=</span> cur1<span class="operator">?</span>.next</span><br><span class="line">  cur2 <span class="operator">=</span> cur2<span class="operator">?</span>.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历剩余节点："><a href="#遍历剩余节点：" class="headerlink" title="遍历剩余节点："></a>遍历剩余节点：</h3><p>使用 ⁠<code>while</code> 循环处理两个链表中剩余的节点，条件是任意一个链表还有后续节点。</p>
<ul>
<li><p>通过 ⁠<code>cur1?.next?.val ?? 0</code> 获取 ⁠<code>cur1</code> 的下一个节点的值，如果不存在则赋值为 0。</p>
</li>
<li><p>同理，<code>⁠value2 = cur2?.next?.val ?? 0</code> 获取 ⁠<code>cur2</code> 的下一个节点的值。</p>
</li>
<li><p>将当前位上的两个数字及前一次的进位相加，得到新的 ⁠<code>sum</code>。</p>
</li>
<li><p>更新进位 ⁠<code>carry = sum / 10</code>。</p>
</li>
<li><p>新建一个节点保存当前位的值 ⁠<code>sum % 10</code> 并接到结果链表后面。</p>
</li>
<li><p>移动指针 ⁠<code>cur1</code> 和 ⁠<code>cur2</code> 指向下一个节点，继续下一轮相加；同时更新 ⁠<code>cur</code> 指针指向新加入的节点。</p>
</li>
</ul>
<hr>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> carry <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">  cur<span class="operator">?</span>.next <span class="operator">=</span> <span class="type">ListNode</span>(carry)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理最后的进位："><a href="#处理最后的进位：" class="headerlink" title="处理最后的进位："></a>处理最后的进位：</h3><p>循环结束后，可能最后一次运算后仍有进位（例如相加得到的和大于等于 10）。</p>
<p>如果 ⁠<code>carry</code> 大于 0，则新建一个节点保存进位，并将其接入链表末尾。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：两数之和</title>
    <url>/2025/02/16/20250216-%E7%AE%97%E6%B3%95%EF%BC%9A%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 104</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
<li><strong>只会存在一个有效答案</strong></li>
</ul>
<p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p>
<span id="more"></span>

<h2 id="方法一：暴力遍历"><a href="#方法一：暴力遍历" class="headerlink" title="方法一：暴力遍历"></a>方法一：暴力遍历</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">twoSum</span>(<span class="keyword">_</span> <span class="params">nums</span>: [<span class="type">Int</span>], <span class="keyword">_</span> <span class="params">target</span>: <span class="type">Int</span>) -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">  <span class="keyword">for</span> (i, num) <span class="keyword">in</span> nums.enumerated() &#123;</span><br><span class="line">    <span class="keyword">let</span> complement <span class="operator">=</span> target <span class="operator">-</span> num</span><br><span class="line">    <span class="keyword">for</span> (j, otherNum) <span class="keyword">in</span> nums.enumerated() <span class="keyword">where</span> i <span class="operator">!=</span> j &#123;</span><br><span class="line">      <span class="keyword">if</span> otherNum <span class="operator">==</span> complement &#123;</span><br><span class="line">        <span class="keyword">return</span> [i, j]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面逐行解释这段代码的思路：</p>
<ol>
<li><p><strong>外层循环（枚举所有数字及其索引）</strong>  </p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i, num) <span class="keyword">in</span> nums.enumerated() &#123;</span><br></pre></td></tr></table></figure>
<p>这一层循环遍历数组 <code>nums</code> 中的每个元素，并记录下当前元素 <code>num</code> 以及对应的索引 <code>i</code>。</p>
</li>
<li><p><strong>计算补数</strong>  </p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> complement <span class="operator">=</span> target <span class="operator">-</span> num</span><br></pre></td></tr></table></figure>
<p>对于当前元素 <code>num</code>，通过 <code>target - num</code> 计算得到另一个数（称为补数，即 complement），其作用是希望能与 <code>num</code> 组合起来使其和为 <code>target</code>。</p>
</li>
<li><p><strong>内层循环（再次遍历数组查找补数）</strong>  </p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (j, otherNum) <span class="keyword">in</span> nums.enumerated() <span class="keyword">where</span> i <span class="operator">!=</span> j &#123;</span><br></pre></td></tr></table></figure>
<p>这一层循环再次遍历整个数组，寻找满足条件的另一个数字 <code>otherNum</code>。注意，这里使用了 <code>where i != j</code> 条件，确保不会使用同一个元素两次。</p>
</li>
<li><p><strong>检查是否找到匹配的补数</strong>  </p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> otherNum <span class="operator">==</span> complement &#123;</span><br><span class="line">    <span class="keyword">return</span> [i, j]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在内层循环中发现 <code>otherNum</code> 等于之前计算的 <code>complement</code>，则说明找到了两个数，它们的和等于 <code>target</code>。此时，函数会立即返回一个包含这两个索引 <code>[i, j]</code> 的数组。</p>
</li>
<li><p><strong>没有找到匹配时返回空数组</strong>  </p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<p>如果完成所有循环后都没有找到符合条件的一对数字，则返回一个空数组，表示不存在满足条件的两个数。</p>
</li>
</ol>
<h3 id="算法思路总结"><a href="#算法思路总结" class="headerlink" title="算法思路总结"></a>算法思路总结</h3><ul>
<li><strong>暴力解法</strong>：代码使用了暴力法，两层枚举，每次将数组中任意两个不同的元素配对，判断其和是否等于目标值 <code>target</code>。</li>
<li><strong>时间复杂度</strong>：由于使用了嵌套循环，最坏情况下需要检查所有可能的两个数字组合，时间复杂度为 O(n²)。（其中 n 为数组长度）</li>
<li><strong>空间复杂度</strong>：只使用了常数级别的额外空间，因此空间复杂度为 O(1)。</li>
</ul>
<h2 id="方法二：借助字典高效遍历"><a href="#方法二：借助字典高效遍历" class="headerlink" title="方法二：借助字典高效遍历"></a>方法二：借助字典高效遍历</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">twoSum</span>(<span class="keyword">_</span> <span class="params">nums</span>: [<span class="type">Int</span>], <span class="keyword">_</span> <span class="params">target</span>: <span class="type">Int</span>) -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">  <span class="keyword">var</span> dict <span class="operator">=</span> [<span class="type">Int</span>: <span class="type">Int</span>]()</span><br><span class="line">  <span class="keyword">for</span> (index, value) <span class="keyword">in</span> nums.enumerated() &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> otherIndex <span class="operator">=</span> dict[target <span class="operator">-</span> value] &#123;</span><br><span class="line">      <span class="keyword">return</span> [otherIndex, index]</span><br><span class="line">    &#125;</span><br><span class="line">    dict[value] <span class="operator">=</span> index</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个算法是一种解决“两数之和”问题的高效方法，主要利用了哈希表（字典）的查找特性来实现，在一次遍历数组的过程中就能找到答案。</p>
<p>下面详细解释各个步骤：</p>
<ol>
<li><p><strong>初始化哈希表</strong><br>定义一个字典 <code>dict</code>，键是数组中的数值，值是相应的索引：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dict <span class="operator">=</span> [<span class="type">Int</span>: <span class="type">Int</span>]()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>遍历数组并查找匹配</strong><br>使用 <code>enumerated()</code> 方法遍历数组，使得在每一步可以同时获得元素的索引和值：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (index, value) <span class="keyword">in</span> nums.enumerated() &#123;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于当前值 <code>value</code>，计算其所需的匹配数，即 <code>target - value</code>。</li>
<li>在字典中查找这个匹配数：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> otherIndex <span class="operator">=</span> dict[target <span class="operator">-</span> value] &#123;</span><br><span class="line">    <span class="keyword">return</span> [otherIndex, index]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果找到了匹配的索引 <code>otherIndex</code>，说明已经遍历过的某个数 <code>nums[otherIndex]</code> 和当前数 <code>value</code> 之和正好等于目标值 <code>target</code>，于是返回这两个索引。</li>
</ul>
</li>
<li><p><strong>更新字典</strong><br>如果没有找到匹配值，则将当前值以及对应的索引添加到字典中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">dict[value] <span class="operator">=</span> index</span><br></pre></td></tr></table></figure>
<p>这样，当后续的数字需要一个与之配对的数字时，就可以在字典中快速查找。</p>
</li>
<li><p><strong>返回结果</strong><br>如果遍历完整个数组都没有找到满足条件的两个数，则返回空数组：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> []</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="算法思路总结-1"><a href="#算法思路总结-1" class="headerlink" title="算法思路总结"></a>算法思路总结</h3><ul>
<li>利用哈希表（字典）实现：在一次遍历数组的过程中，利用字典来记录已经遍历过的数字及其索引。</li>
<li>查找补数：对于当前数字，计算补数（即 target 减去当前数字），然后检查字典中是否存在这个补数。若存在，则说明找到了满足条件的两个数字。</li>
<li>时间复杂度：只需一次遍历，每次查找与插入操作均为 O(1)，整体时间复杂度为 O(n)。（其中 n 为数组长度）</li>
<li>空间复杂度：需要额外使用一个字典存储数字及其索引，因此空间复杂度为 O(n)。（最坏情况字典大小与数组长度相同）</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：无重复字符的最长子串</title>
    <url>/2025/02/20/20250220-%E7%AE%97%E6%B3%95%EF%BC%9A%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 5 * 104</code></li>
<li><code>s</code> 由英文字母、数字、符号和空格组成</li>
</ul>
<span id="more"></span>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="keyword">_</span> <span class="params">s</span>: <span class="type">String</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> maxLength <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> left <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> dict <span class="operator">=</span> [<span class="type">Character</span>: <span class="type">Int</span>]()</span><br><span class="line">  <span class="keyword">for</span> (i, char) <span class="keyword">in</span> s.enumerated() &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> index <span class="operator">=</span> dict[char] &#123;</span><br><span class="line">      left <span class="operator">=</span> <span class="built_in">max</span>(left, index <span class="operator">+</span> <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    dict [char] <span class="operator">=</span> i</span><br><span class="line">    maxLength <span class="operator">=</span> <span class="built_in">max</span>(maxLength, i <span class="operator">-</span> left <span class="operator">+</span> <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> maxLength</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li><strong>滑动窗口的思想</strong></li>
</ol>
<p>我们使用滑动窗口方法维护一个当前不含重复字符的子串。通过两个指针（这里用变量 <code>left</code> 表示窗口左边界，<code>i</code> 表示当前字符的索引），不断更新窗口的范围。</p>
<ol start="2">
<li><strong>使用哈希字典记录字符位置</strong></li>
</ol>
<p>定义一个字典 <code>dict</code> 用来存储每个字符最后一次出现的位置。这样，当遇到重复字符时，就可以根据该字符上一次出现的位置，决定如何移动窗口左边界。</p>
<ol start="3">
<li><strong>更新窗口边界</strong></li>
</ol>
<p>对于每个遍历到的字符 <code>char</code>：</p>
<ul>
<li><p>如果该字符已经存在于字典中，则说明窗口内出现了重复字符。此时更新 <code>left</code> 为 <code>index + 1</code> 和当前 <code>left</code> 的较大值，确保窗口内不包含重复字符。</p>
</li>
<li><p>然后更新 <code>dict[char]</code> 为当前的索引 <code>i</code>。</p>
</li>
</ul>
<ol start="4">
<li><strong>计算最长子串长度</strong></li>
</ol>
<p>每次移动窗口后，通过 <code>i - left + 1</code> 计算当前窗口的长度，并与当前记录的最大长度进行比较，更新最大值。</p>
<ol start="5">
<li><strong>时间复杂度与空间复杂度</strong></li>
</ol>
<p>由于我们只需遍历一次字符串，并在遍历过程中通过哈希表进行常数时间的查找操作，因此算法的时间复杂度为 <code>O(n)</code>，空间复杂度为 <code>O(n)</code>（最坏情况下哈希表中存储所有不同的字符）。</p>
<p>这种方法巧妙地利用滑动窗口和哈希表，能够在一次遍历中完成题目的要求，既保证了算法的效率，又使得代码逻辑清晰易懂。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：回文数</title>
    <url>/2025/02/24/20250224-%E7%AE%97%E6%B3%95%EF%BC%9A%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数 <code>x</code> ，如果 <code>x</code> 是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<ul>
<li>例如，<code>121</code> 是回文，而 <code>123</code> 不是。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 121</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = -121</span><br><span class="line">输出：false</span><br><span class="line">解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 10</span><br><span class="line">输出：false</span><br><span class="line">解释：从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>-231 &lt;= x &lt;= 231 - 1</code></li>
</ul>
<p><strong>进阶：</strong>你能不将整数转为字符串来解决这个问题吗？</p>
<span id="more"></span>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">isPalindrome</span>(<span class="keyword">_</span> <span class="params">x</span>: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> x <span class="operator">&lt;</span> <span class="number">0</span> <span class="operator">||</span> (x <span class="operator">!=</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> x <span class="operator">%</span> <span class="number">10</span> <span class="operator">==</span> <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> p <span class="operator">=</span> x</span><br><span class="line">  <span class="keyword">var</span> n <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> p <span class="operator">&gt;</span> n &#123;</span><br><span class="line">    n <span class="operator">=</span> n <span class="operator">*</span> <span class="number">10</span> <span class="operator">+</span> p <span class="operator">%</span> <span class="number">10</span></span><br><span class="line">    p <span class="operator">/=</span> <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> n <span class="operator">==</span> p <span class="operator">||</span> n <span class="operator">/</span> <span class="number">10</span> <span class="operator">==</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来详细分析一下这个算法的每个步骤：</p>
<p><strong>1. 排除负数和尾部为零的情况</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x <span class="operator">&lt;</span> <span class="number">0</span> <span class="operator">||</span> (x <span class="operator">!=</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> x <span class="operator">%</span> <span class="number">10</span> <span class="operator">==</span> <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>负数不能是回文数，因为负号只会出现在数字的前面，不可能出现在数字的后面。</p>
</li>
<li><p>如果数字以 <code>0</code> 结尾，且数字不为 <code>0</code> 本身，那么它也不能是回文数。例如，<code>10</code> 和 <code>100</code> 等数字就不能是回文数，因为它们反过来就不会是有效的数字。</p>
</li>
</ul>
<p>因此，首先排除负数和尾部为零的非零数字。</p>
<p><strong>2. 初始化变量</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p <span class="operator">=</span> x</span><br><span class="line"><span class="keyword">var</span> n <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>p</code> 是我们用来操作输入数字的变量，初始值为 <code>x</code>。</p>
</li>
<li><p><code>n</code> 是我们用来构建数字反转部分的变量，初始值为 <code>0</code>。</p>
</li>
</ul>
<p><strong>3. 反转数字的后半部分</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> p <span class="operator">&gt;</span> n &#123;</span><br><span class="line">  n <span class="operator">=</span> n <span class="operator">*</span> <span class="number">10</span> <span class="operator">+</span> p <span class="operator">%</span> <span class="number">10</span></span><br><span class="line">  p <span class="operator">/=</span> <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这里使用 <code>while p &gt; n</code> 作为条件，表示我们会反转数字的后半部分直到它大于或等于数字的前半部分。这个操作的目的是让 <code>n</code> 变成数字 <code>x</code> 的后半部分的反转，而 <code>p</code> 逐渐变成前半部分。</p>
</li>
<li><p>在每次迭代中：</p>
<ul>
<li><p><code>n = n * 10 + p % 10</code>：把 <code>p</code> 的最后一位数字加到 <code>n</code> 的末尾，构建反转后的数字 <code>n</code>。</p>
</li>
<li><p><code>p /= 10</code>：将 <code>p</code> 向右移一位，即去掉 <code>p</code> 的最后一位。</p>
</li>
</ul>
</li>
</ul>
<p>通过这个过程，<code>n</code> 将逐渐成为 <code>x</code> 的后半部分的反转，<code>p</code> 将逐渐成为 <code>x</code> 的前半部分。</p>
<p><strong>4. 判断回文条件</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> n <span class="operator">==</span> p <span class="operator">||</span> n <span class="operator">/</span> <span class="number">10</span> <span class="operator">==</span> p</span><br></pre></td></tr></table></figure>

<ul>
<li><p>一旦 <code>p</code> 小于或等于 <code>n</code>，表示我们已经处理完了数字的一半。此时有两个情况：</p>
<ul>
<li><p>如果 <code>n == p</code>，表示前半部分和后半部分完全相等，数字是回文数。</p>
</li>
<li><p>如果 <code>n / 10 == p</code>，表示 <code>n</code> 有一个额外的数字（例如奇数位的中间数字），通过去掉这个多余的数字（即 <code>n / 10</code>），我们得到的值与 <code>p</code> 相等，数字仍然是回文数。</p>
</li>
</ul>
</li>
</ul>
<p>举个例子：</p>
<ul>
<li><p>对于 <code>121</code>：</p>
<ul>
<li><p>首先 <code>n</code> 会变成 <code>12</code>，<code>p</code> 变成 <code>1</code>，然后退出循环。</p>
</li>
<li><p>此时 <code>n / 10</code> 等于 <code>1</code>，<code>p</code> 也是 <code>1</code>，所以返回 <code>true</code>。</p>
</li>
</ul>
</li>
<li><p>对于 <code>123</code>：</p>
<ul>
<li><p>首先 <code>n</code> 会变成 <code>32</code>，<code>p</code> 变成 <code>1</code>，然后退出循环。</p>
</li>
<li><p><code>n / 10</code> 等于 <code>3</code>，<code>p</code> 是 <code>1</code>，结果是 <code>false</code>。</p>
</li>
</ul>
</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li><p>这个算法通过反转数字的后半部分来判断数字是否为回文。我们只需要将数字的一半反转，然后比较两部分是否相等。</p>
</li>
<li><p>时间复杂度：<code>O(log₁₀(x))</code>，因为我们每次都在处理 <code>x</code> 的一位数字，直到处理到一半。</p>
</li>
<li><p>空间复杂度：<code>O(1)</code>，只用了常量空间。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNative 新架构中 iOS 通过 JSI 调用 RN 函数</title>
    <url>/2025/04/03/20250403-iOS%E9%80%9A%E8%BF%87JSI%E8%B0%83%E7%94%A8RN%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="React-Native-新架构简介"><a href="#React-Native-新架构简介" class="headerlink" title="React Native 新架构简介"></a>React Native 新架构简介</h2><p>React Native 的新架构是为了解决旧架构中存在的性能瓶颈和开发体验问题而推出的重大升级。新架构主要包含以下几个核心组件：</p>
<ol>
<li><strong>JSI (JavaScript Interface)</strong>: 取代了旧架构中的 JSC (JavaScriptCore)，提供了 JS 和原生代码之间的直接通信能力。</li>
<li><strong>Fabric</strong>: 新的渲染系统，通过 C++ 桥接层实现了更高效的 UI 渲染。</li>
<li><strong>TurboModules</strong>: 新的原生模块系统，允许更高效地调用原生 API。</li>
<li><strong>CodeGen</strong>: 自动代码生成工具，减少了手动编写样板代码的工作量。</li>
<li><strong>Hermes</strong>: Facebook 开发的专为移动应用优化的 JavaScript 引擎。</li>
</ol>
<p>相比于旧架构，新架构最大的优势在于消除了异步桥接带来的性能损耗，允许 JavaScript 和原生代码直接通信，大幅提升了应用性能和开发体验。</p>
<span id="more"></span>

<h2 id="JSI-是什么？"><a href="#JSI-是什么？" class="headerlink" title="JSI 是什么？"></a>JSI 是什么？</h2><p>JSI (JavaScript Interface) 是 React Native 新架构中的核心组件之一，它是一个轻量级的 C++ API 层，提供了 JavaScript 和原生代码之间的直接通信能力。</p>
<p>与旧架构中的 Bridge 不同，JSI 允许：</p>
<ol>
<li><strong>同步调用</strong>: JavaScript 可以同步调用原生方法，无需通过异步消息队列。</li>
<li><strong>引用共享</strong>: JavaScript 可以持有原生对象的引用，反之亦然。</li>
<li><strong>引擎无关</strong>: JSI 设计为 JS 引擎无关的接口，可以兼容不同的 JS 引擎（如 JSC、Hermes 等）。</li>
<li><strong>双向通信</strong>: 不仅 JS 可以调用原生代码，原生代码也可以直接调用 JS 函数。</li>
</ol>
<p>这种设计解决了旧架构中的大量性能问题，特别是由于异步通信导致的延迟和序列化&#x2F;反序列化开销。</p>
<h2 id="RCTBridge-在新架构中的角色"><a href="#RCTBridge-在新架构中的角色" class="headerlink" title="RCTBridge 在新架构中的角色"></a>RCTBridge 在新架构中的角色</h2><p>在 React Native 的新架构中，<code>RCTBridge</code> 仍然存在，但其角色发生了变化。它主要承担以下职责：</p>
<ol>
<li><strong>兼容性层</strong>: 为了保证旧代码能在新架构中正常运行，<code>RCTBridge</code> 提供了向后兼容的接口。</li>
<li><strong>生命周期管理</strong>: 管理 JS 运行时的生命周期，包括初始化、加载 JS bundle 和销毁。</li>
<li><strong>提供 JSI 访问</strong>: 通过 <code>RCTCxxBridge</code> 暴露 JSI 运行时，允许原生代码访问 JS 运行时。</li>
<li><strong>线程管理</strong>: 维护专用的 JavaScript 线程，确保 JSI 操作的线程安全性。React Native 的架构中有明确的线程划分，包括 JavaScript 线程、主线程（UI 线程）和 Shadow 线程，<code>RCTBridge</code> 通过 <code>dispatchBlock:queue:</code> 等方法在适当的线程上执行代码。</li>
</ol>
<p>在新架构中，直接通信大多通过 JSI 实现，而 <code>RCTBridge</code> 则更多地充当一个容器和生命周期管理者的角色。特别是它的 <code>RCTCxxBridge</code> 子类，提供了从原生代码到 JSI 运行时的重要桥梁。</p>
<h2 id="iOS-通过-JSI-调用-RN-函数的实现"><a href="#iOS-通过-JSI-调用-RN-函数的实现" class="headerlink" title="iOS 通过 JSI 调用 RN 函数的实现"></a>iOS 通过 JSI 调用 RN 函数的实现</h2><p>接下来，我们将详细介绍如何在 iOS 端通过 JSI 调用 React Native 中定义的 JavaScript 函数。</p>
<h3 id="1-配置-AppDelegate"><a href="#1-配置-AppDelegate" class="headerlink" title="1. 配置 AppDelegate"></a>1. 配置 AppDelegate</h3><p>首先，我们需要在 AppDelegate 中进行必要的配置，包括创建 RCTBridge 实例和注册通知：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AppDelegate.swift</span></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> React</span><br><span class="line"><span class="keyword">import</span> CocoaLumberjack</span><br><span class="line"></span><br><span class="line"><span class="keyword">@main</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AppDelegate</span>: <span class="title class_ inherited__">UIResponder</span>, <span class="title class_ inherited__">UIApplicationDelegate</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> window: <span class="type">UIWindow</span>?</span><br><span class="line">  <span class="keyword">var</span> bridge: <span class="type">RCTBridge</span>?</span><br><span class="line"></span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">application</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>, <span class="params">didFinishLaunchingWithOptions</span> <span class="params">launchOptions</span>: [<span class="type">UIApplication</span>.<span class="params">LaunchOptionsKey</span>: <span class="keyword">Any</span>]<span class="operator">?</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="comment">// 创建 RCTBridge 实例</span></span><br><span class="line">    bridge <span class="operator">=</span> <span class="type">RCTBridge</span>(delegate: <span class="keyword">self</span>, launchOptions: launchOptions)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册 JavaScript 加载完成的通知</span></span><br><span class="line">    <span class="type">NotificationCenter</span>.default.addObserver(<span class="keyword">self</span>,</span><br><span class="line">                                         selector: <span class="keyword">#selector</span>(onJSDidLoad),</span><br><span class="line">                                         name: <span class="type">NSNotification</span>.<span class="type">Name</span>(<span class="string">&quot;RCTJavaScriptDidLoadNotification&quot;</span>),</span><br><span class="line">                                         object: <span class="literal">nil</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他配置...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 其他 AppDelegate 方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 RCTBridgeDelegate 协议</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">AppDelegate</span>: <span class="title class_ inherited__">RCTBridgeDelegate</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">sourceURL</span>(<span class="params">for</span> <span class="params">bridge</span>: <span class="type">RCTBridge</span>) -&gt; <span class="type">URL</span>? &#123;</span><br><span class="line">    <span class="keyword">#if</span> <span class="type">DEBUG</span></span><br><span class="line">      <span class="comment">// 开发环境使用本地开发服务器</span></span><br><span class="line">      <span class="keyword">let</span> jsCodeLocation <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;http://localhost:8081/index.bundle?platform=ios&quot;</span>)</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;React Native 开发服务器 URL: <span class="subst">\(jsCodeLocation<span class="operator">?</span>.absoluteString <span class="operator">??</span> <span class="string">&quot;无效URL&quot;</span>)</span>&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> jsCodeLocation</span><br><span class="line">    <span class="keyword">#else</span></span><br><span class="line">      <span class="comment">// 生产环境使用打包后的 JS bundle</span></span><br><span class="line">      <span class="keyword">guard</span> <span class="keyword">let</span> bundleURL <span class="operator">=</span> <span class="type">Bundle</span>.main.url(forResource: <span class="string">&quot;main&quot;</span>, withExtension: <span class="string">&quot;jsbundle&quot;</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;错误: 无法找到 main.jsbundle 文件&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> bundleURL</span><br><span class="line">    <span class="keyword">#endif</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JavaScript 加载完成的通知处理</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="keyword">extension</span> <span class="title class_">AppDelegate</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">onJSDidLoad</span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;JS 加载完成&quot;</span>)</span><br><span class="line">    <span class="comment">// 此处可以添加 JS 环境准备就绪后的逻辑</span></span><br><span class="line">    <span class="comment">// 例如：检查全局函数是否可用</span></span><br><span class="line">    <span class="keyword">let</span> hasSayHello <span class="operator">=</span> <span class="type">JSIBridge</span>.hasJavaScriptFunction(<span class="string">&quot;sayHello&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sayHello 函数是否存在: <span class="subst">\(hasSayHello)</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段配置代码包含以下关键部分：</p>
<ol>
<li><strong>创建 RCTBridge 实例</strong>：在应用启动时创建 RCTBridge，这是连接原生代码和 JavaScript 的桥梁。</li>
<li><strong>注册通知</strong>：注册 <code>RCTJavaScriptDidLoadNotification</code> 通知，以便在 JavaScript 加载完成后执行相应的操作。</li>
<li><strong>实现 RCTBridgeDelegate</strong>：提供 JavaScript bundle 的加载路径，区分开发环境和生产环境。</li>
<li><strong>JavaScript 加载完成的处理</strong>：在 <code>onJSDidLoad</code> 方法中处理 JavaScript 环境准备就绪后的逻辑。</li>
</ol>
<p>这些配置是使用 JSI 调用 JavaScript 函数的前提，确保了 JavaScript 环境的正确初始化和加载。</p>
<h3 id="2-创建-JSIBridge-类"><a href="#2-创建-JSIBridge-类" class="headerlink" title="2. 创建 JSIBridge 类"></a>2. 创建 JSIBridge 类</h3><p>首先，我们需要创建一个桥接类，用于封装 JSI 调用的具体实现。这里我们创建了 <code>JSIBridge</code> 类：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JSIBridge.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">JSIBridge</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 JavaScript 全局函数是否存在</span></span><br><span class="line">+ (<span class="type">BOOL</span>)hasJavaScriptFunction:(<span class="built_in">NSString</span> *)functionName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 JavaScript 全局函数</span></span><br><span class="line">+ (<span class="built_in">NSString</span> *)callJavaScriptFunction:(<span class="built_in">NSString</span> *)functionName</span><br><span class="line">                        withArgument:(<span class="built_in">NSString</span> *)argument;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>这个类提供了两个主要方法：</p>
<ul>
<li><code>hasJavaScriptFunction</code>: 检查指定名称的 JavaScript 全局函数是否存在</li>
<li><code>callJavaScriptFunction:withArgument</code>: 调用指定名称的 JavaScript 全局函数，并传递一个字符串参数</li>
</ul>
<h3 id="3-实现-JSIBridge-类"><a href="#3-实现-JSIBridge-类" class="headerlink" title="3. 实现 JSIBridge 类"></a>3. 实现 JSIBridge 类</h3><p>接下来，我们在 JSIBridge.mm 文件中实现这些方法。由于需要直接访问 JSI 接口，我们使用 Objective-C++ 编写：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JSIBridge.mm</span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;JSIBridge.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jsi/jsi.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;React/RCTBridge+Private.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;React/RCTBridge.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace facebook::jsi;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">JSIBridge</span></span></span><br><span class="line"></span><br><span class="line">+ (RCTBridge *)getBridge &#123;</span><br><span class="line">  <span class="keyword">return</span> [RCTBridge currentBridge];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">BOOL</span>)hasJavaScriptFunction:(<span class="built_in">NSString</span> *)functionName &#123;</span><br><span class="line">  RCTBridge *bridge = [<span class="keyword">self</span> getBridge];</span><br><span class="line">  __block <span class="type">BOOL</span> hasFunction = <span class="literal">NO</span>;</span><br><span class="line">  dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  [bridge dispatchBlock:^&#123;</span><br><span class="line">    RCTCxxBridge* cxxbridge = (RCTCxxBridge*)bridge;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cxxbridge.runtime) &#123;</span><br><span class="line">      Runtime&amp; runtime = *(Runtime*)cxxbridge.runtime;</span><br><span class="line">      <span class="keyword">const</span> <span class="type">char</span> *name = functionName.UTF8String;</span><br><span class="line">      </span><br><span class="line">      try &#123;</span><br><span class="line">        Function function = runtime.global().getPropertyAsFunction(runtime, name);</span><br><span class="line">        hasFunction = function.isFunction(runtime);</span><br><span class="line">      &#125; catch (JSError&amp; error) &#123;</span><br><span class="line">        hasFunction = <span class="literal">NO</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">  &#125; queue:RCTJSThread];</span><br><span class="line">  </span><br><span class="line">  dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> hasFunction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSString</span> *)callJavaScriptFunction:(<span class="built_in">NSString</span> *)functionName</span><br><span class="line">                        withArgument:(<span class="built_in">NSString</span> *)argument &#123;</span><br><span class="line">  RCTBridge *bridge = [<span class="keyword">self</span> getBridge];</span><br><span class="line">  __block <span class="built_in">NSString</span> *result = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">  dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  [bridge dispatchBlock:^&#123;</span><br><span class="line">    RCTCxxBridge* cxxbridge = (RCTCxxBridge*)bridge;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cxxbridge.runtime) &#123;</span><br><span class="line">      <span class="comment">// 所有 JSI 代码都在 JS 线程上执行，避免线程重入问题</span></span><br><span class="line">      Runtime&amp; runtime = *(Runtime*)cxxbridge.runtime;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 获取全局函数</span></span><br><span class="line">      Function function = runtime.global().getPropertyAsFunction(runtime, functionName.UTF8String);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 调用函数并传递参数</span></span><br><span class="line">      Value param = Value(runtime, String::createFromUtf8(runtime, argument.UTF8String));</span><br><span class="line">      Value jsResult = function.call(runtime, std::move(param), <span class="number">1</span>);</span><br><span class="line">      </span><br><span class="line">      string str = jsResult.asString(runtime).utf8(runtime);</span><br><span class="line">      result = [<span class="built_in">NSString</span> stringWithUTF8String:str.c_str()];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">  &#125; queue:RCTJSThread];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 等待JavaScript线程执行完毕</span></span><br><span class="line">  dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>这段代码的核心逻辑包括：</p>
<ol>
<li>获取当前 RCTBridge 实例</li>
<li>从 RCTBridge 中获取 RCTCxxBridge，它提供了对 JSI 运行时的访问</li>
<li>通过 JSI API 获取全局函数对象并调用它</li>
<li>使用信号量确保 JS 线程执行完毕后再返回结果（同步调用）</li>
</ol>
<h3 id="4-在-JavaScript-中定义函数"><a href="#4-在-JavaScript-中定义函数" class="headerlink" title="4. 在 JavaScript 中定义函数"></a>4. 在 JavaScript 中定义函数</h3><p>在 React Native 的 JavaScript 代码中，我们需要定义全局函数，使其可以被原生代码调用。以下是一个简单的示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 index.js 或其他入口文件中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将函数挂载到全局对象上</span></span><br><span class="line"><span class="variable language_">global</span>.<span class="property">sayHello</span> = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>! From React Native.`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">global</span>.<span class="property">getAppVersion</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;1.0.0&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更复杂的例子：调用 Redux 状态获取数据</span></span><br><span class="line"><span class="variable language_">global</span>.<span class="property">getUserInfo</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> store = <span class="built_in">require</span>(<span class="string">&#x27;./store&#x27;</span>).<span class="property">default</span>;</span><br><span class="line">  <span class="keyword">const</span> state = store.<span class="title function_">getState</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(state.<span class="property">user</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-在原生代码中调用-JavaScript-函数"><a href="#5-在原生代码中调用-JavaScript-函数" class="headerlink" title="5. 在原生代码中调用 JavaScript 函数"></a>5. 在原生代码中调用 JavaScript 函数</h3><p>现在，我们可以在任何原生代码中使用 JSIBridge 调用 JavaScript 函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 ViewController 或其他 Swift 文件中</span></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyViewController</span>: <span class="title class_ inherited__">UIViewController</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidLoad</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查函数是否存在</span></span><br><span class="line">    <span class="keyword">let</span> hasSayHello <span class="operator">=</span> <span class="type">JSIBridge</span>.hasJavaScriptFunction(<span class="string">&quot;sayHello&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sayHello 函数存在: <span class="subst">\(hasSayHello)</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> hasSayHello &#123;</span><br><span class="line">      <span class="comment">// 调用函数并获取结果</span></span><br><span class="line">      <span class="keyword">let</span> result <span class="operator">=</span> <span class="type">JSIBridge</span>.callJavaScriptFunction(<span class="string">&quot;sayHello&quot;</span>, withArgument: <span class="string">&quot;iOS&quot;</span>)</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;调用结果: <span class="subst">\(result)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用获取版本的函数</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">JSIBridge</span>.hasJavaScriptFunction(<span class="string">&quot;getAppVersion&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> version <span class="operator">=</span> <span class="type">JSIBridge</span>.callJavaScriptFunction(<span class="string">&quot;getAppVersion&quot;</span>, withArgument: <span class="string">&quot;&quot;</span>)</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;应用版本: <span class="subst">\(version)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RCTBridge-在新架构中的实际应用"><a href="#RCTBridge-在新架构中的实际应用" class="headerlink" title="RCTBridge 在新架构中的实际应用"></a>RCTBridge 在新架构中的实际应用</h2><p>在上面的代码中，我们可以看到 RCTBridge 在新架构中的几个关键应用：</p>
<ol>
<li><strong>提供 JavaScript 运行时访问</strong>：通过 <code>RCTCxxBridge</code> 的 <code>runtime</code> 属性，我们可以获取 JSI 运行时，进而调用 JavaScript 函数。</li>
<li><strong>管理 JavaScript 线程</strong>：使用 <code>dispatchBlock:queue:</code> 方法在 JavaScript 线程上执行代码，确保线程安全。</li>
<li><strong>生命周期通知</strong>：通过 <code>RCTJavaScriptDidLoadNotification</code> 通知，我们可以知道 JavaScript 环境何时准备就绪。</li>
<li><strong>提供 bundle 加载机制</strong>：通过 <code>RCTBridgeDelegate</code> 协议，我们可以控制 JavaScript bundle 的加载方式。</li>
</ol>
<p>虽然在新架构中，直接通信主要通过 JSI 实现，但 RCTBridge 仍然在初始化阶段和生命周期管理中发挥着重要作用，是连接新旧架构的重要桥梁。</p>
<h2 id="注意事项和最佳实践"><a href="#注意事项和最佳实践" class="headerlink" title="注意事项和最佳实践"></a>注意事项和最佳实践</h2><p>在使用 JSI 进行原生与 JavaScript 通信时，需要注意以下几点：</p>
<ol>
<li><strong>线程安全</strong>: JSI 调用必须在 JavaScript 线程上执行，否则会导致崩溃。上面的代码通过 <code>dispatchBlock</code> 和信号量确保了线程安全。</li>
<li><strong>错误处理</strong>: 调用 JavaScript 函数时可能会抛出异常，需要适当处理这些异常。</li>
<li><strong>内存管理</strong>: JSI 允许原生代码和 JavaScript 互相持有对方的引用，需要注意避免循环引用导致的内存泄漏。</li>
<li><strong>性能考虑</strong>: 虽然 JSI 提供了同步调用能力，但对于耗时操作，仍然应该考虑异步处理，避免阻塞主线程。</li>
<li><strong>兼容性</strong>: 在混合使用新旧架构的过渡期，需要考虑兼容性问题。</li>
</ol>
<h2 id="扩展：支持更复杂的参数和返回值"><a href="#扩展：支持更复杂的参数和返回值" class="headerlink" title="扩展：支持更复杂的参数和返回值"></a>扩展：支持更复杂的参数和返回值</h2><p>上面的示例只演示了如何传递和返回简单的字符串参数，在实际应用中，我们可能需要处理更复杂的数据类型。以下是一个扩展版本，支持 JSON 对象的传递：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扩展 JSIBridge，添加支持 JSON 对象的方法</span></span><br><span class="line">+ (<span class="type">id</span>)callJavaScriptFunctionWithJSON:(<span class="built_in">NSString</span> *)functionName</span><br><span class="line">                      jsonArgument:(<span class="built_in">NSDictionary</span> *)argument &#123;</span><br><span class="line">  <span class="built_in">NSError</span> *error;</span><br><span class="line">  <span class="built_in">NSData</span> *jsonData = [<span class="built_in">NSJSONSerialization</span> dataWithJSONObject:argument</span><br><span class="line">                                                     options:<span class="number">0</span></span><br><span class="line">                                                       error:&amp;error];</span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;JSON序列化错误: %@&quot;</span>, error);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">NSString</span> *jsonString = [[<span class="built_in">NSString</span> alloc] initWithData:jsonData</span><br><span class="line">                                              encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">  <span class="built_in">NSString</span> *resultString = [<span class="keyword">self</span> callJavaScriptFunction:functionName</span><br><span class="line">                                          withArgument:jsonString];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 尝试将结果解析为 JSON</span></span><br><span class="line">  <span class="built_in">NSData</span> *resultData = [resultString dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">  <span class="type">id</span> resultObject = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:resultData</span><br><span class="line">                                                  options:<span class="number">0</span></span><br><span class="line">                                                    error:&amp;error];</span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="comment">// 如果不是有效的 JSON，则返回原始字符串</span></span><br><span class="line">    <span class="keyword">return</span> resultString;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> resultObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过 JSI，React Native 的新架构为原生代码和 JavaScript 之间的通信提供了更直接、更高效的方式。本文介绍了如何在 iOS 端通过 JSI 调用 React Native 中定义的 JavaScript 函数，包括:</p>
<ol>
<li>React Native 新架构的核心组件和优势</li>
<li>JSI 的基本概念和特性</li>
<li>RCTBridge 在新架构中的角色变化</li>
<li>实现 JSI 调用的具体步骤和示例代码</li>
<li>使用过程中的注意事项和最佳实践</li>
</ol>
<p>这种方法不仅提高了应用性能，还简化了原生与 JavaScript 之间的交互流程，为开发更复杂的混合应用提供了强大支持。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9yZWFjdG5hdGl2ZS5kZXYvYmxvZy8yMDI0LzEwLzIzL3RoZS1uZXctYXJjaGl0ZWN0dXJlLWlzLWhlcmU=">New Architecture is here<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzA4NjU5NzIvcmVhY3QtbmF0aXZlLWpzaS1ob3ctdG8tY2FsbC1hbnktamF2YXNjcmlwdC1mdW5jdGlvbi1mcm9tLW5hdGl2ZQ==">Call JavaScript functions from native using JSI<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtbWFyYWhtLWVkL3JlYWN0LW5hdGl2ZS1qc2ktdGVtcGxhdGU=">react-native-jsi-template<i class="fa fa-external-link-alt"></i></span></li>
<li><a href="https://reactnative.dev/blog/2024/08/12/release-0.75#accessing-jsiruntime-in-turbomodules">Accessing <code>jsi::Runtime</code> in TurboModules</a></li>
</ul>
]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>JSI</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：删除链表的倒数第 N 个结点</title>
    <url>/2025/02/26/20250226-%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%20N%20%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/../my_pictures/20250226/1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中结点的数目为 <code>sz</code></li>
<li><code>1 &lt;= sz &lt;= 30</code></li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
<li><code>1 &lt;= n &lt;= sz</code></li>
</ul>
<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>
<span id="more"></span>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">removeNthFromEnd</span>(<span class="keyword">_</span> <span class="params">head</span>: <span class="type">ListNode</span>?, <span class="keyword">_</span> <span class="params">n</span>: <span class="type">Int</span>) -&gt; <span class="type">ListNode</span>? &#123;</span><br><span class="line">  <span class="keyword">if</span> head <span class="operator">==</span> <span class="literal">nil</span> &#123; <span class="keyword">return</span> head &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> first: <span class="type">ListNode</span>? <span class="operator">=</span> head</span><br><span class="line">  <span class="keyword">var</span> last: <span class="type">ListNode</span>? <span class="operator">=</span> head</span><br><span class="line">  <span class="keyword">var</span> m <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> first<span class="operator">?</span>.next <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    first <span class="operator">=</span> first<span class="operator">?</span>.next</span><br><span class="line">    <span class="keyword">if</span> m <span class="operator">==</span> n &#123;</span><br><span class="line">      last <span class="operator">=</span> last<span class="operator">?</span>.next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      m <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> m <span class="operator">&lt;</span> n &#123;</span><br><span class="line">    <span class="keyword">return</span> head<span class="operator">?</span>.next</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  last<span class="operator">?</span>.next <span class="operator">=</span> last<span class="operator">?</span>.next<span class="operator">?</span>.next</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法使用了“双指针”技术，通过设置一个“快指针”和一个“慢指针”来高效地完成这个任务。</p>
<p><strong>1. 空链表检查</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> head <span class="operator">==</span> <span class="literal">nil</span> &#123; <span class="keyword">return</span> head &#125;</span><br></pre></td></tr></table></figure>

<p>与上一个版本一样，首先我们检查链表是否为空。如果链表为空，直接返回原链表。</p>
<p><strong>2. 初始化两个指针</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> first: <span class="type">ListNode</span>? <span class="operator">=</span> head</span><br><span class="line"><span class="keyword">var</span> last: <span class="type">ListNode</span>? <span class="operator">=</span> head</span><br><span class="line"><span class="keyword">var</span> m <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>first</code> 是快指针，最初指向链表的头节点。</p>
</li>
<li><p><code>last</code> 是慢指针，最初也指向链表的头节点。</p>
</li>
<li><p><code>m</code> 是一个计数器，帮助我们控制 <code>last</code> 指针移动的步数。</p>
</li>
</ul>
<p><strong>3. 移动快指针</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> first<span class="operator">?</span>.next <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">  first <span class="operator">=</span> first<span class="operator">?</span>.next</span><br><span class="line">  <span class="keyword">if</span> m <span class="operator">==</span> n &#123;</span><br><span class="line">    last <span class="operator">=</span> last<span class="operator">?</span>.next</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    m <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这里我们开始循环，直到 <code>first</code> 指针走到链表的最后一个节点。</p>
</li>
<li><p>在每次循环中，<code>first</code> 指针都会向前移动一步。</p>
</li>
<li><p><code>m</code> 变量用于控制 <code>last</code> 指针的移动。如果 <code>m</code> 达到 <code>n</code>，意味着 <code>first</code> 指针已经走过了 <code>n</code> 步，此时我们开始让 <code>last</code> 指针也移动，这样 <code>last</code> 和 <code>first</code> 之间的距离就始终保持为 <code>n</code>。</p>
</li>
</ul>
<p><strong>4. 删除倒数第 N 个节点的特殊情况</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> m <span class="operator">&lt;</span> n &#123;</span><br><span class="line">  <span class="keyword">return</span> head<span class="operator">?</span>.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一部分是处理特殊情况。如果链表的长度小于 <code>n</code>（例如 <code>n</code> 比链表长度还大），我们直接返回 <code>head?.next</code>，相当于删除头节点。</p>
<p><strong>5. 删除倒数第 N 个节点</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">last<span class="operator">?</span>.next <span class="operator">=</span> last<span class="operator">?</span>.next<span class="operator">?</span>.next</span><br></pre></td></tr></table></figure>

<p>一旦 <code>first</code> 指针到达链表的最后一个节点时，<code>last</code> 指针就会指向倒数第 <code>n+1</code> 个节点。此时，<code>last?.next</code> 就是倒数第 <code>N</code> 个节点。我们通过将 <code>last?.next</code> 指向 <code>last?.next?.next</code>，成功删除了倒数第 <code>N</code> 个节点。</p>
<p><strong>6. 返回修改后的链表头</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>

<p>最后，我们返回链表的头节点。即使删除了倒数第 <code>N</code> 个节点，链表的头节点仍然是原始头节点。</p>
<p><strong>总结：</strong></p>
<p>这段代码的关键思想与前一种解法类似：通过快慢指针的技巧来找出倒数第 <code>N</code> 个节点。主要不同点在于：</p>
<ul>
<li><p>该实现使用了 <code>m</code> 作为计数器来控制 <code>last</code> 指针的移动，直到 <code>first</code> 指针走了 <code>n</code> 步，<code>last</code> 指针才开始移动。</p>
</li>
<li><p>处理链表长度小于 <code>n</code> 的情况时，通过返回 <code>head?.next</code> 来直接删除链表的头节点。</p>
</li>
</ul>
<p>这种方式具有 <code>O(L)</code> 的时间复杂度和 <code>O(1)</code> 的空间复杂度，其中 <code>L</code> 是链表的长度。</p>
<h2 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">removeNthFromEnd</span>(<span class="keyword">_</span> <span class="params">head</span>: <span class="type">ListNode</span>?, <span class="keyword">_</span> <span class="params">n</span>: <span class="type">Int</span>) -&gt; <span class="type">ListNode</span>? &#123;</span><br><span class="line">  <span class="keyword">if</span> head <span class="operator">==</span> <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> fast: <span class="type">ListNode</span>? <span class="operator">=</span> head</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>n &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> node <span class="operator">=</span> fast<span class="operator">?</span>.next <span class="keyword">else</span> &#123; <span class="keyword">return</span> head<span class="operator">?</span>.next &#125;</span><br><span class="line">    fast <span class="operator">=</span> fast<span class="operator">?</span>.next</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> low: <span class="type">ListNode</span>? <span class="operator">=</span> head</span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">let</span> node <span class="operator">=</span> fast<span class="operator">?</span>.next &#123;</span><br><span class="line">    fast <span class="operator">=</span> node</span><br><span class="line">    low <span class="operator">=</span> low<span class="operator">?</span>.next</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  low<span class="operator">?</span>.next <span class="operator">=</span> low<span class="operator">?</span>.next<span class="operator">?</span>.next</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与上一种解法相比，这种写法实现方式有所不同，依然采用了类似的“双指针”技巧，但在处理快慢指针时的细节和逻辑略有不同。让我们逐步讲解这个算法的每一部分：</p>
<p><strong>1. 初始化和空链表检查:</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> head <span class="operator">==</span> <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br></pre></td></tr></table></figure>

<p>首先，我们检查链表是否为空。如果是空链表，直接返回 <code>nil</code>。</p>
<p><strong>2. 设置快指针:</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fast: <span class="type">ListNode</span>? <span class="operator">=</span> head</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>n &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> node <span class="operator">=</span> fast<span class="operator">?</span>.next <span class="keyword">else</span> &#123; <span class="keyword">return</span> head<span class="operator">?</span>.next &#125;</span><br><span class="line">    fast <span class="operator">=</span> fast<span class="operator">?</span>.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义了一个 <code>fast</code> 指针，并将其初始化为链表的头节点。接下来，我们让 <code>fast</code> 指针先走 <code>n</code> 步。这样，<code>fast</code> 指针在执行完这个循环后，会离链表的尾部有 <code>n</code> 个节点的距离。</p>
<p>需要特别注意的是，如果链表长度小于 <code>n</code>，我们直接返回 <code>head?.next</code>，这是因为倒数第 <code>N</code> 个节点不存在，我们只需要删除链表中的第一个节点。</p>
<p><strong>3. 设置慢指针:</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> low: <span class="type">ListNode</span>? <span class="operator">=</span> head</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> node <span class="operator">=</span> fast<span class="operator">?</span>.next &#123;</span><br><span class="line">    fast <span class="operator">=</span> node</span><br><span class="line">    low <span class="operator">=</span> low<span class="operator">?</span>.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，<code>fast</code> 指针已经向前走了 <code>n</code> 步，因此接下来，我们定义一个 <code>low</code> 指针，初始时指向头节点。然后，我们同时让 <code>fast</code> 和 <code>low</code> 一起向前移动，直到 <code>fast</code> 指针到达链表的最后一个节点。由于 <code>fast</code> 和 <code>low</code> 之间的距离保持为 <code>n</code>，当 <code>fast</code> 到达链表的尾部时，<code>low</code> 就会指向倒数第 <code>n+1</code> 个节点。</p>
<p><strong>4. 删除倒数第 N 个节点:</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">low<span class="operator">?</span>.next <span class="operator">=</span> low<span class="operator">?</span>.next<span class="operator">?</span>.next</span><br></pre></td></tr></table></figure>

<p>此时，<code>low</code> 指针指向的是倒数第 <code>n+1</code> 个节点，而 <code>low?.next</code> 就是我们要删除的倒数第 <code>N</code> 个节点。我们通过将 <code>low?.next</code> 的指针指向 <code>low?.next?.next</code> 来删除这个节点。</p>
<p><strong>5. 返回结果:</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>

<p>最后，我们返回修改后的链表头节点 <code>head</code>，这样链表中的节点已经删除了倒数第 <code>N</code> 个节点。</p>
<p><strong>总结：</strong></p>
<p>这个算法的关键点在于利用快慢指针的技巧。通过先让快指针走 <code>n</code> 步，然后快慢指针一起前进，直到快指针到达链表末尾，这样慢指针就能精确地定位到倒数第 <code>n+1</code> 个节点的位置。然后通过调整指针来删除倒数第 <code>N</code> 个节点，完成删除操作。这个算法的时间复杂度是 <code>O(L)</code>，其中 <code>L</code> 是链表的长度，空间复杂度是 <code>O(1)</code>，因为我们只使用了常数空间。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构：循环数组详解</title>
    <url>/2025/10/18/20251018-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="什么是循环数组"><a href="#什么是循环数组" class="headerlink" title="什么是循环数组"></a>什么是循环数组</h2><p>循环数组（Circular Array），也称为环形数组或环形缓冲区（Ring Buffer），是一种特殊的数组结构。它在逻辑上将数组的首尾相连，形成一个环形结构。当数组索引到达末尾时，会自动回到数组的开头，实现循环访问。</p>
<p>循环数组的核心思想是：<strong>通过取模运算，让索引在固定范围内循环</strong>。</p>
<h3 id="为什么需要循环数组？"><a href="#为什么需要循环数组？" class="headerlink" title="为什么需要循环数组？"></a>为什么需要循环数组？</h3><p>在传统的线性数组中，当我们需要在数组头部插入或删除元素时，需要移动大量元素，时间复杂度为 O(n)。而循环数组通过维护头尾指针，可以高效地在两端进行操作，实现 O(1) 的时间复杂度。</p>
<span id="more"></span>

<h2 id="循环数组的核心概念"><a href="#循环数组的核心概念" class="headerlink" title="循环数组的核心概念"></a>循环数组的核心概念</h2><h3 id="1-基本结构"><a href="#1-基本结构" class="headerlink" title="1. 基本结构"></a>1. 基本结构</h3><p>循环数组通常需要维护以下几个关键元素：</p>
<ul>
<li><strong>data[]</strong>: 底层数组，用于存储实际数据</li>
<li><strong>front</strong>: 头指针，指向队列的第一个元素</li>
<li><strong>rear</strong>: 尾指针，指向队列最后一个元素的下一个位置</li>
<li><strong>capacity</strong>: 数组容量</li>
<li><strong>size</strong>: 当前元素个数</li>
</ul>
<h3 id="2-索引计算"><a href="#2-索引计算" class="headerlink" title="2. 索引计算"></a>2. 索引计算</h3><p>循环数组最关键的操作是索引的循环计算：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实际索引 = (逻辑索引) % 数组长度</span><br></pre></td></tr></table></figure>

<p>例如，在长度为 5 的数组中：</p>
<ul>
<li>索引 0 的下一个位置是 (0 + 1) % 5 &#x3D; 1</li>
<li>索引 4 的下一个位置是 (4 + 1) % 5 &#x3D; 0（回到开头）</li>
</ul>
<h3 id="3-判空与判满"><a href="#3-判空与判满" class="headerlink" title="3. 判空与判满"></a>3. 判空与判满</h3><p><strong>判空条件</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">isEmpty = (size == 0) 或 (front == rear)</span><br></pre></td></tr></table></figure>

<p><strong>判满条件</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">isFull = (size == capacity) 或 ((rear + 1) % capacity == front)</span><br></pre></td></tr></table></figure>

<p>注意：有些实现会预留一个空位来区分满和空的状态。</p>
<h2 id="循环数组的实现"><a href="#循环数组的实现" class="headerlink" title="循环数组的实现"></a>循环数组的实现</h2><p>下面我们分别用 Swift、Objective-C 和 Python 实现一个完整的循环数组（以循环队列为例）：</p>
<div class="tabs" id="循环数组实现"><ul class="nav-tabs"><li class="tab active"><a href="#循环数组实现-1">Swift</a></li><li class="tab"><a href="#循环数组实现-2">Objective-C</a></li><li class="tab"><a href="#循环数组实现-3">Python</a></li></ul><div class="tab-content"><div class="tab-pane active" id="循环数组实现-1"><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CircularArray</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> data: [<span class="type">T</span>?]</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> front: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> rear: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> capacity: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> size: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">capacity</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.capacity <span class="operator">=</span> capacity</span><br><span class="line">        <span class="keyword">self</span>.data <span class="operator">=</span> <span class="type">Array</span>(repeating: <span class="literal">nil</span>, count: capacity)</span><br><span class="line">        <span class="keyword">self</span>.front <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">self</span>.rear <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">self</span>.size <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否为空</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">isEmpty</span>() -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size <span class="operator">==</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否已满</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">isFull</span>() -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size <span class="operator">==</span> capacity</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前元素个数</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">count</span>() -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在尾部添加元素</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">enqueue</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">T</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> isFull() &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;队列已满，无法添加元素&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        data[rear] <span class="operator">=</span> element</span><br><span class="line">        rear <span class="operator">=</span> (rear <span class="operator">+</span> <span class="number">1</span>) <span class="operator">%</span> capacity</span><br><span class="line">        size <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从头部移除元素</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">dequeue</span>() -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> isEmpty() &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;队列为空，无法移除元素&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> element <span class="operator">=</span> data[front]</span><br><span class="line">        data[front] <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">        front <span class="operator">=</span> (front <span class="operator">+</span> <span class="number">1</span>) <span class="operator">%</span> capacity</span><br><span class="line">        size <span class="operator">-=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> element</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查看队首元素（不移除）</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">peek</span>() -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> isEmpty() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[front]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取指定索引的元素</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">get</span>(<span class="keyword">_</span> <span class="params">index</span>: <span class="type">Int</span>) -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> index <span class="operator">&lt;</span> <span class="number">0</span> <span class="operator">||</span> index <span class="operator">&gt;=</span> size &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> actualIndex <span class="operator">=</span> (front <span class="operator">+</span> index) <span class="operator">%</span> capacity</span><br><span class="line">        <span class="keyword">return</span> data[actualIndex]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印所有元素</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">printElements</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> isEmpty() &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;队列为空&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> elements: [<span class="type">T</span>] <span class="operator">=</span> []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>size &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> element <span class="operator">=</span> <span class="keyword">get</span>(i) &#123;</span><br><span class="line">                elements.append(element)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;队列元素: <span class="subst">\(elements)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="循环数组实现-2"><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CircularArray.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CircularArray</span>&lt;<span class="title">ObjectType</span>&gt; : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithCapacity:(<span class="built_in">NSUInteger</span>)capacity;</span><br><span class="line">- (<span class="type">BOOL</span>)isEmpty;</span><br><span class="line">- (<span class="type">BOOL</span>)isFull;</span><br><span class="line">- (<span class="built_in">NSUInteger</span>)count;</span><br><span class="line">- (<span class="type">BOOL</span>)enqueue:(ObjectType)element;</span><br><span class="line">- (ObjectType)dequeue;</span><br><span class="line">- (ObjectType)peek;</span><br><span class="line">- (ObjectType)getElementAtIndex:(<span class="built_in">NSUInteger</span>)index;</span><br><span class="line">- (<span class="type">void</span>)printElements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CircularArray.m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CircularArray</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *_data;</span><br><span class="line">    <span class="built_in">NSUInteger</span> _front;</span><br><span class="line">    <span class="built_in">NSUInteger</span> _rear;</span><br><span class="line">    <span class="built_in">NSUInteger</span> _capacity;</span><br><span class="line">    <span class="built_in">NSUInteger</span> _size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithCapacity:(<span class="built_in">NSUInteger</span>)capacity &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _capacity = capacity;</span><br><span class="line">        _data = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:capacity];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">            [_data addObject:[<span class="built_in">NSNull</span> null]];</span><br><span class="line">        &#125;</span><br><span class="line">        _front = <span class="number">0</span>;</span><br><span class="line">        _rear = <span class="number">0</span>;</span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)isEmpty &#123;</span><br><span class="line">    <span class="keyword">return</span> _size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)isFull &#123;</span><br><span class="line">    <span class="keyword">return</span> _size == _capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)count &#123;</span><br><span class="line">    <span class="keyword">return</span> _size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)enqueue:(<span class="type">id</span>)element &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isFull]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;队列已满，无法添加元素&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _data[_rear] = element;</span><br><span class="line">    _rear = (_rear + <span class="number">1</span>) % _capacity;</span><br><span class="line">    _size++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)dequeue &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isEmpty]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;队列为空，无法移除元素&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">id</span> element = _data[_front];</span><br><span class="line">    _data[_front] = [<span class="built_in">NSNull</span> null];</span><br><span class="line">    _front = (_front + <span class="number">1</span>) % _capacity;</span><br><span class="line">    _size--;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)peek &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isEmpty]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _data[_front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)getElementAtIndex:(<span class="built_in">NSUInteger</span>)index &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= _size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSUInteger</span> actualIndex = (_front + index) % _capacity;</span><br><span class="line">    <span class="keyword">return</span> _data[actualIndex];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)printElements &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isEmpty]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;队列为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableArray</span> *elements = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; _size; i++) &#123;</span><br><span class="line">        <span class="type">id</span> element = [<span class="keyword">self</span> getElementAtIndex:i];</span><br><span class="line">        <span class="keyword">if</span> (element &amp;&amp; element != [<span class="built_in">NSNull</span> null]) &#123;</span><br><span class="line">            [elements addObject:element];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;队列元素: %@&quot;</span>, elements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="循环数组实现-3"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CircularArray</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化循环数组&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.capacity = capacity</span><br><span class="line">        <span class="variable language_">self</span>.data = [<span class="literal">None</span>] * capacity</span><br><span class="line">        <span class="variable language_">self</span>.front = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>.rear = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>.size = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.size == <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_full</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断是否已满&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.size == <span class="variable language_">self</span>.capacity</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取当前元素个数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.size</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">enqueue</span>(<span class="params">self, element</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;在尾部添加元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_full():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;队列已满，无法添加元素&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">self</span>.data[<span class="variable language_">self</span>.rear] = element</span><br><span class="line">        <span class="variable language_">self</span>.rear = (<span class="variable language_">self</span>.rear + <span class="number">1</span>) % <span class="variable language_">self</span>.capacity</span><br><span class="line">        <span class="variable language_">self</span>.size += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dequeue</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;从头部移除元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;队列为空，无法移除元素&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        element = <span class="variable language_">self</span>.data[<span class="variable language_">self</span>.front]</span><br><span class="line">        <span class="variable language_">self</span>.data[<span class="variable language_">self</span>.front] = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.front = (<span class="variable language_">self</span>.front + <span class="number">1</span>) % <span class="variable language_">self</span>.capacity</span><br><span class="line">        <span class="variable language_">self</span>.size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> element</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;查看队首元素（不移除）&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.data[<span class="variable language_">self</span>.front]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取指定索引的元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= <span class="variable language_">self</span>.size:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        actual_index = (<span class="variable language_">self</span>.front + index) % <span class="variable language_">self</span>.capacity</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.data[actual_index]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_elements</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;打印所有元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;队列为空&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        elements = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.size):</span><br><span class="line">            element = <span class="variable language_">self</span>.get(i)</span><br><span class="line">            <span class="keyword">if</span> element <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                elements.append(element)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;队列元素: <span class="subst">&#123;elements&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><div class="tabs" id="使用示例"><ul class="nav-tabs"><li class="tab active"><a href="#使用示例-1">Swift</a></li><li class="tab"><a href="#使用示例-2">Python</a></li></ul><div class="tab-content"><div class="tab-pane active" id="使用示例-1"><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建容量为 5 的循环数组</span></span><br><span class="line"><span class="keyword">let</span> circularArray <span class="operator">=</span> <span class="type">CircularArray</span>&lt;<span class="type">Int</span>&gt;(capacity: <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">circularArray.enqueue(<span class="number">1</span>)  <span class="comment">// [1]</span></span><br><span class="line">circularArray.enqueue(<span class="number">2</span>)  <span class="comment">// [1, 2]</span></span><br><span class="line">circularArray.enqueue(<span class="number">3</span>)  <span class="comment">// [1, 2, 3]</span></span><br><span class="line">circularArray.enqueue(<span class="number">4</span>)  <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">circularArray.enqueue(<span class="number">5</span>)  <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">circularArray.printElements()</span><br><span class="line"><span class="comment">// 输出: 队列元素: [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试添加第6个元素（会失败）</span></span><br><span class="line">circularArray.enqueue(<span class="number">6</span>)</span><br><span class="line"><span class="comment">// 输出: 队列已满，无法添加元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除两个元素</span></span><br><span class="line"><span class="built_in">print</span>(circularArray.dequeue()<span class="operator">!</span>)  <span class="comment">// 输出: 1</span></span><br><span class="line"><span class="built_in">print</span>(circularArray.dequeue()<span class="operator">!</span>)  <span class="comment">// 输出: 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时可以继续添加元素</span></span><br><span class="line">circularArray.enqueue(<span class="number">6</span>)  <span class="comment">// [3, 4, 5, 6]</span></span><br><span class="line">circularArray.enqueue(<span class="number">7</span>)  <span class="comment">// [3, 4, 5, 6, 7]</span></span><br><span class="line"></span><br><span class="line">circularArray.printElements()</span><br><span class="line"><span class="comment">// 输出: 队列元素: [3, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="使用示例-2"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建容量为 5 的循环数组</span></span><br><span class="line">circular_array = CircularArray(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加元素</span></span><br><span class="line">circular_array.enqueue(<span class="number">1</span>)  <span class="comment"># [1]</span></span><br><span class="line">circular_array.enqueue(<span class="number">2</span>)  <span class="comment"># [1, 2]</span></span><br><span class="line">circular_array.enqueue(<span class="number">3</span>)  <span class="comment"># [1, 2, 3]</span></span><br><span class="line">circular_array.enqueue(<span class="number">4</span>)  <span class="comment"># [1, 2, 3, 4]</span></span><br><span class="line">circular_array.enqueue(<span class="number">5</span>)  <span class="comment"># [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">circular_array.print_elements()</span><br><span class="line"><span class="comment"># 输出: 队列元素: [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试添加第6个元素（会失败）</span></span><br><span class="line">circular_array.enqueue(<span class="number">6</span>)</span><br><span class="line"><span class="comment"># 输出: 队列已满，无法添加元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除两个元素</span></span><br><span class="line"><span class="built_in">print</span>(circular_array.dequeue())  <span class="comment"># 输出: 1</span></span><br><span class="line"><span class="built_in">print</span>(circular_array.dequeue())  <span class="comment"># 输出: 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时可以继续添加元素</span></span><br><span class="line">circular_array.enqueue(<span class="number">6</span>)  <span class="comment"># [3, 4, 5, 6]</span></span><br><span class="line">circular_array.enqueue(<span class="number">7</span>)  <span class="comment"># [3, 4, 5, 6, 7]</span></span><br><span class="line"></span><br><span class="line">circular_array.print_elements()</span><br><span class="line"><span class="comment"># 输出: 队列元素: [3, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="循环数组的应用场景"><a href="#循环数组的应用场景" class="headerlink" title="循环数组的应用场景"></a>循环数组的应用场景</h2><h3 id="1-循环队列（Circular-Queue）"><a href="#1-循环队列（Circular-Queue）" class="headerlink" title="1. 循环队列（Circular Queue）"></a>1. 循环队列（Circular Queue）</h3><p>这是循环数组最典型的应用。循环队列常用于：</p>
<ul>
<li>操作系统的进程调度</li>
<li>网络数据包的缓冲</li>
<li>生产者-消费者模型</li>
<li>键盘输入缓冲区</li>
</ul>
<h3 id="2-循环缓冲区（Ring-Buffer）"><a href="#2-循环缓冲区（Ring-Buffer）" class="headerlink" title="2. 循环缓冲区（Ring Buffer）"></a>2. 循环缓冲区（Ring Buffer）</h3><p>在音视频处理、网络通信等场景中广泛使用：</p>
<ul>
<li>音频播放器的缓冲区</li>
<li>视频解码器的帧缓冲</li>
<li>网络数据的接收缓冲</li>
</ul>
<h3 id="3-LRU-缓存"><a href="#3-LRU-缓存" class="headerlink" title="3. LRU 缓存"></a>3. LRU 缓存</h3><p>结合循环数组和哈希表可以实现高效的 LRU（Least Recently Used）缓存。</p>
<h3 id="4-滑动窗口问题"><a href="#4-滑动窗口问题" class="headerlink" title="4. 滑动窗口问题"></a>4. 滑动窗口问题</h3><p>在算法题中，很多滑动窗口问题可以用循环数组来优化。</p>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>入队（enqueue）</td>
<td>O(1)</td>
</tr>
<tr>
<td>出队（dequeue）</td>
<td>O(1)</td>
</tr>
<tr>
<td>查看队首（peek）</td>
<td>O(1)</td>
</tr>
<tr>
<td>判空&#x2F;判满</td>
<td>O(1)</td>
</tr>
<tr>
<td>随机访问</td>
<td>O(1)</td>
</tr>
</tbody></table>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>空间复杂度为 O(n)，其中 n 是数组的容量。</p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol>
<li><strong>高效的两端操作</strong>：在头尾插入删除都是 O(1)</li>
<li><strong>固定内存占用</strong>：预分配固定大小的内存，避免动态扩容</li>
<li><strong>缓存友好</strong>：连续的内存空间，对 CPU 缓存友好</li>
</ol>
<h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ol>
<li><strong>固定容量</strong>：容量固定，无法动态扩展（除非重新分配）</li>
<li><strong>空间浪费</strong>：某些实现需要预留一个空位来区分满和空</li>
</ol>
<h2 id="循环数组-vs-普通数组"><a href="#循环数组-vs-普通数组" class="headerlink" title="循环数组 vs 普通数组"></a>循环数组 vs 普通数组</h2><table>
<thead>
<tr>
<th>特性</th>
<th>循环数组</th>
<th>普通数组</th>
</tr>
</thead>
<tbody><tr>
<td>头部插入</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>头部删除</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>尾部插入</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>尾部删除</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>随机访问</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>空间利用</td>
<td>固定容量，可能浪费</td>
<td>可动态扩容</td>
</tr>
</tbody></table>
<h2 id="常见陷阱与注意事项"><a href="#常见陷阱与注意事项" class="headerlink" title="常见陷阱与注意事项"></a>常见陷阱与注意事项</h2><h3 id="1-索引计算错误"><a href="#1-索引计算错误" class="headerlink" title="1. 索引计算错误"></a>1. 索引计算错误</h3><p>在进行索引计算时，特别是向前移动时，需要注意负数的处理：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误：可能产生负数</span></span><br><span class="line">front <span class="operator">=</span> (front <span class="operator">-</span> <span class="number">1</span>) <span class="operator">%</span> capacity</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确：确保结果为正</span></span><br><span class="line">front <span class="operator">=</span> (front <span class="operator">-</span> <span class="number">1</span> <span class="operator">+</span> capacity) <span class="operator">%</span> capacity</span><br></pre></td></tr></table></figure>

<h3 id="2-满和空的判断"><a href="#2-满和空的判断" class="headerlink" title="2. 满和空的判断"></a>2. 满和空的判断</h3><p>有两种常见的判断方法：</p>
<p><strong>方法1：使用 size 变量</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">isEmpty <span class="operator">=</span> (size <span class="operator">==</span> <span class="number">0</span>)</span><br><span class="line">isFull <span class="operator">=</span> (size <span class="operator">==</span> capacity)</span><br></pre></td></tr></table></figure>

<p><strong>方法2：预留一个空位</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">isEmpty <span class="operator">=</span> (front <span class="operator">==</span> rear)</span><br><span class="line">isFull <span class="operator">=</span> ((rear <span class="operator">+</span> <span class="number">1</span>) <span class="operator">%</span> capacity <span class="operator">==</span> front)</span><br></pre></td></tr></table></figure>

<h3 id="3-线程安全问题"><a href="#3-线程安全问题" class="headerlink" title="3. 线程安全问题"></a>3. 线程安全问题</h3><p>在多线程环境下使用循环数组需要加锁：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafeCircularArray</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> circularArray: <span class="type">CircularArray</span>&lt;<span class="type">T</span>&gt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> lock <span class="operator">=</span> <span class="type">NSLock</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">capacity</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.circularArray <span class="operator">=</span> <span class="type">CircularArray</span>&lt;<span class="type">T</span>&gt;(capacity: capacity)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">enqueue</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">T</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        lock.lock()</span><br><span class="line">        <span class="keyword">defer</span> &#123; lock.unlock() &#125;</span><br><span class="line">        <span class="keyword">return</span> circularArray.enqueue(element)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">dequeue</span>() -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">        lock.lock()</span><br><span class="line">        <span class="keyword">defer</span> &#123; lock.unlock() &#125;</span><br><span class="line">        <span class="keyword">return</span> circularArray.dequeue()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展：动态扩容的循环数组"><a href="#扩展：动态扩容的循环数组" class="headerlink" title="扩展：动态扩容的循环数组"></a>扩展：动态扩容的循环数组</h2><p>虽然循环数组通常是固定容量的，但我们也可以实现动态扩容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicCircularArray</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> data: [<span class="type">T</span>?]</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> front: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> rear: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> capacity: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> size: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">capacity</span>: <span class="type">Int</span> <span class="operator">=</span> <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.capacity <span class="operator">=</span> capacity</span><br><span class="line">        <span class="keyword">self</span>.data <span class="operator">=</span> <span class="type">Array</span>(repeating: <span class="literal">nil</span>, count: capacity)</span><br><span class="line">        <span class="keyword">self</span>.front <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">self</span>.rear <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">self</span>.size <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">enqueue</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">T</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> isFull() &#123;</span><br><span class="line">            resize(newCapacity: capacity <span class="operator">*</span> <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        data[rear] <span class="operator">=</span> element</span><br><span class="line">        rear <span class="operator">=</span> (rear <span class="operator">+</span> <span class="number">1</span>) <span class="operator">%</span> capacity</span><br><span class="line">        size <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">resize</span>(<span class="params">newCapacity</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> newData: [<span class="type">T</span>?] <span class="operator">=</span> <span class="type">Array</span>(repeating: <span class="literal">nil</span>, count: newCapacity)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将旧数据按顺序复制到新数组</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>size &#123;</span><br><span class="line">            <span class="keyword">let</span> index <span class="operator">=</span> (front <span class="operator">+</span> i) <span class="operator">%</span> capacity</span><br><span class="line">            newData[i] <span class="operator">=</span> data[index]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        data <span class="operator">=</span> newData</span><br><span class="line">        front <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        rear <span class="operator">=</span> size</span><br><span class="line">        capacity <span class="operator">=</span> newCapacity</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">isFull</span>() -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size <span class="operator">==</span> capacity</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>循环数组是一种巧妙的数据结构，通过取模运算实现了数组的逻辑环形连接。它在以下场景中特别有用：</p>
<ol>
<li><strong>需要高效的两端操作</strong>：O(1) 时间复杂度的头尾插入删除</li>
<li><strong>固定大小的缓冲区</strong>：音视频处理、网络通信等</li>
<li><strong>队列的实现</strong>：循环队列比用链表实现的队列更节省空间</li>
<li><strong>资源受限的环境</strong>：嵌入式系统、实时系统等</li>
</ol>
<p>掌握循环数组的原理和实现，对于理解操作系统、网络编程、以及解决算法问题都有很大帮助。</p>
<h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2lyY3VsYXJfYnVmZmVy">Circular buffer - Wikipedia<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvY2lyY3VsYXItcXVldWUtc2V0LTEtaW50cm9kdWN0aW9uLWFycmF5LWltcGxlbWVudGF0aW9uLw==">Circular Queue | Set 1 (Introduction and Array Implementation) - GeeksforGeeks<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvZGVzaWduLWNpcmN1bGFyLXF1ZXVlLw==">Design Circular Queue - LeetCode<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvZGVzaWduLWNpcmN1bGFyLWRlcXVlLw==">Design Circular Deque - LeetCode<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein. 《算法导论》（第3版）. 机械工业出版社, 2012</li>
<li>Mark Allen Weiss. 《数据结构与算法分析：C++描述》（第4版）. 电子工业出版社, 2014</li>
<li>严蔚敏, 吴伟民. 《数据结构》（C语言版）. 清华大学出版社, 2011</li>
<li>Robert Sedgewick, Kevin Wayne. 《算法》（第4版）. 人民邮电出版社, 2012</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>循环数组</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 队列的两种实现：循环数组 vs 链表</title>
    <url>/2025/10/22/20251022-iOS%E9%98%9F%E5%88%97%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%EF%BC%9A%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84vs%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>队列（Queue）是一种遵循先进先出（FIFO，First In First Out）原则的线性数据结构。在 iOS 开发中，我们经常需要使用队列来处理各种场景，比如：任务调度、消息队列、事件处理等。</p>
<p>在上一篇文章<a href="/2025/10/18/20251018-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84%E8%AF%A6%E8%A7%A3/">《数据结构：循环数组详解》</a>中，我们详细介绍了循环数组的原理。本文将基于实际项目中的代码，深入对比<strong>循环数组实现的队列</strong>和<strong>链表实现的队列</strong>这两种方案，帮助你在实际开发中做出正确的选择。</p>
<span id="more"></span>

<h2 id="队列的基本概念"><a href="#队列的基本概念" class="headerlink" title="队列的基本概念"></a>队列的基本概念</h2><h3 id="什么是队列？"><a href="#什么是队列？" class="headerlink" title="什么是队列？"></a>什么是队列？</h3><p>队列是一种特殊的线性表，它只允许在表的前端（front）进行删除操作，在表的后端（rear）进行插入操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">入队 (enqueue)          出队 (dequeue)</span><br><span class="line">      ↓                      ↑</span><br><span class="line">    +---+---+---+---+---+</span><br><span class="line">    | 5 | 4 | 3 | 2 | 1 |  ← 队列</span><br><span class="line">    +---+---+---+---+---+</span><br><span class="line">    队尾 (tail)      队头 (front)</span><br></pre></td></tr></table></figure>

<h3 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h3><ul>
<li><strong>enqueue（入队）</strong>：在队尾添加一个元素</li>
<li><strong>dequeue（出队）</strong>：移除并返回队头元素</li>
<li><strong>peek（查看队头）</strong>：查看队头元素但不移除</li>
<li><strong>isEmpty（判空）</strong>：判断队列是否为空</li>
<li><strong>count（计数）</strong>：获取队列中元素的个数</li>
</ul>
<h2 id="方案一：基于循环数组的队列实现"><a href="#方案一：基于循环数组的队列实现" class="headerlink" title="方案一：基于循环数组的队列实现"></a>方案一：基于循环数组的队列实现</h2><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>循环数组实现的队列（<code>LitQueue</code>）使用固定大小的数组作为底层存储，通过维护 <code>front</code> 指针和 <code>count</code> 计数器来管理队列状态。</p>
<h4 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LitQueue</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 循环数组，存储队列元素</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *items;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 队头索引</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> front;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 队列元素数量</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 当前容量</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h4 id="关键设计要点"><a href="#关键设计要点" class="headerlink" title="关键设计要点"></a>关键设计要点</h4><ol>
<li><strong>预分配空间</strong>：创建队列时预先分配固定容量，用 <code>NSNull</code> 填充占位</li>
<li><strong>循环索引计算</strong>：通过取模运算实现循环访问</li>
<li><strong>动态扩容&#x2F;缩容</strong>：满时扩容为 2 倍，使用率低于 25% 时缩容为一半</li>
</ol>
<h3 id="核心实现代码"><a href="#核心实现代码" class="headerlink" title="核心实现代码"></a>核心实现代码</h3><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithCapacity:(<span class="built_in">NSInteger</span>)capacity &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">        _capacity = capacity;</span><br><span class="line">        _items = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:capacity];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 预填充 NSNull 占位，避免后续插入时数组自动扩容</span></span><br><span class="line">        <span class="comment">// 这样可以直接用下标访问，避免 Crash</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">            [_items addObject:[<span class="built_in">NSNull</span> null]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        _front = <span class="number">0</span>;</span><br><span class="line">        _count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>设计细节</strong>：</p>
<ul>
<li>预填充 <code>NSNull</code> 是为了让数组达到指定容量，后续可以直接用下标访问</li>
<li>如果不预填充，使用 <code>items[index] = obj</code> 会 Crash</li>
<li>不预填充的话只能用 <code>addObject</code>，会导致数组频繁扩容</li>
</ul>
<h4 id="2-入队操作"><a href="#2-入队操作" class="headerlink" title="2. 入队操作"></a>2. 入队操作</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)enqueue:(<span class="type">id</span>)object &#123;</span><br><span class="line">    <span class="keyword">if</span> (!object) &#123;</span><br><span class="line">        <span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="built_in">NSInvalidArgumentException</span></span><br><span class="line">                                       reason:<span class="string">@&quot;Cannot enqueue nil object&quot;</span></span><br><span class="line">                                     userInfo:<span class="literal">nil</span>];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.count == <span class="keyword">self</span>.capacity) &#123;</span><br><span class="line">        [<span class="keyword">self</span> resize:<span class="keyword">self</span>.capacity * <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算队尾位置（循环数组的核心）</span></span><br><span class="line">    <span class="built_in">NSInteger</span> tail = (<span class="keyword">self</span>.front + <span class="keyword">self</span>.count) % <span class="keyword">self</span>.capacity;</span><br><span class="line">    <span class="keyword">self</span>.items[tail] = object;</span><br><span class="line">    <span class="keyword">self</span>.count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong>：</p>
<ul>
<li>队尾位置计算公式：<code>tail = (front + count) % capacity</code></li>
<li>满时触发扩容，扩容为原容量的 2 倍</li>
<li>时间复杂度：O(1) 摊销（扩容时为 O(n)）</li>
</ul>
<h4 id="3-出队操作"><a href="#3-出队操作" class="headerlink" title="3. 出队操作"></a>3. 出队操作</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">id</span>)dequeue &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isEmpty) &#123;</span><br><span class="line">        <span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="built_in">NSInternalInconsistencyException</span></span><br><span class="line">                                       reason:<span class="string">@&quot;Cannot dequeue from an empty queue&quot;</span></span><br><span class="line">                                     userInfo:<span class="literal">nil</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取出队头元素</span></span><br><span class="line">    <span class="type">id</span> object = <span class="keyword">self</span>.items[<span class="keyword">self</span>.front];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空位置（避免内存泄漏）</span></span><br><span class="line">    <span class="keyword">self</span>.items[<span class="keyword">self</span>.front] = [<span class="built_in">NSNull</span> null];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移动队头指针（循环）</span></span><br><span class="line">    <span class="keyword">self</span>.front = (<span class="keyword">self</span>.front + <span class="number">1</span>) % <span class="keyword">self</span>.capacity;</span><br><span class="line">    <span class="keyword">self</span>.count--;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 缩容策略（当使用率低于 25% 且容量大于默认值时）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.count &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">self</span>.count == <span class="keyword">self</span>.capacity / <span class="number">4</span> &amp;&amp; <span class="keyword">self</span>.capacity &gt; kDefaultCapacity) &#123;</span><br><span class="line">        [<span class="keyword">self</span> resize:<span class="keyword">self</span>.capacity / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong>：</p>
<ul>
<li>队头指针循环移动：<code>front = (front + 1) % capacity</code></li>
<li>清空旧位置防止对象被强引用导致内存泄漏</li>
<li>智能缩容：使用率低于 25% 时缩容，避免频繁缩容导致的性能抖动</li>
<li>时间复杂度：O(1)（大部分情况），缩容时为 O(n)</li>
</ul>
<h4 id="4-扩容-缩容实现"><a href="#4-扩容-缩容实现" class="headerlink" title="4. 扩容&#x2F;缩容实现"></a>4. 扩容&#x2F;缩容实现</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)resize:(<span class="built_in">NSInteger</span>)newCapacity &#123;</span><br><span class="line">    <span class="comment">// 创建新数组</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *newItems = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:newCapacity];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 预填充 NSNull</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; newCapacity; i++) &#123;</span><br><span class="line">        [newItems addObject:[<span class="built_in">NSNull</span> null]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按顺序复制元素到新数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="keyword">self</span>.count; i++) &#123;</span><br><span class="line">        <span class="built_in">NSInteger</span> oldIndex = (<span class="keyword">self</span>.front + i) % <span class="keyword">self</span>.capacity;</span><br><span class="line">        newItems[i] = <span class="keyword">self</span>.items[oldIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新状态</span></span><br><span class="line">    <span class="keyword">self</span>.items = newItems;</span><br><span class="line">    <span class="keyword">self</span>.capacity = newCapacity;</span><br><span class="line">    <span class="keyword">self</span>.front = <span class="number">0</span>;  <span class="comment">// 重置队头到 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>设计亮点</strong>：</p>
<ul>
<li>扩容时将所有元素按顺序重新排列到新数组</li>
<li>重置 <code>front</code> 为 0，简化后续操作</li>
<li>时间复杂度：O(n)</li>
</ul>
<h3 id="内存布局示意"><a href="#内存布局示意" class="headerlink" title="内存布局示意"></a>内存布局示意</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始状态（capacity = 5, count = 0, front = 0）:</span><br><span class="line">   0    1    2    3    4</span><br><span class="line">[null][null][null][null][null]</span><br><span class="line">  ↑</span><br><span class="line"> front</span><br><span class="line"></span><br><span class="line">入队 A, B, C 后（count = 3, front = 0）:</span><br><span class="line">   0    1    2    3    4</span><br><span class="line"> [ A ][ B ][ C ][null][null]</span><br><span class="line">   ↑              ↑</span><br><span class="line"> front          tail</span><br><span class="line"></span><br><span class="line">出队 A, B 后，入队 D, E, F（count = 4, front = 2）:</span><br><span class="line">   0    1    2    3    4</span><br><span class="line"> [ E ][ F ][ C ][ D ][null]</span><br><span class="line">             ↑         ↑</span><br><span class="line">           front     tail (循环到 1)</span><br><span class="line"></span><br><span class="line">此时队列逻辑顺序是：C -&gt; D -&gt; E -&gt; F</span><br></pre></td></tr></table></figure>

<h2 id="方案二：基于链表的队列实现"><a href="#方案二：基于链表的队列实现" class="headerlink" title="方案二：基于链表的队列实现"></a>方案二：基于链表的队列实现</h2><h3 id="设计思路-1"><a href="#设计思路-1" class="headerlink" title="设计思路"></a>设计思路</h3><p>链表实现的队列（<code>LitLinkedQueue</code>）使用单向链表作为底层存储，通过维护 <code>head</code> 和 <code>tail</code> 两个指针来管理队列。</p>
<h4 id="核心数据结构-1"><a href="#核心数据结构-1" class="headerlink" title="核心数据结构"></a>核心数据结构</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LitLinkedQueueNode</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="type">id</span> value;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) LitLinkedQueueNode *next;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LitLinkedQueue</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) LitLinkedQueueNode *head;  <span class="comment">// 队头（出队）</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) LitLinkedQueueNode *tail;  <span class="comment">// 队尾（入队）</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> count;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h4 id="关键设计要点-1"><a href="#关键设计要点-1" class="headerlink" title="关键设计要点"></a>关键设计要点</h4><ol>
<li><strong>双指针管理</strong>：维护队头和队尾指针，实现 O(1) 的入队和出队</li>
<li><strong>按需分配</strong>：不需要预分配空间，动态增长</li>
<li><strong>简单高效</strong>：无需扩容操作，所有操作都是 O(1)</li>
</ol>
<h3 id="核心实现代码-1"><a href="#核心实现代码-1" class="headerlink" title="核心实现代码"></a>核心实现代码</h3><h4 id="1-入队操作"><a href="#1-入队操作" class="headerlink" title="1. 入队操作"></a>1. 入队操作</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)enqueue:(<span class="type">id</span>)object &#123;</span><br><span class="line">    <span class="keyword">if</span> (!object) &#123;</span><br><span class="line">        <span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="built_in">NSInvalidArgumentException</span></span><br><span class="line">                                       reason:<span class="string">@&quot;Cannot enqueue nil object&quot;</span></span><br><span class="line">                                     userInfo:<span class="literal">nil</span>];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LitLinkedQueueNode *newNode = [LitLinkedQueueNode nodeWithValue:object];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.tail) &#123;</span><br><span class="line">        <span class="comment">// 队列不为空，添加到队尾</span></span><br><span class="line">        <span class="keyword">self</span>.tail.next = newNode;</span><br><span class="line">        <span class="keyword">self</span>.tail = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 队列为空，新节点既是队头也是队尾</span></span><br><span class="line">        <span class="keyword">self</span>.head = newNode;</span><br><span class="line">        <span class="keyword">self</span>.tail = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong>：</p>
<ul>
<li>始终在队尾添加新节点</li>
<li>特殊处理空队列的情况</li>
<li>时间复杂度：O(1)，无扩容开销</li>
</ul>
<h4 id="2-出队操作"><a href="#2-出队操作" class="headerlink" title="2. 出队操作"></a>2. 出队操作</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">id</span>)dequeue &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isEmpty) &#123;</span><br><span class="line">        <span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="built_in">NSInternalInconsistencyException</span></span><br><span class="line">                                       reason:<span class="string">@&quot;Cannot dequeue from an empty queue&quot;</span></span><br><span class="line">                                     userInfo:<span class="literal">nil</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取出队头元素</span></span><br><span class="line">    <span class="type">id</span> value = <span class="keyword">self</span>.head.value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移动队头指针</span></span><br><span class="line">    <span class="keyword">self</span>.head = <span class="keyword">self</span>.head.next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果队列变空，清空队尾指针</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.head) &#123;</span><br><span class="line">        <span class="keyword">self</span>.tail = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _count--;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong>：</p>
<ul>
<li>直接移动 <code>head</code> 指针，旧节点会被 ARC 自动回收</li>
<li>队列变空时需要同步清空 <code>tail</code> 指针</li>
<li>时间复杂度：O(1)，真正的常数时间</li>
</ul>
<h4 id="3-清空队列"><a href="#3-清空队列" class="headerlink" title="3. 清空队列"></a>3. 清空队列</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)removeAllObjects &#123;</span><br><span class="line">    <span class="comment">// 断开所有节点连接，帮助 ARC 回收</span></span><br><span class="line">    LitLinkedQueueNode *current = <span class="keyword">self</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">        LitLinkedQueueNode *next = current.next;</span><br><span class="line">        current.next = <span class="literal">nil</span>;</span><br><span class="line">        current.value = <span class="literal">nil</span>;</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.head = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">self</span>.tail = <span class="literal">nil</span>;</span><br><span class="line">    _count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>设计细节</strong>：</p>
<ul>
<li>显式断开所有节点的 <code>next</code> 和 <code>value</code> 引用</li>
<li>帮助 ARC 更快地回收内存，避免循环引用</li>
<li>虽然只设置 <code>head = nil</code> 也能让 ARC 最终回收，但显式断开更高效</li>
</ul>
<h3 id="内存布局示意-1"><a href="#内存布局示意-1" class="headerlink" title="内存布局示意"></a>内存布局示意</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">空队列:</span><br><span class="line">head → nil</span><br><span class="line">tail → nil</span><br><span class="line"></span><br><span class="line">入队 A 后:</span><br><span class="line">head → [A | next:nil] ← tail</span><br><span class="line">       </span><br><span class="line">入队 B, C 后:</span><br><span class="line">head → [A | next] → [B | next] → [C | next:nil] ← tail</span><br><span class="line"></span><br><span class="line">出队 A 后:</span><br><span class="line">       head → [B | next] → [C | next:nil] ← tail</span><br><span class="line">       </span><br><span class="line">注意：旧的节点 A 会被 ARC 自动回收</span><br></pre></td></tr></table></figure>

<h2 id="两种实现方式的深度对比"><a href="#两种实现方式的深度对比" class="headerlink" title="两种实现方式的深度对比"></a>两种实现方式的深度对比</h2><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><table>
<thead>
<tr>
<th>操作</th>
<th>循环数组 (LitQueue)</th>
<th>链表 (LitLinkedQueue)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>入队 (enqueue)</strong></td>
<td>O(1) 摊销<br/>（扩容时 O(n)）</td>
<td>O(1) 真正常数时间</td>
</tr>
<tr>
<td><strong>出队 (dequeue)</strong></td>
<td>O(1)<br/>（缩容时 O(n)）</td>
<td>O(1) 真正常数时间</td>
</tr>
<tr>
<td><strong>查看队头 (peek)</strong></td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>查看队尾 (last)</strong></td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>随机访问</strong></td>
<td>O(1) 支持</td>
<td>O(n) 不支持</td>
</tr>
<tr>
<td><strong>空间开销（每个元素）</strong></td>
<td>8 字节（指针）</td>
<td>16 字节（对象+指针）</td>
</tr>
<tr>
<td><strong>初始化</strong></td>
<td>O(n) 需预分配</td>
<td>O(1) 无需预分配</td>
</tr>
<tr>
<td><strong>清空队列</strong></td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody></table>
<h3 id="内存特性对比"><a href="#内存特性对比" class="headerlink" title="内存特性对比"></a>内存特性对比</h3><h4 id="1-内存占用"><a href="#1-内存占用" class="headerlink" title="1. 内存占用"></a>1. 内存占用</h4><p><strong>循环数组（LitQueue）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基础开销：</span><br><span class="line">- NSMutableArray 对象：约 32 字节</span><br><span class="line">- 数组内存：capacity × 8 字节（每个指针）</span><br><span class="line"></span><br><span class="line">实际占用示例（capacity = 100, count = 50）：</span><br><span class="line">32 + 100 × 8 = 832 字节</span><br><span class="line">空间利用率 = 50 / 100 = 50%</span><br></pre></td></tr></table></figure>

<p><strong>链表（LitLinkedQueue）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基础开销：</span><br><span class="line">- LitLinkedQueue 对象：约 32 字节</span><br><span class="line">- 每个节点：约 32 字节（对象头 + value + next 指针）</span><br><span class="line"></span><br><span class="line">实际占用示例（count = 50）：</span><br><span class="line">32 + 50 × 32 = 1632 字节</span><br><span class="line">空间利用率 = 100%（按需分配）</span><br></pre></td></tr></table></figure>

<h4 id="2-缓存友好性"><a href="#2-缓存友好性" class="headerlink" title="2. 缓存友好性"></a>2. 缓存友好性</h4><p><strong>循环数组</strong>：</p>
<ul>
<li>✅ 内存连续，CPU 缓存命中率高</li>
<li>✅ 适合现代 CPU 的预取机制</li>
<li>✅ 遍历性能优秀</li>
</ul>
<p><strong>链表</strong>：</p>
<ul>
<li>❌ 内存分散，缓存命中率低</li>
<li>❌ 节点跳转导致缓存失效</li>
<li>⚠️ 遍历性能相对较差</li>
</ul>
<h4 id="3-内存碎片"><a href="#3-内存碎片" class="headerlink" title="3. 内存碎片"></a>3. 内存碎片</h4><p><strong>循环数组</strong>：</p>
<ul>
<li>✅ 单次大块分配，碎片少</li>
<li>❌ 扩容时可能产生内存峰值</li>
</ul>
<p><strong>链表</strong>：</p>
<ul>
<li>⚠️ 频繁小对象分配，可能产生碎片</li>
<li>✅ 无扩容峰值</li>
</ul>
<h3 id="优缺点总结"><a href="#优缺点总结" class="headerlink" title="优缺点总结"></a>优缺点总结</h3><h4 id="循环数组（LitQueue）"><a href="#循环数组（LitQueue）" class="headerlink" title="循环数组（LitQueue）"></a>循环数组（LitQueue）</h4><p><strong>优点</strong>：</p>
<ol>
<li>✅ <strong>缓存友好</strong>：连续内存，遍历性能优秀</li>
<li>✅ <strong>支持随机访问</strong>：可通过索引快速访问任意位置元素</li>
<li>✅ <strong>内存占用相对较小</strong>：没有额外的节点对象开销</li>
<li>✅ <strong>空间局部性好</strong>：对 CPU 缓存友好</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>❌ <strong>需要预分配容量</strong>：初始化时需要指定大小</li>
<li>❌ <strong>扩容开销</strong>：满时需要 O(n) 的扩容操作，可能导致性能抖动</li>
<li>❌ <strong>空间浪费</strong>：容量大于实际元素数时会浪费空间</li>
<li>❌ <strong>扩容时内存峰值</strong>：扩容期间会同时存在新旧两个数组</li>
</ol>
<h4 id="链表（LitLinkedQueue）"><a href="#链表（LitLinkedQueue）" class="headerlink" title="链表（LitLinkedQueue）"></a>链表（LitLinkedQueue）</h4><p><strong>优点</strong>：</p>
<ol>
<li>✅ <strong>真正的 O(1) 操作</strong>：所有操作都是常数时间，无扩容</li>
<li>✅ <strong>无需预分配</strong>：按需分配，初始化快速</li>
<li>✅ <strong>动态增长</strong>：天然支持任意大小，不会满</li>
<li>✅ <strong>无内存峰值</strong>：没有扩容，内存增长平稳</li>
<li>✅ <strong>实现简单</strong>：代码更简洁，易于理解和维护</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>❌ <strong>节点开销</strong>：每个元素需要额外的节点对象（约 32 字节）</li>
<li>❌ <strong>缓存不友好</strong>：内存分散，CPU 缓存命中率低</li>
<li>❌ <strong>不支持随机访问</strong>：访问第 n 个元素需要 O(n) 时间</li>
<li>❌ <strong>内存碎片</strong>：频繁分配小对象可能产生碎片</li>
</ol>
<h3 id="代码复杂度对比"><a href="#代码复杂度对比" class="headerlink" title="代码复杂度对比"></a>代码复杂度对比</h3><p><strong>循环数组</strong>：</p>
<ul>
<li>代码量：约 210 行</li>
<li>需要处理：扩容、缩容、循环索引计算</li>
<li>维护成本：较高</li>
</ul>
<p><strong>链表</strong>：</p>
<ul>
<li>代码量：约 190 行</li>
<li>逻辑简单：只需维护头尾指针</li>
<li>维护成本：较低</li>
</ul>
<h2 id="适用场景分析"><a href="#适用场景分析" class="headerlink" title="适用场景分析"></a>适用场景分析</h2><h3 id="选择循环数组（LitQueue）的场景"><a href="#选择循环数组（LitQueue）的场景" class="headerlink" title="选择循环数组（LitQueue）的场景"></a>选择循环数组（LitQueue）的场景</h3><ol>
<li><p><strong>队列大小可预估且相对固定</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：音频缓冲队列，固定 1024 个采样点</span></span><br><span class="line">LitQueue *audioBuffer = [LitQueue queueWithCapacity:<span class="number">1024</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>需要频繁遍历队列</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：需要定期检查队列中所有任务的状态</span></span><br><span class="line"><span class="built_in">NSArray</span> *tasks = [queue toArray];</span><br><span class="line"><span class="keyword">for</span> (Task *task <span class="keyword">in</span> tasks) &#123;</span><br><span class="line">    [task checkStatus];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对内存占用敏感</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：嵌入式设备或内存受限环境</span></span><br><span class="line"><span class="comment">// 循环数组比链表节省约 50% 的内存</span></span><br><span class="line">LitQueue *messageQueue = [LitQueue queueWithCapacity:<span class="number">100</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对性能稳定性要求不高</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：非实时任务调度，可以容忍偶尔的扩容延迟</span></span><br><span class="line">LitQueue *backgroundTasks = [LitQueue queueWithCapacity:<span class="number">50</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>需要随机访问队列元素</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：消息队列中需要查看特定位置的消息</span></span><br><span class="line"><span class="comment">// 只有循环数组支持 O(1) 随机访问</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="选择链表（LitLinkedQueue）的场景"><a href="#选择链表（LitLinkedQueue）的场景" class="headerlink" title="选择链表（LitLinkedQueue）的场景"></a>选择链表（LitLinkedQueue）的场景</h3><ol>
<li><p><strong>队列大小不可预估或变化剧烈</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：网络请求队列，请求数量不确定</span></span><br><span class="line">LitLinkedQueue *requestQueue = [LitLinkedQueue queue];</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对性能稳定性要求高</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：实时音视频处理，不能有性能抖动</span></span><br><span class="line"><span class="comment">// 链表的所有操作都是真正的 O(1)</span></span><br><span class="line">LitLinkedQueue *frameQueue = [LitLinkedQueue queue];</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>入队出队频繁，很少遍历</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：生产者-消费者模型</span></span><br><span class="line">LitLinkedQueue *workQueue = [LitLinkedQueue queue];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(producerQueue, ^&#123;</span><br><span class="line">    <span class="keyword">while</span> (producing) &#123;</span><br><span class="line">        <span class="type">id</span> work = [<span class="keyword">self</span> produceWork];</span><br><span class="line">        [workQueue enqueue:work];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(consumerQueue, ^&#123;</span><br><span class="line">    <span class="keyword">while</span> (consuming) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!workQueue.isEmpty) &#123;</span><br><span class="line">            <span class="type">id</span> work = [workQueue dequeue];</span><br><span class="line">            [<span class="keyword">self</span> consumeWork:work];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>需要优先考虑代码简洁性</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表实现更简单，易于维护和扩展</span></span><br><span class="line">LitLinkedQueue *eventQueue = [LitLinkedQueue queue];</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>频繁创建和销毁队列</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：临时任务处理</span></span><br><span class="line"><span class="comment">// 链表无需预分配，创建更快</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    LitLinkedQueue *tempQueue = [LitLinkedQueue queue];</span><br><span class="line">    [<span class="keyword">self</span> processWithQueue:tempQueue];</span><br><span class="line">    <span class="comment">// 销毁时也更快</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="实际项目场景举例"><a href="#实际项目场景举例" class="headerlink" title="实际项目场景举例"></a>实际项目场景举例</h3><h4 id="场景-1：图片下载队列（推荐链表）"><a href="#场景-1：图片下载队列（推荐链表）" class="headerlink" title="场景 1：图片下载队列（推荐链表）"></a>场景 1：图片下载队列（推荐链表）</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ImageDownloader</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) LitLinkedQueue&lt;ImageDownloadTask *&gt; *downloadQueue;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ImageDownloader</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">        <span class="comment">// 使用链表：任务数量不确定，频繁入队出队</span></span><br><span class="line">        _downloadQueue = [LitLinkedQueue queue];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)downloadImage:(<span class="built_in">NSURL</span> *)url completion:(<span class="type">void</span>(^)(<span class="built_in">UIImage</span> *))completion &#123;</span><br><span class="line">    ImageDownloadTask *task = [[ImageDownloadTask alloc] initWithURL:url completion:completion];</span><br><span class="line">    [<span class="keyword">self</span>.downloadQueue enqueue:task];</span><br><span class="line">    [<span class="keyword">self</span> processNextTask];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)processNextTask &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.downloadQueue.isEmpty) &#123;</span><br><span class="line">        ImageDownloadTask *task = [<span class="keyword">self</span>.downloadQueue dequeue];</span><br><span class="line">        [<span class="keyword">self</span> executeTask:task];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p><strong>选择理由</strong>：</p>
<ul>
<li>下载任务数量不可预估</li>
<li>频繁入队出队，很少遍历</li>
<li>需要性能稳定，避免扩容抖动</li>
</ul>
<h4 id="场景-2：音频环形缓冲（推荐循环数组）"><a href="#场景-2：音频环形缓冲（推荐循环数组）" class="headerlink" title="场景 2：音频环形缓冲（推荐循环数组）"></a>场景 2：音频环形缓冲（推荐循环数组）</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AudioRingBuffer</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) LitQueue&lt;AudioSample *&gt; *sampleBuffer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AudioRingBuffer</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">        <span class="comment">// 使用循环数组：固定 4096 个采样点</span></span><br><span class="line">        _sampleBuffer = [LitQueue queueWithCapacity:<span class="number">4096</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)writeSample:(AudioSample *)sample &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.sampleBuffer.count == <span class="number">4096</span>) &#123;</span><br><span class="line">        <span class="comment">// 满了就丢弃最旧的样本</span></span><br><span class="line">        [<span class="keyword">self</span>.sampleBuffer dequeue];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.sampleBuffer enqueue:sample];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (AudioSample *)readSample &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.sampleBuffer.isEmpty) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span>.sampleBuffer dequeue];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p><strong>选择理由</strong>：</p>
<ul>
<li>缓冲区大小固定（4096）</li>
<li>对缓存友好性要求高（音频处理）</li>
<li>内存占用小</li>
<li>永远不会触发扩容（满了就覆盖）</li>
</ul>
<h4 id="场景-3：消息队列（推荐链表）"><a href="#场景-3：消息队列（推荐链表）" class="headerlink" title="场景 3：消息队列（推荐链表）"></a>场景 3：消息队列（推荐链表）</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MessageQueue</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) LitLinkedQueue&lt;Message *&gt; *pendingMessages;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MessageQueue</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">        <span class="comment">// 使用链表：消息数量波动大</span></span><br><span class="line">        _pendingMessages = [LitLinkedQueue queue];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)sendMessage:(Message *)message &#123;</span><br><span class="line">    [<span class="keyword">self</span>.pendingMessages enqueue:message];</span><br><span class="line">    [<span class="keyword">self</span> processMessages];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)processMessages &#123;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">self</span>.pendingMessages.isEmpty) &#123;</span><br><span class="line">        Message *message = [<span class="keyword">self</span>.pendingMessages dequeue];</span><br><span class="line">        [<span class="keyword">self</span> handleMessage:message];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p><strong>选择理由</strong>：</p>
<ul>
<li>消息数量完全不可预估</li>
<li>可能突然涌入大量消息</li>
<li>需要快速入队出队</li>
<li>避免扩容带来的延迟</li>
</ul>
<h2 id="性能测试对比"><a href="#性能测试对比" class="headerlink" title="性能测试对比"></a>性能测试对比</h2><p>下面是一个简单的性能测试，对比两种实现在不同操作下的表现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)performanceTest &#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> testCount = <span class="number">10000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试 1：连续入队</span></span><br><span class="line">    &#123;</span><br><span class="line">        LitQueue *arrayQueue = [LitQueue queueWithCapacity:<span class="number">10</span>];</span><br><span class="line">        LitLinkedQueue *linkedQueue = [LitLinkedQueue queue];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 循环数组：会触发多次扩容</span></span><br><span class="line">        <span class="built_in">CFTimeInterval</span> start1 = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; testCount; i++) &#123;</span><br><span class="line">            [arrayQueue enqueue:@(i)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">CFTimeInterval</span> time1 = <span class="built_in">CACurrentMediaTime</span>() - start1;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 链表：无扩容</span></span><br><span class="line">        <span class="built_in">CFTimeInterval</span> start2 = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; testCount; i++) &#123;</span><br><span class="line">            [linkedQueue enqueue:@(i)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">CFTimeInterval</span> time2 = <span class="built_in">CACurrentMediaTime</span>() - start2;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;入队 %ld 个元素:&quot;</span>, testCount);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;  循环数组: %.4f 秒 (含扩容)&quot;</span>, time1);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;  链表:     %.4f 秒&quot;</span>, time2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试 2：入队+出队混合</span></span><br><span class="line">    &#123;</span><br><span class="line">        LitQueue *arrayQueue = [LitQueue queueWithCapacity:<span class="number">1000</span>];</span><br><span class="line">        LitLinkedQueue *linkedQueue = [LitLinkedQueue queue];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CFTimeInterval</span> start1 = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; testCount; i++) &#123;</span><br><span class="line">            [arrayQueue enqueue:@(i)];</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; !arrayQueue.isEmpty) &#123;</span><br><span class="line">                [arrayQueue dequeue];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">CFTimeInterval</span> time1 = <span class="built_in">CACurrentMediaTime</span>() - start1;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CFTimeInterval</span> start2 = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; testCount; i++) &#123;</span><br><span class="line">            [linkedQueue enqueue:@(i)];</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; !linkedQueue.isEmpty) &#123;</span><br><span class="line">                [linkedQueue dequeue];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">CFTimeInterval</span> time2 = <span class="built_in">CACurrentMediaTime</span>() - start2;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;\n混合操作 %ld 次:&quot;</span>, testCount);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;  循环数组: %.4f 秒&quot;</span>, time1);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;  链表:     %.4f 秒&quot;</span>, time2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试 3：遍历性能</span></span><br><span class="line">    &#123;</span><br><span class="line">        LitQueue *arrayQueue = [LitQueue queueWithCapacity:testCount];</span><br><span class="line">        LitLinkedQueue *linkedQueue = [LitLinkedQueue queue];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; testCount; i++) &#123;</span><br><span class="line">            [arrayQueue enqueue:@(i)];</span><br><span class="line">            [linkedQueue enqueue:@(i)];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CFTimeInterval</span> start1 = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">        <span class="built_in">NSArray</span> *array1 = [arrayQueue toArray];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">id</span> obj <span class="keyword">in</span> array1) &#123;</span><br><span class="line">            <span class="comment">// 模拟访问</span></span><br><span class="line">            [obj description];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">CFTimeInterval</span> time1 = <span class="built_in">CACurrentMediaTime</span>() - start1;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CFTimeInterval</span> start2 = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">        <span class="built_in">NSArray</span> *array2 = [linkedQueue toArray];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">id</span> obj <span class="keyword">in</span> array2) &#123;</span><br><span class="line">            <span class="comment">// 模拟访问</span></span><br><span class="line">            [obj description];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">CFTimeInterval</span> time2 = <span class="built_in">CACurrentMediaTime</span>() - start2;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;\n遍历 %ld 个元素:&quot;</span>, testCount);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;  循环数组: %.4f 秒&quot;</span>, time1);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;  链表:     %.4f 秒&quot;</span>, time2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>典型测试结果</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">入队 10000 个元素:</span><br><span class="line">  循环数组: 0.0023 秒 (含扩容)</span><br><span class="line">  链表:     0.0018 秒</span><br><span class="line"></span><br><span class="line">混合操作 10000 次:</span><br><span class="line">  循环数组: 0.0015 秒</span><br><span class="line">  链表:     0.0012 秒</span><br><span class="line"></span><br><span class="line">遍历 10000 个元素:</span><br><span class="line">  循环数组: 0.0008 秒</span><br><span class="line">  链表:     0.0012 秒</span><br></pre></td></tr></table></figure>

<p><strong>测试结论</strong>：</p>
<ol>
<li>链表在频繁入队时性能更稳定（无扩容抖动）</li>
<li>循环数组在遍历时性能更优（缓存友好）</li>
<li>混合操作下两者性能接近</li>
<li>实际差异在微秒级别，选择时应更关注适用场景</li>
</ol>
<h2 id="线程安全考虑"><a href="#线程安全考虑" class="headerlink" title="线程安全考虑"></a>线程安全考虑</h2><p>上述两种实现都<strong>不是线程安全</strong>的。在多线程环境下使用时，需要添加同步机制：</p>
<h3 id="方案-1：使用锁"><a href="#方案-1：使用锁" class="headerlink" title="方案 1：使用锁"></a>方案 1：使用锁</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ThreadSafeQueue</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) LitLinkedQueue *queue;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSLock</span> *lock;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ThreadSafeQueue</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">        _queue = [LitLinkedQueue queue];</span><br><span class="line">        _lock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)enqueue:(<span class="type">id</span>)object &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    [<span class="keyword">self</span>.queue enqueue:object];</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)dequeue &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="type">id</span> object = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.queue.isEmpty) &#123;</span><br><span class="line">        object = [<span class="keyword">self</span>.queue dequeue];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="方案-2：使用-GCD-串行队列"><a href="#方案-2：使用-GCD-串行队列" class="headerlink" title="方案 2：使用 GCD 串行队列"></a>方案 2：使用 GCD 串行队列</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ConcurrentQueue</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) LitLinkedQueue *queue;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">dispatch_queue_t</span> syncQueue;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ConcurrentQueue</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">        _queue = [LitLinkedQueue queue];</span><br><span class="line">        _syncQueue = dispatch_queue_create(<span class="string">&quot;com.example.queue&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)enqueue:(<span class="type">id</span>)object &#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.syncQueue, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span>.queue enqueue:object];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)dequeue &#123;</span><br><span class="line">    __block <span class="type">id</span> object = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.syncQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.queue.isEmpty) &#123;</span><br><span class="line">            object = [<span class="keyword">self</span>.queue dequeue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h2 id="最佳实践建议"><a href="#最佳实践建议" class="headerlink" title="最佳实践建议"></a>最佳实践建议</h2><h3 id="1-根据场景选择"><a href="#1-根据场景选择" class="headerlink" title="1. 根据场景选择"></a>1. 根据场景选择</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ 好的选择</span></span><br><span class="line"><span class="comment">// 场景：固定大小的音频缓冲</span></span><br><span class="line">LitQueue *audioBuffer = [LitQueue queueWithCapacity:<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 好的选择</span></span><br><span class="line"><span class="comment">// 场景：网络请求队列，数量不确定</span></span><br><span class="line">LitLinkedQueue *requestQueue = [LitLinkedQueue queue];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 不好的选择</span></span><br><span class="line"><span class="comment">// 场景：任务数量不确定，但用了固定容量</span></span><br><span class="line">LitQueue *taskQueue = [LitQueue queueWithCapacity:<span class="number">10</span>]; <span class="comment">// 可能频繁扩容</span></span><br></pre></td></tr></table></figure>

<h3 id="2-合理设置初始容量"><a href="#2-合理设置初始容量" class="headerlink" title="2. 合理设置初始容量"></a>2. 合理设置初始容量</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ 好的做法：根据历史数据设置合理的初始容量</span></span><br><span class="line"><span class="comment">// 假设 90% 的情况下任务数不超过 100</span></span><br><span class="line">LitQueue *taskQueue = [LitQueue queueWithCapacity:<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 不好的做法：容量过小，频繁扩容</span></span><br><span class="line">LitQueue *taskQueue = [LitQueue queueWithCapacity:<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 不好的做法：容量过大，浪费内存</span></span><br><span class="line">LitQueue *taskQueue = [LitQueue queueWithCapacity:<span class="number">100000</span>];</span><br></pre></td></tr></table></figure>

<h3 id="3-注意内存管理"><a href="#3-注意内存管理" class="headerlink" title="3. 注意内存管理"></a>3. 注意内存管理</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ 好的做法：及时清空不再使用的队列</span></span><br><span class="line">[queue removeAllObjects];</span><br><span class="line">queue = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 好的做法：使用弱引用避免循环引用</span></span><br><span class="line">@weakify(<span class="keyword">self</span>);</span><br><span class="line">[queue enqueue:^&#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>);</span><br><span class="line">    [<span class="keyword">self</span> doSomething];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h3 id="4-异常处理"><a href="#4-异常处理" class="headerlink" title="4. 异常处理"></a>4. 异常处理</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ 好的做法：检查队列状态</span></span><br><span class="line"><span class="keyword">if</span> (!queue.isEmpty) &#123;</span><br><span class="line">    <span class="type">id</span> obj = [queue dequeue];</span><br><span class="line">    [<span class="keyword">self</span> process:obj];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 不好的做法：不检查直接出队（会抛异常）</span></span><br><span class="line"><span class="type">id</span> obj = [queue dequeue]; <span class="comment">// 队列为空时 Crash</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文的详细对比，我们可以得出以下结论：</p>
<h3 id="关键区别"><a href="#关键区别" class="headerlink" title="关键区别"></a>关键区别</h3><table>
<thead>
<tr>
<th>维度</th>
<th>循环数组</th>
<th>链表</th>
</tr>
</thead>
<tbody><tr>
<td><strong>核心思想</strong></td>
<td>预分配+循环索引</td>
<td>动态节点+指针</td>
</tr>
<tr>
<td><strong>性能特点</strong></td>
<td>O(1) 摊销</td>
<td>O(1) 真实</td>
</tr>
<tr>
<td><strong>内存占用</strong></td>
<td>较小但可能浪费</td>
<td>较大但按需分配</td>
</tr>
<tr>
<td><strong>缓存友好</strong></td>
<td>优秀</td>
<td>较差</td>
</tr>
<tr>
<td><strong>代码复杂度</strong></td>
<td>较高</td>
<td>较低</td>
</tr>
</tbody></table>
<h3 id="选择建议"><a href="#选择建议" class="headerlink" title="选择建议"></a>选择建议</h3><p><strong>选择循环数组（LitQueue）当</strong>：</p>
<ul>
<li>✅ 队列大小可预估</li>
<li>✅ 需要频繁遍历</li>
<li>✅ 内存受限</li>
<li>✅ 需要随机访问</li>
</ul>
<p><strong>选择链表（LitLinkedQueue）当</strong>：</p>
<ul>
<li>✅ 队列大小不确定</li>
<li>✅ 对性能稳定性要求高</li>
<li>✅ 频繁入队出队</li>
<li>✅ 很少遍历队列</li>
</ul>
<h3 id="最终建议"><a href="#最终建议" class="headerlink" title="最终建议"></a>最终建议</h3><p>在实际项目中，<strong>链表实现（LitLinkedQueue）是更通用的选择</strong>，因为：</p>
<ol>
<li>真正的 O(1) 性能，无扩容抖动</li>
<li>实现简单，易于维护</li>
<li>适应性强，适合大多数场景</li>
</ol>
<p>只有在以下明确需求时，才考虑使用循环数组：</p>
<ol>
<li>队列大小固定或可准确预估</li>
<li>需要高频遍历或随机访问</li>
<li>对内存占用极度敏感</li>
</ol>
<p>记住：<strong>过早优化是万恶之源</strong>。如果不确定，就选择更简单、更通用的链表实现。等到真正遇到性能瓶颈时，再根据 Profiling 结果进行针对性优化。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2RvY3VtZW50YXRpb24vZm91bmRhdGlvbi9uc211dGFibGVhcnJheQ==">Apple Developer Documentation - NSMutableArray<i class="fa fa-external-link-alt"></i></span></li>
<li><a href="/2025/10/18/20251018-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84%E8%AF%A6%E8%A7%A3/">数据结构：循环数组详解</a></li>
<li>Thomas H. Cormen et al. 《算法导论》（第3版）</li>
<li>Robert Sedgewick, Kevin Wayne. 《算法》（第4版）</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUXVldWVfKGFic3RyYWN0X2RhdGFfdHlwZSk=">Queue (abstract data type) - Wikipedia<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>iOS</tag>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 中的 MMap 内存映射技术详解</title>
    <url>/2025/10/18/20251018-iOS%20%E4%B8%AD%E7%9A%84%20MMap%20%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="什么是-MMap"><a href="#什么是-MMap" class="headerlink" title="什么是 MMap"></a>什么是 MMap</h2><p>MMap（Memory Mapping）是一种内存映射技术，它允许将文件或其他对象映射到进程的地址空间。在 iOS 开发中，mmap 是一个强大的系统调用，能够将磁盘文件的内容直接映射到内存地址空间，使得对文件的读写操作可以像访问内存一样简单高效。</p>
<p>与传统的文件 I&#x2F;O（通过 <code>read()</code>&#x2F;<code>write()</code> 系统调用）不同，mmap 通过虚拟内存机制，让应用程序可以像访问数组一样访问文件内容，操作系统会自动处理磁盘和内存之间的数据传输。</p>
<h3 id="核心特点"><a href="#核心特点" class="headerlink" title="核心特点"></a>核心特点</h3><ul>
<li><strong>零拷贝</strong>：数据不需要在用户空间和内核空间之间复制</li>
<li><strong>延迟加载</strong>：只有真正访问数据时才从磁盘加载（页面调度）</li>
<li><strong>共享内存</strong>：多个进程可以映射同一文件实现进程间通信</li>
<li><strong>高效访问</strong>：随机访问文件时性能更优</li>
</ul>
<span id="more"></span>

<h2 id="MMap-的工作原理"><a href="#MMap-的工作原理" class="headerlink" title="MMap 的工作原理"></a>MMap 的工作原理</h2><h3 id="传统文件-I-O-流程"><a href="#传统文件-I-O-流程" class="headerlink" title="传统文件 I&#x2F;O 流程"></a>传统文件 I&#x2F;O 流程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">应用程序 -&gt; read() -&gt; 内核缓冲区 -&gt; 用户空间缓冲区 -&gt; 应用程序</span><br><span class="line">磁盘    -&gt; DMA    -&gt; 内核缓冲区</span><br></pre></td></tr></table></figure>

<p>这个过程涉及多次数据拷贝：</p>
<ol>
<li>磁盘数据通过 DMA 拷贝到内核缓冲区</li>
<li>内核缓冲区数据拷贝到用户空间缓冲区</li>
<li>应用程序从用户空间缓冲区读取数据</li>
</ol>
<h3 id="MMap-文件映射流程"><a href="#MMap-文件映射流程" class="headerlink" title="MMap 文件映射流程"></a>MMap 文件映射流程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">应用程序 -&gt; 直接访问虚拟内存 -&gt; 页表映射 -&gt; 物理内存/磁盘</span><br></pre></td></tr></table></figure>

<p>使用 mmap 后：</p>
<ol>
<li>文件被映射到进程的虚拟地址空间</li>
<li>访问映射区域时触发缺页中断</li>
<li>操作系统自动从磁盘加载数据页到物理内存</li>
<li>应用程序直接读写内存，无需额外拷贝</li>
</ol>
<h3 id="虚拟内存与页面调度"><a href="#虚拟内存与页面调度" class="headerlink" title="虚拟内存与页面调度"></a>虚拟内存与页面调度</h3><p>mmap 依赖于操作系统的虚拟内存机制：</p>
<ul>
<li><strong>虚拟地址空间</strong>：应用程序看到的是连续的虚拟地址</li>
<li><strong>物理内存页</strong>：实际数据存储在物理内存页中</li>
<li><strong>页表映射</strong>：虚拟地址通过页表映射到物理地址</li>
<li><strong>按需加载</strong>：只有访问时才加载对应页面（Lazy Loading）</li>
</ul>
<h2 id="MMap-的优势与劣势"><a href="#MMap-的优势与劣势" class="headerlink" title="MMap 的优势与劣势"></a>MMap 的优势与劣势</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p><strong>1. 性能优势</strong></p>
<ul>
<li>减少数据拷贝次数（零拷贝技术）</li>
<li>随机访问效率高，无需频繁 seek</li>
<li>大文件处理时节省内存（不需要一次性加载）</li>
</ul>
<p><strong>2. 编程便利性</strong></p>
<ul>
<li>像操作数组一样操作文件</li>
<li>无需手动管理缓冲区</li>
<li>多进程可以共享内存映射</li>
</ul>
<p><strong>3. 系统优化</strong></p>
<ul>
<li>操作系统自动管理页面换入换出</li>
<li>利用文件系统的缓存机制</li>
<li>支持写时复制（Copy-on-Write）</li>
</ul>
<h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><p><strong>1. 内存压力</strong></p>
<ul>
<li>映射大文件会占用虚拟地址空间</li>
<li>32位系统地址空间有限</li>
<li>可能触发频繁的页面换入换出</li>
</ul>
<p><strong>2. 使用限制</strong></p>
<ul>
<li>不适合小文件（映射开销大于直接读写）</li>
<li>顺序读取时可能不如流式读取高效</li>
<li>映射失败时错误处理复杂</li>
</ul>
<p><strong>3. 并发问题</strong></p>
<ul>
<li>多进程写入需要额外的同步机制</li>
<li>文件大小变化时需要重新映射</li>
<li>内存映射区域的错误可能导致崩溃</li>
</ul>
<h2 id="iOS-中-MMap-的应用场景"><a href="#iOS-中-MMap-的应用场景" class="headerlink" title="iOS 中 MMap 的应用场景"></a>iOS 中 MMap 的应用场景</h2><h3 id="1-大文件读取"><a href="#1-大文件读取" class="headerlink" title="1. 大文件读取"></a>1. 大文件读取</h3><p>处理大型日志文件、数据库文件时，使用 mmap 可以避免将整个文件加载到内存：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统方式（不推荐大文件）</span></span><br><span class="line"><span class="keyword">let</span> data <span class="operator">=</span> <span class="keyword">try</span> <span class="type">Data</span>(contentsOf: fileURL) <span class="comment">// 一次性加载全部内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mmap 方式（推荐）</span></span><br><span class="line"><span class="keyword">let</span> data <span class="operator">=</span> <span class="keyword">try</span> <span class="type">Data</span>(contentsOf: fileURL, options: .alwaysMapped)</span><br></pre></td></tr></table></figure>

<h3 id="2-进程间通信（IPC）"><a href="#2-进程间通信（IPC）" class="headerlink" title="2. 进程间通信（IPC）"></a>2. 进程间通信（IPC）</h3><p>通过共享内存映射实现高效的进程间通信：</p>
<ul>
<li>App 和 Extension 之间共享数据</li>
<li>多进程架构中的数据共享</li>
<li>插件系统的数据交换</li>
</ul>
<h3 id="3-数据持久化"><a href="#3-数据持久化" class="headerlink" title="3. 数据持久化"></a>3. 数据持久化</h3><p>许多高性能数据库使用 mmap 来实现数据持久化：</p>
<ul>
<li>MMKV（微信开源的高性能键值存储）</li>
<li>LMDB（Lightning Memory-Mapped Database）</li>
<li>Realm（部分场景使用 mmap）</li>
</ul>
<h3 id="4-图片解码优化"><a href="#4-图片解码优化" class="headerlink" title="4. 图片解码优化"></a>4. 图片解码优化</h3><p>在图片加载和解码时，使用 mmap 可以减少内存峰值：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 mmap 映射图片文件</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> data <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">Data</span>(contentsOf: imageURL, options: .mappedIfSafe) &#123;</span><br><span class="line">    <span class="keyword">let</span> image <span class="operator">=</span> <span class="type">UIImage</span>(data: data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-日志系统"><a href="#5-日志系统" class="headerlink" title="5. 日志系统"></a>5. 日志系统</h3><p>高性能日志库通常使用 mmap 来实现异步写入：</p>
<ul>
<li>减少日志写入对主线程的影响</li>
<li>崩溃时日志不丢失</li>
<li>支持大量日志快速写入</li>
</ul>
<h2 id="MMap-的基本使用"><a href="#MMap-的基本使用" class="headerlink" title="MMap 的基本使用"></a>MMap 的基本使用</h2><h3 id="C-语言-API"><a href="#C-语言-API" class="headerlink" title="C 语言 API"></a>C 语言 API</h3><div class="tabs" id="mmap-基本使用"><ul class="nav-tabs"><li class="tab active"><a href="#mmap-基本使用-1">C API</a></li><li class="tab"><a href="#mmap-基本使用-2">Objective-C</a></li><li class="tab"><a href="#mmap-基本使用-3">Swift</a></li></ul><div class="tab-content"><div class="tab-pane active" id="mmap-基本使用-1"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/path/to/file&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件大小</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line"><span class="keyword">if</span> (fstat(fd, &amp;sb) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;fstat&quot;</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存映射</span></span><br><span class="line"><span class="type">void</span> *addr = mmap(<span class="literal">NULL</span>,                    <span class="comment">// 让系统选择映射地址</span></span><br><span class="line">                  sb.st_size,              <span class="comment">// 映射大小</span></span><br><span class="line">                  PROT_READ | PROT_WRITE,  <span class="comment">// 读写权限</span></span><br><span class="line">                  MAP_SHARED,              <span class="comment">// 共享映射</span></span><br><span class="line">                  fd,                      <span class="comment">// 文件描述符</span></span><br><span class="line">                  <span class="number">0</span>);                      <span class="comment">// 文件偏移量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (addr == MAP_FAILED) &#123;</span><br><span class="line">    perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用映射区域</span></span><br><span class="line"><span class="type">char</span> *data = (<span class="type">char</span> *)addr;</span><br><span class="line">data[<span class="number">0</span>] = <span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">data[<span class="number">1</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">data[<span class="number">2</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">data[<span class="number">3</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">data[<span class="number">4</span>] = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步到磁盘（可选）</span></span><br><span class="line">msync(addr, sb.st_size, MS_SYNC);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除映射</span></span><br><span class="line">munmap(addr, sb.st_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭文件</span></span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="mmap-基本使用-2"><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MMapHelper</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSData</span> *)mapFileAtPath:(<span class="built_in">NSString</span> *)path error:(<span class="built_in">NSError</span> **)error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MMapHelper</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSData</span> *)mapFileAtPath:(<span class="built_in">NSString</span> *)path error:(<span class="built_in">NSError</span> **)error &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *filePath = [path UTF8String];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(filePath, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSPOSIXErrorDomain</span></span><br><span class="line">                                        code:errno</span><br><span class="line">                                    userInfo:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取文件大小</span></span><br><span class="line">    <span class="keyword">struct</span> stat sb;</span><br><span class="line">    <span class="keyword">if</span> (fstat(fd, &amp;sb) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSPOSIXErrorDomain</span></span><br><span class="line">                                        code:errno</span><br><span class="line">                                    userInfo:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内存映射</span></span><br><span class="line">    <span class="type">void</span> *addr = mmap(<span class="literal">NULL</span>, sb.st_size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">    close(fd); <span class="comment">// 映射后可以关闭文件描述符</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (addr == MAP_FAILED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSPOSIXErrorDomain</span></span><br><span class="line">                                        code:errno</span><br><span class="line">                                    userInfo:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 包装为 NSData</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSData</span> dataWithBytesNoCopy:addr</span><br><span class="line">                                length:sb.st_size</span><br><span class="line">                          freeWhenDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="built_in">NSData</span> *data = [MMapHelper mapFileAtPath:<span class="string">@&quot;/path/to/file&quot;</span> error:&amp;error];</span><br><span class="line"><span class="keyword">if</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 直接访问数据</span></span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *bytes = data.bytes;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;First byte: %c&quot;</span>, bytes[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="mmap-基本使用-3"><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MMapHelper</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 使用 mmap 映射文件</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">mapFile</span>(<span class="params">at</span> <span class="params">url</span>: <span class="type">URL</span>) <span class="keyword">throws</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> fd <span class="operator">=</span> <span class="keyword">open</span>(url.path, <span class="type">O_RDONLY</span>)</span><br><span class="line">        <span class="keyword">guard</span> fd <span class="operator">&gt;=</span> <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">NSError</span>(domain: <span class="type">NSPOSIXErrorDomain</span>, code: <span class="type">Int</span>(errno))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> &#123; close(fd) &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取文件大小</span></span><br><span class="line">        <span class="keyword">var</span> sb <span class="operator">=</span> stat()</span><br><span class="line">        <span class="keyword">guard</span> fstat(fd, <span class="operator">&amp;</span>sb) <span class="operator">==</span> <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">NSError</span>(domain: <span class="type">NSPOSIXErrorDomain</span>, code: <span class="type">Int</span>(errno))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> size <span class="operator">=</span> <span class="type">Int</span>(sb.st_size)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 内存映射</span></span><br><span class="line">        <span class="keyword">let</span> addr <span class="operator">=</span> mmap(<span class="literal">nil</span>, size, <span class="type">PROT_READ</span>, <span class="type">MAP_PRIVATE</span>, fd, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">guard</span> addr <span class="operator">!=</span> <span class="type">MAP_FAILED</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">NSError</span>(domain: <span class="type">NSPOSIXErrorDomain</span>, code: <span class="type">Int</span>(errno))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 包装为 Data（自动管理内存）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Data</span>(bytesNoCopy: addr<span class="operator">!</span>, count: size, deallocator: .custom &#123; ptr, length <span class="keyword">in</span></span><br><span class="line">            munmap(ptr, length)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 使用系统 API（推荐）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">mapFileUsingFoundation</span>(<span class="params">at</span> <span class="params">url</span>: <span class="type">URL</span>) <span class="keyword">throws</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> <span class="type">Data</span>(contentsOf: url, options: .alwaysMapped)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> fileURL <span class="operator">=</span> <span class="type">URL</span>(fileURLWithPath: <span class="string">&quot;/path/to/file&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> data <span class="operator">=</span> <span class="keyword">try</span> <span class="type">MMapHelper</span>.mapFile(at: fileURL)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问数据</span></span><br><span class="line">    data.withUnsafeBytes &#123; (ptr: <span class="type">UnsafeRawBufferPointer</span>) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> baseAddress <span class="operator">=</span> ptr.baseAddress &#123;</span><br><span class="line">            <span class="keyword">let</span> firstByte <span class="operator">=</span> baseAddress.load(as: <span class="type">UInt8</span>.<span class="keyword">self</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;First byte: <span class="subst">\(firstByte)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error: <span class="subst">\(error)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="高级用法：共享内存"><a href="#高级用法：共享内存" class="headerlink" title="高级用法：共享内存"></a>高级用法：共享内存</h2><p>使用 mmap 实现进程间通信（IPC）：</p>
<div class="tabs" id="共享内存"><ul class="nav-tabs"><li class="tab active"><a href="#共享内存-1">Swift</a></li><li class="tab"><a href="#共享内存-2">Objective-C</a></li></ul><div class="tab-content"><div class="tab-pane active" id="共享内存-1"><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedMemory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> fileDescriptor: <span class="type">Int32</span> <span class="operator">=</span> <span class="operator">-</span><span class="number">1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mappedAddress: <span class="type">UnsafeMutableRawPointer</span>?</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> size: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">size</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.size <span class="operator">=</span> size</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 创建共享内存</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">create</span>() <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="comment">// 创建共享内存对象</span></span><br><span class="line">        fileDescriptor <span class="operator">=</span> shm_open(name, <span class="type">O_CREAT</span> <span class="operator">|</span> <span class="type">O_RDWR</span>, <span class="type">S_IRUSR</span> <span class="operator">|</span> <span class="type">S_IWUSR</span>)</span><br><span class="line">        <span class="keyword">guard</span> fileDescriptor <span class="operator">&gt;=</span> <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">NSError</span>(domain: <span class="type">NSPOSIXErrorDomain</span>, code: <span class="type">Int</span>(errno))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置共享内存大小</span></span><br><span class="line">        <span class="keyword">guard</span> ftruncate(fileDescriptor, off_t(size)) <span class="operator">==</span> <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">NSError</span>(domain: <span class="type">NSPOSIXErrorDomain</span>, code: <span class="type">Int</span>(errno))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 映射到进程地址空间</span></span><br><span class="line">        mappedAddress <span class="operator">=</span> mmap(<span class="literal">nil</span>, size, <span class="type">PROT_READ</span> <span class="operator">|</span> <span class="type">PROT_WRITE</span>, <span class="type">MAP_SHARED</span>, fileDescriptor, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">guard</span> mappedAddress <span class="operator">!=</span> <span class="type">MAP_FAILED</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">NSError</span>(domain: <span class="type">NSPOSIXErrorDomain</span>, code: <span class="type">Int</span>(errno))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 打开已存在的共享内存</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">open</span>() <span class="keyword">throws</span> &#123;</span><br><span class="line">        fileDescriptor <span class="operator">=</span> shm_open(name, <span class="type">O_RDWR</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">guard</span> fileDescriptor <span class="operator">&gt;=</span> <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">NSError</span>(domain: <span class="type">NSPOSIXErrorDomain</span>, code: <span class="type">Int</span>(errno))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        mappedAddress <span class="operator">=</span> mmap(<span class="literal">nil</span>, size, <span class="type">PROT_READ</span> <span class="operator">|</span> <span class="type">PROT_WRITE</span>, <span class="type">MAP_SHARED</span>, fileDescriptor, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">guard</span> mappedAddress <span class="operator">!=</span> <span class="type">MAP_FAILED</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">NSError</span>(domain: <span class="type">NSPOSIXErrorDomain</span>, code: <span class="type">Int</span>(errno))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 写入数据</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">write</span>(<span class="params">data</span>: <span class="type">Data</span>) &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> address <span class="operator">=</span> mappedAddress <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        data.withUnsafeBytes &#123; ptr <span class="keyword">in</span></span><br><span class="line">            memcpy(address, ptr.baseAddress, <span class="built_in">min</span>(data.count, size))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 读取数据</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">read</span>(<span class="params">length</span>: <span class="type">Int</span>) -&gt; <span class="type">Data</span>? &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> address <span class="operator">=</span> mappedAddress <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Data</span>(bytes: address, count: <span class="built_in">min</span>(length, size))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 清理资源</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">close</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> address <span class="operator">=</span> mappedAddress &#123;</span><br><span class="line">            munmap(address, size)</span><br><span class="line">            mappedAddress <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> fileDescriptor <span class="operator">&gt;=</span> <span class="number">0</span> &#123;</span><br><span class="line">            <span class="type">Darwin</span>.close(fileDescriptor)</span><br><span class="line">            fileDescriptor <span class="operator">=</span> <span class="operator">-</span><span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 删除共享内存</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">unlink</span>() &#123;</span><br><span class="line">        shm_unlink(name)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程 A：创建并写入</span></span><br><span class="line"><span class="keyword">let</span> sharedMem <span class="operator">=</span> <span class="type">SharedMemory</span>(name: <span class="string">&quot;/my_shared_memory&quot;</span>, size: <span class="number">1024</span>)</span><br><span class="line"><span class="keyword">try?</span> sharedMem.create()</span><br><span class="line"><span class="keyword">let</span> message <span class="operator">=</span> <span class="string">&quot;Hello from Process A&quot;</span>.data(using: .utf8)<span class="operator">!</span></span><br><span class="line">sharedMem.write(data: message)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程 B：读取</span></span><br><span class="line"><span class="keyword">let</span> sharedMem2 <span class="operator">=</span> <span class="type">SharedMemory</span>(name: <span class="string">&quot;/my_shared_memory&quot;</span>, size: <span class="number">1024</span>)</span><br><span class="line"><span class="keyword">try?</span> sharedMem2.open()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> data <span class="operator">=</span> sharedMem2.read(length: <span class="number">1024</span>),</span><br><span class="line">   <span class="keyword">let</span> message <span class="operator">=</span> <span class="type">String</span>(data: data, encoding: .utf8) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Received: <span class="subst">\(message)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="共享内存-2"><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SharedMemory</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) size_t size;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name size:(size_t)size;</span><br><span class="line">- (<span class="type">BOOL</span>)create:(<span class="built_in">NSError</span> **)error;</span><br><span class="line">- (<span class="type">BOOL</span>)open:(<span class="built_in">NSError</span> **)error;</span><br><span class="line">- (<span class="type">void</span>)writeData:(<span class="built_in">NSData</span> *)data;</span><br><span class="line">- (<span class="built_in">NSData</span> *)readDataWithLength:(size_t)length;</span><br><span class="line">- (<span class="type">void</span>)close;</span><br><span class="line">- (<span class="type">void</span>)unlink;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SharedMemory</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _fd;</span><br><span class="line">    <span class="type">void</span> *_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name size:(size_t)size &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">        _name = name;</span><br><span class="line">        _size = size;</span><br><span class="line">        _fd = <span class="number">-1</span>;</span><br><span class="line">        _addr = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)create:(<span class="built_in">NSError</span> **)error &#123;</span><br><span class="line">    _fd = shm_open([_name UTF8String], O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);</span><br><span class="line">    <span class="keyword">if</span> (_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSPOSIXErrorDomain</span></span><br><span class="line">                                        code:errno</span><br><span class="line">                                    userInfo:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ftruncate(_fd, _size) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSPOSIXErrorDomain</span></span><br><span class="line">                                        code:errno</span><br><span class="line">                                    userInfo:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        close(_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _addr = mmap(<span class="literal">NULL</span>, _size, PROT_READ | PROT_WRITE, MAP_SHARED, _fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (_addr == MAP_FAILED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSPOSIXErrorDomain</span></span><br><span class="line">                                        code:errno</span><br><span class="line">                                    userInfo:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        close(_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)open:(<span class="built_in">NSError</span> **)error &#123;</span><br><span class="line">    _fd = shm_open([_name UTF8String], O_RDWR, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSPOSIXErrorDomain</span></span><br><span class="line">                                        code:errno</span><br><span class="line">                                    userInfo:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _addr = mmap(<span class="literal">NULL</span>, _size, PROT_READ | PROT_WRITE, MAP_SHARED, _fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (_addr == MAP_FAILED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSPOSIXErrorDomain</span></span><br><span class="line">                                        code:errno</span><br><span class="line">                                    userInfo:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        close(_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)writeData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="keyword">if</span> (_addr) &#123;</span><br><span class="line">        memcpy(_addr, data.bytes, MIN(data.length, _size));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSData</span> *)readDataWithLength:(size_t)length &#123;</span><br><span class="line">    <span class="keyword">if</span> (_addr) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSData</span> dataWithBytes:_addr length:MIN(length, _size)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)close &#123;</span><br><span class="line">    <span class="keyword">if</span> (_addr) &#123;</span><br><span class="line">        munmap(_addr, _size);</span><br><span class="line">        _addr = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        close(_fd);</span><br><span class="line">        _fd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)unlink &#123;</span><br><span class="line">    shm_unlink([_name UTF8String]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span> close];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="实战案例：高性能日志系统"><a href="#实战案例：高性能日志系统" class="headerlink" title="实战案例：高性能日志系统"></a>实战案例：高性能日志系统</h2><p>使用 mmap 实现一个简单的日志系统：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MMapLogger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> fileURL: <span class="type">URL</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> fileHandle: <span class="type">FileHandle</span>?</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mappedData: <span class="type">UnsafeMutableRawPointer</span>?</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mappedSize: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> writeOffset: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> maxFileSize: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">DispatchQueue</span>(label: <span class="string">&quot;com.logger.mmap&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">logPath</span>: <span class="type">String</span>, <span class="params">maxSize</span>: <span class="type">Int</span> <span class="operator">=</span> <span class="number">10</span> <span class="operator">*</span> <span class="number">1024</span> <span class="operator">*</span> <span class="number">1024</span>) &#123; <span class="comment">// 默认 10MB</span></span><br><span class="line">        <span class="keyword">self</span>.fileURL <span class="operator">=</span> <span class="type">URL</span>(fileURLWithPath: logPath)</span><br><span class="line">        <span class="keyword">self</span>.maxFileSize <span class="operator">=</span> maxSize</span><br><span class="line">        setupLogFile()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">setupLogFile</span>() &#123;</span><br><span class="line">        <span class="comment">// 创建文件（如果不存在）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="operator">!</span><span class="type">FileManager</span>.default.fileExists(atPath: fileURL.path) &#123;</span><br><span class="line">            <span class="type">FileManager</span>.default.createFile(atPath: fileURL.path, contents: <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 打开文件</span></span><br><span class="line">            fileHandle <span class="operator">=</span> <span class="keyword">try</span> <span class="type">FileHandle</span>(forUpdating: fileURL)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 扩展文件到指定大小</span></span><br><span class="line">            <span class="keyword">try</span> fileHandle<span class="operator">?</span>.truncate(atOffset: <span class="type">UInt64</span>(maxFileSize))</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 映射文件</span></span><br><span class="line">            <span class="keyword">let</span> fd <span class="operator">=</span> fileHandle<span class="operator">!</span>.fileDescriptor</span><br><span class="line">            mappedData <span class="operator">=</span> mmap(<span class="literal">nil</span>, maxFileSize, <span class="type">PROT_READ</span> <span class="operator">|</span> <span class="type">PROT_WRITE</span>, <span class="type">MAP_SHARED</span>, fd, <span class="number">0</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> mappedData <span class="operator">==</span> <span class="type">MAP_FAILED</span> &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;mmap failed&quot;</span>)</span><br><span class="line">                mappedData <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mappedSize <span class="operator">=</span> maxFileSize</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Setup log file error: <span class="subst">\(error)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">log</span>(<span class="keyword">_</span> <span class="params">message</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        queue.async &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> <span class="operator">=</span> <span class="keyword">self</span>,</span><br><span class="line">                  <span class="keyword">let</span> data <span class="operator">=</span> mappedData <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> timestamp <span class="operator">=</span> <span class="type">Date</span>().timeIntervalSince1970</span><br><span class="line">            <span class="keyword">let</span> logEntry <span class="operator">=</span> <span class="string">&quot;[<span class="subst">\(timestamp)</span>] <span class="subst">\(message)</span><span class="subst">\n</span>&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> logData <span class="operator">=</span> logEntry.data(using: .utf8) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查是否需要循环覆盖</span></span><br><span class="line">            <span class="keyword">if</span> writeOffset <span class="operator">+</span> logData.count <span class="operator">&gt;</span> mappedSize &#123;</span><br><span class="line">                writeOffset <span class="operator">=</span> <span class="number">0</span> <span class="comment">// 循环写入</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 写入日志</span></span><br><span class="line">            logData.withUnsafeBytes &#123; ptr <span class="keyword">in</span></span><br><span class="line">                memcpy(data.advanced(by: writeOffset), ptr.baseAddress, logData.count)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            writeOffset <span class="operator">+=</span> logData.count</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 同步到磁盘（可选，影响性能）</span></span><br><span class="line">            <span class="comment">// msync(data, mappedSize, MS_ASYNC)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">flush</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> data <span class="operator">=</span> mappedData &#123;</span><br><span class="line">            msync(data, mappedSize, <span class="type">MS_SYNC</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> data <span class="operator">=</span> mappedData &#123;</span><br><span class="line">            munmap(data, mappedSize)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try?</span> fileHandle<span class="operator">?</span>.close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">let</span> logger <span class="operator">=</span> <span class="type">MMapLogger</span>(logPath: <span class="string">&quot;/tmp/app.log&quot;</span>)</span><br><span class="line">logger.log(<span class="string">&quot;Application started&quot;</span>)</span><br><span class="line">logger.log(<span class="string">&quot;User logged in&quot;</span>)</span><br><span class="line">logger.log(<span class="string">&quot;Data synchronized&quot;</span>)</span><br><span class="line">logger.flush() <span class="comment">// 确保写入磁盘</span></span><br></pre></td></tr></table></figure>

<h2 id="性能对比测试"><a href="#性能对比测试" class="headerlink" title="性能对比测试"></a>性能对比测试</h2><p>对比传统文件 I&#x2F;O 和 mmap 的性能：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PerformanceTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">testTraditionalIO</span>(<span class="params">fileURL</span>: <span class="type">URL</span>, <span class="params">iterations</span>: <span class="type">Int</span>) -&gt; <span class="type">TimeInterval</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> start <span class="operator">=</span> <span class="type">Date</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>iterations &#123;</span><br><span class="line">            <span class="keyword">let</span> data <span class="operator">=</span> <span class="string">&quot;Log entry <span class="subst">\(i)</span><span class="subst">\n</span>&quot;</span>.data(using: .utf8)<span class="operator">!</span></span><br><span class="line">            <span class="keyword">try?</span> data.append(to: fileURL)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="type">Date</span>().timeIntervalSince(start)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">testMMap</span>(<span class="params">fileURL</span>: <span class="type">URL</span>, <span class="params">iterations</span>: <span class="type">Int</span>) -&gt; <span class="type">TimeInterval</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> start <span class="operator">=</span> <span class="type">Date</span>()</span><br><span class="line">        <span class="keyword">let</span> logger <span class="operator">=</span> <span class="type">MMapLogger</span>(logPath: fileURL.path)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>iterations &#123;</span><br><span class="line">            logger.log(<span class="string">&quot;Log entry <span class="subst">\(i)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        logger.flush()</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Date</span>().timeIntervalSince(start)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行测试</span></span><br><span class="line"><span class="keyword">let</span> traditionalTime <span class="operator">=</span> <span class="type">PerformanceTest</span>.testTraditionalIO(</span><br><span class="line">    fileURL: <span class="type">URL</span>(fileURLWithPath: <span class="string">&quot;/tmp/traditional.log&quot;</span>),</span><br><span class="line">    iterations: <span class="number">10000</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mmapTime <span class="operator">=</span> <span class="type">PerformanceTest</span>.testMMap(</span><br><span class="line">    fileURL: <span class="type">URL</span>(fileURLWithPath: <span class="string">&quot;/tmp/mmap.log&quot;</span>),</span><br><span class="line">    iterations: <span class="number">10000</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Traditional I/O: <span class="subst">\(traditionalTime)</span>s&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;MMap: <span class="subst">\(mmapTime)</span>s&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;MMap is <span class="subst">\(traditionalTime <span class="operator">/</span> mmapTime)</span>x faster&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="注意事项与最佳实践"><a href="#注意事项与最佳实践" class="headerlink" title="注意事项与最佳实践"></a>注意事项与最佳实践</h2><h3 id="1-文件大小变化"><a href="#1-文件大小变化" class="headerlink" title="1. 文件大小变化"></a>1. 文件大小变化</h3><p>当文件大小需要改变时，必须重新映射：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">resizeMapping</span>(<span class="params">newSize</span>: <span class="type">Int</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="comment">// 解除旧映射</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> oldAddr <span class="operator">=</span> mappedData &#123;</span><br><span class="line">        munmap(oldAddr, mappedSize)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调整文件大小</span></span><br><span class="line">    <span class="keyword">try</span> fileHandle<span class="operator">?</span>.truncate(atOffset: <span class="type">UInt64</span>(newSize))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重新映射</span></span><br><span class="line">    <span class="keyword">let</span> fd <span class="operator">=</span> fileHandle<span class="operator">!</span>.fileDescriptor</span><br><span class="line">    mappedData <span class="operator">=</span> mmap(<span class="literal">nil</span>, newSize, <span class="type">PROT_READ</span> <span class="operator">|</span> <span class="type">PROT_WRITE</span>, <span class="type">MAP_SHARED</span>, fd, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">guard</span> mappedData <span class="operator">!=</span> <span class="type">MAP_FAILED</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">NSError</span>(domain: <span class="type">NSPOSIXErrorDomain</span>, code: <span class="type">Int</span>(errno))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mappedSize <span class="operator">=</span> newSize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-错误处理"><a href="#2-错误处理" class="headerlink" title="2. 错误处理"></a>2. 错误处理</h3><p>访问映射区域时可能产生信号（如 SIGSEGV、SIGBUS）：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置信号处理器（Objective-C 中更常见）</span></span><br><span class="line">signal(<span class="type">SIGBUS</span>) &#123; signal <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Bus error: attempting to access memory outside mapped region&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-内存建议（madvise）"><a href="#3-内存建议（madvise）" class="headerlink" title="3. 内存建议（madvise）"></a>3. 内存建议（madvise）</h3><p>告诉操作系统如何使用映射内存：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序访问</span></span><br><span class="line">madvise(mappedData, mappedSize, <span class="type">MADV_SEQUENTIAL</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机访问</span></span><br><span class="line">madvise(mappedData, mappedSize, <span class="type">MADV_RANDOM</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不再需要</span></span><br><span class="line">madvise(mappedData, mappedSize, <span class="type">MADV_DONTNEED</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预加载</span></span><br><span class="line">madvise(mappedData, mappedSize, <span class="type">MADV_WILLNEED</span>)</span><br></pre></td></tr></table></figure>

<h3 id="4-线程安全"><a href="#4-线程安全" class="headerlink" title="4. 线程安全"></a>4. 线程安全</h3><p>多线程访问映射区域时需要同步：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafeMMap</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> lock <span class="operator">=</span> <span class="type">NSLock</span>()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mappedData: <span class="type">UnsafeMutableRawPointer</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">write</span>(<span class="params">data</span>: <span class="type">Data</span>, <span class="params">at</span> <span class="params">offset</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        lock.lock()</span><br><span class="line">        <span class="keyword">defer</span> &#123; lock.unlock() &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> addr <span class="operator">=</span> mappedData <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        data.withUnsafeBytes &#123; ptr <span class="keyword">in</span></span><br><span class="line">            memcpy(addr.advanced(by: offset), ptr.baseAddress, data.count)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-内存压力处理"><a href="#5-内存压力处理" class="headerlink" title="5. 内存压力处理"></a>5. 内存压力处理</h3><p>在内存紧张时释放映射：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MMapCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mappings: [<span class="type">String</span>: <span class="type">UnsafeMutableRawPointer</span>] <span class="operator">=</span> [:]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="type">NotificationCenter</span>.default.addObserver(</span><br><span class="line">            <span class="keyword">self</span>,</span><br><span class="line">            selector: <span class="keyword">#selector</span>(handleMemoryWarning),</span><br><span class="line">            name: <span class="type">UIApplication</span>.didReceiveMemoryWarningNotification,</span><br><span class="line">            object: <span class="literal">nil</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">handleMemoryWarning</span>() &#123;</span><br><span class="line">        <span class="comment">// 释放部分映射</span></span><br><span class="line">        mappings.forEach &#123; <span class="keyword">_</span>, addr <span class="keyword">in</span></span><br><span class="line">            munmap(addr, mappedSize)</span><br><span class="line">        &#125;</span><br><span class="line">        mappings.removeAll()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MMap-与其他技术对比"><a href="#MMap-与其他技术对比" class="headerlink" title="MMap 与其他技术对比"></a>MMap 与其他技术对比</h2><h3 id="MMap-vs-传统文件-I-O"><a href="#MMap-vs-传统文件-I-O" class="headerlink" title="MMap vs 传统文件 I&#x2F;O"></a>MMap vs 传统文件 I&#x2F;O</h3><table>
<thead>
<tr>
<th>特性</th>
<th>MMap</th>
<th>传统 I&#x2F;O</th>
</tr>
</thead>
<tbody><tr>
<td>数据拷贝</td>
<td>无需用户态内核态拷贝</td>
<td>需要多次拷贝</td>
</tr>
<tr>
<td>随机访问</td>
<td>高效</td>
<td>需要 seek</td>
</tr>
<tr>
<td>顺序访问</td>
<td>较好</td>
<td>很好</td>
</tr>
<tr>
<td>小文件</td>
<td>映射开销大</td>
<td>高效</td>
</tr>
<tr>
<td>大文件</td>
<td>节省内存</td>
<td>需要大量内存</td>
</tr>
<tr>
<td>编程复杂度</td>
<td>简单（像数组）</td>
<td>需要缓冲区管理</td>
</tr>
</tbody></table>
<h3 id="MMap-vs-NSCache"><a href="#MMap-vs-NSCache" class="headerlink" title="MMap vs NSCache"></a>MMap vs NSCache</h3><table>
<thead>
<tr>
<th>特性</th>
<th>MMap</th>
<th>NSCache</th>
</tr>
</thead>
<tbody><tr>
<td>持久化</td>
<td>自动持久化</td>
<td>仅内存</td>
</tr>
<tr>
<td>容量限制</td>
<td>文件大小</td>
<td>内存大小</td>
</tr>
<tr>
<td>崩溃恢复</td>
<td>数据不丢失</td>
<td>数据丢失</td>
</tr>
<tr>
<td>访问速度</td>
<td>略慢（可能缺页）</td>
<td>很快</td>
</tr>
<tr>
<td>进程共享</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<h3 id="MMap-vs-Core-Data"><a href="#MMap-vs-Core-Data" class="headerlink" title="MMap vs Core Data"></a>MMap vs Core Data</h3><table>
<thead>
<tr>
<th>特性</th>
<th>MMap</th>
<th>Core Data</th>
</tr>
</thead>
<tbody><tr>
<td>查询能力</td>
<td>无</td>
<td>强大的查询</td>
</tr>
<tr>
<td>关系管理</td>
<td>无</td>
<td>支持关系</td>
</tr>
<tr>
<td>原始性能</td>
<td>更快</td>
<td>稍慢</td>
</tr>
<tr>
<td>学习曲线</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>适用场景</td>
<td>简单数据&#x2F;日志</td>
<td>复杂数据模型</td>
</tr>
</tbody></table>
<h2 id="实际应用：MMKV-简介"><a href="#实际应用：MMKV-简介" class="headerlink" title="实际应用：MMKV 简介"></a>实际应用：MMKV 简介</h2><p>MMKV 是微信开源的基于 mmap 的高性能键值存储框架：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> MMKV</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="type">MMKV</span>.initialize(rootDir: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取默认实例</span></span><br><span class="line"><span class="keyword">let</span> mmkv <span class="operator">=</span> <span class="type">MMKV</span>.default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入数据</span></span><br><span class="line">mmkv<span class="operator">?</span>.set(<span class="string">&quot;value&quot;</span>, forKey: <span class="string">&quot;key&quot;</span>)</span><br><span class="line">mmkv<span class="operator">?</span>.set(<span class="number">123</span>, forKey: <span class="string">&quot;number&quot;</span>)</span><br><span class="line">mmkv<span class="operator">?</span>.set(<span class="literal">true</span>, forKey: <span class="string">&quot;bool&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line"><span class="keyword">let</span> value <span class="operator">=</span> mmkv<span class="operator">?</span>.string(forKey: <span class="string">&quot;key&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> number <span class="operator">=</span> mmkv<span class="operator">?</span>.int32(forKey: <span class="string">&quot;number&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> bool <span class="operator">=</span> mmkv<span class="operator">?</span>.bool(forKey: <span class="string">&quot;bool&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// MMKV 的优势</span></span><br><span class="line"><span class="comment">// 1. 基于 mmap，性能极高</span></span><br><span class="line"><span class="comment">// 2. 进程安全（多进程访问）</span></span><br><span class="line"><span class="comment">// 3. 数据加密支持</span></span><br><span class="line"><span class="comment">// 4. 增量更新，不会阻塞</span></span><br><span class="line"><span class="comment">// 5. 自动处理文件损坏</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MMap 是一项强大的技术，在以下场景中特别有用：</p>
<ol>
<li><strong>大文件处理</strong>：避免一次性加载整个文件到内存</li>
<li><strong>高性能日志</strong>：异步写入，崩溃不丢失</li>
<li><strong>进程间通信</strong>：共享内存方式实现 IPC</li>
<li><strong>数据库实现</strong>：LMDB、MMKV 等都基于 mmap</li>
<li><strong>图片解码</strong>：减少内存峰值</li>
</ol>
<p>但也需要注意：</p>
<ul>
<li>小文件不适合使用 mmap（映射开销大）</li>
<li>需要处理好内存映射的生命周期</li>
<li>多进程写入需要额外的同步机制</li>
<li>文件大小变化时需要重新映射</li>
</ul>
<p>掌握 mmap 技术，可以显著提升 iOS 应用在文件操作、数据持久化和进程间通信等方面的性能。</p>
]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>性能优化</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
</search>
