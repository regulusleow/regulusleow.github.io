<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/avatar_images/apple-touch-icon-avatar.webp">
  <link rel="icon" type="image/png" sizes="32x32" href="/avatar_images/favicon-32x32-avatar.webp">
  <link rel="icon" type="image/png" sizes="16x16" href="/avatar_images/favicon-16x16-avatar.webp">
  <meta name="google-site-verification" content="XhaJbrdsD96m39iYKuBCoofZVM7q9cGB5zf-KI1L7Ss">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"regulusleow.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.22.0","exturl":true,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"default"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"stickytabs":false,"motion":{"enable":false,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="指针简介指针？什么是指针？从根本上看，指针（pointer）是一个值为内存地址的变量（或数据对象）。正如char类型变量的值是字符，int类型变量的值是整数，指针变量的值是地址。在 C 语言中，指针有许多用法。本章将介绍如何把指针作为函数参数使用，以及为何要这样用。 假设一个指针变量名是ptr，可以编写如下语句： 1ptr &#x3D; &amp;pooh; &#x2F;&#x2F; 把 pooh 的地址赋给 ptr  对于这">
<meta property="og:type" content="article">
<meta property="og:title" content="C 语言重拾【五】指针">
<meta property="og:url" content="https://regulusleow.github.io/2023/03/09/20230309-C%20%E8%AF%AD%E8%A8%80%E9%87%8D%E6%8B%BE%E3%80%90%E4%BA%94%E3%80%91/index.html">
<meta property="og:site_name" content="轩辕十四">
<meta property="og:description" content="指针简介指针？什么是指针？从根本上看，指针（pointer）是一个值为内存地址的变量（或数据对象）。正如char类型变量的值是字符，int类型变量的值是整数，指针变量的值是地址。在 C 语言中，指针有许多用法。本章将介绍如何把指针作为函数参数使用，以及为何要这样用。 假设一个指针变量名是ptr，可以编写如下语句： 1ptr &#x3D; &amp;pooh; &#x2F;&#x2F; 把 pooh 的地址赋给 ptr  对于这">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://regulusleow.github.io/my_pictures/20230309/1.png">
<meta property="og:image" content="https://regulusleow.github.io/my_pictures/20230309/2.png">
<meta property="og:image" content="https://regulusleow.github.io/my_pictures/20230309/3.png">
<meta property="og:image" content="https://regulusleow.github.io/my_pictures/20230309/4.png">
<meta property="og:image" content="https://regulusleow.github.io/my_pictures/20230309/5.png">
<meta property="og:image" content="https://regulusleow.github.io/my_pictures/20230309/6.png">
<meta property="og:image" content="https://regulusleow.github.io/my_pictures/20230309/7.png">
<meta property="article:published_time" content="2023-03-08T16:00:00.000Z">
<meta property="article:modified_time" content="2025-10-22T04:20:48.646Z">
<meta property="article:author" content="轩辕十四">
<meta property="article:tag" content="C">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://regulusleow.github.io/my_pictures/20230309/1.png">


<link rel="canonical" href="https://regulusleow.github.io/2023/03/09/20230309-C%20%E8%AF%AD%E8%A8%80%E9%87%8D%E6%8B%BE%E3%80%90%E4%BA%94%E3%80%91/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://regulusleow.github.io/2023/03/09/20230309-C%20%E8%AF%AD%E8%A8%80%E9%87%8D%E6%8B%BE%E3%80%90%E4%BA%94%E3%80%91/","path":"2023/03/09/20230309-C 语言重拾【五】/","title":"C 语言重拾【五】指针"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C 语言重拾【五】指针 | 轩辕十四</title>
  



  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{&quot;token&quot;: &quot;1cb638399d744ce59f291432164b2248&quot;}'></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">轩辕十四</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">探索科技与创新的个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">指针简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%B4%E6%8E%A5%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9A"><span class="nav-number">1.1.</span> <span class="nav-text">间接运算符：*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E6%8C%87%E9%92%88"><span class="nav-number">1.2.</span> <span class="nav-text">声明指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E5%9C%A8%E5%87%BD%E6%95%B0%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">1.3.</span> <span class="nav-text">使用指针在函数间通信</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84"><span class="nav-number">2.</span> <span class="nav-text">指针和数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88"><span class="nav-number">3.</span> <span class="nav-text">函数、数组和指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84%E5%BD%A2%E5%8F%82"><span class="nav-number">3.1.</span> <span class="nav-text">声明数组形参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E5%BD%A2%E5%8F%82"><span class="nav-number">3.2.</span> <span class="nav-text">使用指针形参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">3.3.</span> <span class="nav-text">指针变量的基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%EF%BC%9A"><span class="nav-number">3.3.1.</span> <span class="nav-text">赋值：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%BC%95%E7%94%A8%EF%BC%9A"><span class="nav-number">3.3.2.</span> <span class="nav-text">解引用：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%96%E5%9D%80%EF%BC%9A"><span class="nav-number">3.3.3.</span> <span class="nav-text">取址：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B4%E6%95%B0%E7%9B%B8%E5%8A%A0%EF%BC%9A"><span class="nav-number">3.3.4.</span> <span class="nav-text">指针与整数相加：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%A2%9E%E6%8C%87%E9%92%88%EF%BC%9A"><span class="nav-number">3.3.5.</span> <span class="nav-text">递增指针：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%87%8F%E5%8E%BB%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%EF%BC%9A"><span class="nav-number">3.3.6.</span> <span class="nav-text">指针减去一个整数：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%87%8F%E6%8C%87%E9%92%88%EF%BC%9A"><span class="nav-number">3.3.7.</span> <span class="nav-text">递减指针：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E6%B1%82%E5%B7%AE%EF%BC%9A"><span class="nav-number">3.3.8.</span> <span class="nav-text">指针求差：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%EF%BC%9A"><span class="nav-number">3.3.9.</span> <span class="nav-text">比较：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%BC%95%E7%94%A8%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-number">3.4.</span> <span class="nav-text">解引用未初始化的指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88"><span class="nav-number">4.</span> <span class="nav-text">指针常量与常量指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88"><span class="nav-number">4.1.</span> <span class="nav-text">常量指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F"><span class="nav-number">4.2.</span> <span class="nav-text">指针常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%86%99%E6%B3%95"><span class="nav-number">4.3.</span> <span class="nav-text">其他写法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">5.</span> <span class="nav-text">指针和多维数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E5%90%91%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-number">5.1.</span> <span class="nav-text">指向多维数组的指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="nav-number">5.2.</span> <span class="nav-text">多维数组的声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84"><span class="nav-number">5.3.</span> <span class="nav-text">变长数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-number">5.4.</span> <span class="nav-text">复合字面量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="nav-number">7.</span> <span class="nav-text">参考文献</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="轩辕十四"
      src="/avatar_images/avatar.webp">
  <p class="site-author-name" itemprop="name">轩辕十四</p>
  <div class="site-description" itemprop="description">Stay hungry. Stay foolish.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">127</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">125</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JlZ3VsdXNsZW93" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;regulusleow"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9yZWd1bHVzX3dq" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;regulus_wj"><i class="fab fa-twitter fa-fw"></i>Twitter</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly90Lm1lL3JlZ3Vzdw==" title="Telegram → https:&#x2F;&#x2F;t.me&#x2F;regusw"><i class="fab fa-telegram fa-fw"></i>Telegram</span>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://regulusleow.github.io/2023/03/09/20230309-C%20%E8%AF%AD%E8%A8%80%E9%87%8D%E6%8B%BE%E3%80%90%E4%BA%94%E3%80%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar_images/avatar.webp">
      <meta itemprop="name" content="轩辕十四">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="轩辕十四">
      <meta itemprop="description" content="Stay hungry. Stay foolish.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C 语言重拾【五】指针 | 轩辕十四">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C 语言重拾【五】指针
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-09 00:00:00" itemprop="dateCreated datePublished" datetime="2023-03-09T00:00:00+08:00">2023-03-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2023/03/09/20230309-C%20%E8%AF%AD%E8%A8%80%E9%87%8D%E6%8B%BE%E3%80%90%E4%BA%94%E3%80%91/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/03/09/20230309-C 语言重拾【五】/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="指针简介"><a href="#指针简介" class="headerlink" title="指针简介"></a>指针简介</h2><p>指针？什么是指针？从根本上看，指针（pointer）是一个值为内存地址的变量（或数据对象）。正如<code>char</code>类型变量的值是字符，<code>int</code>类型变量的值是整数，指针变量的值是地址。在 C 语言中，指针有许多用法。本章将介绍如何把指针作为函数参数使用，以及为何要这样用。</p>
<p>假设一个指针变量名是<code>ptr</code>，可以编写如下语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr = &amp;pooh; <span class="comment">// 把 pooh 的地址赋给 ptr</span></span><br></pre></td></tr></table></figure>

<p>对于这条语句，我们说<code>ptr</code>“指向”<code>pooh</code>。<code>ptr</code>和<code>&amp;pooh</code>的区别是<code>ptr</code>是变量，而<code>&amp;pooh</code>是常量。或者，<code>ptr</code>是可修改的左值，而<code>&amp;pooh</code>是右值。还可以把<code>ptr</code>指向别处：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr = &amp;bah; <span class="comment">// 把 ptr 指向 bah，而不是 pooh</span></span><br></pre></td></tr></table></figure>

<p>现在<code>ptr</code>的值是<code>bah</code>的地址。</p>
<p>要创建指针变量，先要声明指针变量的类型。假设想把<code>ptr</code>声明为储存<code>int</code>类型变量地址的指针，就要使用下面介绍的新运算符。</p>
<span id="more"></span>

<h3 id="间接运算符："><a href="#间接运算符：" class="headerlink" title="间接运算符：*"></a>间接运算符：*</h3><p>假设已知<code>ptr</code>指向<code>bah</code>，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr = &amp;bah;</span><br></pre></td></tr></table></figure>

<p>然后使用间接运算符<code>*</code>（indirection operator）找出储存在<code>bah</code>中的值，该运算符有时也称为解引用运算符（dereferencing operator）。不要把间接运算符和二元乘法运算符（*）混淆，虽然它们使用的符号相同，但语法功能不同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = *ptr; <span class="comment">// 找出 ptr 指向的值</span></span><br></pre></td></tr></table></figure>

<p>语句<code>ptr = &amp;bah;</code>和<code>val = *ptr;</code>放在一起相当于下面的语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = bah;</span><br></pre></td></tr></table></figure>

<p>由此可见，使用地址和间接运算符可以间接完成上面这条语句的功能，这也是“间接运算符”名称的由来。</p>
<blockquote>
<p>小结：与指针相关的运算符<br>地址运算符：<code>&amp;</code><br>一般注解：<br>后跟一个变量名时，<code>&amp;</code>给出该变量的地址。<br>示例：<br><code>&amp;nurse</code>表示变量<code>nurse</code>的地址。<br>地址运算符：<code>*</code><br>一般注解：<br>后跟一个指针名或地址时，<code>*</code>给出储存在指针指向地址上的值。<br>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nurse　=　<span class="number">22</span>;</span><br><span class="line">ptr = &amp;nurse; <span class="comment">// 指向 nurse 的指针</span></span><br><span class="line">val = *ptr;　 <span class="comment">// 把 ptr 指向的地址上的值赋给 val</span></span><br></pre></td></tr></table></figure>

<p>执行以上 3 条语句的最终结果是把 22 赋给<code>val</code>。</p>
</blockquote>
<h3 id="声明指针"><a href="#声明指针" class="headerlink" title="声明指针"></a>声明指针</h3><p>相信读者已经很熟悉如何声明int类型和其他基本类型的变量，那么如何声明指针变量？你也许认为是这样声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointer ptr; <span class="comment">// 不能这样声明指针</span></span><br></pre></td></tr></table></figure>

<p>为什么不能这样声明？因为声明指针变量时必须指定指针所指向变量的类型，因为不同的变量类型占用不同的存储空间，一些指针操作要求知道操作对象的大小。另外，程序必须知道储存在指定地址上的数据类型。<code>long</code>和<code>float</code>可能占用相同的存储空间，但是它们储存数字却大相径庭。下面是一些指针的声明示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * pi;　　 <span class="comment">// pi 是指向 int 类型变量的指针</span></span><br><span class="line"><span class="type">char</span> * pc;　　　　<span class="comment">// pc 是指向 char 类型变量的指针</span></span><br><span class="line"><span class="type">float</span> * pf, * pg; <span class="comment">// pf、pg 都是指向 float 类型变量的指针</span></span><br></pre></td></tr></table></figure>

<p>类型说明符表明了指针所指向对象的类型，星号（*）表明声明的变量是一个指针。<code>int * pi;</code>声明的意思是<code>pi</code>是一个指针，<code>*pi</code>是<code>int</code>类型（见图9.5）。</p>
<img src="/my_pictures/20230309/1.png" style="zoom: 33%;" />

<p><code>*</code>和指针名之间的空格可有可无。通常，程序员在声明时使用空格，在解引用变量时省略空格。<br><code>pc</code>指向的值<code>（*pc）</code>是<code>char</code>类型。<code>pc</code>本身是什么类型？我们描述它的类型是 “指向<code>char</code>类型的指针”。<code>pc</code>的值是一个地址，在大部分系统内部，该地址由一个无符号整数表示。但是，不要把指针认为是整数类型。一些处理整数的操作不能用来处理指针，反之亦然。例如，可以把两个整数相乘，但是不能把两个指针相乘。所以，指针实际上是一个新类型，不是整数类型。因此，如前所述，ANSI C 专门为指针提供了<code>%p</code>格式的转换说明。</p>
<h3 id="使用指针在函数间通信"><a href="#使用指针在函数间通信" class="headerlink" title="使用指针在函数间通信"></a>使用指针在函数间通信</h3><p>我们才刚刚接触指针，指针的世界丰富多彩。本节着重介绍如何使用指针解决函数间的通信问题。请看程序清单 9.15，该程序在<code>interchange()</code>函数中使用了指针参数。稍后我们将对该程序做详细分析。</p>
<p><strong>程序清单 9.15 swap3.c 程序</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* swap3.c -- 使用指针解决交换函数的问题 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>　<span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">interchange</span><span class="params">(<span class="type">int</span> * u, <span class="type">int</span> * v)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">5</span>,　y = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Originally x = %d and y = %d.\n&quot;</span>, x, y);</span><br><span class="line">  interchange(&amp;x, &amp;y);　 <span class="comment">// 把地址发送给函数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Now x = %d　and　y = %d.\n&quot;</span>, x, y);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interchange</span><span class="params">(<span class="type">int</span> * u, <span class="type">int</span> * v)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> temp;</span><br><span class="line">  temp = *u;　　<span class="comment">// temp 获得 u 所指向对象的值</span></span><br><span class="line">  *u = *v;</span><br><span class="line">  *v = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序是否能正常运行？下面是程序的输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Originally　x　=　<span class="number">5</span>　and　y　=　<span class="number">10.</span></span><br><span class="line">Now　x　=　<span class="number">10</span>　and　y　=　<span class="number">5.</span></span><br></pre></td></tr></table></figure>

<p>没问题，一切正常。接下来，我们分析程序清单 9.15 的运行情况。首先看函数调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interchange(&amp;x, &amp;y);</span><br></pre></td></tr></table></figure>

<p>该函数传递的不是<code>x</code>和<code>y</code>的值，而是它们的地址。这意味着出现在<code>interchange()</code>原型和定义中的形式参数<code>u</code>和<code>v</code>将把地址作为它们的值。因此，应把它们声明为指针。由于<code>x</code>和<code>y</code>是整数，所以<code>u</code>和<code>v</code>是指向整数的指针，其声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">interchange</span> <span class="params">(<span class="type">int</span> * u, <span class="type">int</span> * v)</span></span><br></pre></td></tr></table></figure>

<p>接下来，在函数体中声明了一个交换值时必需的临时变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp;</span><br></pre></td></tr></table></figure>

<p>通过下面的语句把x的值储存在<code>temp</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">temp = *u;</span><br></pre></td></tr></table></figure>

<p>记住，<code>u</code>的值是<code>&amp;x</code>，所以<code>u</code>指向<code>x</code>。这意味着用<code>*u</code>即可表示<code>x</code>的值，这正是我们需要的。不要写成这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">temp = u; <span class="comment">/* 不要这样做 */</span></span><br></pre></td></tr></table></figure>

<p>因为这条语句赋给<code>temp</code>的是<code>x</code>的地址（<code>u</code>的值就是<code>x</code>的地址），而不是<code>x</code>的值。函数要交换的是<code>x</code>和<code>y</code>的值，而不是它们的地址。</p>
<p>与此类似，把y的值赋给x，要使用下面的语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*u = *v;</span><br></pre></td></tr></table></figure>

<p>这条语句相当于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = y;</span><br></pre></td></tr></table></figure>

<p>我们总结一下该程序示例做了什么。我们需要一个函数交换<code>x</code>和<code>y</code>的值。把<code>x</code>和<code>y</code>的地址传递给函数，我们让<code>interchange()</code>访问这两个函数。使用指针和<code>*</code>运算符，该函数可以访问储存在这些位置的值并改变它们。</p>
<p>可以省略 ANSI C 风格的函数原型中的形参名，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">interchange</span><span class="params">(<span class="type">int</span> *, <span class="type">int</span> *)</span>;</span><br></pre></td></tr></table></figure>

<p>一般而言，可以把变量相关的两类信息传递给函数。如果这种形式的函数调用，那么传递的是<code>x</code>的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function1(x);</span><br></pre></td></tr></table></figure>

<p>如果下面形式的函数调用，那么传递的是<code>x</code>的地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function2(&amp;x);</span><br></pre></td></tr></table></figure>

<p>第 1 种形式要求函数定义中的形式参数必须是一个与<code>x</code>的类型相同的变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">function1</span><span class="params">(<span class="type">int</span> num)</span></span><br></pre></td></tr></table></figure>

<p>第 2 种形式要求函数定义中的形式参数必须是一个指向正确类型的指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">function2</span><span class="params">(<span class="type">int</span> * ptr)</span></span><br></pre></td></tr></table></figure>

<p>如果要计算或处理值，那么使用第 1 种形式的函数调用；如果要在被调函数中改变主调函数的变量，则使用第 2 种形式的函数调用。我们用过的<code>scanf()</code>函数就是这样。当程序要把一个值读入变量时（如本例中的<code>num</code>），调用的是<code>scanf(&quot;%d&quot;, &amp;num)</code>。<code>scanf()</code>读取一个值，然后把该值储存到指定的地址上。</p>
<p>对本例而言，指针让<code>interchange()</code>函数通过自己的局部变量改变<code>main()</code>中变量的值。</p>
<p>熟悉 Pascal 和 Modula-2 的读者应该看出第 1 种形式和 Pascal 的值参数相同，第 2 种形式和 Pascal 的变量参数类似。C++ 程序员可能认为，既然 C 和 C++ 都使用指针变量，那么 C 应该也有引用变量。让他们失望了，C 没有引用变量。对 BASIC 程序员而言，可能很难理解整个程序。如果觉得本节的内容晦涩难懂，请多做一些相关的编程练习，你会发现指针非常简单实用（见图9.6）。</p>
<img src="/my_pictures/20230309/2.png" style="zoom: 33%;" />

<blockquote>
<p><strong>变量：名称、地址和值</strong></p>
<p>通过前面的讨论发现，变量的名称、地址和变量的值之间关系密切。我们来进一步分析。<br>编写程序时，可以认为变量有两个属性：名称和值（还有其他性质，如类型，暂不讨论）。计算机编译和加载程序后，认为变量也有两个属性：地址和值。地址就是变量在计算机内部的名称。</p>
<p>在许多语言中，地址都归计算机管，对程序员隐藏。然而在 C 中，可以通过<code>&amp;</code>运算符访问地址，通过<code>*</code>运算符获得地址上的值。例如，<code>&amp;barn</code>表示变量<code>barn</code>的地址，使用函数名即可获得变量的数值。例如，<code>printf(&quot;%d\n&quot;, barn)</code>打印<code>barn</code>的值，使用<code>*</code>运算符即可获得储存在地址上的值。如果<code>pbarn= &amp;barn;</code>，那么<code>*pbarn</code>表示的是储存在<code>&amp;barn</code>地址上的值。</p>
<p>简而言之，普通变量把值作为基本量，把地址作为通过<code>&amp;</code>运算符获得的派生量，而指针变量把地址作为基本量，把值作为通过<code>*</code>运算符获得的派生量。</p>
<p>虽然打印地址可以满足读者好奇心，但是这并不是<code>&amp;</code>运算符的主要用途。更重要的是使用<code>&amp;</code>、<code>*</code>和指针可以操纵地址和地址上的内容，如 swap3.c 程序（程序清单9.15）所示。</p>
</blockquote>
<h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><p>指针提供一种以符号形式使用地址的方法。因为计算机的硬件指令非常依赖地址，指针在某种程度上把程序员想要传达的指令以更接近机器的方式表达。因此，使用指针的程序更有效率。尤其是，指针能有效地处理数组。数组表示法其实是在变相地使用指针。</p>
<p>我们举一个变相使用指针的例子：数组名是数组首元素的地址。也就是说，如果<code>flizny</code>是一个数组，下面的语句成立：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flizny == &amp;flizny[<span class="number">0</span>]; <span class="comment">// 数组名是该数组首元素的地址</span></span><br></pre></td></tr></table></figure>

<p><code>flizny</code>和<code>&amp;flizny[0]</code>都表示数组首元素的内存地址（<code>&amp;</code>是地址运算符）。两者都是常量，在程序的运行过程中，不会改变。但是，可以把它们赋值给指针变量，然后可以修改指针变量的值，如程序清单 10.8 所示。注意指针加上一个数时，它的值发生了什么变化（转换说明<code>%p</code>通常以十六进制显示指针的值）。</p>
<p><strong>程序清单 10.8 pnt_add.c 程序</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pnt_add.c -- 指针地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>　<span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>　SIZE　4</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">short</span> dates[SIZE];</span><br><span class="line">  <span class="type">short</span> * pti;</span><br><span class="line">  <span class="type">short</span> index;</span><br><span class="line">  <span class="type">double</span> bills[SIZE];</span><br><span class="line">  <span class="type">double</span> * ptf;</span><br><span class="line">  pti = dates;　<span class="comment">// 把数组地址赋给指针</span></span><br><span class="line">  ptf = bills;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%23s　%15s\n&quot;</span>,　<span class="string">&quot;short&quot;</span>,　<span class="string">&quot;double&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (index　=　<span class="number">0</span>;　index　&lt;　SIZE;　index++)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pointers　+　%d:　%10p　%10p\n&quot;</span>, index, pti + index, ptf + index);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是该例的输出示例：</p>
<table>
<thead>
<tr>
<th></th>
<th>short</th>
<th>double</th>
</tr>
</thead>
<tbody><tr>
<td>pointers　+　0:</td>
<td>0x7fff5fbff8dc</td>
<td>0x7fff5fbff8a0</td>
</tr>
<tr>
<td>pointers　+　1:</td>
<td>0x7fff5fbff8de</td>
<td>0x7fff5fbff8a8</td>
</tr>
<tr>
<td>pointers　+　2:</td>
<td>0x7fff5fbff8e0</td>
<td>0x7fff5fbff8b0</td>
</tr>
<tr>
<td>pointers　+　3:</td>
<td>0x7fff5fbff8e2</td>
<td>0x7fff5fbff8b8</td>
</tr>
</tbody></table>
<p>第 2 行打印的是两个数组开始的地址，下一行打印的是指针加 1 后的地址，以此类推。注意，地址是十六进制的，因此<code>dd</code>比<code>dc</code>大1，<code>a1</code>比<code>a0</code>大 1。但是，显示的地址是怎么回事？</p>
<blockquote>
<p>0x7fff5fbff8dc + 1 是否是 0x7fff5fbff8de?<br>0x7fff5fbff8a0 + 1 是否是 0x7fff5fbff8a8?</p>
</blockquote>
<p>我们的系统中，地址按字节编址，<code>short</code>类型占用 2 字节，<code>double</code>类型占用 8 字节。在 C 中，指针加 1 指的是增加一个存储单元。对数组而言，这意味着把加 1 后的地址是下一个元素的地址，而不是下一个字节的地址（见图10.3）。这是为什么必须声明指针所指向对象类型的原因之一。只知道地址不够，因为计算机要知道储存对象需要多少字节（即使指针指向的是标量变量，也要知道变量的类型，否则<code>*pt</code>就无法正确地取回地址上的值）。</p>
<img src="/my_pictures/20230309/3.png" style="zoom: 20%;" />

<p>现在可以更清楚地定义指向<code>int</code>的指针、指向<code>float</code>的指针，以及指向其他数据对象的指针。</p>
<ul>
<li>指针的值是它所指向对象的地址。地址的表示方式依赖于计算机内部的硬件。许多计算机（包括 PC 和 Macintosh）都是按字节编址，意思是内存中的每个字节都按顺序编号。这里，一个较大对象的地址（如<code>double</code>类型的变量）通常是该对象第一个字节的地址。</li>
<li>在指针前面使用<code>*</code>运算符可以得到该指针所指向对象的值。</li>
<li>指针加 1，指针的值递增它所指向类型的大小（以字节为单位）。</li>
</ul>
<p>下面的等式体现了 C 语言的灵活性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dates + <span class="number">2</span> == &amp;date[<span class="number">2</span>]　　　 <span class="comment">// 相同的地址</span></span><br><span class="line">*(dates + <span class="number">2</span>) == dates[<span class="number">2</span>]　 <span class="comment">// 相同的值</span></span><br></pre></td></tr></table></figure>

<p>以上关系表明了数组和指针的关系十分密切，可以使用指针标识数组的元素和获得元素的值。从本质上看，同一个对象有两种表示法。实际上，C 语言标准在描述数组表示法时确实借助了指针。也就是说，定义<code>ar[n]</code>的意思是<code>*(ar + n)</code>。可以认为<code>*(ar + n)</code>的意思是“到内存的<code>ar</code>位置，然后移动<code>n</code>个单元，检索储存在那里的值”。</p>
<h2 id="函数、数组和指针"><a href="#函数、数组和指针" class="headerlink" title="函数、数组和指针"></a>函数、数组和指针</h2><h3 id="声明数组形参"><a href="#声明数组形参" class="headerlink" title="声明数组形参"></a>声明数组形参</h3><p>因为数组名是该数组首元素的地址，作为实际参数的数组名要求形式参数是一个与之匹配的指针。只有在这种情况下，C 才会把<code>int ar[]</code>和<code>int * ar</code>解释成一样。也就是说，<code>ar</code>是指向<code>int</code>的指针。由于函数原型可以省略参数名，所以下面 4 种原型都是等价的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *ar, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> ar[], <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> [],　<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>但是，在函数定义中不能省略参数名。下面两种形式的函数定义等价：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *ar, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 其他代码已省略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> ar[], <span class="type">int</span> n)</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 其他代码已省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用以上提到的任意一种函数原型和函数定义。</p>
<p>程序清单 10.10 演示了一个程序，使用<code>sum()</code>函数。该程序打印原始数组的大小和表示该数组的函数形参的大小。</p>
<p><strong>程序清单 10.10 sum_arr1.c 程序</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sum_arr1.c -- 数组元素之和</span></span><br><span class="line"><span class="comment">// 如果编译器不支持 %zd，用 %u 或 %lu 替换它</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 10</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> ar[],　<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> marbles[SIZE] = &#123; <span class="number">20</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">39</span>, <span class="number">4</span>, <span class="number">16</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">31</span>, <span class="number">20</span> &#125;;</span><br><span class="line">  <span class="type">long</span> answer;</span><br><span class="line">  answer = sum(marbles, SIZE);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The total number of marbles is %ld.\n&quot;</span>, answer);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The size of marbles is %zd bytes.\n&quot;</span>,</span><br><span class="line">         <span class="keyword">sizeof</span> marbles);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> ar[], <span class="type">int</span> n)</span>  <span class="comment">// 这个数组的大小是？</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  	total += ar[i];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The size of ar is %zd bytes.\n&quot;</span>, <span class="keyword">sizeof</span> ar);</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序的输出如下：</p>
<blockquote>
<p>The size of ar is 8 bytes.<br>The total number of marbles is 190.<br>The size of marbles is 40 bytes.</p>
</blockquote>
<p>注意，<code>marbles</code>的大小是 40 字节。这没问题，因为<code>marbles</code>内含 10 个<code>int</code>类型的值，每个值占 4 字节，所以整个<code>marbles</code>的大小是 40 字节。但是，<code>ar</code>才 8 字节。这是因为<code>ar</code>并不是数组本身，它是一个指向<code>marbles</code>数组首元素的指针。我们的系统中用 8 字节储存地址，所以指针变量的大小是 8 字节（其他系统中地址的大小可能不是8字节）。简而言之，在程序清单 10.10 中，<code>marbles</code>是一个数组，<code>ar</code>是一个指向<code>marbles</code>数组首元素的指针，利用 C 中数组和指针的特殊关系，可以用数组表示法来表示指针<code>ar</code>。</p>
<h3 id="使用指针形参"><a href="#使用指针形参" class="headerlink" title="使用指针形参"></a>使用指针形参</h3><p>上面的<code>sum()</code>函数传递了一个<code>n</code>参数来表示数组的长度，我们还有另外一种方式可以实现，那就是利用两个指针来做遍历，也即是使用指针形参。</p>
<p><strong>程序清单 10.11 sum_arr2.c 程序</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sum_arr2.c -- 数组元素之和 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 10</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sump</span><span class="params">(<span class="type">int</span> * start, <span class="type">int</span> * end)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> marbles[SIZE] = &#123; <span class="number">20</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">39</span>, <span class="number">4</span>, <span class="number">16</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">31</span>, <span class="number">20</span> &#125;;</span><br><span class="line">  <span class="type">long</span> answer;</span><br><span class="line">  answer = sump(marbles, marbles + SIZE);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The total number of marbles is %ld.\n&quot;</span>, answer);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 使用指针算法 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sump</span><span class="params">(<span class="type">int</span> * start, <span class="type">int</span> * end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (start &lt; end)</span><br><span class="line">  &#123;</span><br><span class="line">    total += *start;  <span class="comment">// 把数组元素的值加起来</span></span><br><span class="line">    start++; <span class="comment">// 让指针指向下一个元素</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指针变量的基本操作"><a href="#指针变量的基本操作" class="headerlink" title="指针变量的基本操作"></a>指针变量的基本操作</h3><p><strong>程序清单 10.13 ptr_ops.c 程序</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ptr_ops.c -- 指针操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> urn[<span class="number">5</span>] = &#123; <span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span> &#125;;</span><br><span class="line">  <span class="type">int</span> * ptr1, *ptr2, *ptr3;</span><br><span class="line">  ptr1 = urn; <span class="comment">// 把一个地址赋给指针</span></span><br><span class="line">  ptr2 = &amp;urn[<span class="number">2</span>];  <span class="comment">// 把一个地址赋给指针</span></span><br><span class="line">  <span class="comment">// 解引用指针，以及获得指针的地址</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pointer value, dereferenced pointer, pointer address:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ptr1 = %p, *ptr1 =%d, &amp;ptr1 = %p\n&quot;</span>, ptr1, *ptr1, &amp;ptr1);</span><br><span class="line">  <span class="comment">// 指针加法</span></span><br><span class="line">  ptr3 = ptr1 + <span class="number">4</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nadding an int to a pointer:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ptr1 + 4 = %p, *(ptr1 + 4) = %d\n&quot;</span>, ptr1 + <span class="number">4</span>, *(ptr1 + <span class="number">4</span>));</span><br><span class="line">  ptr1++; <span class="comment">// 递增指针</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nvalues after ptr1++:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ptr1 = %p, *ptr1 =%d, &amp;ptr1 = %p\n&quot;</span>, ptr1, *ptr1, &amp;ptr1);</span><br><span class="line">  ptr2--; <span class="comment">// 递减指针</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nvalues after --ptr2:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ptr2 = %p, *ptr2 = %d, &amp;ptr2 = %p\n&quot;</span>, ptr2, *ptr2, &amp;ptr2);</span><br><span class="line">  --ptr1; <span class="comment">// 恢复为初始值</span></span><br><span class="line">  ++ptr2; <span class="comment">// 恢复为初始值</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nPointers reset to original values:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ptr1 = %p, ptr2 = %p\n&quot;</span>, ptr1, ptr2);</span><br><span class="line">  <span class="comment">// 一个指针减去另一个指针</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nsubtracting one pointer from another:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ptr2 = %p, ptr1 = %p, ptr2 - ptr1 = %td\n&quot;</span>, ptr2, ptr1, ptr2 - ptr1);</span><br><span class="line">  <span class="comment">// 一个指针减去一个整数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nsubtracting an int from a pointer:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ptr3 = %p, ptr3 - 2 = %p\n&quot;</span>, ptr3, ptr3 - <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是我们的系统运行该程序后的输出：</p>
<blockquote>
<p>pointer value, dereferenced pointer, pointer address:<br>ptr1 &#x3D; 0x7fff5fbff8d0, *ptr1 &#x3D;100, &amp;ptr1 &#x3D; 0x7fff5fbff8c8</p>
<p>adding an int to a pointer:<br>ptr1 + 4 &#x3D; 0x7fff5fbff8e0, *(ptr1 + 4) &#x3D; 500</p>
<p>values after ptr1++:<br>ptr1 &#x3D; 0x7fff5fbff8d4, *ptr1 &#x3D;200, &amp;ptr1 &#x3D; 0x7fff5fbff8c8</p>
<p>values after –ptr2:<br>ptr2 &#x3D; 0x7fff5fbff8d4, *ptr2 &#x3D; 200, &amp;ptr2 &#x3D; 0x7fff5fbff8c0</p>
<p>Pointers reset to original values:<br>ptr1 &#x3D; 0x7fff5fbff8d0, ptr2 &#x3D; 0x7fff5fbff8d8</p>
<p>subtracting one pointer from another:<br>ptr2 &#x3D; 0x7fff5fbff8d8, ptr1 &#x3D; 0x7fff5fbff8d0, ptr2 - ptr1 &#x3D; 2</p>
<p>subtracting an int from a pointer:<br>ptr3 &#x3D; 0x7fff5fbff8e0, ptr3 - 2 &#x3D; 0x7fff5fbff8d8</p>
</blockquote>
<h4 id="赋值："><a href="#赋值：" class="headerlink" title="赋值："></a>赋值：</h4><p>可以把地址赋给指针。例如，用数组名、带地址运算符（<code>&amp;</code>）的变量名、另一个指针进行赋值。在该例中，把<code>urn</code>数组的首地址赋给了<code>ptr1</code>，该地址的编号恰好是<code>0x7fff5fbff8d0</code>。变量<code>ptr2</code>获得数组<code>urn</code>的第 3 个元素（<code>urn[2]</code>）的地址。注意，地址应该和指针类型兼容。也就是说，不能把<code>double</code>类型的地址赋给指向<code>int</code>的指针，至少要避免不明智的类型转换。C99&#x2F;C11 已经强制不允许这样做。</p>
<h4 id="解引用："><a href="#解引用：" class="headerlink" title="解引用："></a>解引用：</h4><p><code>*</code>运算符给出指针指向地址上储存的值。因此，<code>*ptr1</code>的初值是 100，该值储存在编号为<code>0x7fff5fbff8d0</code>的地址上。</p>
<h4 id="取址："><a href="#取址：" class="headerlink" title="取址："></a>取址：</h4><p>和所有变量一样，指针变量也有自己的地址和值。对指针而言，<code>&amp;</code>运算符给出指针本身的地址。本例中，<code>ptr1</code>储存在内存编号为<code>0x7fff5fbff8c8</code>的地址上，该存储单元储存的内容是<code>0x7fff5fbff8d0</code>，即<code>urn</code>的地址。因此<code>&amp;ptr1</code>是指向<code>ptr1</code>的指针，而<code>ptr1</code>是指向<code>utn[0]</code>的指针。</p>
<h4 id="指针与整数相加："><a href="#指针与整数相加：" class="headerlink" title="指针与整数相加："></a>指针与整数相加：</h4><p>可以使用<code>+</code>运算符把指针与整数相加，或整数与指针相加。无论哪种情况，整数都会和指针所指向类型的大小（以字节为单位）相乘，然后把结果与初始地址相加。因此<code>ptr1 + 4</code>与<code>&amp;urn[4]</code>等价。如果相加的结果超出了初始指针指向的数组范围，计算结果则是未定义的。除非正好超过数组末尾第一个位置，C 保证该指针有效。</p>
<h4 id="递增指针："><a href="#递增指针：" class="headerlink" title="递增指针："></a>递增指针：</h4><p>递增指向数组元素的指针可以让该指针移动至数组的下一个元素。因此，<code>ptr1++</code>相当于把<code>ptr1</code>的值加上 4（我们的系统中<code>int</code>为 4 字节），<code>ptr1</code>指向<code>urn[1]</code>（见图10.4，该图中使用了简化的地址）。现在<code>ptr1</code>的值是<code>0x7fff5fbff8d4</code>（数组的下一个元素的地址），<code>*ptr</code>的值为 200（即<code>urn[1]</code>的值）。注意，<code>ptr1</code>本身的地址仍是<code>0x7fff5fbff8c8</code>。毕竟，变量不会因为值发生变化就移动位置。</p>
<h4 id="指针减去一个整数："><a href="#指针减去一个整数：" class="headerlink" title="指针减去一个整数："></a>指针减去一个整数：</h4><p>可以使用<code>-</code>运算符从一个指针中减去一个整数。指针必须是第 1 个运算对象，整数是第 2 个运算对象。该整数将乘以指针指向类型的大小（以字节为单位），然后用初始地址减去乘积。所以<code>ptr3 - 2</code>与<code>&amp;urn[2]</code>等价，因为<code>ptr3</code>指向的是<code>&amp;arn[4]</code>。如果相减的结果超出了初始指针所指向数组的范围，计算结果则是未定义的。除非正好超过数组末尾第一个位置， C 保证该指针有效。</p>
<h4 id="递减指针："><a href="#递减指针：" class="headerlink" title="递减指针："></a>递减指针：</h4><p>当然，除了递增指针还可以递减指针。在本例中，递减<code>ptr3</code>使其指向数组的第 2 个元素而不是第 3 个元素。前缀或后缀的递增和递减运算符都可以使用。注意，在重置<code>ptr1</code>和<code>ptr2</code>前，它们都指向相同的元素<code>urn[1]</code>。</p>
<h4 id="指针求差："><a href="#指针求差：" class="headerlink" title="指针求差："></a>指针求差：</h4><p>可以计算两个指针的差值。通常，求差的两个指针分别指向同一个数组的不同元素，通过计算求出两元素之间的距离。差值的单位与数组类型的单位相同。例如，程序清单 10.13 的输出中，<code>ptr2 - ptr1</code>得 2，意思是这两个指针所指向的两个元素相隔两个<code>int</code>，而不是 2 字节。只要两个指针都指向相同的数组（或者其中一个指针指向数组后面的第 1 个地址），C 都能保证相减运算有效。如果指向两个不同数组的指针进行求差运算可能会得出一个值，或者导致运行时错误。</p>
<h4 id="比较："><a href="#比较：" class="headerlink" title="比较："></a>比较：</h4><p>使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象。</p>
<h3 id="解引用未初始化的指针"><a href="#解引用未初始化的指针" class="headerlink" title="解引用未初始化的指针"></a>解引用未初始化的指针</h3><p>说到注意事项，一定要牢记一点：千万不要解引用未初始化的指针。例如，考虑下面的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * pt;	 <span class="comment">// 未初始化的指针</span></span><br><span class="line">*pt = <span class="number">5</span>;　　<span class="comment">// 严重的错误</span></span><br></pre></td></tr></table></figure>

<p>为何不行？第 2 行的意思是把5储存在pt指向的位置。但是pt未被初始化，其值是一个随机值，所以不知道 5 将储存在何处。这可能不会出什么错，也可能会擦写数据或代码，或者导致程序崩溃。切记：创建一个指针时，系统只分配了储存指针本身的内存，并未分配储存数据的内存。因此，在使用指针之前，必须先用已分配的地址初始化它。例如，可以用一个现有变量的地址初始化该指针（使用带指针形参的函数时，就属于这种情况）。或者还可以使用第 12 章将介绍的<code>malloc()</code>函数先分配内存。无论如何，使用指针时一定要注意，不要解引用未初始化的指针！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> * pd;　<span class="comment">// 未初始化的指针</span></span><br><span class="line">*pd = <span class="number">2.4</span>;　　<span class="comment">// 不要这样做</span></span><br></pre></td></tr></table></figure>

<p>假设</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> urn[<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> * ptr1, * ptr2;</span><br></pre></td></tr></table></figure>

<p>下面是一些有效和无效的语句：</p>
<table>
<thead>
<tr>
<th>有效语句</th>
<th>无效语句</th>
</tr>
</thead>
<tbody><tr>
<td>ptr1++;</td>
<td>urn++;</td>
</tr>
<tr>
<td>ptr2 &#x3D; ptr1 + 2;</td>
<td>ptr2 &#x3D; ptr2 + ptr1;</td>
</tr>
<tr>
<td>ptr2 &#x3D; urn + 1;</td>
<td>ptr2 &#x3D; urn * ptr1;</td>
</tr>
</tbody></table>
<h2 id="指针常量与常量指针"><a href="#指针常量与常量指针" class="headerlink" title="指针常量与常量指针"></a>指针常量与常量指针</h2><p>C 语言中的指针是非常基础也是非常复杂难懂的概念，其中配合<code>const</code>使用更会让初学者一头雾水，接下来我们就来看看 C 语言中的常量指针和指针常量。</p>
<h3 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h3><p>指针指向的对象是常量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * pt = &amp;a;</span><br></pre></td></tr></table></figure>

<p>因为<code>const</code>修饰的是<code>int</code>，所以<code>pt</code>所指向的内存地址所对应的值是常量不可修改。故，如下写法编译器会报错：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*pt = <span class="number">10</span>; <span class="comment">// Read-only variable is not assignable</span></span><br></pre></td></tr></table></figure>

<p>虽然<code>pt</code>指向的内容是不可变的，但是指针本身并没有被<code>const</code>修饰，所以指针本身是可变的，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">pt = &amp;b;</span><br></pre></td></tr></table></figure>

<h3 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h3><p>指针本身是一个常量，所以指针的指向不允许被修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="type">const</span> pr = &amp;a;</span><br></pre></td></tr></table></figure>

<p>因为<code>const</code>修饰的是指针<code>pr</code>，所以指针所指向的地址是不可以被修改的，如下代码编译器会报错：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pr = &amp;b; <span class="comment">// Cannot assign to variable &#x27;pr&#x27; with const-qualified type &#x27;int *const&#x27;</span></span><br></pre></td></tr></table></figure>

<p>但是变量<code>a</code>并不是常量，所以其值可以被修改，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*pr = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<h3 id="其他写法"><a href="#其他写法" class="headerlink" title="其他写法"></a>其他写法</h3><p>如下均表示常量指针，意义相同：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> * p;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> * p;</span><br></pre></td></tr></table></figure>

<p>如下两行代码均表示的是常量指针 p 指向一个 int 常量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> * <span class="type">const</span> p;</span><br></pre></td></tr></table></figure>

<h2 id="指针和多维数组"><a href="#指针和多维数组" class="headerlink" title="指针和多维数组"></a>指针和多维数组</h2><p>指针和多维数组有什么关系？为什么要了解它们的关系？处理多维数组的函数要用到指针，所以在使用这种函数之前，先要更深入地学习指针。至于第 1 个问题，我们通过几个示例来回答。为简化讨论，我们使用较小的数组。假设有下面的声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> zippo[<span class="number">4</span>][<span class="number">2</span>]; <span class="comment">/* 内含 int 数组的数组 */</span></span><br></pre></td></tr></table></figure>

<p>然后数组名<code>zippo</code>是该数组首元素的地址。在本例中，<code>zippo</code>的首元素是一个内含两个<code>int</code>值的数组，所以<code>zippo</code>是这个内含两个<code>int</code>值的数组的地址。下面，我们从指针的属性进一步分析。</p>
<p>因为<code>zippo</code>是数组首元素的地址，所以<code>zippo</code>的值和<code>&amp;zippo[0]</code>的值相同。而<code>zippo[0]</code>本身是一个内含两个整数的数组，所以<code>zippo[0]</code>的值和它首元素（一个整数）的地址（即<code>&amp;zippo[0][0]</code>的值）相同。简而言之，<code>zippo[0]</code>是一个占用一个<code>int</code>大小对象的地址，而<code>zippo</code>是一个占用两个<code>int</code>大小对象的地址。由于这个整数和内含两个整数的数组都开始于同一个地址，所以<code>zippo</code>和<code>zippo[0]</code>的值相同。</p>
<p>给指针或地址加 1，其值会增加对应类型大小的数值。在这方面，<code>zippo</code>和<code>zippo[0]</code>不同，因为<code>zippo</code>指向的对象占用了两个<code>int</code>大小，而<code>zippo[0]</code>指向的对象只占用一个<code>int</code>大小。因此，<code>zippo + 1</code>和<code>zippo[0] + 1</code>的值不同。</p>
<p>解引用一个指针（在指针前使用<code>*</code>运算符）或在数组名后使用带下标的<code>[]</code>运算符，得到引用对象代表的值。因为<code>zippo[0]</code>是该数组首元素（<code>zippo[0][0]</code>）的地址，所以<code>*(zippo[0])</code>表示储存在<code>zippo[0][0]</code>上的值（即一个<code>int</code>类型的值）。与此类似，<code>*zippo</code>代表该数组首元素（<code>zippo[0]</code>）的值，但是<code>zippo[0]</code>本身是一个<code>int</code>类型值的地址。该值的地址是<code>&amp;zippo[0][0]</code>，所以<code>*zippo</code>就是<code>&amp;zippo[0][0]</code>。对两个表达式应用解引用运算符表明，<code>**zippo</code>与<code>*&amp;zippo[0][0]</code>等价，这相当于<code>zippo[0][0]</code>，即一个<code>int</code>类型的值。简而言之，<code>zippo</code>是地址的地址，必须解引用两次才能获得原始值。地址的地址或指针的指针是就是双重间接（double indirection）的例子。</p>
<p>显然，增加数组维数会增加指针的复杂度。现在，大部分初学者都开始意识到指针为什么是 C 语言中最难的部分。认真思考上述内容，看看是否能用所学的知识解释程序清单 10.15 中的程序。该程序显示了一些地址值和数组的内容。</p>
<p><strong>程序清单 10.15 zippo1.c 程序</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* zippo1.c -- zippo的相关信息 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> zippo[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123; <span class="number">2</span>, <span class="number">4</span> &#125;, &#123; <span class="number">6</span>, <span class="number">8</span> &#125;, &#123; <span class="number">1</span>, <span class="number">3</span> &#125;, &#123; <span class="number">5</span>, <span class="number">7</span> &#125; &#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;zippo             = %p, zippo + 1    = %p\n&quot;</span>,zippo, zippo + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;zippo[0]          = %p, zippo[0] + 1 = %p\n&quot;</span>,zippo[<span class="number">0</span>], zippo[<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;*zippo            = %p, *zippo + 1   = %p\n&quot;</span>,*zippo, *zippo + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;zippo[0][0]       = %d\n&quot;</span>, zippo[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;*zippo[0]         = %d\n&quot;</span>, *zippo[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;**zippo           = %d\n&quot;</span>, **zippo);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;zippo[2][1]       = %d\n&quot;</span>, zippo[<span class="number">2</span>][<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;*(*(zippo+2) + 1) = %d\n&quot;</span>, *(*(zippo + <span class="number">2</span>) + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是我们的系统运行该程序后的输出：</p>
<img src="/my_pictures/20230309/4.png" style="zoom: 70%;" />

<p>要特别注意，与<code>zippo[2][1]</code>等价的指针表示法是<code>*(*(zippo+2) + 1)</code>。看上去比较复杂，应最好能理解。下面列出了理解该表达式的思路：</p>
<img src="/my_pictures/20230309/5.png" style="zoom: 50%;" />

<p>下图以另一种视图演示了数组地址、数组内容和指针之间的关系。</p>
<img src="/my_pictures/20230309/6.png" style="zoom: 45%;" />

<h3 id="指向多维数组的指针"><a href="#指向多维数组的指针" class="headerlink" title="指向多维数组的指针"></a>指向多维数组的指针</h3><p>如何声明一个指针变量<code>pz</code>指向一个二维数组（如，<code>zippo</code>）？在编写处理类似<code>zippo</code>这样的二维数组时会用到这样的指针。把指针声明为指向<code>int</code>的类型还不够。因为指向<code>int</code>只能与<code>zippo[0]</code>的类型匹配，说明该指针指向一个<code>int</code>类型的值。但是<code>zippo</code>是它首元素的地址，该元素是一个内含两个<code>int</code>类型值的一维数组。因此，<code>pz</code>必须指向一个内含两个<code>int</code>类型值的数组，而不是指向一个<code>int</code>类型值，其声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (* pz)[<span class="number">2</span>];　　<span class="comment">// pz指向一个内含两个 int 类型值的数组</span></span><br></pre></td></tr></table></figure>

<p>以上代码把<code>pz</code>声明为指向一个数组的指针，该数组内含两个<code>int</code>类型值。为什么要在声明中使用圆括号？因为<code>[]</code>的优先级高于<code>*</code>。考虑下面的声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * pax[<span class="number">2</span>];　　 <span class="comment">// pax 是一个内含两个指针元素的数组，每个元素都指向 int 的指针</span></span><br></pre></td></tr></table></figure>

<p>由于<code>[]</code>优先级高，先与<code>pax</code>结合，所以<code>pax</code>成为一个内含两个元素的数组。然后<code>*</code>表示<code>pax</code>数组内含两个指针。最后，<code>int</code>表示<code>pax</code>数组中的指针都指向<code>int</code>类型的值。因此，这行代码声明了两个指向<code>int</code>的指针。而前面有圆括号的版本，<code>*</code>先与<code>pz</code>结合，因此声明的是一个指向数组（内含两个<code>int</code>类型的值）的指针。程序清单 10.16 演示了如何使用指向二维数组的指针。</p>
<p><strong>程序清单10.16 zippo2.c程序</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* zippo2.c -- 通过指针获取zippo的信息 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> zippo[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123; <span class="number">2</span>, <span class="number">4</span> &#125;, &#123; <span class="number">6</span>, <span class="number">8</span> &#125;, &#123; <span class="number">1</span>, <span class="number">3</span> &#125;, &#123; <span class="number">5</span>, <span class="number">7</span> &#125; &#125;;</span><br><span class="line">  <span class="type">int</span>(*pz)[<span class="number">2</span>];</span><br><span class="line">  pz = zippo;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pz       = %p, pz + 1    = %p\n&quot;</span>,  pz, pz + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pz[0]    = %p, pz[0] + 1 = %p\n&quot;</span>,  pz[<span class="number">0</span>], pz[<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;*pz      = %p, *pz + 1   = %p\n&quot;</span>,  *pz, *pz + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pz[0][0] = %d\n&quot;</span>, pz[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;*pz[0]   = %d\n&quot;</span>, *pz[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;**pz     = %d\n&quot;</span>, **pz);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pz[2][1] = %d\n&quot;</span>, pz[<span class="number">2</span>][<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;*(*(pz+2) + 1) = %d\n&quot;</span>, *(*(pz + <span class="number">2</span>) + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是该程序的输出：</p>
<img src="/my_pictures/20230309/7.png" style="zoom: 70%;" />

<p>如前所述，虽然<code>pz</code>是一个指针，不是数组名，但是也可以使用 <code>pz[2][1]</code>这样的写法。可以用数组表示法或指针表示法来表示一个数组元素，既可以使用数组名，也可以使用指针名：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zippo[m][n] == *(*(zippo + m) + n)</span><br><span class="line">pz[m][n] == *(*(pz + m) + n)</span><br></pre></td></tr></table></figure>

<h3 id="多维数组的声明"><a href="#多维数组的声明" class="headerlink" title="多维数组的声明"></a>多维数组的声明</h3><p>如果要编写处理二维数组的函数，首先要能正确地理解指针才能写出声明函数的形参。在函数体中，通常使用数组表示法进行相关操作。可以这样声明函数的形参：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">somefunction</span><span class="params">(<span class="type">int</span> (* pt)[<span class="number">4</span>])</span>;</span><br></pre></td></tr></table></figure>

<p>另外，如果当且仅当<code>pt</code>是一个函数的形式参数时，可以这样声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">somefunction</span><span class="params">(<span class="type">int</span> pt[][<span class="number">4</span>])</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，第 1 个方括号是空的。空的方括号表明<code>pt</code>是一个指针。</p>
</blockquote>
<p>注意，下面的声明不正确：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum2</span><span class="params">(<span class="type">int</span> ar[][], <span class="type">int</span> rows)</span>; <span class="comment">// 错误的声明</span></span><br></pre></td></tr></table></figure>

<p>前面介绍过，编译器会把数组表示法转换成指针表示法。例如，编译器会把<code>ar[1]</code>转换成<code>ar+1</code>。编译器对<code>ar+1</code>求值，要知道<code>ar</code>所指向的对象大小。下面的声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum2</span><span class="params">(<span class="type">int</span> ar[][<span class="number">4</span>], <span class="type">int</span> rows)</span>;　　<span class="comment">// 有效声明</span></span><br></pre></td></tr></table></figure>

<p>表示<code>ar</code>指向一个内含 4 个<code>int</code>类型值的数组（在我们的系统中，<code>ar</code>指向的对象占 16 字节），所以<code>ar+1</code>的意思是“该地址加上 16 字节”。如果第 2 对方括号是空的，编译器就不知道该怎样处理。</p>
<p>也可以在第 1 对方括号中写上大小，如下所示，但是编译器会忽略该值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum2</span><span class="params">(<span class="type">int</span> ar[<span class="number">3</span>][<span class="number">4</span>], <span class="type">int</span> rows)</span>; <span class="comment">// 有效声明，但是3将被忽略</span></span><br></pre></td></tr></table></figure>

<h3 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h3><p>C99 新增了变长数组（variable-length array，VLA），允许使用变量表示数组的维度。如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>　quarters　=　<span class="number">4</span>;</span><br><span class="line"><span class="type">int</span>　regions　=　<span class="number">5</span>;</span><br><span class="line"><span class="type">double</span> sales[regions][quarters];　　<span class="comment">// 一个变长数组（VLA）</span></span><br></pre></td></tr></table></figure>

<p>前面提到过，变长数组有一些限制。变长数组必须是自动存储类别，这意味着无论在函数中声明还是作为函数形参声明，都不能使用<code>static</code>或<code>extern</code>存储类别说明符（在之后章节介绍）。而且，不能在声明中初始化它们。最终，C11 把变长数组作为一个可选特性，而不是必须强制实现的特性。</p>
<blockquote>
<p><strong>注意 变长数组不能改变大小</strong></p>
<p>长数组中的“变”不是指可以修改已创建数组的大小。一旦创建了变长数组，它的大小则保持不变。这里的“变”指的是：在创建数组时，可以使用变量指定数组的维度。</p>
</blockquote>
<p>由于变长数组是 C 语言的新特性，目前完全支持这一特性的编译器不多。下面我们来看一个简单的例子：如何编写一个函数，计算<code>int</code>的二维数组所有元素之和。<br>首先，要声明一个带二维变长数组参数的函数，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum2d</span><span class="params">(<span class="type">int</span> rows, <span class="type">int</span> cols, <span class="type">int</span> ar[rows][cols])</span>; <span class="comment">// ar 是一个变长数组（VLA）</span></span><br></pre></td></tr></table></figure>

<p>注意前两个形参（<code>rows</code>和<code>cols</code>）用作第 3 个形参二维数组<code>ar</code>的两个维度。因为<code>ar</code>的声明要使用<code>rows</code>和<code>cols</code>，所以在形参列表中必须在声明<code>ar</code>之前先声明这两个形参。因此，下面的原型是错误的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum2d</span><span class="params">(<span class="type">int</span> ar[rows][cols], <span class="type">int</span> rows, <span class="type">int</span> cols)</span>; <span class="comment">// 无效的顺序</span></span><br></pre></td></tr></table></figure>

<p>C99&#x2F;C11 标准规定，可以省略原型中的形参名，但是在这种情况下，必须用星号来代替省略的维度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum2d</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span> ar[*][*])</span>; <span class="comment">// ar 是一个变长数组（VLA），省略了维度形参名</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>const 和数组大小</strong></p>
<p>是否可以在声明数组时使用<code>const</code>变量？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span>　<span class="type">int</span>　SZ　=　<span class="number">80</span>;</span><br><span class="line">...</span><br><span class="line"><span class="type">double</span> ar[SZ]; <span class="comment">// 是否允许？</span></span><br></pre></td></tr></table></figure>

<p>C90 标准不允许（也可能允许）。数组的大小必须是给定的整型常量表达式，可以是整型常量组合，如 20、<code>sizeof</code>表达式或其他不是<code>const</code>的内容。由于 C 实现可以扩大整型常量表达式的范围，所以可能会允许使用<code>const</code>，但是这种代码可能无法移植。<br>C99&#x2F;C11 标准允许在声明变长数组时使用<code>const</code>变量。所以该数组的定义必须是声明在块中的自动存储类别数组。</p>
</blockquote>
<p>变长数组还允许动态内存分配，这说明可以在程序运行时指定数组的大小。普通 C 数组都是静态内存分配，即在编译时确定数组的大小。由于数组大小是常量，所以编译器在编译时就知道了。之后章节将详细介绍动态内存分配。</p>
<h3 id="复合字面量"><a href="#复合字面量" class="headerlink" title="复合字面量"></a>复合字面量</h3><p>假设给带<code>int</code>类型形参的函数传递一个值，要传递<code>int</code>类型的变量，但是也可以传递<code>int</code>类型常量，如 5。在 C99 标准以前，对于带数组形参的函数，情况不同，可以传递数组，但是没有等价的数组常量。C99 新增了复合字面量（compound literal）。字面量是除符号常量外的常量。例如，5 是<code>int</code>类型字面量， 81.3 是<code>double</code>类型的字面量，<code>&#39;Y&#39;</code>是<code>char</code>类型的字面量，<code>&quot;elephant&quot;</code>是字符串字面量。发布 C99 标准的委员会认为，如果有代表数组和结构内容的复合字面量，在编程时会更方便。</p>
<p>对于数组，复合字面量类似数组初始化列表，前面是用括号括起来的类型名。例如，下面是一个普通的数组声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> diva[<span class="number">2</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>下面的复合字面量创建了一个和<code>diva</code>数组相同的匿名数组，也有两个<code>int</code>类型的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">int</span> [<span class="number">2</span>])&#123;<span class="number">10</span>, <span class="number">20</span>&#125;　　　<span class="comment">// 复合字面量</span></span><br></pre></td></tr></table></figure>

<p>注意，去掉声明中的数组名，留下的<code>int [2]</code>即是复合字面量的类型名。<br>初始化有数组名的数组时可以省略数组大小，复合字面量也可以省略大小，编译器会自动计算数组当前的元素个数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">int</span> [])&#123;<span class="number">50</span>, <span class="number">20</span>, <span class="number">90</span>&#125; <span class="comment">// 内含 3 个元素的复合字面量</span></span><br></pre></td></tr></table></figure>

<p>因为复合字面量是匿名的，所以不能先创建然后再使用它，必须在创建的同时使用它。使用指针记录地址就是一种用法。也就是说，可以这样用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * pt1;</span><br><span class="line">pt1 = (<span class="type">int</span> [<span class="number">2</span>]) &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，该复合字面量的字面常量与上面创建的<code>diva</code>数组的字面常量完全相同。与有数组名的数组类似，复合字面量的类型名也代表首元素的地址，所以可以把它赋给指向<code>int</code>的指针。然后便可使用这个指针。例如，本例中<code>*pt1</code>是 10，<code>pt1[1]</code>是 20。<br>还可以把复合字面量作为实际参数传递给带有匹配形式参数的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>　<span class="title function_">sum</span><span class="params">(<span class="type">const</span>　<span class="type">int</span>　ar[],　<span class="type">int</span>　n)</span>;</span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> total3;</span><br><span class="line">total3 = sum((<span class="type">int</span> [])&#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>&#125;, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>这里，第 1 个实参是内含 6 个<code>int</code>类型值的数组，和数组名类似，这同时也是该数组首元素的地址。这种用法的好处是，把信息传入函数前不必先创建数组，这是复合字面量的典型用法。</p>
<p>可以把这种用法应用于二维数组或多维数组。例如，下面的代码演示了如何创建二维int数组并储存其地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*pt2)[<span class="number">4</span>];　　 <span class="comment">// 声明一个指向二维数组的指针，该数组内含 2 个数组元素，</span></span><br><span class="line">									<span class="comment">// 每个元素是内含 4 个 int 类型值的数组</span></span><br><span class="line">pt2　=　(<span class="type">int</span>　[<span class="number">2</span>][<span class="number">4</span>])　&#123;　&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">-9</span>&#125;,　&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">-8</span>&#125;　&#125;;</span><br></pre></td></tr></table></figure>

<p>如上所示，该复合字面量的类型是<code>int [2][4]</code>，即一个 2×4 的<code>int</code>数组。</p>
<p>程序清单 10.19 把上述例子放进一个完整的程序中。</p>
<p><strong>程序清单 10.19 flc.c 程序</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flc.c -- 有趣的常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLS 4</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum2d</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ar[][COLS], <span class="type">int</span> rows)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ar[], <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> total1, total2, total3;</span><br><span class="line">  <span class="type">int</span> * pt1;</span><br><span class="line">  <span class="type">int</span>(*pt2)[COLS];</span><br><span class="line">  pt1 = (<span class="type">int</span>[<span class="number">2</span>]) &#123; <span class="number">10</span>, <span class="number">20</span> &#125;;</span><br><span class="line">  pt2 = (<span class="type">int</span>[<span class="number">2</span>][COLS]) &#123; &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">-9</span>&#125;, &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">-8</span> &#125; &#125;;</span><br><span class="line">  total1 = sum(pt1, <span class="number">2</span>);</span><br><span class="line">  total2 = sum2d(pt2, <span class="number">2</span>);</span><br><span class="line">  total3 = sum((<span class="type">int</span> [])&#123; <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span> &#125;, <span class="number">6</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;total1 = %d\n&quot;</span>, total1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;total2 = %d\n&quot;</span>, total2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;total3 = %d\n&quot;</span>, total3);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ar [], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  total += ar[i];</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum2d</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ar [][COLS], <span class="type">int</span> rows)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (r = <span class="number">0</span>; r &lt; rows; r++)</span><br><span class="line">  <span class="keyword">for</span> (c = <span class="number">0</span>; c &lt; COLS; c++)</span><br><span class="line">  tot += ar[r][c];</span><br><span class="line">  <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记住，复合字面量是提供只临时需要的值的一种手段。复合字面量具有块作用域（以后章节将介绍相关内容），这意味着一旦离开定义复合字面量的块，程序将无法保证该字面量是否存在。也就是说，复合字面量的定义在最内层的花括号中。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数组是一组数据类型相同的元素。数组元素按顺序储存在内存中，通过整数下标（或索引）可以访问各元素。在 C 中，数组首元素的下标是 0，所以对于内含<code>n</code>个元素的数组，其最后一个元素的下标是<code>n-1</code>。作为程序员，要确保使用有效的数组下标，因为编译器和运行的程序都不会检查下标的有效性。<br>声明一个简单的一维数组形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type name [ size ];</span><br></pre></td></tr></table></figure>

<p>这里，<code>type</code>是数组中每个元素的数据类型，<code>name</code>是数组名，<code>size</code>是数组元素的个数。对于传统的 C 数组，要求<code>size</code>是整型常量表达式。但是 C99&#x2F;C11 允许使用整型非常量表达式。这种情况下的数组被称为变长数组。</p>
<p>C 把数组名解释为该数组首元素的地址。换言之，数组名与指向该数组首元素的指针等价。概括地说，数组和指针的关系十分密切。如果<code>ar</code>是一个数组，那么表达式<code>ar[i]</code>和<code>*(ar+i)</code>等价。</p>
<p>对于 C 语言而言，不能把整个数组作为参数传递给函数，但是可以传递数组的地址。然后函数可以使用传入的地址操控原始数组。如果函数没有修改原始数组的意图，应在声明函数的形式参数时使用关键字<code>const</code>。在被调函数中可以使用数组表示法或指针表示法，无论用哪种表示法，实际上使用的都是指针变量。</p>
<p>指针加上一个整数或递增指针，指针的值以所指向对象的大小为单位改变。也就是说，如果<code>pd</code>指向一个数组的 8 字节<code>double</code>类型值，那么<code>pd</code>加 1 意味着其值加 8，以便它指向该数组的下一个元素。</p>
<p>二维数组即是数组的数组。例如，下面声明了一个二维数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> sales[<span class="number">5</span>][<span class="number">12</span>];</span><br></pre></td></tr></table></figure>

<p>该数组名为<code>sales</code>，有 5 个元素（一维数组），每个元素都是一个内含 12 个<code>double</code>类型值的数组。第 1 个一维数组是<code>sales[0]</code>，第 2 个一维数组是<code>sales[1]</code>，以此类推，每个元素都是内含 12 个<code>double</code>类型值的数组。使用第 2 个下标可以访问这些一维数组中的特定元素。例如，<code>sales[2][5]</code>是<code>slaes[2]</code>的第 6 个元素，而<code>sales[2]</code>是<code>sales</code>的第 3 个元素。</p>
<p>C 语言传递多维数组的传统方法是把数组名（即数组的地址）传递给类型匹配的指针形参。声明这样的指针形参要指定所有的数组维度，除了第 1 个维度。传递的第 1 个维度通常作为第 2 个参数。例如，为了处理前面声明的<code>sales</code>数组，函数原型和函数调用如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>　<span class="title function_">display</span><span class="params">(<span class="type">double</span>　ar[][<span class="number">12</span>],　<span class="type">int</span>　rows)</span>;</span><br><span class="line">...</span><br><span class="line">display(sales, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>变长数组提供第 2 种语法，把数组维度作为参数传递。在这种情况下，对应函数原型和函数调用如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>　<span class="title function_">display</span><span class="params">(<span class="type">int</span>　rows,　<span class="type">int</span>　cols,　<span class="type">double</span>　ar[rows][cols])</span>;</span><br><span class="line">...</span><br><span class="line">display(<span class="number">5</span>, <span class="number">12</span>, sales);</span><br></pre></td></tr></table></figure>

<p>虽然上述讨论中使用的是<code>int</code>类型的数组和<code>double</code>类型的数组，其他类型的数组也是如此。然而，字符串有一些特殊的规则，这是由于其末尾的空字符所致。有了这个空字符，不用传递数组的大小，函数通过检测字符串的末尾也知道在何处停止。我们将在以后章节中详细介绍。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>C Primer Plus</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/03/08/20230308-C%20%E8%AF%AD%E8%A8%80%E9%87%8D%E6%8B%BE%E3%80%90%E5%9B%9B%E3%80%91/" rel="prev" title="C 语言重拾【四】ctype.h 系列的字符函数">
                  <i class="fa fa-angle-left"></i> C 语言重拾【四】ctype.h 系列的字符函数
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/03/17/20230317-%E4%BB%A3%E7%90%86%20Xcode%20SPM/" rel="next" title="代理 Xcode SPM">
                  代理 Xcode SPM <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2018 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">轩辕十四</span>
  </div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9taXN0Lw==">NexT.Mist</span> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JlZ3VsdXNsZW93" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>



  




<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"regulusleow-github-io","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
