<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/avatar_images/apple-touch-icon-avatar.webp">
  <link rel="icon" type="image/png" sizes="32x32" href="/avatar_images/favicon-32x32-avatar.webp">
  <link rel="icon" type="image/png" sizes="16x16" href="/avatar_images/favicon-16x16-avatar.webp">
  <meta name="google-site-verification" content="XhaJbrdsD96m39iYKuBCoofZVM7q9cGB5zf-KI1L7Ss">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"regulusleow.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.22.0","exturl":true,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"default"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"stickytabs":false,"motion":{"enable":false,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="用 Objective-C 等面向对象语言编程时，“对象”（object）就是“基本构造单元”（building block），开发者可以通过对象来存储并传递数据。在对象之间传递数据并执行任务的过程就叫做“消息传递”（Messaging）。若想编写出高效且易维护的代码，就一定要熟悉这两个特性的工作原理。 当应用程序运行起来以后，为其提供相关支持的代码叫做“Objective-C 运行期环境”（Ob">
<meta property="og:type" content="article">
<meta property="og:title" content="Objective-C 回顾【二】之 对象、消息、运行期">
<meta property="og:url" content="https://regulusleow.github.io/2018/04/23/20180423-Objective-C%20%E5%9B%9E%E9%A1%BE%E3%80%90%E4%BA%8C%E3%80%91%E4%B9%8B%20%E5%AF%B9%E8%B1%A1%E3%80%81%E6%B6%88%E6%81%AF%E3%80%81%E8%BF%90%E8%A1%8C%E6%9C%9F/index.html">
<meta property="og:site_name" content="轩辕十四">
<meta property="og:description" content="用 Objective-C 等面向对象语言编程时，“对象”（object）就是“基本构造单元”（building block），开发者可以通过对象来存储并传递数据。在对象之间传递数据并执行任务的过程就叫做“消息传递”（Messaging）。若想编写出高效且易维护的代码，就一定要熟悉这两个特性的工作原理。 当应用程序运行起来以后，为其提供相关支持的代码叫做“Objective-C 运行期环境”（Ob">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://regulusleow.github.io/my_pictures/20180423/1.png">
<meta property="og:image" content="https://regulusleow.github.io/my_pictures/20180423/2.png">
<meta property="og:image" content="https://regulusleow.github.io/my_pictures/20180423/3.png">
<meta property="article:published_time" content="2018-04-22T16:00:00.000Z">
<meta property="article:modified_time" content="2025-10-22T04:01:25.328Z">
<meta property="article:author" content="轩辕十四">
<meta property="article:tag" content="Objective-C">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://regulusleow.github.io/my_pictures/20180423/1.png">


<link rel="canonical" href="https://regulusleow.github.io/2018/04/23/20180423-Objective-C%20%E5%9B%9E%E9%A1%BE%E3%80%90%E4%BA%8C%E3%80%91%E4%B9%8B%20%E5%AF%B9%E8%B1%A1%E3%80%81%E6%B6%88%E6%81%AF%E3%80%81%E8%BF%90%E8%A1%8C%E6%9C%9F/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://regulusleow.github.io/2018/04/23/20180423-Objective-C%20%E5%9B%9E%E9%A1%BE%E3%80%90%E4%BA%8C%E3%80%91%E4%B9%8B%20%E5%AF%B9%E8%B1%A1%E3%80%81%E6%B6%88%E6%81%AF%E3%80%81%E8%BF%90%E8%A1%8C%E6%9C%9F/","path":"2018/04/23/20180423-Objective-C 回顾【二】之 对象、消息、运行期/","title":"Objective-C 回顾【二】之 对象、消息、运行期"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Objective-C 回顾【二】之 对象、消息、运行期 | 轩辕十四</title>
  



  <script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{&quot;token&quot;: &quot;1cb638399d744ce59f291432164b2248&quot;}'></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">轩辕十四</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">探索科技与创新的个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E2%80%9C%E5%B1%9E%E6%80%A7%E2%80%9D%E8%BF%99%E4%B8%80%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">理解“属性”这一概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E7%89%B9%E8%B4%A8"><span class="nav-number">1.1.</span> <span class="nav-text">属性特质</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E5%B0%BD%E9%87%8F%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F"><span class="nav-number">2.</span> <span class="nav-text">在对象内部尽量直接访问实例变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E2%80%9C%E5%AF%B9%E8%B1%A1%E7%AD%89%E5%90%8C%E6%80%A7%E2%80%9D%E8%BF%99%E4%B8%80%E6%A6%82%E5%BF%B5"><span class="nav-number">3.</span> <span class="nav-text">理解“对象等同性”这一概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E6%97%A2%E6%9C%89%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%94%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE"><span class="nav-number">4.</span> <span class="nav-text">在既有类中使用关联对象存放自定义数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3-objc-msgSend-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">5.</span> <span class="nav-text">理解 objc_msgSend 的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="nav-number">6.</span> <span class="nav-text">理解消息转发机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="nav-number">6.1.</span> <span class="nav-text">动态方法解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%87%E6%8F%B4%E6%8E%A5%E6%94%B6%E8%80%85"><span class="nav-number">6.2.</span> <span class="nav-text">备援接收者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91"><span class="nav-number">6.3.</span> <span class="nav-text">完整的消息转发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number">6.4.</span> <span class="nav-text">一个完整的例子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%96%B9%E6%B3%95%E8%B0%83%E9%85%8D%EF%BC%88method-swizzling%EF%BC%89%E6%8A%80%E6%9C%AF%E8%B0%83%E8%AF%95%E2%80%9C%E9%BB%91%E7%9B%92%E6%96%B9%E6%B3%95%E2%80%9D"><span class="nav-number">7.</span> <span class="nav-text">用方法调配（method swizzling）技术调试“黑盒方法”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E2%80%9C%E7%B1%BB%E5%AF%B9%E8%B1%A1%E2%80%9D%E7%9A%84%E7%94%A8%E6%84%8F"><span class="nav-number">8.</span> <span class="nav-text">理解“类对象”的用意</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E7%B1%BB%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%AD%E6%9F%A5%E8%AF%A2%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="nav-number">8.1.</span> <span class="nav-text">在类继承体系中查询类型信息</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="轩辕十四"
      src="/avatar_images/avatar.webp">
  <p class="site-author-name" itemprop="name">轩辕十四</p>
  <div class="site-description" itemprop="description">Stay hungry. Stay foolish.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">127</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">48</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JlZ3VsdXNsZW93" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;regulusleow"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9yZWd1bHVzX3dq" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;regulus_wj"><i class="fab fa-twitter fa-fw"></i>Twitter</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly90Lm1lL3JlZ3Vzdw==" title="Telegram → https:&#x2F;&#x2F;t.me&#x2F;regusw"><i class="fab fa-telegram fa-fw"></i>Telegram</span>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://regulusleow.github.io/2018/04/23/20180423-Objective-C%20%E5%9B%9E%E9%A1%BE%E3%80%90%E4%BA%8C%E3%80%91%E4%B9%8B%20%E5%AF%B9%E8%B1%A1%E3%80%81%E6%B6%88%E6%81%AF%E3%80%81%E8%BF%90%E8%A1%8C%E6%9C%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar_images/avatar.webp">
      <meta itemprop="name" content="轩辕十四">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="轩辕十四">
      <meta itemprop="description" content="Stay hungry. Stay foolish.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Objective-C 回顾【二】之 对象、消息、运行期 | 轩辕十四">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Objective-C 回顾【二】之 对象、消息、运行期
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-23 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-23T00:00:00+08:00">2018-04-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2018/04/23/20180423-Objective-C%20%E5%9B%9E%E9%A1%BE%E3%80%90%E4%BA%8C%E3%80%91%E4%B9%8B%20%E5%AF%B9%E8%B1%A1%E3%80%81%E6%B6%88%E6%81%AF%E3%80%81%E8%BF%90%E8%A1%8C%E6%9C%9F/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/04/23/20180423-Objective-C 回顾【二】之 对象、消息、运行期/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>用 Objective-C 等面向对象语言编程时，“对象”（object）就是“基本构造单元”（building block），开发者可以通过对象来存储并传递数据。在对象之间传递数据并执行任务的过程就叫做“消息传递”（Messaging）。若想编写出高效且易维护的代码，就一定要熟悉这两个特性的工作原理。</p>
<p>当应用程序运行起来以后，为其提供相关支持的代码叫做“Objective-C 运行期环境”（Objective-C runtime），它提供了一些使得对象之间能够传递消息的重要函数，并且包含创建类实例所用的全部逻辑。在理解了运行期环境中各个部分协同工作的原理之后，你的开发水平将会进一步提升。</p>
<h3 id="理解“属性”这一概念"><a href="#理解“属性”这一概念" class="headerlink" title="理解“属性”这一概念"></a>理解“属性”这一概念</h3><hr>
<p>“属性”（property）是 Objective-C 的一项特性，用于封装对象中的数据。Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”（access method）来访问，也就是 <code>getter</code> 和 <code>setter</code> 方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCPerson</span>: <span class="title">NSOjbect</span> </span>&#123;</span><br><span class="line"><span class="keyword">@public</span></span><br><span class="line">    <span class="built_in">NSString</span> *_firstName;</span><br><span class="line">    <span class="built_in">NSString</span> *_lastName;</span><br><span class="line"><span class="keyword">@private</span></span><br><span class="line">    <span class="built_in">NSString</span> *_someInternalData;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>上面的代码对于写过 Java 和 C++ 程序的人来说比较熟悉，但是 Objective-C 中却很少这么做。这种写法的问题是：对象布局在编译期已经固定了，只要碰到方位 <code>_firstName</code> 变量的代码，编译器就把其替换为“偏移量”（offset），这个偏移量是“硬编码”（hardcode），表示该变量距离存放对象的内存区域的起始地址有多远。这样做目前看来没什么问题，但是如果又加了一个实例变量，那就麻烦了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCPerson</span>: <span class="title">NSOjbect</span> </span>&#123;</span><br><span class="line"><span class="keyword">@public</span></span><br><span class="line">    <span class="built_in">NSDate</span> *_dateOfBirth;</span><br><span class="line">    <span class="built_in">NSString</span> *_firstName;</span><br><span class="line">    <span class="built_in">NSString</span> *_lastName;</span><br><span class="line"><span class="keyword">@private</span></span><br><span class="line">    <span class="built_in">NSString</span> *_someInternalData;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>原来表示 <code>_firstName</code> 的偏移量现在却指向 <code>_dateOfBirth</code> 了。把偏移量硬编码于其中的那些代码都会读取到错误的值。如下图所示：</p>
<p><img src="/my_pictures/20180423/1.png"></p>
<p>如果代码使用了编译期计算出来的偏移量，那么在修改类定义之后必须重新编译，否则就会出错。例如，某个代码库中的代码使用了一份旧的类定义。如果和其相链接的代码使用了新的类定义，那么运行时就会出现不兼容的现象。</p>
<p>Objective-C 的解决方式：</p>
<ul>
<li>稳固的“应用程序二进制接口”（Application Binary Interface，ABI）。<ul>
<li>将实例变量当做一种存储偏移量所用的“特殊变量”，交由“类对象”保管。偏移量会在运行时期查找，如果类的定义变了，那么存储的偏移量也就变了，这样的话，无论何时访问实例变量，总能使用正确的偏移量。甚至可以在运行期向类中新增实例变量。</li>
</ul>
</li>
<li>尽量不要直接访问实例变量（在对象之外），而是通过存取方法来做。</li>
</ul>
<p>属性的优势：</p>
<ul>
<li>使用“点语法”相当于调用存取方法。</li>
<li>自动生成存取方法（前提是没有用 <code>@dynamic</code> 做限制）。<ul>
<li><code>@dynamic</code> 关键字会告诉编译器：不要自动创建属性所用的实例变量，也不要为其创建存取方法。而且，在编译访问属性代码时，即使编译器发现没有定义存取方法，也不会报错，它相信这些方法能在运行期找到。比方说，如果从 CoreData 框架中的 <code>NSManagedObject</code> 类里继承了一个子类，那么就需要在运行期动态创建存取方法。继承 <code>NSManagedObject</code> 时之所以要这样做，是因为子类的某些属性不是实例变量，其数据来自后端的数据库。</li>
</ul>
</li>
<li>自动生成加下划线的实例变量。</li>
<li>我们可以用 <code>@synthesize</code> 来指定实例变量的名字。（不推荐）</li>
</ul>
<h4 id="属性特质"><a href="#属性特质" class="headerlink" title="属性特质"></a>属性特质</h4><ul>
<li>原子性（atomic&#x2F;nonatomic）</li>
<li>读&#x2F;写权限（readwrite&#x2F;readonly）</li>
<li>内存管理语义<ul>
<li><code>assign</code>：针对于“纯量类型”（scalar type，例如：<code>CGFloat</code> 或 <code>NSInteger</code>等）的简单赋值操作。</li>
<li><code>strong</code>：定义了一种“拥有关系”。为这种属性设置新值时，设置方法会先保留新值，并释放旧值，然后再将新值设置上去。</li>
<li><code>weak</code>：定义了一种“非拥有关系”。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同 <code>assign</code> 类似，然后在属性所指的对象遭到摧毁时，属性值也会清空。</li>
<li><code>unsafe_unretained</code>：此特质的语义和 <code>assign</code> 相同，但是它适用于“对象类型”，该特质表达一种“非拥有关系”，当目标对象遭到摧毁时，属性值不会自动清空（“不安全”，unsafe），这一点与 <code>weak</code> 有区别。</li>
<li><code>copy</code>：此特质所表达的所属关系与 <code>strong</code> 类似。然而设置方法并不保留新值，而是将其“拷贝”（copy）。当属性类型为 <code>NSString*</code> 时，经常用此特质来保护其封装性。</li>
</ul>
</li>
<li>方法名<ul>
<li><code>getter=&lt;name&gt;</code> 指定“获取方法”的方法名。</li>
<li><code>setter=&lt;name&gt;</code> 指定“设置方法”的方法名。这种用法不太常见。</li>
</ul>
</li>
</ul>
<p><strong>要点：</strong></p>
<ul>
<li>可以用 <code>@property</code> 语法来定义对象中所封装的数据</li>
<li>通过“特质”来指定存储数据所需要的正确语义。</li>
<li>在设置属性所对应的实例变量时，一定要遵从该属性所声明的语义。</li>
<li>开发 iOS 程序时应该使用 <code>nonatomic</code> 属性，因为 <code>atomic</code> 属性会严重影响性能。</li>
</ul>
<h3 id="在对象内部尽量直接访问实例变量"><a href="#在对象内部尽量直接访问实例变量" class="headerlink" title="在对象内部尽量直接访问实例变量"></a>在对象内部尽量直接访问实例变量</h3><hr>
<p><strong>在读取实例变量的时候采用直接访问的形式，而在设置实例变量的时候通过属性来做。</strong>此办法既能提高读取操作的速度，又能控制对属性的写入操作。之所以要通过“设置方法”来写入实例变量，其首要原因在于，这样做能够确保相关属性的“内存管理语义”得以贯彻。选用这种做法时，需要注意两点：</p>
<ul>
<li>在初始化方法中应该如何设置属性值。这种情况下<strong>总是应该直接访问实例变量</strong>，因为子类可能会“覆写”设置方法。</li>
<li>“惰性初始化”：这种情况下<strong>必须通过“获取方法”来访问属性</strong>，否则，实例变量就永远不会初始化。</li>
</ul>
<p><strong>直接访问实例变量和通过属性访问有几点区别：</strong></p>
<ul>
<li>由于不经过 Objective-C 的“方法派发”步骤，所以直接访问实例变量的速度当然比较快。在这种情况下，编译器所生成的代码会直接访问保存对象实例变量的那块内存。</li>
<li>直接访问实例变量时，不会调用其“设置方法”，这就绕过了为相关属性所定义的“内存管理语义”。比方说，如果在 ARC 下直接访问一个声明为 <code>copy</code> 的属性，那么并不会拷贝该属性，只会保留新值并释放旧值。</li>
<li>如果直接访问实例变量，那么不会触发“键值观测”（KVO）通知。这样做是否会产生问题，还取决于具体的对象行为。</li>
<li>通过属性来访问有助于排查与之相关的错误，因为可以给“获取方法”和&#x2F;或“设置方法”中新增“断点”，监控该属性的调用者及其访问时机。</li>
</ul>
<p><strong>要点：</strong></p>
<ul>
<li>在对象内部读取数据时，应该直接通过实例变量来读取，而写入数据时，则应通过属性来写</li>
<li>在初始化方法及 <code>dealloc</code> 方法中，总是应该直接通过实例变量来读写数据。</li>
<li>有时会使用惰性初始化技术配置某分数据，这种情况下，需要通过属性来读取数据。</li>
</ul>
<h3 id="理解“对象等同性”这一概念"><a href="#理解“对象等同性”这一概念" class="headerlink" title="理解“对象等同性”这一概念"></a>理解“对象等同性”这一概念</h3><hr>
<p><strong>要点：</strong></p>
<ul>
<li>若想检测对象的等同性，请提供 <code>isEqual:</code> 与hash方法。</li>
<li>相同的对象必须具有相同的哈希码，但是两个哈希码相同的对象却未必相同。</li>
<li>不要盲目的逐个检测每条属性，而是应该依照具体需求来制定检测方案。</li>
<li>编写 hash 方法时，应该使用计算速度快而且哈希码碰撞几率低的算法。</li>
</ul>
<h3 id="在既有类中使用关联对象存放自定义数据"><a href="#在既有类中使用关联对象存放自定义数据" class="headerlink" title="在既有类中使用关联对象存放自定义数据"></a>在既有类中使用关联对象存放自定义数据</h3><hr>
<p>“关联对象”（Associated Object）可以给某对象关联许多其他对象，这些对象通过“键”来区分。存储对象值的时候，可以指明“存储策略”（storage policy），用以维护相应的“内存管理语义”。</p>
<table>
<thead>
<tr>
<th>关联类型</th>
<th>等效的@property属性</th>
</tr>
</thead>
<tbody><tr>
<td>OBJC_ASSOCIATION_ASSIGN</td>
<td>assign</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>
<td>nonatomic, retain</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY_NONATOMIC</td>
<td>nonatomic, copy</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN</td>
<td>retain</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY</td>
<td>copy</td>
</tr>
</tbody></table>
<p>下列方法可以管理关联对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> objc_setAssociatedObject(<span class="type">id</span> object, <span class="keyword">const</span> <span class="type">void</span> *key, <span class="type">id</span> value, objc_AssociationPolicy policy);</span><br></pre></td></tr></table></figure>
<p>此方法以给定的键和策略为某对象设置关联对象值。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span> objc_getAssociatedObject(<span class="type">id</span> object, <span class="keyword">const</span> <span class="type">void</span> *key);</span><br></pre></td></tr></table></figure>
<p>此方法根据给定的键从某对象中获取相应的关联对象值。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> objc_removeAssociatedObjects(<span class="type">id</span> object);</span><br></pre></td></tr></table></figure>
<p>此方法移除指定对象的全部关联对象。</p>
<p>这种做法很有用，但是只应该在其他办法行不通时才去考虑用它。若是滥用，则很快就会令代码失控，使其难于调试。“保留环”产生的原因很难查明，因为关联对象之间的关系并没有正式的定义，其内存管理语义是在关联的时候才定义的，而不是在接口中预先定好的。使用这种写法时要小心，不能仅仅因为某处可以用该写法就一定要用它。</p>
<p><strong>要点：</strong></p>
<ul>
<li>可以通过“关联对象”机制来把两个对象连起来。</li>
<li>定义关联对象时可指定内存管理语义，用以模仿定义属性时所采用的“拥有关系”与“非拥有关系”。</li>
<li>只有在其他做法不可行时才应选用关联对象，因为这种做法通常会引入难于查找的bug。</li>
</ul>
<h3 id="理解-objc-msgSend-的作用"><a href="#理解-objc-msgSend-的作用" class="headerlink" title="理解 objc_msgSend 的作用"></a>理解 objc_msgSend 的作用</h3><hr>
<p>在对象上调用方法是 Objective-C 中经常使用的功能。用 Objective-C 的术语来说，这叫做消息传递。消息有“名称”（name）或“选择器”（selector），可以接受参数，而且可能还有返回值。</p>
<p>在 Objective-C 中，如果向某对象传递消息，那就会使用动态绑定机制来决定需要调用的方法。在底层，所有方法都是普通的 C 语言函数，然而对象收到消息后，究竟该调用哪个方法则完全于运行期决定，甚至可以在程序运行时改变，这些特性使得 Objective-C 成为一门真正的动态语言。</p>
<p>给对象发消息可以这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span> returnValue = [someObject messageName: parameter];</span><br></pre></td></tr></table></figure>

<p>在本例中，<code>someObject</code> 叫做“接收者”（receiver），<code>messageName</code> 叫做选择器。选择器与参数合起来称为消息。编译器看到此消息后，将其转换为一条标准的 C 语言函数调用，所调用的函数乃是消息传递机制中的核心函数，叫做 <code>objc_msgSend</code>，其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> objc_msgSend(<span class="type">id</span> <span class="keyword">self</span>, SEL cmd, ...)</span><br></pre></td></tr></table></figure>

<p>这是个可变参数函数，能接受两个或两个以上的参数。第一个参数代表接收者，第二个参数代表选择器（<code>SEL</code> 是选择器的类型），后续参数就是消息中的那些参数，其顺序不变。选择器指的是方法的名字。选择器和方法这两个词经常交替使用。编译器会把刚才那个例子中的消息转换为如下函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span> returnValue = objc_msgSend(someObject, <span class="keyword">@selector</span>(messageName:), parameter);</span><br></pre></td></tr></table></figure>

<p><code>objc_msgSend</code> 函数会依据接收者与选择器的类型来调用适当的方法。为了完成此操作，<strong>该方法需要在接收者所属的类中搜寻其方法列表，如果能找到与选择器名称相符的方法，就跳至实现代码。若是找不到，那就沿着继承体系继续向上查找，等找到合适的方法之后再跳转。如果最终还是找不到相符的方法，那就执行消息转发操作。</strong></p>
<p>这么说来，想调用一个方法似乎需要很多步骤。所幸 <code>objc_msgSend</code> 会将匹配结果缓存在“快速映射表”（fast map）里面，每个类都有这样一块缓存，若是稍后还向该类发送与选择器相同的消息，那么执行起来就很快了。当然啦，这种“快速执行路径”(fast path)还是不如“静态绑定的函数调用操作”（statically bound function call）那样迅速，不过只要把选择器缓存起来了，也就不会慢很多，实际上，消息派发（message dispatch）并非应用程序的瓶颈所在。</p>
<p>前面讲的这部分内容只描述了部分消息的调用过程，其他“边界情况”（edge case）则需要交由 Objective-C 运行环境中的另一些函数来处理</p>
<ul>
<li><code>objc_msgSend_stret</code>：如果待发送的消息要返回结构体，那么可交由此函数处理。只有当 CPU 的寄存器能够容纳得下消息返回类型时，这个函数才能处理此消息。若是返回值无法容纳于 CPU 寄存器中（比如说返回的结构体太大了），那么就由另一个函数执行派发。此时，那个函数会通过分配在栈上的某个变量来处理消息所返回的结构体。</li>
<li><code>objc_msgSend_fpret</code>：如果消息返回的是浮点数，那么可交由此函数处理。在某些架构的 CPU 中调用函数时，需要对浮点数寄存器做特殊处理，也就是说，通常所用的 <code>objc_msgSend</code> 在这种情况下并不合适。这个函数是为了处理 x86 等架构 CPU 中某些令人稍觉惊讶的奇怪状况。</li>
<li><code>objc_msgSendSuper</code>：如果要给超类发消息，例如 <code>[super message: parameter]</code>，那么就交由此函数处理。也有另外两个与 <code>objc_msgSend_stret</code> 和 <code>objc_msgSend_fpret</code> 等效的函数，用于处理发给 <code>super</code> 的相应消息。</li>
</ul>
<p>刚才曾提到，<code>objc_msgSend</code> 等函数一旦找到应该调用的方法实现之后，就会跳转过去。之所以能这样做，是因为 Objective-C 对象的每个方法都可以视为简单的 C 函数，其原型如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;retum_type&gt; Class_selector(<span class="type">id</span> <span class="keyword">self</span>, SEL _cmd, ...)</span><br></pre></td></tr></table></figure>

<p>真正的函数名和上面写的可能不太一样，笔者用类和选择器来命名是想解释其工作原理。每个类里都有一张表格，其中的指针都会指向这种函数，而选择器的名称则是査表时所用的“键”。<code>objc_msgSend</code> 等函数正是通过这张表格来寻找应该执行的方法并跳至其实现的。请注意，原型的样子和 <code>objc_msgSend</code> 函数很像。这不是巧合，而是为了利用尾调用优化（尾递归优化）技术。令<strong>跳至方法实现</strong>这一操作变得更简单些。</p>
<p>如果某函数的最后一项操作是调用另外一个函数，那么就可以运用尾调用优化技术。编译器会生成调转至另一函数所需的指令码，而且不会向调用堆栈中推人新的“栈帧”（frame stack）。只有当某函数的最后一个操作仅仅是调用其他函数而不会将其返回值另作他用时，才能执行尾调用优化。这项优化对 <code>objc_msgSend</code> 非常关健，如果不这么做的话，那么每次调用 Objective-C 方法之前，都需要为调用 <code>objc_msgSend</code> 函数准备栈帧。，大家在“栈踪迹”（stack trace）中可以看到这种“栈帧”。此外，若是不优化，还会过早地发生“栈溢出”现象。</p>
<p><strong>要点：</strong></p>
<ul>
<li>消息接收者、选择器及参数构成。给某对象发送消息也就相当于在该对象上调用方法。</li>
<li>发给某对象的全部消息都要由动态消息派发系统来处理，该系统会查出对应的方法，并执行其代码。</li>
</ul>
<h3 id="理解消息转发机制"><a href="#理解消息转发机制" class="headerlink" title="理解消息转发机制"></a>理解消息转发机制</h3><hr>
<p>若想令类能理解某条消息，我们必须用代码实现出对应的方法才行。但是，在编译期向类发送了其无法解读的消息并不会报错，因为在运行期可以继续向类中添加方法，所以编译器在编译时还无法确知类中到底会不会有某个方法实现。当对象接收到无法解读的消息<br>后，就会启动消息转发机制，程序员可经由此过程告诉对象应该如何处理未知消息。</p>
<p><strong>消息转发分为两大阶段：</strong></p>
<ul>
<li>第一阶段先征询接收者，所属的类，看其是否能动态添加方法，以处理当前这个未知的选择器，这叫做<strong>动态方法解析</strong>。</li>
<li>第二阶段涉及<strong>完整的消息转发机制</strong>。如果运行期系统已经把第一阶段执行完了，那么接收者自己就无法再以动态新增方法的手段来响应包含该选择器的消息了。此时，运行期系统会请求接收者以其他手段来处理与消息相关的方法调用。这又细分为两小步。<ul>
<li>首先，请接收者看看有没有其他对象能处理这条消息。若有，则运行期系统会把消息转给那个对象，于是消息转发过程结束，一切如常。</li>
<li>若没有备援的接收者，则启动完整的消息转发机制，运行期系统会把与消息有关的全部细节都封装到 <code>NSInvocation</code> 对象中，再给接收者最后一次机会，令其设法解决当前还未处理的这条消息。</li>
</ul>
</li>
</ul>
<h4 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h4><hr>
<p>对象在收到无法解读的消息后，首先将调用其所属类的下列类方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">BOOL</span>)resolveInstanceMethod:(SEL)sel</span><br></pre></td></tr></table></figure>

<p>该方法的参数就手那个未知的选择器，其返回值为 <code>Boolean</code> 类型。表示这个类是否能新增一个实例方法用以外理此选择器。在继续往下执行转发机制之前，本类有机会新增一个处理此选择器的方法。假如尚未实现的方法不是实例方法而是类方法，那么运行期系统就会调用另外一个方法，该方法与 <code>resolveInstanceMethod:</code> 类似，叫做 <code>resolveClassMethod:</code>。</p>
<p>使用这种办法的前提是：相关方法的实现代码已经写好，只等着运行的时候动态插入到类里面就可以了。此方案常用来实现 <code>@dynamic</code> 属性，比如说，要访问 <code>CoreData</code>框架中 <code>NSManagedObjects</code> 对象的属性时就可以这么做，因为实现这些属性所需的存取方法在编译期就能确定。</p>
<p>下列代码演示了如何用 <code>resolveInstanceMethod</code> 来实现 <code>@dynamic</code> 属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span> dynmaicGetMethod(<span class="type">id</span> <span class="keyword">self</span>, SEL _cmd);</span><br><span class="line"><span class="type">void</span> dynmaicSetMethod(<span class="type">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="type">id</span> value);</span><br><span class="line"></span><br><span class="line">+ (<span class="type">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(sel);</span><br><span class="line">    <span class="keyword">if</span> ([selectorString hasPrefix:<span class="string">@&quot;set&quot;</span>]) &#123;</span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)dynmaicSetMethod, <span class="string">&quot;v@:@&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)dynmaicGetMethod, <span class="string">&quot;@@:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="备援接收者"><a href="#备援接收者" class="headerlink" title="备援接收者"></a>备援接收者</h4><p>当前接收者还有第二次机会能处理未知的选择器，在这一步中，运行期系统会问它：能不能把这条消息转给其他接收者来处理。与该步骤对应的处理方法如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">id</span>)forwardingTargetForSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure>

<p>方法参数代表未知的选择器，若当前接收者能找到备援对象，则将其返回，若找不到，就返回 <code>nil</code>。通过此方案，我们可以用“组合”(composition)来模拟出多重继承的某些特性。在一个对象内部，可能还有一系列其他对象，该对象可经由此方法将能够处理某选择器的相关内部对象返回，这样的话，在外界看来，好像是该对象亲自处理了这些消息似的。</p>
<p>请注意，<strong>我们无法操作经由这一步所转发的消息</strong>。若是想在发送给备援接收者之前先修改消息内容，那就得通过完整的消息转发机制来做了。</p>
<h4 id="完整的消息转发"><a href="#完整的消息转发" class="headerlink" title="完整的消息转发"></a>完整的消息转发</h4><p>如果转发算法巳经来到这一步的话，那么唯一能做的就是启用完整的消息转发机制了。首先创建 <code>NSInvocalion</code> 对象，把与尚未处理的那条消息有关的全部细节都封于其中，此对象包含选择器、目标（target）及参数。在触发 <code>NSInvocation</code> 对象时，消息派发系统将亲自出马，把消息指派给目标对象。</p>
<p>此步骤会调用下列方法来转发消息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation</span><br></pre></td></tr></table></figure>

<p>这个方法可以实现得很简单：只需改变调用目标，使消息在新目标上得以调用即可。然而这样实现出来的方法与备援接收者方案所实现的方法等效，所以很少有人采用这么简单的实现方式。比较有用的实现方式为：在触发消息前，先以某种方式改变消息内容，比如追加另外一个参数，或是改换选择器，等等。</p>
<p>实现此方法时，若发现某调用操作不应由本类处理，则需调用超类的同名方法。这样的话，继承体系中的每个类都有机会处理此调用请求，直至 <code>NSObject</code>。如果最后调用了 <code>NSObject</code> 类的方法，那么该方法还会继而调用 <code>doesNotRecognizeSelector:</code> 以抛出异常，此异常表名选择器最终未能得到处理。</p>
<p><img src="/my_pictures/20180423/2.png"></p>
<h4 id="一个完整的例子"><a href="#一个完整的例子" class="headerlink" title="一个完整的例子"></a>一个完整的例子</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DemoHelper</span>: <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)myPrint:(<span class="built_in">NSString</span> *)message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DemoHelper</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)myPrint:(<span class="built_in">NSString</span> *)message &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;DemoHelper: %@&quot;</span>, message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Demo</span> ()</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">id</span> helper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *propertyDictionary;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Demo</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@dynamic</span> name, sex;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        helper = [[DemoHelper alloc] init];</span><br><span class="line">        _propertyDictionary = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">id</span> dynmaicGetMethod(<span class="type">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">NSString</span> *key = <span class="built_in">NSStringFromSelector</span>(_cmd);</span><br><span class="line">    Demo *typedSelf = (Demo *)<span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">return</span> [typedSelf.propertyDictionary objectForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> dynmaicSetMethod(<span class="type">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="type">id</span> value) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">NSString</span> *selectorName = <span class="built_in">NSStringFromSelector</span>(_cmd);</span><br><span class="line">    <span class="built_in">NSMutableString</span> *key = [selectorName mutableCopy];</span><br><span class="line">    [key deleteCharactersInRange:<span class="built_in">NSMakeRange</span>(key.length - <span class="number">1</span>, <span class="number">1</span>)];</span><br><span class="line">    [key deleteCharactersInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">3</span>)];</span><br><span class="line">    <span class="built_in">NSString</span> *firstCharacter = [[key substringToIndex:<span class="number">1</span>] lowercaseString];</span><br><span class="line">    [key replaceCharactersInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">1</span>) withString:firstCharacter];</span><br><span class="line">    <span class="comment">//处理字符串，比如吧setName:处理为name</span></span><br><span class="line">    Demo *typedSelf = (Demo *)<span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        typedSelf.propertyDictionary[key] = value;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        [typedSelf.propertyDictionary removeObjectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(setName:) || sel == <span class="keyword">@selector</span>(setSex:)) &#123;</span><br><span class="line">        <span class="comment">//是Set方法</span></span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)dynmaicSetMethod, <span class="string">&quot;v@:@&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(name) || sel == <span class="keyword">@selector</span>(sex)) &#123;</span><br><span class="line">        <span class="comment">//是get方法</span></span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)dynmaicGetMethod, <span class="string">&quot;@:@&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里注销 helper 返回值是为了消息继续向下传递，调用 forwardInvocation: 方法</span></span><br><span class="line">- (<span class="type">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __FUNCTION__);</span><br><span class="line"><span class="comment">//    if (aSelector == @selector(myPrint:)) &#123;</span></span><br><span class="line"><span class="comment">//        return helper;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 forwardInvocation: 方法前需要先调用此方法生成方法签名</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *signature = [<span class="variable language_">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">    <span class="keyword">if</span> (!signature) &#123;</span><br><span class="line">        <span class="comment">//生成方法签名</span></span><br><span class="line">        signature = [helper methodSignatureForSelector:aSelector];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="keyword">if</span> (!helper) &#123;</span><br><span class="line">        [<span class="keyword">self</span> doesNotRecognizeSelector: [anInvocation selector]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改参数</span></span><br><span class="line">    <span class="built_in">NSString</span> *message = <span class="string">@&quot;This is a message&quot;</span>;</span><br><span class="line">    [anInvocation setArgument:&amp;message atIndex:<span class="number">2</span>];</span><br><span class="line">    [anInvocation invokeWithTarget:helper];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>① 中所说的第四个参数是 <code>types</code>：描述方法参数类型的字符数组。有关可能的值，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvZXRjL3JlZGlyZWN0L3hjb2RlL2NvbnRlbnQvMTE4OS9kb2N1bWVudGF0aW9uL0NvY29hL0NvbmNlcHR1YWwvT2JqQ1J1bnRpbWVHdWlkZS9JbnRyb2R1Y3Rpb24vSW50cm9kdWN0aW9uLmh0bWwjLy9hcHBsZV9yZWYvZG9jL3VpZC9UUDQwMDA4MDQ4">Objective-C Runtime Programming Guide<i class="fa fa-external-link-alt"></i></span> &gt; <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvZXRjL3JlZGlyZWN0L3hjb2RlL2NvbnRlbnQvMTE4OS9kb2N1bWVudGF0aW9uL0NvY29hL0NvbmNlcHR1YWwvT2JqQ1J1bnRpbWVHdWlkZS9BcnRpY2xlcy9vY3J0VHlwZUVuY29kaW5ncy5odG1sIy8vYXBwbGVfcmVmL2RvYy91aWQvVFA0MDAwODA0OC1DSDEwMA==">Type Encodings<i class="fa fa-external-link-alt"></i></span>。由于函数至少需要两个参数 <code>self</code> 和 <code>_cmd</code>，所以第二个和第三个字符必须是“@：”（第一个字符是返回类型）。</p>
<p>举个例子：</p>
<p>“v@:”</p>
<ul>
<li>v：返回值为 <code>void</code></li>
<li>@：参数 <code>self</code></li>
<li>“:”：选择器 <code>SEL(_cmd)</code> </li>
<li>无参数</li>
</ul>
<p>“i@:@”</p>
<ul>
<li>i：返回值类型为 <code>int</code></li>
<li>@：同上</li>
<li>“:”：同上</li>
<li>@：参数（id）</li>
</ul>
<p>我们运行代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Demo *demo = [[Demo alloc] init];</span><br><span class="line">demo.name = <span class="string">@&quot;Tom&quot;</span>;</span><br><span class="line">demo.sex = <span class="string">@&quot;Male&quot;</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;name: %@, sex: %@&quot;</span>, demo.name, demo.sex);</span><br><span class="line"></span><br><span class="line">[demo myPrint:<span class="string">@&quot;demo print&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+[Demo resolveInstanceMethod:]</span><br><span class="line">dynmaicSetMethod</span><br><span class="line">+[Demo resolveInstanceMethod:]</span><br><span class="line">dynmaicSetMethod</span><br><span class="line">+[Demo resolveInstanceMethod:]</span><br><span class="line">dynmaicGetMethod</span><br><span class="line">+[Demo resolveInstanceMethod:]</span><br><span class="line">dynmaicGetMethod</span><br><span class="line">name: Tom, sex: Male</span><br><span class="line">+[Demo resolveInstanceMethod:]</span><br><span class="line">-[Demo forwardingTargetForSelector:]</span><br><span class="line">-[Demo methodSignatureForSelector:]</span><br><span class="line">+[Demo resolveInstanceMethod:]</span><br><span class="line">+[Demo resolveInstanceMethod:]</span><br><span class="line">-[Demo forwardInvocation:]</span><br><span class="line">DemoHelper: This is a message</span><br></pre></td></tr></table></figure>

<p><strong>要点：</strong></p>
<ul>
<li>若对象无法响应某个选择器，则进入消息转发流程。</li>
<li>通过运行期的动态方法解析功能，我们可以在需要用到某个方法时再将其加入类中。</li>
<li>对象可以把其无法解读的某些选择器转交给其他对象来处理。</li>
<li>经过上述两步之后，如果还是没办法处理选择器，那就启动完整的消息转发机制。</li>
</ul>
<h3 id="用方法调配（method-swizzling）技术调试“黑盒方法”"><a href="#用方法调配（method-swizzling）技术调试“黑盒方法”" class="headerlink" title="用方法调配（method swizzling）技术调试“黑盒方法”"></a>用方法调配（method swizzling）技术调试“黑盒方法”</h3><hr>
<p>与给定的选择器名称相对应的方法也是可以在运行期改变的。我们既不需要源代码，也不需要通过继承子类型来覆写方法就能改变这个类本身的功能。这样一来，新功能将在本类的所有实例中生效，而不是仅限于覆写了相关方法的那些子类实例。此方案经常称为“方法调配”（method swizzling）。</p>
<p>类方法列表会把选择器的名称映射到相关的方法之上，使得“动态消息派发系统”能够据此找到应该调用的方法。这些方法均以函数指针的形式来表示，这种指针叫做 IMP，其原型如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span> (*IMP)(<span class="type">id</span>, SEL, ...)</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<p><code>Demo</code> 中有一个 <code>lowercase</code> 方法，现在我们在 <code>Demo</code> 的类别 <code>SubDemo</code> 中交换两个方法的实现。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Demo</span> (<span class="title">SubDemo</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">        </span><br><span class="line">        SEL originalSelector = <span class="keyword">@selector</span>(lowercase);</span><br><span class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(uppercase);</span><br><span class="line">        </span><br><span class="line">        Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  我们在这里使用 class_addMethod() 函数对 originalMethod 做了一层验证，如果 self 没有实现被交换的方法，会导致失败。</span></span><br><span class="line"><span class="comment">         *  而且 self 没有交换的方法实现，但是父类有这个方法，这样就会调用父类的方法，结果就不是我们想要的结果了。</span></span><br><span class="line"><span class="comment">         *  所以我们在这里通过 class_addMethod() 的验证，如果 self 实现了这个方法，class_addMethod() 函数将会返回 NO，我们就可以对其进行交换了。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Boolean didAddMethod = class_addMethod(<span class="keyword">class</span>,</span><br><span class="line">                                               originalSelector,</span><br><span class="line">                                               method_getImplementation(swizzledMethod),</span><br><span class="line">                                               method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">            class_addMethod(<span class="keyword">class</span>,</span><br><span class="line">                            swizzledSelector,</span><br><span class="line">                            method_getImplementation(originalMethod),</span><br><span class="line">                            method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)uppercase &#123;</span><br><span class="line">    <span class="comment">// 这时候调用的其实是 Demo 类的 lowercase 方法</span></span><br><span class="line">    [<span class="keyword">self</span> uppercase];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;SubDemo uppercase&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Demo lowercase</span><br><span class="line">SubDemo uppercase</span><br></pre></td></tr></table></figure>

<p><strong>要点：</strong></p>
<ul>
<li>在运行期，可以向类中新增或替换选择器所对应的方法实现。</li>
<li>使用另一份实现来替换原有的方法实现，这道工序叫做“方法调配”，开发者常用此技术向原有的实现中添加新功能。</li>
<li>一般来说，只有调试程序的时候才需要在运行期修改方法实现，这种做法不宜滥用。</li>
</ul>
<h3 id="理解“类对象”的用意"><a href="#理解“类对象”的用意" class="headerlink" title="理解“类对象”的用意"></a>理解“类对象”的用意</h3><hr>
<p>描述 Objective-C 对象所用的数据结构定义在运行期程序库的头文件里，<code>id</code> 类型本身也定义在这里：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125; *<span class="type">id</span>;</span><br></pre></td></tr></table></figure>

<p>由此可见，每个对象结构体的首个成员是 <code>Class</code> 类的变量。该变量定义了对象所属的类，通常称为“is a”指针。例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@&quot;Some string&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>这里的对象“是一个”（is a）<code>NSString</code>，所以其“is a”指针就指向 <code>NSString</code>。</strong><code>Class</code> 对象也定义在运行期程序库的头文件中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">    Class super_class;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">long</span> version;</span><br><span class="line">    <span class="type">long</span> info;</span><br><span class="line">    <span class="type">long</span> instance_size;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此结构体存放类的“元数据”（metadata），例如类的实力实现了几个方法，具备多少个实例变量等信息。此结构体的首个变量也是 <code>isa</code> 指针，这说明 <code>Class</code> 本身亦为 Objective-C 对象。结构体里还有个变量叫做 <code>super_class</code>，它定义了本类的超类。类对象所属的类型（也就是 <code>isa</code> 指针所指向的类型）是另外一个类，叫做“元类”（metaclass），用来表述类对象本身所具备的元数据。<strong>“类方法”就定义与此处</strong>，因为这些方法可以理解成类对象的实例方法。每个类仅有一个“类对象”，而每个“类对象”仅有一个与之相关的“元类”。</p>
<p>假设有个名为 <code>SomeClass</code> 的子类从 <code>NSObject</code> 中继承而来，则其继承体系如图所示：</p>
<p><img src="/my_pictures/20180423/3.png"></p>
<p><strong><code>super_class</code> 指针确立了继承关系，而 <code>isa</code> 指针描述了实例所属的类。</strong>通过这张布局关系图即可执行“类型信息查询”。我们可以查出对象是否能相应某个选择器，是否遵从某项协议，并且能看出此对象位于“类继承体系”的哪一部分。</p>
<h4 id="在类继承体系中查询类型信息"><a href="#在类继承体系中查询类型信息" class="headerlink" title="在类继承体系中查询类型信息"></a>在类继承体系中查询类型信息</h4><p><strong>可以用类型信息查询方法类检视类继承体系。<code>isMemberOfClass:</code>能够判断出对象是否为某个特定类的实例，而<code>isKindOfClass:</code>则能够判断出对象是否为其类或派生类的实例。</strong>例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Demo *demo = [[Demo alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, [demo isMemberOfClass:[Demo <span class="keyword">class</span>]]); <span class="comment">// YES</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, [demo isMemberOfClass:[SubForDemo <span class="keyword">class</span>]]); <span class="comment">// NO</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, [demo isKindOfClass:[Demo <span class="keyword">class</span>]]); <span class="comment">// YES</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, [demo isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]); <span class="comment">// NO</span></span><br></pre></td></tr></table></figure>

<p><strong>要点：</strong></p>
<ul>
<li>每个实例都有一个指向 <code>Class</code> 对象的指针，用以表明其类型，而这些 <code>Class</code> 对象则构成了类的继承体系。</li>
<li>如果对象类型无法在编译期确定，那么就应该使用类型信息查询方法来探知。</li>
<li>尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Objective-C/" rel="tag"><i class="fa fa-tag"></i> Objective-C</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/04/22/20180422-Objective-C%20%E5%9B%9E%E9%A1%BE%E3%80%90%E4%B8%80%E3%80%91%E4%B9%8B%20%E7%86%9F%E6%82%89%20Objective-C/" rel="prev" title="Objective-C 回顾【一】之 熟悉 Objective-C">
                  <i class="fa fa-angle-left"></i> Objective-C 回顾【一】之 熟悉 Objective-C
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2018/04/30/20180430-iOS%20%E5%B9%B6%E5%8F%91%EF%BC%8C%E9%94%81%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E3%80%90%E4%BA%8C%E3%80%91Operation/" rel="next" title="iOS 并发，锁，线程同步【二】Operation">
                  iOS 并发，锁，线程同步【二】Operation <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2018 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">轩辕十四</span>
  </div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9taXN0Lw==">NexT.Mist</span> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JlZ3VsdXNsZW93" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>



  




<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"regulusleow-github-io","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
